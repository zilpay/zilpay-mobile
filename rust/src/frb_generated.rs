// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1022365844;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__wallet__add_bip39_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_bip39_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::Bip39AddWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_bip39_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__add_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_meta = <crate::models::ftoken::FTokenInfo>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::add_ftoken(api_meta, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__add_ledger_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ledger_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_pub_key = <String>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::add_ledger_account(
                            api_wallet_index,
                            api_account_index,
                            api_name,
                            api_pub_key,
                            &api_identifiers,
                            api_session_cipher,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__add_ledger_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ledger_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::ledger::LedgerParamsInput>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::add_ledger_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__book__add_new_book_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_new_book_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_net = <usize>::sse_decode(&mut deserializer);
            let api_slip44 = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::add_new_book_address(
                            api_name, api_addr, api_net, api_slip44,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_next_bip39_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_next_bip39_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::AddNextBip39AccountParams>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::add_next_bip39_account(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <crate::models::provider::NetworkConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_provider(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_providers_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_providers_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_providers_list(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_sk_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_sk_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::wallet::AddSKWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_sk_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__bip39_checksum_valid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bip39_checksum_valid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_words = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::utils::bip39_checksum_valid(api_words))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__cacl_gas_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cacl_gas_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_params =
                <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::cacl_gas_fee(
                            api_wallet_index,
                            api_account_index,
                            api_params,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_account_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_account_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::change_account_name(
                            api_wallet_index,
                            api_account_index,
                            api_new_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_wallet_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::change_wallet_name(api_wallet_index, api_new_name)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__check_not_exists_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_not_exists_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_words = <Vec<String>>::sse_decode(&mut deserializer);
            let api__lang = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::methods::check_not_exists_bip39_words(api_words, api__lang),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__check_pending_tranasctions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_pending_tranasctions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::check_pending_tranasctions(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__clear_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::clear_history(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__create_or_update_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_or_update_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <crate::models::provider::NetworkConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::create_or_update_chain(api_provider_config)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__create_token_transfer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_token_transfer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::transaction::TokenTransferParamsInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::create_token_transfer(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__create_update_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_update_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_conn =
                <crate::models::connection::ConnectionInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::create_update_connection(
                            api_wallet_index,
                            api_conn,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::delete_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::delete_wallet(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api_session_cipher,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__fetch_token_meta_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_token_meta",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::fetch_token_meta(api_addr, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__gen_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_count = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_bip39_words(api_count)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__methods__gen_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_keypair()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_png_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_png_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_png_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_svg_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_svg_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_svg_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__book__get_address_book_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::get_address_book_list().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_chains_providers_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_chains_providers_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_json_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::provider::get_chains_providers_from_json(api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__connections__get_connections_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_connections_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::connections::get_connections_list(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__get_currencies_tickets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_currencies_tickets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::utils::get_currencies_tickets())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__get_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::get_data().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__get_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::get_history(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::cache::get_image_bytes(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::cache::get_image_name(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_provider(api_chain_hash).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_providers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_providers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_providers().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::get_wallets().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_zil_bech32_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_zil_bech32_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::get_zil_bech32_addresses(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_zil_eth_checksum_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_zil_eth_checksum_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::get_zil_eth_checksum_addresses(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::methods::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__intl_number_formating_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "intl_number_formating",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <String>::sse_decode(&mut deserializer);
            let api_decimals = <u8>::sse_decode(&mut deserializer);
            let api_locale_str = <String>::sse_decode(&mut deserializer);
            let api_native_symbol_str = <String>::sse_decode(&mut deserializer);
            let api_converted_symbol_str = <String>::sse_decode(&mut deserializer);
            let api_threshold = <f64>::sse_decode(&mut deserializer);
            let api_compact = <bool>::sse_decode(&mut deserializer);
            let api_converted = <f64>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::utils::intl_number_formating(
                    api_value,
                    api_decimals,
                    &api_locale_str,
                    &api_native_symbol_str,
                    &api_converted_symbol_str,
                    api_threshold,
                    api_compact,
                    api_converted,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__methods__is_crypto_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_crypto_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::methods::is_crypto_address(api_addr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__is_service_running_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_service_running",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::backend::is_service_running().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__keypair_from_sk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_from_sk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sk = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::keypair_from_sk(api_sk)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_old_database_android_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_old_database_android",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::backend::load_old_database_android()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_old_database_ios_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_old_database_ios",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::backend::load_old_database_ios(api_base_dir)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::load_service(&api_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__make_keystore_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "make_keystore_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_device_indicators = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::make_keystore_file(
                            api_wallet_index,
                            api_password,
                            api_device_indicators,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qrcode__parse_qrcode_str_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_qrcode_str",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::parse_qrcode_str(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__provider__provider_req_proxy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "provider_req_proxy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <String>::sse_decode(&mut deserializer);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::provider_req_proxy(api_payload, api_chain_hash)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__remove_connections_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_connections",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_domain = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::remove_connections(
                            api_wallet_index,
                            api_domain,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__remove_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_index = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::remove_provider(api_provider_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_bip39_phrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_bip39_phrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api__passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_bip39_phrase(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api__passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_keypair(
                            api_wallet_index,
                            api_account_index,
                            api_identifiers,
                            api_password,
                            api_passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__rm_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rm_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_token_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::rm_ftoken(api_wallet_index, api_token_address)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__select_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::select_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__select_accounts_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_accounts_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::select_accounts_chain(
                            api_wallet_index,
                            api_chain_hash,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__set_biometric_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_biometric",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_new_biometric_type = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::set_biometric(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api_session_cipher,
                            api_new_biometric_type,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_browser_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_browser_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_browser_settings =
                <crate::models::settings::BrowserSettingsInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_browser_settings(api_browser_settings)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_default_locale_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_default_locale",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_locale = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_default_locale(api_locale).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_global_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_global_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_global_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_global_notifications(api_global_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_rate_engine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rate_engine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_engine_code = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_rate_engine(
                            api_wallet_index,
                            api_engine_code,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_rate_fetcher_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rate_fetcher",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_currency = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_rate_fetcher(api_wallet_index, api_currency)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_theme_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_theme",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_appearances_code = <u8>::sse_decode(&mut deserializer);
            let api_compact_numbers = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_theme(
                            api_appearances_code,
                            api_compact_numbers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ens_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ens",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_ens_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ens(api_wallet_index, api_ens_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_gas_control_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_gas_control",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_gas_control(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ipfs_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ipfs_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_node = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ipfs_node(api_wallet_index, api_node)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_node_ranking_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_node_ranking",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_node_ranking(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_transactions = <bool>::sse_decode(&mut deserializer);
            let api_price = <bool>::sse_decode(&mut deserializer);
            let api_security = <bool>::sse_decode(&mut deserializer);
            let api_balance = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_notifications(
                            api_wallet_index,
                            api_transactions,
                            api_price,
                            api_security,
                            api_balance,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_message(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_message,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_send_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_send_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_tx = <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_send_transactions(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_typed_data_eip712_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_typed_data_eip712",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_typed_data_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_typed_data_eip712(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_typed_data_json,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__start_block_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_block_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_sink = <StreamSink<
                crate::api::backend::BlockEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::backend::start_block_worker(api_wallet_index, api_sink)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__start_history_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_history_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_sink =
                <StreamSink<String, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::start_history_worker(
                            api_wallet_index,
                            api_sink,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__stop_block_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_block_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::stop_block_worker().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__stop_history_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_history_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::stop_history_worker().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__stop_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::stop_service().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__sync_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::sync_balances(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__try_restore_rkstorage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_restore_rkstorage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_vault_json = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::backend::try_restore_rkstorage(api_vault_json, api_password)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_password_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_password",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_password(
                            api_password,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_session_cipher = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_session(
                            api_session_cipher,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__update_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::update_rates(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_get_0x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_get_0x",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::zilliqa_get_0x(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_get_bech32_base16_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_get_bech32_base16_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::zilliqa_get_bech32_base16_address(
                            api_wallet_index,
                            api_account_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_legacy_base16_to_bech32_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_legacy_base16_to_bech32",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base16 = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::wallet::zilliqa_legacy_base16_to_bech32(api_base16)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_swap_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_swap_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::zilliqa_swap_chain(
                            api_wallet_index,
                            api_account_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(usize, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::backend::BlockEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_storageKeys = <Vec<String>>::sse_decode(deserializer);
        return crate::models::transactions::access_list::AccessListItem {
            address: var_address,
            storage_keys: var_storageKeys,
        };
    }
}

impl SseDecode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_addrType = <u8>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_chainId = <u64>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        let mut var_index = <usize>::sse_decode(deserializer);
        return crate::models::account::AccountInfo {
            addr: var_addr,
            addr_type: var_addrType,
            name: var_name,
            chain_hash: var_chainHash,
            chain_id: var_chainId,
            slip_44: var_slip44,
            index: var_index,
        };
    }
}

impl SseDecode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_password = <Option<String>>::sse_decode(deserializer);
        let mut var_sessionCipher = <Option<String>>::sse_decode(deserializer);
        return crate::api::wallet::AddNextBip39AccountParams {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            name: var_name,
            passphrase: var_passphrase,
            identifiers: var_identifiers,
            password: var_password,
            session_cipher: var_sessionCipher,
        };
    }
}

impl SseDecode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::wallet::AddSKWalletParams {
            sk: var_sk,
            password: var_password,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_net = <usize>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        return crate::models::book::AddressBookEntryInfo {
            name: var_name,
            addr: var_addr,
            net: var_net,
            slip44: var_slip44,
        };
    }
}

impl SseDecode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactions = <bool>::sse_decode(deserializer);
        let mut var_price = <bool>::sse_decode(deserializer);
        let mut var_security = <bool>::sse_decode(deserializer);
        let mut var_balance = <bool>::sse_decode(deserializer);
        return crate::models::notification::BackgroundNotificationState {
            transactions: var_transactions,
            price: var_price,
            security: var_security,
            balance: var_balance,
        };
    }
}

impl SseDecode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wallets = <Vec<crate::models::wallet::WalletInfo>>::sse_decode(deserializer);
        let mut var_notificationsWalletStates = <std::collections::HashMap<
            usize,
            crate::models::notification::BackgroundNotificationState,
        >>::sse_decode(deserializer);
        let mut var_notificationsGlobalEnabled = <bool>::sse_decode(deserializer);
        let mut var_locale = <Option<String>>::sse_decode(deserializer);
        let mut var_appearances = <u8>::sse_decode(deserializer);
        let mut var_abbreviatedNumber = <bool>::sse_decode(deserializer);
        let mut var_browserSettings =
            <crate::models::settings::BrowserSettingsInfo>::sse_decode(deserializer);
        let mut var_providers =
            <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(deserializer);
        return crate::models::background::BackgroundState {
            wallets: var_wallets,
            notifications_wallet_states: var_notificationsWalletStates,
            notifications_global_enabled: var_notificationsGlobalEnabled,
            locale: var_locale,
            appearances: var_appearances,
            abbreviated_number: var_abbreviatedNumber,
            browser_settings: var_browserSettings,
            providers: var_providers,
        };
    }
}

impl SseDecode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        return crate::models::transactions::base_token::BaseTokenInfo {
            value: var_value,
            symbol: var_symbol,
            decimals: var_decimals,
        };
    }
}

impl SseDecode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_mnemonicStr = <String>::sse_decode(deserializer);
        let mut var_mnemonicCheck = <bool>::sse_decode(deserializer);
        let mut var_accounts = <Vec<(usize, String)>>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        return crate::api::wallet::Bip39AddWalletParams {
            password: var_password,
            mnemonic_str: var_mnemonicStr,
            mnemonic_check: var_mnemonicCheck,
            accounts: var_accounts,
            passphrase: var_passphrase,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            chain_hash: var_chainHash,
            identifiers: var_identifiers,
        };
    }
}

impl SseDecode for crate::api::backend::BlockEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockNumber = <Option<u64>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::api::backend::BlockEvent {
            block_number: var_blockNumber,
            error: var_error,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::settings::BrowserSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_searchEngineIndex = <u8>::sse_decode(deserializer);
        let mut var_cacheEnabled = <bool>::sse_decode(deserializer);
        let mut var_cookiesEnabled = <bool>::sse_decode(deserializer);
        let mut var_contentBlocking = <u8>::sse_decode(deserializer);
        let mut var_doNotTrack = <bool>::sse_decode(deserializer);
        let mut var_incognitoMode = <bool>::sse_decode(deserializer);
        let mut var_textScalingFactor = <f32>::sse_decode(deserializer);
        let mut var_allowGeolocation = <bool>::sse_decode(deserializer);
        let mut var_allowCamera = <bool>::sse_decode(deserializer);
        let mut var_allowMicrophone = <bool>::sse_decode(deserializer);
        let mut var_allowAutoPlay = <bool>::sse_decode(deserializer);
        return crate::models::settings::BrowserSettingsInfo {
            search_engine_index: var_searchEngineIndex,
            cache_enabled: var_cacheEnabled,
            cookies_enabled: var_cookiesEnabled,
            content_blocking: var_contentBlocking,
            do_not_track: var_doNotTrack,
            incognito_mode: var_incognitoMode,
            text_scaling_factor: var_textScalingFactor,
            allow_geolocation: var_allowGeolocation,
            allow_camera: var_allowCamera,
            allow_microphone: var_allowMicrophone,
            allow_auto_play: var_allowAutoPlay,
        };
    }
}

impl SseDecode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_primary = <Option<String>>::sse_decode(deserializer);
        let mut var_secondary = <Option<String>>::sse_decode(deserializer);
        let mut var_background = <Option<String>>::sse_decode(deserializer);
        let mut var_text = <Option<String>>::sse_decode(deserializer);
        return crate::models::connection::ColorsInfo {
            primary: var_primary,
            secondary: var_secondary,
            background: var_background,
            text: var_text,
        };
    }
}

impl SseDecode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_accountIndexes = <Vec<usize>>::sse_decode(deserializer);
        let mut var_favicon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_colors =
            <Option<crate::models::connection::ColorsInfo>>::sse_decode(deserializer);
        let mut var_lastConnected = <u64>::sse_decode(deserializer);
        let mut var_canReadAccounts = <bool>::sse_decode(deserializer);
        let mut var_canRequestSignatures = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTokens = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTransactions = <bool>::sse_decode(deserializer);
        return crate::models::connection::ConnectionInfo {
            domain: var_domain,
            account_indexes: var_accountIndexes,
            favicon: var_favicon,
            title: var_title,
            description: var_description,
            colors: var_colors,
            last_connected: var_lastConnected,
            can_read_accounts: var_canReadAccounts,
            can_request_signatures: var_canRequestSignatures,
            can_suggest_tokens: var_canSuggestTokens,
            can_suggest_transactions: var_canSuggestTransactions,
        };
    }
}

impl SseDecode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_standard = <u16>::sse_decode(deserializer);
        return crate::models::provider::ExplorerInfo {
            name: var_name,
            url: var_url,
            icon: var_icon,
            standard: var_standard,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_addrType = <u8>::sse_decode(deserializer);
        let mut var_logo = <Option<String>>::sse_decode(deserializer);
        let mut var_balances = <std::collections::HashMap<usize, String>>::sse_decode(deserializer);
        let mut var_rate = <f64>::sse_decode(deserializer);
        let mut var_default_ = <bool>::sse_decode(deserializer);
        let mut var_native = <bool>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::models::ftoken::FTokenInfo {
            name: var_name,
            symbol: var_symbol,
            decimals: var_decimals,
            addr: var_addr,
            addr_type: var_addrType,
            logo: var_logo,
            balances: var_balances,
            rate: var_rate,
            default: var_default_,
            native: var_native,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxFee = <u128>::sse_decode(deserializer);
        let mut var_priorityFee = <u128>::sse_decode(deserializer);
        let mut var_baseFee = <u128>::sse_decode(deserializer);
        return crate::models::gas::GasFeeHistoryInfo {
            max_fee: var_maxFee,
            priority_fee: var_priorityFee,
            base_fee: var_baseFee,
        };
    }
}

impl SseDecode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactionHash = <String>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_contractAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_status =
            <crate::models::transactions::history::TransactionStatusInfo>::sse_decode(deserializer);
        let mut var_statusCode = <Option<u8>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_blockNumber = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasUsed = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasLimit = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_blobGasUsed = <Option<u128>>::sse_decode(deserializer);
        let mut var_blobGasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_effectiveGasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_fee = <u128>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        let mut var_sig = <String>::sse_decode(deserializer);
        let mut var_nonce = <u128>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        let mut var_chainType = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::models::transactions::history::HistoricalTransactionInfo {
            transaction_hash: var_transactionHash,
            amount: var_amount,
            sender: var_sender,
            recipient: var_recipient,
            contract_address: var_contractAddress,
            status: var_status,
            status_code: var_statusCode,
            timestamp: var_timestamp,
            block_number: var_blockNumber,
            gas_used: var_gasUsed,
            gas_limit: var_gasLimit,
            gas_price: var_gasPrice,
            blob_gas_used: var_blobGasUsed,
            blob_gas_price: var_blobGasPrice,
            effective_gas_price: var_effectiveGasPrice,
            fee: var_fee,
            icon: var_icon,
            title: var_title,
            error: var_error,
            sig: var_sig,
            nonce: var_nonce,
            token_info: var_tokenInfo,
            chain_type: var_chainType,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_pk = <String>::sse_decode(deserializer);
        return crate::models::keypair::KeyPairInfo {
            sk: var_sk,
            pk: var_pk,
        };
    }
}

impl SseDecode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubKey = <String>::sse_decode(deserializer);
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_ledgerId = <String>::sse_decode(deserializer);
        let mut var_accountName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::ledger::LedgerParamsInput {
            pub_key: var_pubKey,
            wallet_index: var_walletIndex,
            wallet_name: var_walletName,
            ledger_id: var_ledgerId,
            account_name: var_accountName,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::access_list::AccessListItem>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::account::AccountInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::book::AddressBookEntryInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::connection::ConnectionInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::ExplorerInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::ftoken::FTokenInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::history::HistoricalTransactionInfo>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::NetworkConfigInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u16>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<usize>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(usize, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::wallet::WalletInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_logo = <String>::sse_decode(deserializer);
        let mut var_chain = <String>::sse_decode(deserializer);
        let mut var_shortName = <String>::sse_decode(deserializer);
        let mut var_rpc = <Vec<String>>::sse_decode(deserializer);
        let mut var_features = <Vec<u16>>::sse_decode(deserializer);
        let mut var_chainId = <u64>::sse_decode(deserializer);
        let mut var_chainIds = <Vec<u64>>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        let mut var_diffBlockTime = <u64>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_ens = <Option<String>>::sse_decode(deserializer);
        let mut var_explorers =
            <Vec<crate::models::provider::ExplorerInfo>>::sse_decode(deserializer);
        let mut var_fallbackEnabled = <bool>::sse_decode(deserializer);
        let mut var_testnet = <Option<bool>>::sse_decode(deserializer);
        let mut var_ftokens = <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(deserializer);
        return crate::models::provider::NetworkConfigInfo {
            name: var_name,
            logo: var_logo,
            chain: var_chain,
            short_name: var_shortName,
            rpc: var_rpc,
            features: var_features,
            chain_id: var_chainId,
            chain_ids: var_chainIds,
            slip_44: var_slip44,
            diff_block_time: var_diffBlockTime,
            chain_hash: var_chainHash,
            ens: var_ens,
            explorers: var_explorers,
            fallback_enabled: var_fallbackEnabled,
            testnet: var_testnet,
            ftokens: var_ftokens,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::base_token::BaseTokenInfo>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::connection::ColorsInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::evm::TransactionRequestEVM>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::scilla::TransactionRequestScilla>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<
                crate::models::transactions::access_list::AccessListItem,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_provider = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_amount = <Option<String>>::sse_decode(deserializer);
        return crate::models::qrcode::QRcodeScanResultInfo {
            recipient: var_recipient,
            provider: var_provider,
            token_address: var_tokenAddress,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_size = <u32>::sse_decode(deserializer);
        let mut var_gapless = <bool>::sse_decode(deserializer);
        let mut var_color = <u32>::sse_decode(deserializer);
        let mut var_eyeShape = <u8>::sse_decode(deserializer);
        let mut var_dataModuleShape = <u8>::sse_decode(deserializer);
        return crate::models::qrcode::QrConfigInfo {
            size: var_size,
            gapless: var_gapless,
            color: var_color,
            eye_shape: var_eyeShape,
            data_module_shape: var_dataModuleShape,
        };
    }
}

impl SseDecode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 =
            <crate::models::notification::BackgroundNotificationState>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::models::gas::RequiredTxParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_maxPriorityFee = <u128>::sse_decode(deserializer);
        let mut var_feeHistory = <crate::models::gas::GasFeeHistoryInfo>::sse_decode(deserializer);
        let mut var_txEstimateGas = <u64>::sse_decode(deserializer);
        let mut var_blobBaseFee = <u128>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        return crate::models::gas::RequiredTxParamsInfo {
            gas_price: var_gasPrice,
            max_priority_fee: var_maxPriorityFee,
            fee_history: var_feeHistory,
            tx_estimate_gas: var_txEstimateGas,
            blob_base_fee: var_blobBaseFee,
            nonce: var_nonce,
        };
    }
}

impl SseDecode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_token = <crate::models::ftoken::FTokenInfo>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        return crate::api::transaction::TokenTransferParamsInfo {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            token: var_token,
            amount: var_amount,
            recipient: var_recipient,
            icon: var_icon,
        };
    }
}

impl SseDecode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_hash = <Option<String>>::sse_decode(deserializer);
        let mut var_info = <Option<String>>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_signer = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
            chain_hash: var_chainHash,
            hash: var_hash,
            info: var_info,
            icon: var_icon,
            title: var_title,
            signer: var_signer,
            token_info: var_tokenInfo,
        };
    }
}

impl SseDecode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nonce = <Option<u64>>::sse_decode(deserializer);
        let mut var_from = <Option<String>>::sse_decode(deserializer);
        let mut var_to = <Option<String>>::sse_decode(deserializer);
        let mut var_value = <Option<String>>::sse_decode(deserializer);
        let mut var_gasLimit = <Option<u64>>::sse_decode(deserializer);
        let mut var_data = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_maxFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_maxPriorityFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_chainId = <Option<u64>>::sse_decode(deserializer);
        let mut var_accessList = <Option<
            Vec<crate::models::transactions::access_list::AccessListItem>,
        >>::sse_decode(deserializer);
        let mut var_blobVersionedHashes = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_maxFeePerBlobGas = <Option<u128>>::sse_decode(deserializer);
        return crate::models::transactions::evm::TransactionRequestEVM {
            nonce: var_nonce,
            from: var_from,
            to: var_to,
            value: var_value,
            gas_limit: var_gasLimit,
            data: var_data,
            max_fee_per_gas: var_maxFeePerGas,
            max_priority_fee_per_gas: var_maxPriorityFeePerGas,
            gas_price: var_gasPrice,
            chain_id: var_chainId,
            access_list: var_accessList,
            blob_versioned_hashes: var_blobVersionedHashes,
            max_fee_per_blob_gas: var_maxFeePerBlobGas,
        };
    }
}

impl SseDecode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_metadata = <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_decode(deserializer);
        let mut var_scilla =
            <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_decode(
                deserializer,
            );
        let mut var_evm =
            <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::request::TransactionRequestInfo {
            metadata: var_metadata,
            scilla: var_scilla,
            evm: var_evm,
        };
    }
}

impl SseDecode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainId = <u16>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_gasLimit = <u64>::sse_decode(deserializer);
        let mut var_toAddr = <String>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_data = <String>::sse_decode(deserializer);
        return crate::models::transactions::scilla::TransactionRequestScilla {
            chain_id: var_chainId,
            nonce: var_nonce,
            gas_price: var_gasPrice,
            gas_limit: var_gasLimit,
            to_addr: var_toAddr,
            amount: var_amount,
            code: var_code,
            data: var_data,
        };
    }
}

impl SseDecode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::transactions::history::TransactionStatusInfo::Pending,
            1 => crate::models::transactions::history::TransactionStatusInfo::Confirmed,
            2 => crate::models::transactions::history::TransactionStatusInfo::Rejected,
            _ => unreachable!("Invalid variant for TransactionStatusInfo: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_memory = <u32>::sse_decode(deserializer);
        let mut var_iterations = <u32>::sse_decode(deserializer);
        let mut var_threads = <u32>::sse_decode(deserializer);
        let mut var_secret = <String>::sse_decode(deserializer);
        return crate::models::settings::WalletArgonParamsInfo {
            memory: var_memory,
            iterations: var_iterations,
            threads: var_threads,
            secret: var_secret,
        };
    }
}

impl SseDecode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletType = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_authType = <String>::sse_decode(deserializer);
        let mut var_walletAddress = <String>::sse_decode(deserializer);
        let mut var_accounts = <Vec<crate::models::account::AccountInfo>>::sse_decode(deserializer);
        let mut var_selectedAccount = <usize>::sse_decode(deserializer);
        let mut var_tokens = <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(deserializer);
        let mut var_settings =
            <crate::models::settings::WalletSettingsInfo>::sse_decode(deserializer);
        let mut var_defaultChainHash = <u64>::sse_decode(deserializer);
        return crate::models::wallet::WalletInfo {
            wallet_type: var_walletType,
            wallet_name: var_walletName,
            auth_type: var_authType,
            wallet_address: var_walletAddress,
            accounts: var_accounts,
            selected_account: var_selectedAccount,
            tokens: var_tokens,
            settings: var_settings,
            default_chain_hash: var_defaultChainHash,
        };
    }
}

impl SseDecode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cipherOrders = <Vec<u8>>::sse_decode(deserializer);
        let mut var_argonParams =
            <crate::models::settings::WalletArgonParamsInfo>::sse_decode(deserializer);
        let mut var_currencyConvert = <String>::sse_decode(deserializer);
        let mut var_ipfsNode = <Option<String>>::sse_decode(deserializer);
        let mut var_ensEnabled = <bool>::sse_decode(deserializer);
        let mut var_gasControlEnabled = <bool>::sse_decode(deserializer);
        let mut var_nodeRankingEnabled = <bool>::sse_decode(deserializer);
        let mut var_maxConnections = <u8>::sse_decode(deserializer);
        let mut var_requestTimeoutSecs = <u32>::sse_decode(deserializer);
        let mut var_ratesApiOptions = <u8>::sse_decode(deserializer);
        return crate::models::settings::WalletSettingsInfo {
            cipher_orders: var_cipherOrders,
            argon_params: var_argonParams,
            currency_convert: var_currencyConvert,
            ipfs_node: var_ipfsNode,
            ens_enabled: var_ensEnabled,
            gas_control_enabled: var_gasControlEnabled,
            node_ranking_enabled: var_nodeRankingEnabled,
            max_connections: var_maxConnections,
            request_timeout_secs: var_requestTimeoutSecs,
            rates_api_options: var_ratesApiOptions,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__wallet__add_bip39_wallet_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__token__add_ftoken_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__ledger__add_ledger_account_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__ledger__add_ledger_wallet_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__book__add_new_book_address_impl(port, ptr, rust_vec_len, data_len),
        6 => {
            wire__crate__api__wallet__add_next_bip39_account_impl(port, ptr, rust_vec_len, data_len)
        }
        7 => wire__crate__api__provider__add_provider_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__provider__add_providers_list_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__wallet__add_sk_wallet_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__utils__bip39_checksum_valid_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__transaction__cacl_gas_fee_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__wallet__change_account_name_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__wallet__change_wallet_name_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__methods__check_not_exists_bip39_words_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire__crate__api__transaction__check_pending_tranasctions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        16 => wire__crate__api__transaction__clear_history_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__provider__create_or_update_chain_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__transaction__create_token_transfer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__connections__create_update_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        20 => wire__crate__api__wallet__delete_account_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__wallet__delete_wallet_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__token__fetch_token_meta_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__methods__gen_bip39_words_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__api__methods__gen_keypair_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__qrcode__gen_png_qrcode_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__qrcode__gen_svg_qrcode_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__book__get_address_book_list_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__provider__get_chains_providers_from_json_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        29 => wire__crate__api__connections__get_connections_list_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => {
            wire__crate__api__utils__get_currencies_tickets_impl(port, ptr, rust_vec_len, data_len)
        }
        31 => wire__crate__api__backend__get_data_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__transaction__get_history_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__cache__get_image_bytes_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__cache__get_image_name_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__provider__get_provider_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__provider__get_providers_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__wallet__get_wallets_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__wallet__get_zil_bech32_addresses_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        39 => wire__crate__api__wallet__get_zil_eth_checksum_addresses_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        40 => wire__crate__api__methods__init_app_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__methods__is_crypto_address_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__backend__is_service_running_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__methods__keypair_from_sk_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__backend__load_old_database_android_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        46 => {
            wire__crate__api__backend__load_old_database_ios_impl(port, ptr, rust_vec_len, data_len)
        }
        47 => wire__crate__api__backend__load_service_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__wallet__make_keystore_file_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__qrcode__parse_qrcode_str_impl(port, ptr, rust_vec_len, data_len),
        50 => {
            wire__crate__api__provider__provider_req_proxy_impl(port, ptr, rust_vec_len, data_len)
        }
        51 => wire__crate__api__connections__remove_connections_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        52 => wire__crate__api__provider__remove_provider_impl(port, ptr, rust_vec_len, data_len),
        53 => wire__crate__api__wallet__reveal_bip39_phrase_impl(port, ptr, rust_vec_len, data_len),
        54 => wire__crate__api__wallet__reveal_keypair_impl(port, ptr, rust_vec_len, data_len),
        55 => wire__crate__api__token__rm_ftoken_impl(port, ptr, rust_vec_len, data_len),
        56 => wire__crate__api__wallet__select_account_impl(port, ptr, rust_vec_len, data_len),
        57 => wire__crate__api__provider__select_accounts_chain_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        58 => wire__crate__api__wallet__set_biometric_impl(port, ptr, rust_vec_len, data_len),
        59 => {
            wire__crate__api__settings__set_browser_settings_impl(port, ptr, rust_vec_len, data_len)
        }
        60 => {
            wire__crate__api__settings__set_default_locale_impl(port, ptr, rust_vec_len, data_len)
        }
        61 => wire__crate__api__settings__set_global_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        62 => wire__crate__api__settings__set_rate_engine_impl(port, ptr, rust_vec_len, data_len),
        63 => wire__crate__api__settings__set_rate_fetcher_impl(port, ptr, rust_vec_len, data_len),
        64 => wire__crate__api__settings__set_theme_impl(port, ptr, rust_vec_len, data_len),
        65 => wire__crate__api__settings__set_wallet_ens_impl(port, ptr, rust_vec_len, data_len),
        66 => wire__crate__api__settings__set_wallet_gas_control_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        67 => {
            wire__crate__api__settings__set_wallet_ipfs_node_impl(port, ptr, rust_vec_len, data_len)
        }
        68 => wire__crate__api__settings__set_wallet_node_ranking_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        69 => wire__crate__api__settings__set_wallet_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        70 => wire__crate__api__transaction__sign_message_impl(port, ptr, rust_vec_len, data_len),
        71 => wire__crate__api__transaction__sign_send_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        72 => wire__crate__api__transaction__sign_typed_data_eip712_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        73 => wire__crate__api__backend__start_block_worker_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__transaction__start_history_worker_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        75 => wire__crate__api__backend__stop_block_worker_impl(port, ptr, rust_vec_len, data_len),
        76 => wire__crate__api__transaction__stop_history_worker_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        77 => wire__crate__api__backend__stop_service_impl(port, ptr, rust_vec_len, data_len),
        78 => wire__crate__api__token__sync_balances_impl(port, ptr, rust_vec_len, data_len),
        79 => {
            wire__crate__api__backend__try_restore_rkstorage_impl(port, ptr, rust_vec_len, data_len)
        }
        80 => {
            wire__crate__api__auth__try_unlock_with_password_impl(port, ptr, rust_vec_len, data_len)
        }
        81 => {
            wire__crate__api__auth__try_unlock_with_session_impl(port, ptr, rust_vec_len, data_len)
        }
        82 => wire__crate__api__token__update_rates_impl(port, ptr, rust_vec_len, data_len),
        83 => wire__crate__api__wallet__zilliqa_get_0x_impl(port, ptr, rust_vec_len, data_len),
        84 => wire__crate__api__wallet__zilliqa_get_bech32_base16_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        85 => wire__crate__api__wallet__zilliqa_legacy_base16_to_bech32_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        86 => wire__crate__api__wallet__zilliqa_swap_chain_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        41 => wire__crate__api__utils__intl_number_formating_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::access_list::AccessListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.storage_keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::access_list::AccessListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::access_list::AccessListItem>
    for crate::models::transactions::access_list::AccessListItem
{
    fn into_into_dart(self) -> crate::models::transactions::access_list::AccessListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::account::AccountInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.addr_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.slip_44.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::account::AccountInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::account::AccountInfo>
    for crate::models::account::AccountInfo
{
    fn into_into_dart(self) -> crate::models::account::AccountInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddNextBip39AccountParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.session_cipher.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddNextBip39AccountParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddNextBip39AccountParams>
    for crate::api::wallet::AddNextBip39AccountParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddNextBip39AccountParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddSKWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddSKWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddSKWalletParams>
    for crate::api::wallet::AddSKWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddSKWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::book::AddressBookEntryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.net.into_into_dart().into_dart(),
            self.slip44.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::book::AddressBookEntryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::book::AddressBookEntryInfo>
    for crate::models::book::AddressBookEntryInfo
{
    fn into_into_dart(self) -> crate::models::book::AddressBookEntryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::notification::BackgroundNotificationState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transactions.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
            self.security.into_into_dart().into_dart(),
            self.balance.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::notification::BackgroundNotificationState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::notification::BackgroundNotificationState>
    for crate::models::notification::BackgroundNotificationState
{
    fn into_into_dart(self) -> crate::models::notification::BackgroundNotificationState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::background::BackgroundState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallets.into_into_dart().into_dart(),
            self.notifications_wallet_states
                .into_into_dart()
                .into_dart(),
            self.notifications_global_enabled
                .into_into_dart()
                .into_dart(),
            self.locale.into_into_dart().into_dart(),
            self.appearances.into_into_dart().into_dart(),
            self.abbreviated_number.into_into_dart().into_dart(),
            self.browser_settings.into_into_dart().into_dart(),
            self.providers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::background::BackgroundState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::background::BackgroundState>
    for crate::models::background::BackgroundState
{
    fn into_into_dart(self) -> crate::models::background::BackgroundState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::base_token::BaseTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::base_token::BaseTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::base_token::BaseTokenInfo>
    for crate::models::transactions::base_token::BaseTokenInfo
{
    fn into_into_dart(self) -> crate::models::transactions::base_token::BaseTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::Bip39AddWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.password.into_into_dart().into_dart(),
            self.mnemonic_str.into_into_dart().into_dart(),
            self.mnemonic_check.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::Bip39AddWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::Bip39AddWalletParams>
    for crate::api::wallet::Bip39AddWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::Bip39AddWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::backend::BlockEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_number.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::backend::BlockEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::backend::BlockEvent>
    for crate::api::backend::BlockEvent
{
    fn into_into_dart(self) -> crate::api::backend::BlockEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::BrowserSettingsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.search_engine_index.into_into_dart().into_dart(),
            self.cache_enabled.into_into_dart().into_dart(),
            self.cookies_enabled.into_into_dart().into_dart(),
            self.content_blocking.into_into_dart().into_dart(),
            self.do_not_track.into_into_dart().into_dart(),
            self.incognito_mode.into_into_dart().into_dart(),
            self.text_scaling_factor.into_into_dart().into_dart(),
            self.allow_geolocation.into_into_dart().into_dart(),
            self.allow_camera.into_into_dart().into_dart(),
            self.allow_microphone.into_into_dart().into_dart(),
            self.allow_auto_play.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::BrowserSettingsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::BrowserSettingsInfo>
    for crate::models::settings::BrowserSettingsInfo
{
    fn into_into_dart(self) -> crate::models::settings::BrowserSettingsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ColorsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.primary.into_into_dart().into_dart(),
            self.secondary.into_into_dart().into_dart(),
            self.background.into_into_dart().into_dart(),
            self.text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ColorsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ColorsInfo>
    for crate::models::connection::ColorsInfo
{
    fn into_into_dart(self) -> crate::models::connection::ColorsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ConnectionInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.domain.into_into_dart().into_dart(),
            self.account_indexes.into_into_dart().into_dart(),
            self.favicon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.colors.into_into_dart().into_dart(),
            self.last_connected.into_into_dart().into_dart(),
            self.can_read_accounts.into_into_dart().into_dart(),
            self.can_request_signatures.into_into_dart().into_dart(),
            self.can_suggest_tokens.into_into_dart().into_dart(),
            self.can_suggest_transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ConnectionInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ConnectionInfo>
    for crate::models::connection::ConnectionInfo
{
    fn into_into_dart(self) -> crate::models::connection::ConnectionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::ExplorerInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.standard.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::ExplorerInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::ExplorerInfo>
    for crate::models::provider::ExplorerInfo
{
    fn into_into_dart(self) -> crate::models::provider::ExplorerInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::ftoken::FTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.addr_type.into_into_dart().into_dart(),
            self.logo.into_into_dart().into_dart(),
            self.balances.into_into_dart().into_dart(),
            self.rate.into_into_dart().into_dart(),
            self.default.into_into_dart().into_dart(),
            self.native.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::ftoken::FTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::ftoken::FTokenInfo>
    for crate::models::ftoken::FTokenInfo
{
    fn into_into_dart(self) -> crate::models::ftoken::FTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::GasFeeHistoryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_fee.into_into_dart().into_dart(),
            self.priority_fee.into_into_dart().into_dart(),
            self.base_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::gas::GasFeeHistoryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::GasFeeHistoryInfo>
    for crate::models::gas::GasFeeHistoryInfo
{
    fn into_into_dart(self) -> crate::models::gas::GasFeeHistoryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transaction_hash.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
            self.contract_address.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.status_code.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.block_number.into_into_dart().into_dart(),
            self.gas_used.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.blob_gas_used.into_into_dart().into_dart(),
            self.blob_gas_price.into_into_dart().into_dart(),
            self.effective_gas_price.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
            self.sig.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
            self.chain_type.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::HistoricalTransactionInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::history::HistoricalTransactionInfo,
    > for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::HistoricalTransactionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::keypair::KeyPairInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.pk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::keypair::KeyPairInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::keypair::KeyPairInfo>
    for crate::models::keypair::KeyPairInfo
{
    fn into_into_dart(self) -> crate::models::keypair::KeyPairInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ledger::LedgerParamsInput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pub_key.into_into_dart().into_dart(),
            self.wallet_index.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.ledger_id.into_into_dart().into_dart(),
            self.account_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ledger::LedgerParamsInput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ledger::LedgerParamsInput>
    for crate::api::ledger::LedgerParamsInput
{
    fn into_into_dart(self) -> crate::api::ledger::LedgerParamsInput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::NetworkConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.logo.into_into_dart().into_dart(),
            self.chain.into_into_dart().into_dart(),
            self.short_name.into_into_dart().into_dart(),
            self.rpc.into_into_dart().into_dart(),
            self.features.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.chain_ids.into_into_dart().into_dart(),
            self.slip_44.into_into_dart().into_dart(),
            self.diff_block_time.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.ens.into_into_dart().into_dart(),
            self.explorers.into_into_dart().into_dart(),
            self.fallback_enabled.into_into_dart().into_dart(),
            self.testnet.into_into_dart().into_dart(),
            self.ftokens.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::NetworkConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::NetworkConfigInfo>
    for crate::models::provider::NetworkConfigInfo
{
    fn into_into_dart(self) -> crate::models::provider::NetworkConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QRcodeScanResultInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.recipient.into_into_dart().into_dart(),
            self.provider.into_into_dart().into_dart(),
            self.token_address.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QRcodeScanResultInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QRcodeScanResultInfo>
    for crate::models::qrcode::QRcodeScanResultInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QRcodeScanResultInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QrConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.size.into_into_dart().into_dart(),
            self.gapless.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.eye_shape.into_into_dart().into_dart(),
            self.data_module_shape.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QrConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QrConfigInfo>
    for crate::models::qrcode::QrConfigInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QrConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::RequiredTxParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.gas_price.into_into_dart().into_dart(),
            self.max_priority_fee.into_into_dart().into_dart(),
            self.fee_history.into_into_dart().into_dart(),
            self.tx_estimate_gas.into_into_dart().into_dart(),
            self.blob_base_fee.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::gas::RequiredTxParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::RequiredTxParamsInfo>
    for crate::models::gas::RequiredTxParamsInfo
{
    fn into_into_dart(self) -> crate::models::gas::RequiredTxParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::transaction::TokenTransferParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transaction::TokenTransferParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::transaction::TokenTransferParamsInfo>
    for crate::api::transaction::TokenTransferParamsInfo
{
    fn into_into_dart(self) -> crate::api::transaction::TokenTransferParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_hash.into_into_dart().into_dart(),
            self.hash.into_into_dart().into_dart(),
            self.info.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.signer.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::transaction_metadata::TransactionMetadataInfo,
    > for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_into_dart(
        self,
    ) -> crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::evm::TransactionRequestEVM {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.nonce.into_into_dart().into_dart(),
            self.from.into_into_dart().into_dart(),
            self.to.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
            self.max_fee_per_gas.into_into_dart().into_dart(),
            self.max_priority_fee_per_gas.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.access_list.into_into_dart().into_dart(),
            self.blob_versioned_hashes.into_into_dart().into_dart(),
            self.max_fee_per_blob_gas.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::evm::TransactionRequestEVM
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::evm::TransactionRequestEVM>
    for crate::models::transactions::evm::TransactionRequestEVM
{
    fn into_into_dart(self) -> crate::models::transactions::evm::TransactionRequestEVM {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.metadata.into_into_dart().into_dart(),
            self.scilla.into_into_dart().into_dart(),
            self.evm.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::request::TransactionRequestInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::request::TransactionRequestInfo>
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_into_dart(self) -> crate::models::transactions::request::TransactionRequestInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_id.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.to_addr.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.code.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::scilla::TransactionRequestScilla
{
}
impl
    flutter_rust_bridge::IntoIntoDart<crate::models::transactions::scilla::TransactionRequestScilla>
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_into_dart(self) -> crate::models::transactions::scilla::TransactionRequestScilla {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::history::TransactionStatusInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Confirmed => 1.into_dart(),
            Self::Rejected => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::TransactionStatusInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::history::TransactionStatusInfo>
    for crate::models::transactions::history::TransactionStatusInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::TransactionStatusInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletArgonParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.memory.into_into_dart().into_dart(),
            self.iterations.into_into_dart().into_dart(),
            self.threads.into_into_dart().into_dart(),
            self.secret.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletArgonParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletArgonParamsInfo>
    for crate::models::settings::WalletArgonParamsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletArgonParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::wallet::WalletInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_type.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.auth_type.into_into_dart().into_dart(),
            self.wallet_address.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.selected_account.into_into_dart().into_dart(),
            self.tokens.into_into_dart().into_dart(),
            self.settings.into_into_dart().into_dart(),
            self.default_chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::wallet::WalletInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::wallet::WalletInfo>
    for crate::models::wallet::WalletInfo
{
    fn into_into_dart(self) -> crate::models::wallet::WalletInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletSettingsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.cipher_orders.into_into_dart().into_dart(),
            self.argon_params.into_into_dart().into_dart(),
            self.currency_convert.into_into_dart().into_dart(),
            self.ipfs_node.into_into_dart().into_dart(),
            self.ens_enabled.into_into_dart().into_dart(),
            self.gas_control_enabled.into_into_dart().into_dart(),
            self.node_ranking_enabled.into_into_dart().into_dart(),
            self.max_connections.into_into_dart().into_dart(),
            self.request_timeout_secs.into_into_dart().into_dart(),
            self.rates_api_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletSettingsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletSettingsInfo>
    for crate::models::settings::WalletSettingsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletSettingsInfo {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(usize, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::backend::BlockEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <Vec<String>>::sse_encode(self.storage_keys, serializer);
    }
}

impl SseEncode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.addr, serializer);
        <u8>::sse_encode(self.addr_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <u64>::sse_encode(self.chain_id, serializer);
        <u32>::sse_encode(self.slip_44, serializer);
        <usize>::sse_encode(self.index, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <Option<String>>::sse_encode(self.password, serializer);
        <Option<String>>::sse_encode(self.session_cipher, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.addr, serializer);
        <usize>::sse_encode(self.net, serializer);
        <u32>::sse_encode(self.slip44, serializer);
    }
}

impl SseEncode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.transactions, serializer);
        <bool>::sse_encode(self.price, serializer);
        <bool>::sse_encode(self.security, serializer);
        <bool>::sse_encode(self.balance, serializer);
    }
}

impl SseEncode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::wallet::WalletInfo>>::sse_encode(self.wallets, serializer);
        <std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>>::sse_encode(self.notifications_wallet_states, serializer);
        <bool>::sse_encode(self.notifications_global_enabled, serializer);
        <Option<String>>::sse_encode(self.locale, serializer);
        <u8>::sse_encode(self.appearances, serializer);
        <bool>::sse_encode(self.abbreviated_number, serializer);
        <crate::models::settings::BrowserSettingsInfo>::sse_encode(
            self.browser_settings,
            serializer,
        );
        <Vec<crate::models::provider::NetworkConfigInfo>>::sse_encode(self.providers, serializer);
    }
}

impl SseEncode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
    }
}

impl SseEncode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.mnemonic_str, serializer);
        <bool>::sse_encode(self.mnemonic_check, serializer);
        <Vec<(usize, String)>>::sse_encode(self.accounts, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
    }
}

impl SseEncode for crate::api::backend::BlockEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.block_number, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::settings::BrowserSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.search_engine_index, serializer);
        <bool>::sse_encode(self.cache_enabled, serializer);
        <bool>::sse_encode(self.cookies_enabled, serializer);
        <u8>::sse_encode(self.content_blocking, serializer);
        <bool>::sse_encode(self.do_not_track, serializer);
        <bool>::sse_encode(self.incognito_mode, serializer);
        <f32>::sse_encode(self.text_scaling_factor, serializer);
        <bool>::sse_encode(self.allow_geolocation, serializer);
        <bool>::sse_encode(self.allow_camera, serializer);
        <bool>::sse_encode(self.allow_microphone, serializer);
        <bool>::sse_encode(self.allow_auto_play, serializer);
    }
}

impl SseEncode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.primary, serializer);
        <Option<String>>::sse_encode(self.secondary, serializer);
        <Option<String>>::sse_encode(self.background, serializer);
        <Option<String>>::sse_encode(self.text, serializer);
    }
}

impl SseEncode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.domain, serializer);
        <Vec<usize>>::sse_encode(self.account_indexes, serializer);
        <Option<String>>::sse_encode(self.favicon, serializer);
        <String>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<crate::models::connection::ColorsInfo>>::sse_encode(self.colors, serializer);
        <u64>::sse_encode(self.last_connected, serializer);
        <bool>::sse_encode(self.can_read_accounts, serializer);
        <bool>::sse_encode(self.can_request_signatures, serializer);
        <bool>::sse_encode(self.can_suggest_tokens, serializer);
        <bool>::sse_encode(self.can_suggest_transactions, serializer);
    }
}

impl SseEncode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <u16>::sse_encode(self.standard, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
        <String>::sse_encode(self.addr, serializer);
        <u8>::sse_encode(self.addr_type, serializer);
        <Option<String>>::sse_encode(self.logo, serializer);
        <std::collections::HashMap<usize, String>>::sse_encode(self.balances, serializer);
        <f64>::sse_encode(self.rate, serializer);
        <bool>::sse_encode(self.default, serializer);
        <bool>::sse_encode(self.native, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.max_fee, serializer);
        <u128>::sse_encode(self.priority_fee, serializer);
        <u128>::sse_encode(self.base_fee, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.transaction_hash, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.sender, serializer);
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.contract_address, serializer);
        <crate::models::transactions::history::TransactionStatusInfo>::sse_encode(
            self.status,
            serializer,
        );
        <Option<u8>>::sse_encode(self.status_code, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <Option<u128>>::sse_encode(self.block_number, serializer);
        <Option<u128>>::sse_encode(self.gas_used, serializer);
        <Option<u128>>::sse_encode(self.gas_limit, serializer);
        <Option<u128>>::sse_encode(self.gas_price, serializer);
        <Option<u128>>::sse_encode(self.blob_gas_used, serializer);
        <Option<u128>>::sse_encode(self.blob_gas_price, serializer);
        <Option<u128>>::sse_encode(self.effective_gas_price, serializer);
        <u128>::sse_encode(self.fee, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
        <String>::sse_encode(self.sig, serializer);
        <u128>::sse_encode(self.nonce, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
        <String>::sse_encode(self.chain_type, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.pk, serializer);
    }
}

impl SseEncode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pub_key, serializer);
        <usize>::sse_encode(self.wallet_index, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.ledger_id, serializer);
        <String>::sse_encode(self.account_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::access_list::AccessListItem>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::account::AccountInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::book::AddressBookEntryInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::connection::ConnectionInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::ExplorerInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::ftoken::FTokenInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::history::HistoricalTransactionInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::NetworkConfigInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u16>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <usize>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(usize, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::wallet::WalletInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.logo, serializer);
        <String>::sse_encode(self.chain, serializer);
        <String>::sse_encode(self.short_name, serializer);
        <Vec<String>>::sse_encode(self.rpc, serializer);
        <Vec<u16>>::sse_encode(self.features, serializer);
        <u64>::sse_encode(self.chain_id, serializer);
        <Vec<u64>>::sse_encode(self.chain_ids, serializer);
        <u32>::sse_encode(self.slip_44, serializer);
        <u64>::sse_encode(self.diff_block_time, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.ens, serializer);
        <Vec<crate::models::provider::ExplorerInfo>>::sse_encode(self.explorers, serializer);
        <bool>::sse_encode(self.fallback_enabled, serializer);
        <Option<bool>>::sse_encode(self.testnet, serializer);
        <Vec<crate::models::ftoken::FTokenInfo>>::sse_encode(self.ftokens, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::base_token::BaseTokenInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::connection::ColorsInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::evm::TransactionRequestEVM>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::scilla::TransactionRequestScilla>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::transactions::access_list::AccessListItem>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.provider, serializer);
        <Option<String>>::sse_encode(self.token_address, serializer);
        <Option<String>>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.size, serializer);
        <bool>::sse_encode(self.gapless, serializer);
        <u32>::sse_encode(self.color, serializer);
        <u8>::sse_encode(self.eye_shape, serializer);
        <u8>::sse_encode(self.data_module_shape, serializer);
    }
}

impl SseEncode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <crate::models::notification::BackgroundNotificationState>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::models::gas::RequiredTxParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.gas_price, serializer);
        <u128>::sse_encode(self.max_priority_fee, serializer);
        <crate::models::gas::GasFeeHistoryInfo>::sse_encode(self.fee_history, serializer);
        <u64>::sse_encode(self.tx_estimate_gas, serializer);
        <u128>::sse_encode(self.blob_base_fee, serializer);
        <u64>::sse_encode(self.nonce, serializer);
    }
}

impl SseEncode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <crate::models::ftoken::FTokenInfo>::sse_encode(self.token, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.recipient, serializer);
        <String>::sse_encode(self.icon, serializer);
    }
}

impl SseEncode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.hash, serializer);
        <Option<String>>::sse_encode(self.info, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.signer, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.nonce, serializer);
        <Option<String>>::sse_encode(self.from, serializer);
        <Option<String>>::sse_encode(self.to, serializer);
        <Option<String>>::sse_encode(self.value, serializer);
        <Option<u64>>::sse_encode(self.gas_limit, serializer);
        <Option<Vec<u8>>>::sse_encode(self.data, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.max_priority_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.gas_price, serializer);
        <Option<u64>>::sse_encode(self.chain_id, serializer);
        <Option<Vec<crate::models::transactions::access_list::AccessListItem>>>::sse_encode(
            self.access_list,
            serializer,
        );
        <Option<Vec<String>>>::sse_encode(self.blob_versioned_hashes, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_blob_gas, serializer);
    }
}

impl SseEncode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_encode(
            self.metadata,
            serializer,
        );
        <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_encode(
            self.scilla,
            serializer,
        );
        <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_encode(
            self.evm, serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.chain_id, serializer);
        <u64>::sse_encode(self.nonce, serializer);
        <u128>::sse_encode(self.gas_price, serializer);
        <u64>::sse_encode(self.gas_limit, serializer);
        <String>::sse_encode(self.to_addr, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::transactions::history::TransactionStatusInfo::Pending => 0,
                crate::models::transactions::history::TransactionStatusInfo::Confirmed => 1,
                crate::models::transactions::history::TransactionStatusInfo::Rejected => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.memory, serializer);
        <u32>::sse_encode(self.iterations, serializer);
        <u32>::sse_encode(self.threads, serializer);
        <String>::sse_encode(self.secret, serializer);
    }
}

impl SseEncode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_type, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.auth_type, serializer);
        <String>::sse_encode(self.wallet_address, serializer);
        <Vec<crate::models::account::AccountInfo>>::sse_encode(self.accounts, serializer);
        <usize>::sse_encode(self.selected_account, serializer);
        <Vec<crate::models::ftoken::FTokenInfo>>::sse_encode(self.tokens, serializer);
        <crate::models::settings::WalletSettingsInfo>::sse_encode(self.settings, serializer);
        <u64>::sse_encode(self.default_chain_hash, serializer);
    }
}

impl SseEncode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.cipher_orders, serializer);
        <crate::models::settings::WalletArgonParamsInfo>::sse_encode(self.argon_params, serializer);
        <String>::sse_encode(self.currency_convert, serializer);
        <Option<String>>::sse_encode(self.ipfs_node, serializer);
        <bool>::sse_encode(self.ens_enabled, serializer);
        <bool>::sse_encode(self.gas_control_enabled, serializer);
        <bool>::sse_encode(self.node_ranking_enabled, serializer);
        <u8>::sse_encode(self.max_connections, serializer);
        <u32>::sse_encode(self.request_timeout_secs, serializer);
        <u8>::sse_encode(self.rates_api_options, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
