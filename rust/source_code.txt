Project Path: rust

Source Tree:

```txt
rust
└── src
    ├── api
    │   ├── auth.rs
    │   ├── backend.rs
    │   ├── book.rs
    │   ├── cache.rs
    │   ├── connections.rs
    │   ├── ledger.rs
    │   ├── methods.rs
    │   ├── mod.rs
    │   ├── provider.rs
    │   ├── qrcode.rs
    │   ├── settings.rs
    │   ├── stake.rs
    │   ├── token.rs
    │   ├── transaction.rs
    │   ├── utils.rs
    │   └── wallet.rs
    ├── frb_generated.rs
    ├── lib.rs
    ├── models
    │   ├── account.rs
    │   ├── background.rs
    │   ├── book.rs
    │   ├── connection.rs
    │   ├── ftoken.rs
    │   ├── gas.rs
    │   ├── keypair.rs
    │   ├── mod.rs
    │   ├── notification.rs
    │   ├── provider.rs
    │   ├── qrcode.rs
    │   ├── settings.rs
    │   ├── transactions
    │   │   ├── access_list.rs
    │   │   ├── base_token.rs
    │   │   ├── evm.rs
    │   │   ├── history.rs
    │   │   ├── mod.rs
    │   │   ├── request.rs
    │   │   ├── scilla.rs
    │   │   └── transaction_metadata.rs
    │   └── wallet.rs
    ├── service
    │   ├── mod.rs
    │   └── service.rs
    ├── tests
    │   ├── mod.rs
    │   └── wallet.rs
    └── utils
        ├── errors.rs
        ├── mod.rs
        └── utils.rs

```

`rust/src/api/auth.rs`:

```rs
use crate::utils::utils::{decode_session, with_service};
pub use zilpay::background::bg_wallet::WalletManagement;

pub async fn try_unlock_with_session(
    session_cipher: String,
    wallet_index: usize,
    identifiers: Vec<String>,
) -> Result<bool, String> {
    let session = decode_session(Some(session_cipher))?;
    with_service(|core| {
        core.unlock_wallet_with_session(session, &identifiers, wallet_index)?;

        Ok(true)
    })
    .await
    .map_err(Into::into)
}

pub async fn try_unlock_with_password(
    password: String,
    wallet_index: usize,
    identifiers: Vec<String>,
) -> Result<bool, String> {
    with_service(|core| {
        core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;

        Ok(true)
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/backend.rs`:

```rs
use std::fs;

use aes::cipher::generic_array::GenericArray;
use aes::cipher::{BlockDecrypt, KeyInit};
use aes::Aes256;
use base64::engine::general_purpose;
use base64::Engine;
use pbkdf2::pbkdf2_hmac;
use serde_json::{from_str, Value};
use sha2::{Digest, Sha256, Sha512};
use tokio::sync::mpsc;
pub use zilpay::background::bg_worker::{JobMessage, WorkerManager};
pub use zilpay::{
    background::{Background, BackgroundBip39Params, BackgroundSKParams},
    config::key::{PUB_KEY_SIZE, SECRET_KEY_SIZE},
    proto::{address::Address, pubkey::PubKey, secret_key::SecretKey},
    settings::{
        notifications::NotificationState,
        theme::{Appearances, Theme},
    },
    wallet::LedgerParams,
};

use crate::{
    frb_generated::StreamSink,
    models::background::BackgroundState,
    service::service::{ServiceBackground, BACKGROUND_SERVICE},
    utils::{
        errors::ServiceError,
        utils::{get_background_state, with_service},
    },
};

fn generate_key(password: &str, salt: &str, cost: u32) -> [u8; 32] {
    let password_bytes = password.as_bytes();

    let mut hasher = Sha256::default();
    hasher.update(password_bytes);
    let password_hash = hasher.finalize();
    let password_hex = hex::encode(password_hash);

    let salt = salt.as_bytes();

    let mut key = [0u8; 32];
    pbkdf2_hmac::<Sha512>(&password_hex.as_bytes(), salt, cost, &mut key);

    key
}

fn decrypt(key_bytes: &[u8; 32], iv: &str, cipher: &str) -> Result<String, String> {
    let iv_bytes = hex::decode(iv).map_err(|e| e.to_string())?;
    let cipher_bytes = general_purpose::STANDARD
        .decode(cipher)
        .map_err(|e| e.to_string())?;

    if key_bytes.len() != 32 {
        return Err("Key must be 32 bytes long".into());
    }
    if iv_bytes.len() != 16 {
        return Err("IV must be 16 bytes long".into());
    }
    if cipher_bytes.len() % 16 != 0 {
        return Err("Cipher length must be multiple of 16 bytes".into());
    }

    let cipher = Aes256::new(GenericArray::from_slice(&key_bytes[..32]));
    let mut plaintext = Vec::with_capacity(cipher_bytes.len());
    let mut previous_block = iv_bytes;
    let mut cipher_bytes = cipher_bytes;

    for chunk in cipher_bytes.chunks_mut(16) {
        let mut decrypted_block = chunk.to_vec();
        cipher.decrypt_block((&mut decrypted_block[..]).into());
        for (i, &byte) in previous_block.iter().enumerate() {
            decrypted_block[i] ^= byte;
        }
        plaintext.extend_from_slice(&decrypted_block);
        previous_block = chunk.to_vec();
    }

    if let Some(&padding_len) = plaintext.last() {
        let len = plaintext.len();
        if padding_len > 0
            && padding_len <= 16
            && plaintext[len - padding_len as usize..]
                .iter()
                .all(|&x| x == padding_len)
        {
            plaintext.truncate(len - padding_len as usize);
        }
    }

    Ok(String::from_utf8(plaintext).map_err(|e| e.to_string())?)
}

pub fn load_old_database_android() -> Result<(String, String), String> {
    let path = "/data/data/com.zilpaymobile/databases/RKStorage";
    let conn = rusqlite::Connection::open(path).map_err(|e| e.to_string())?;
    let vault: String = conn
        .query_row(
            "SELECT value FROM catalystLocalStorage WHERE key = '@/ZilPay/vault'",
            [],
            |row| row.get(0),
        )
        .map_err(|e| e.to_string())?;
    let accounts: String = conn
        .query_row(
            "SELECT value FROM catalystLocalStorage WHERE key = '@/ZilPay/accounts'",
            [],
            |row| row.get(0),
        )
        .map_err(|e| e.to_string())?;

    Ok((vault, accounts))
}

pub fn load_old_database_ios(base_dir: String) -> Result<(String, String), String> {
    let file = "org.reactjs.native.zilpayMobile/RCTAsyncLocalStorage_V1/manifest.json";
    let path = format!("{}/{}", base_dir, file);
    let content = fs::read_to_string(&path).map_err(|e| e.to_string())?;
    let json: Value = from_str(&content).map_err(|e| e.to_string())?;

    if !json.is_object() {
        return Err("JSON is not an object".to_string());
    }

    let vault = json["@/ZilPay/vault"].as_str().unwrap_or("").to_string();
    let accounts = json["@/ZilPay/accounts"].as_str().unwrap_or("").to_string();

    Ok((vault, accounts))
}

pub fn try_restore_rkstorage(vault_json: String, password: String) -> Result<String, String> {
    let salt = "ZilPay";
    let cost = 5000;
    let json_value: Value = serde_json::from_str(&vault_json).map_err(|e| e.to_string())?;
    let key = generate_key(&password, salt, cost);
    let iv = json_value
        .get("iv")
        .ok_or(String::from("invalid iv"))?
        .as_str()
        .unwrap_or_default();
    let cipher = json_value
        .get("cipher")
        .ok_or(String::from("invalid cipher"))?
        .as_str()
        .unwrap_or_default();
    let secre_words = decrypt(&key, &iv, &cipher)?;

    Ok(secre_words)
}

pub async fn load_service(path: &str) -> Result<BackgroundState, String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    if guard.is_none() {
        let bg = ServiceBackground::from_path(path)?;
        let state = get_background_state(&bg.core)?;
        *guard = Some(bg);
        Ok(state)
    } else {
        Err("service already running".to_string())
    }
}

pub async fn stop_service() -> Result<(), String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    if let Some(background) = guard.as_mut() {
        background.stop();
        *guard = None;
        Ok(())
    } else {
        Err("Service is not running".to_string())
    }
}

pub async fn is_service_running() -> bool {
    BACKGROUND_SERVICE.read().await.is_some()
}

pub async fn stop_block_worker() -> Result<(), String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    let service = guard.as_mut().ok_or(ServiceError::NotRunning)?;

    if let Some(block_handle) = &service.block_handle {
        block_handle.abort();

        service.block_handle = None;
    }

    Ok(())
}

pub struct BlockEvent {
    pub block_number: Option<u64>,
    pub error: Option<String>,
}

pub async fn start_block_worker(
    wallet_index: usize,
    sink: StreamSink<BlockEvent>,
) -> Result<(), String> {
    let (tx, mut rx) = mpsc::channel(10);

    {
        let mut guard = BACKGROUND_SERVICE.write().await;
        let service = guard.as_mut().ok_or(ServiceError::NotRunning)?;

        let handle = service
            .core
            .start_block_track_job(wallet_index, tx)
            .await
            .map_err(|e| e.to_string())?;

        if let Some(block_handle) = &service.block_handle {
            block_handle.abort();
            service.block_handle = None;
        }

        service.block_handle = Some(handle);
    }

    while let Some(msg) = rx.recv().await {
        match msg {
            JobMessage::Block(block_number) => {
                sink.add(BlockEvent {
                    block_number: Some(block_number),
                    error: None,
                })
                .unwrap_or_default();
            }
            JobMessage::Error(e) => {
                sink.add(BlockEvent {
                    block_number: None,
                    error: Some(e),
                })
                .unwrap_or_default();
            }
            _ => break,
        }
    }

    Ok(())
}

pub async fn get_data() -> Result<BackgroundState, String> {
    with_service(get_background_state).await.map_err(Into::into)
}

```

`rust/src/api/book.rs`:

```rs
use crate::{
    models::book::AddressBookEntryInfo,
    utils::{
        errors::ServiceError,
        utils::{parse_address, with_service},
    },
};
pub use zilpay::background::bg_book::AddressBookManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};
use zilpay::{
    background::{bg_provider::ProvidersManagement, bg_wallet::WalletManagement},
    crypto::slip44::ZILLIQA,
    proto::{address::Address, pubkey::PubKey},
    wallet::wallet_storage::StorageOperations,
};

pub async fn add_new_book_address(
    name: String,
    addr: String,
    net: usize,
    slip44: u32,
) -> Result<(), String> {
    with_service(|core| {
        let address = parse_address(addr)?;
        let book = AddressBookEntry::add(name, address, net, slip44);

        core.add_to_address_book(book)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn remove_from_address_book(addr: String) -> Result<(), String> {
    with_service(|core| {
        let address = parse_address(addr)?;

        core.remove_from_address_book(&address)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn get_address_book_list() -> Result<Vec<AddressBookEntryInfo>, String> {
    with_service(|core| Ok(core.get_address_book().iter().map(Into::into).collect()))
        .await
        .map_err(Into::into)
}

pub struct Category {
    pub name: String,
    pub entries: Vec<Entry>,
}

pub struct Entry {
    pub name: String,
    pub address: String,
    pub tag: Option<String>,
}

pub async fn get_combine_sort_addresses(
    wallet_index: usize,
    history: bool,
) -> Result<Vec<Category>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let wallet_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let selected_account = wallet_data
            .get_selected_account()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let providers = core.get_providers();

        let my_accounts: Vec<Entry> = if selected_account.slip_44 == ZILLIQA {
            let capacity = wallet_data.accounts.len() * 2;
            let mut accounts = Vec::with_capacity(capacity);

            accounts.extend(wallet_data.accounts.iter().flat_map(|acc| {
                let name = acc.name.clone();
                let pub_key_bytes = acc.pub_key.as_bytes();
                vec![
                    Entry {
                        name: name.clone(),
                        address: PubKey::Secp256k1Sha256(pub_key_bytes)
                            .get_addr()
                            .unwrap_or(Address::Secp256k1Sha256(Address::ZERO))
                            .auto_format(),
                        tag: Some("legacy".to_string()),
                    },
                    Entry {
                        name: name,
                        address: PubKey::Secp256k1Keccak256(pub_key_bytes)
                            .get_addr()
                            .unwrap_or(Address::Secp256k1Keccak256(Address::ZERO))
                            .auto_format(),
                        tag: Some("evm".to_string()),
                    },
                ]
            }));

            accounts
        } else {
            wallet_data
                .accounts
                .iter()
                .map(|acc| Entry {
                    name: acc.name.clone(),
                    address: acc.addr.auto_format(),
                    tag: None,
                })
                .collect()
        };
        let book: Vec<Entry> = core
            .get_address_book()
            .into_iter()
            .filter_map(|contact| {
                if selected_account.addr.prefix_type() == contact.addr.prefix_type() {
                    Some(Entry {
                        name: contact.name,
                        address: contact.addr.auto_format(),
                        tag: Some("book".to_string()),
                    })
                } else {
                    None
                }
            })
            .collect();
        let wallets_category: Vec<Category> = core
            .wallets
            .iter()
            .filter_map(|other_wallet| {
                if other_wallet.wallet_address == wallet.wallet_address {
                    return None;
                }

                let data = if let Some(data) = other_wallet.get_wallet_data().ok() {
                    data
                } else {
                    return None;
                };

                let chain_teg = providers
                    .iter()
                    .find(|p| p.config.hash() == data.default_chain_hash)
                    .and_then(|p| Some(&p.config.name));
                let entries: Vec<Entry> = data
                    .accounts
                    .into_iter()
                    .filter_map(|acc| {
                        if acc.addr.prefix_type() == selected_account.addr.prefix_type() {
                            Some(Entry {
                                name: acc.name,
                                address: acc.addr.auto_format(),
                                tag: chain_teg.cloned(),
                            })
                        } else {
                            None
                        }
                    })
                    .collect();

                Some(Category {
                    entries,
                    name: data.wallet_name,
                })
            })
            .collect();
        let mut categories: Vec<Category> = vec![
            Category {
                name: String::from("my_accounts"),
                entries: my_accounts,
            },
            Category {
                name: String::from("book"),
                entries: book,
            },
        ];

        categories.extend(wallets_category);

        if history {
            let history_accounts: Vec<Entry> = wallet
                .get_history()
                .map_err(|e| ServiceError::WalletError(wallet_index, e))?
                .into_iter()
                .filter_map(|tx| {
                    if tx.chain_hash == selected_account.chain_hash {
                        Some(Entry {
                            name: tx.title.unwrap_or_default(),
                            address: tx.recipient,
                            tag: None,
                        })
                    } else {
                        None
                    }
                })
                .collect();

            categories.push(Category {
                name: String::from("history"),
                entries: history_accounts,
            });
        }

        Ok(categories)
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/cache.rs`:

```rs
use std::path::PathBuf;

pub use zilpay::background::bg_book::AddressBookManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::cache::Cache;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};

pub async fn get_image_name(dir: String, url: String) -> Result<String, String> {
    let cache = Cache::new(PathBuf::from(dir)).map_err(|e| e.to_string())?;
    let image_name = cache
        .get_image_name(&url)
        .await
        .map_err(|e| e.to_string())?;

    Ok(image_name)
}

pub async fn get_image_bytes(dir: String, url: String) -> Result<(Vec<u8>, String), String> {
    let cache = Cache::new(PathBuf::from(dir)).map_err(|e| e.to_string())?;
    let image_bytes = cache
        .get_image_bytes(&url)
        .await
        .map_err(|e| e.to_string())?;

    Ok(image_bytes)
}

```

`rust/src/api/connections.rs`:

```rs
use crate::{
    models::connection::ConnectionInfo,
    utils::{errors::ServiceError, utils::with_service},
};
pub use zilpay::background::bg_connections::ConnectionManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};

pub async fn create_update_connection(
    wallet_index: usize,
    conn: ConnectionInfo,
) -> Result<(), String> {
    with_service(|core| {
        let mut connections = core.get_connections(wallet_index);

        if let Some(existing_conn) = connections.iter_mut().find(|c| c.domain == conn.domain) {
            *existing_conn = conn.into();
            core.save_connection(wallet_index, connections)?;
        } else {
            core.add_connection(wallet_index, conn.into())
                .map_err(ServiceError::BackgroundError)?;
        }

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn remove_connections(wallet_index: usize, domain: String) -> Result<(), String> {
    with_service(|core| {
        core.remove_connection(wallet_index, &domain)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn get_connections_list(wallet_index: usize) -> Result<Vec<ConnectionInfo>, String> {
    with_service(|core| {
        Ok(core
            .get_connections(wallet_index)
            .into_iter()
            .map(Into::into)
            .collect())
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/ledger.rs`:

```rs
use zilpay::{
    background::bg_provider::ProvidersManagement, wallet::wallet_storage::StorageOperations,
};
pub use zilpay::{
    background::{bg_wallet::WalletManagement, BackgroundLedgerParams},
    settings::wallet_settings::WalletSettings,
    wallet::wallet_account::AccountManagement,
};
pub use zilpay::{errors::token::TokenError, token::ft::FToken};
pub use zilpay::{proto::pubkey::PubKey, wallet::LedgerParams};

use crate::{
    models::{ftoken::FTokenInfo, settings::WalletSettingsInfo},
    utils::{
        errors::ServiceError,
        utils::{get_last_wallet, pubkey_from_provider, with_service, with_service_mut},
    },
};

pub struct LedgerParamsInput {
    pub pub_keys: Vec<(u8, String)>,
    pub wallet_index: usize,
    pub wallet_name: String,
    pub ledger_id: String,
    pub account_names: Vec<String>,
    pub biometric_type: String,
    pub identifiers: Vec<String>,
    pub chain_hash: u64,
    pub zilliqa_legacy: bool,
}

pub async fn add_ledger_wallet(
    params: LedgerParamsInput,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let provider = core.get_provider(params.chain_hash)?;
        let bip49 = provider.get_bip49(params.wallet_index);
        let pub_keys = params
            .pub_keys
            .into_iter()
            .map(|(ledger_index, pk)| {
                pubkey_from_provider(&pk, bip49, params.zilliqa_legacy)
                    .map(|pub_key| (ledger_index, pub_key))
            })
            .collect::<Result<Vec<(u8, PubKey)>, ServiceError>>()?;
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let identifiers = params.identifiers;
        let params = BackgroundLedgerParams {
            ftokens,
            pub_keys,
            chain_hash: params.chain_hash,
            account_names: params.account_names,
            wallet_index: params.wallet_index,
            wallet_name: params.wallet_name,
            ledger_id: params.ledger_id.as_bytes().to_vec(),
            biometric_type: params.biometric_type.into(),
            wallet_settings: wallet_settings.try_into()?,
        };

        let session = core
            .add_ledger_wallet(params, WalletSettings::default(), &identifiers)
            .map_err(ServiceError::BackgroundError)?;
        let wallet = get_last_wallet(core)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

pub async fn update_ledger_accounts(
    wallet_index: usize,
    accounts: Vec<(u8, String, String)>, // index, pubkey, name
    zilliqa_legacy: bool,
) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let wallet_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        let provider = core.get_provider(wallet_data.default_chain_hash)?;
        let bip49 = provider.get_bip49(wallet_index);
        let mut accounts = accounts
            .into_iter()
            .map(|(ledger_index, pk, name)| {
                pubkey_from_provider(&pk, bip49, zilliqa_legacy)
                    .map(|pub_key| (ledger_index, pub_key, name))
            })
            .collect::<Result<Vec<(u8, PubKey, String)>, ServiceError>>()?;

        accounts.dedup_by(|a, b| a.0 == b.0 && a.1 == b.1);

        wallet
            .update_ledger_accounts(accounts, &provider.config)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/methods.rs`:

```rs
use crate::{models::keypair::KeyPairInfo, utils::utils::decode_secret_key};
pub use zilpay::background::{bg_crypto::CryptoOperations, Background};
use zilpay::proto::{address::Address, keypair::KeyPair};

pub fn gen_bip39_words(count: u8) -> Result<String, String> {
    Background::gen_bip39(count).map_err(|e| e.to_string())
}

pub fn check_not_exists_bip39_words(words: Vec<String>, _lang: String) -> Vec<usize> {
    // TODO: add more lang for bip39.
    Background::find_invalid_bip39_words(&words)
}

pub fn gen_keypair() -> Result<KeyPairInfo, String> {
    let (sk, pk) = Background::gen_keypair().map_err(|e| e.to_string())?;

    Ok(KeyPairInfo { sk, pk })
}

pub fn keypair_from_sk(sk: String) -> Result<KeyPairInfo, String> {
    let sk = decode_secret_key(&sk)?;
    let (pk, sk) = KeyPair::from_sk_bytes(sk).map_err(|e| e.to_string())?;

    Ok(KeyPairInfo {
        sk: hex::encode(sk),
        pk: hex::encode(pk),
    })
}

pub fn is_crypto_address(addr: String) -> bool {
    let is_zil_bech32 = Address::from_zil_bech32(&addr).is_ok();
    let is_eth_checksum = Address::from_eth_address(&addr).is_ok();
    let is_zil_base16 = Address::from_zil_base16(&addr).is_ok();

    is_zil_bech32 || is_eth_checksum || is_zil_base16
}

pub fn init_app() {
    // Default utilities - feel free to customize
    flutter_rust_bridge::setup_default_user_utils();
}

```

`rust/src/api/mod.rs`:

```rs
pub mod auth;
pub mod backend;
pub mod book;
pub mod cache;
pub mod connections;
pub mod ledger;
pub mod methods;
pub mod provider;
pub mod qrcode;
pub mod settings;
pub mod stake;
pub mod token;
pub mod transaction;
pub mod utils;
pub mod wallet;

```

`rust/src/api/provider.rs`:

```rs
use crate::{
    models::provider::NetworkConfigInfo,
    service::service::BACKGROUND_SERVICE,
    utils::{errors::ServiceError, utils::with_service},
};
use serde_json::Value;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};
use zilpay::{background::bg_provider::ProvidersManagement, network::provider::NetworkProvider};
pub use zilpay::{
    background::bg_settings::SettingsManagement, wallet::wallet_storage::StorageOperations,
};

pub async fn get_providers() -> Result<Vec<NetworkConfigInfo>, String> {
    with_service(|core| {
        let providers = core.get_providers();

        Ok(providers
            .into_iter()
            .map(|p| p.config.into())
            .collect::<Vec<NetworkConfigInfo>>())
    })
    .await
    .map_err(Into::into)
}

pub async fn get_provider(chain_hash: u64) -> Result<NetworkConfigInfo, String> {
    with_service(|core| {
        let provider = core.get_provider(chain_hash)?;

        Ok(provider.config.into())
    })
    .await
    .map_err(Into::into)
}

pub async fn provider_req_proxy(payload: String, chain_hash: u64) -> Result<String, String> {
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    let provider = service
        .core
        .get_provider(chain_hash)
        .map_err(ServiceError::BackgroundError)?;

    let res = provider
        .proxy_req(payload)
        .await
        .map_err(ServiceError::NetworkErrors)?;

    Ok(res.to_string())
}

pub async fn add_provider(provider_config: NetworkConfigInfo) -> Result<u64, String> {
    with_service(|core| {
        let config = provider_config.try_into()?;
        let hash = core.add_provider(config)?;

        Ok(hash)
    })
    .await
    .map_err(Into::into)
}

pub async fn remove_provider(provider_index: u16) -> Result<(), String> {
    with_service(|core| {
        core.remvoe_provider(provider_index as usize)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn add_providers_list(provider_config: Vec<NetworkConfigInfo>) -> Result<(), String> {
    with_service(|core| {
        let mut providers = core.get_providers();

        for new_provider in &provider_config {
            providers.retain(|p| p.config.chain_id() != new_provider.chain_id);
        }

        for new_conf in provider_config {
            let new_provider = NetworkProvider::new(new_conf.try_into()?);

            providers.push(new_provider);
        }

        core.update_providers(providers)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn create_or_update_chain(provider_config: NetworkConfigInfo) -> Result<(), String> {
    with_service(|core| {
        let mut new_chain = provider_config;

        new_chain.ftokens.iter_mut().for_each(|t| {
            t.chain_hash = new_chain.chain_hash;
        });

        let mut providers = core.get_providers();
        let existing_provider_index = providers
            .iter()
            .position(|p| p.config.hash() == new_chain.chain_hash);

        match existing_provider_index {
            Some(index) => {
                providers[index].config = new_chain.try_into()?;
                core.update_providers(providers)?;
            }
            None => {
                core.add_provider(new_chain.try_into()?)?;
            }
        }

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn select_accounts_chain(wallet_index: usize, chain_hash: u64) -> Result<(), String> {
    with_service(|core| {
        core.select_accounts_chain(wallet_index, chain_hash)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub fn get_chains_providers_from_json(json_str: String) -> Result<Vec<NetworkConfigInfo>, String> {
    let json_value_list: Value = serde_json::from_str(&json_str).map_err(|e| e.to_string())?;

    let chains = json_value_list
        .as_array()
        .ok_or(ServiceError::SerdeSerror("json shoud be array".to_string()))?
        .into_iter()
        .map(|chain| NetworkConfigInfo::from_json_value(chain))
        .collect::<Result<Vec<NetworkConfigInfo>, ServiceError>>()?;

    Ok(chains)
}

```

`rust/src/api/qrcode.rs`:

```rs
use crate::models::qrcode::{QRcodeScanResultInfo, QrConfigInfo};
use zilpay::qrcodes::gen::generate_qr_png;
pub use zilpay::qrcodes::gen::generate_qr_svg;
pub use zilpay::qrcodes::parse::QRcodeScanResult;

pub fn gen_svg_qrcode(data: String, config: QrConfigInfo) -> Result<String, String> {
    generate_qr_svg(&data, config.into()).map_err(|e| e.to_string())
}

pub fn gen_png_qrcode(data: String, config: QrConfigInfo) -> Result<Vec<u8>, String> {
    generate_qr_png(&data, config.into()).map_err(|e| e.to_string())
}

pub fn parse_qrcode_str(data: String) -> Result<QRcodeScanResultInfo, String> {
    let params = data
        .parse::<QRcodeScanResult>()
        .map_err(|e| e.to_string())?;

    Ok(params.into())
}

```

`rust/src/api/settings.rs`:

```rs
use crate::{
    models::settings::BrowserSettingsInfo,
    utils::{
        errors::ServiceError,
        utils::{with_service, with_wallet},
    },
};
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};
use zilpay::{
    background::bg_settings::SettingsManagement, token_quotes::TokenQuotesAPIOptions,
    wallet::wallet_storage::StorageOperations,
};

pub async fn set_theme(appearances_code: u8, compact_numbers: bool) -> Result<(), String> {
    with_service(|core| {
        let new_theme = Theme {
            compact_numbers,
            appearances: Appearances::from_code(appearances_code)
                .map_err(ServiceError::SettingsError)?,
        };
        core.set_theme(new_theme)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn set_wallet_notifications(
    wallet_index: usize,
    transactions: bool,
    price: bool,
    security: bool,
    balance: bool,
) -> Result<(), String> {
    with_service(|core| {
        core.set_wallet_notifications(
            wallet_index,
            NotificationState {
                transactions,
                price,
                security,
                balance,
            },
        )
        .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn set_global_notifications(global_enabled: bool) -> Result<(), String> {
    with_service(|core| {
        core.set_global_notifications(global_enabled)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

pub async fn set_default_locale(locale: Option<String>) -> Result<(), String> {
    with_service(|core| {
        core.set_locale(locale)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn set_rate_fetcher(wallet_index: usize, currency: String) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.currency_convert = currency;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_rate_engine(wallet_index: usize, engine_code: u8) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.rates_api_options = TokenQuotesAPIOptions::from_code(engine_code);

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_wallet_ens(wallet_index: usize, ens_enabled: bool) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.ens_enabled = ens_enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_wallet_ipfs_node(wallet_index: usize, node: Option<String>) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.ipfs_node = node;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_tokens_list_fetcher(wallet_index: usize, enabled: bool) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.network.tokens_list_fetcher = enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_wallet_node_ranking(wallet_index: usize, enabled: bool) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.network.node_ranking_enabled = enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn set_browser_settings(browser_settings: BrowserSettingsInfo) -> Result<(), String> {
    with_service(|core| {
        core.set_browser_settings(browser_settings.into())?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/token.rs`:

```rs
use crate::{
    models::ftoken::FTokenInfo,
    service::service::BACKGROUND_SERVICE,
    utils::{
        errors::ServiceError,
        utils::{parse_address, with_service},
    },
};
use std::sync::Arc;
pub use zilpay::background::{bg_rates::RatesManagement, bg_token::TokensManagement};
pub use zilpay::proto::address::Address;
use zilpay::{
    background::bg_wallet::WalletManagement,
    token::ft::FToken,
    token_quotes::{
        bnb_tokens::pancakeswap_get_tokens, coingecko_tokens::coingecko_get_tokens,
        zilliqa_tokens::zilpay_get_tokens,
    },
    wallet::{wallet_storage::StorageOperations, wallet_token::TokenManagement},
};

pub async fn sync_balances(wallet_index: usize) -> Result<(), String> {
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);

        core.sync_ftokens_balances(wallet_index)
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

pub async fn update_rates(wallet_index: usize) -> Result<(), String> {
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);

        core.update_rates(wallet_index)
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

pub async fn fetch_token_meta(addr: String, wallet_index: usize) -> Result<FTokenInfo, String> {
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);
        let address = parse_address(addr)?;

        let token_meta = core
            .fetch_ftoken_meta(wallet_index, address)
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(token_meta.into())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

pub async fn fetch_tokens_list_zilliqa_legacy(
    limit: u32,
    offset: u32,
) -> Result<Vec<FTokenInfo>, String> {
    let tokens = zilpay_get_tokens(limit, offset)
        .await
        .map_err(|e| e.to_string())?;

    Ok(tokens
        .into_iter()
        .map(From::from)
        .collect::<Vec<FTokenInfo>>())
}

pub async fn fetch_tokens_evm_list(
    chain_name: String,
    chain_id: u16,
) -> Result<Vec<FTokenInfo>, String> {
    let tokens = match chain_id {
        56 => pancakeswap_get_tokens().await.map_err(|e| e.to_string())?,
        _ => coingecko_get_tokens(&chain_name)
            .await
            .map_err(|e| e.to_string())?,
    };

    Ok(tokens
        .into_iter()
        .map(From::from)
        .collect::<Vec<FTokenInfo>>())
}

pub async fn add_ftoken(meta: FTokenInfo, wallet_index: usize) -> Result<Vec<FTokenInfo>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let token: FToken = meta.try_into()?;

        wallet
            .add_ftoken(token)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        let ftokens = wallet
            .get_ftokens()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?
            .into_iter()
            .map(|t| t.into())
            .collect();

        Ok(ftokens)
    })
    .await
    .map_err(Into::into)
}

pub async fn rm_ftoken(wallet_index: usize, token_address: String) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let ftokens = wallet
            .get_ftokens()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let mb_token_index = ftokens
            .iter()
            .position(|ftoken| ftoken.addr.auto_format() == token_address);

        if let Some(token_index) = mb_token_index {
            wallet
                .remove_ftoken(token_index)
                .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        }

        Ok(())
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/api/transaction.rs`:

```rs
use std::sync::Arc;

use crate::frb_generated::StreamSink;
use crate::models::ftoken::FTokenInfo;
use crate::models::gas::RequiredTxParamsInfo;
use crate::models::transactions::history::HistoricalTransactionInfo;
use crate::models::transactions::request::TransactionRequestInfo;
use crate::service::service::BACKGROUND_SERVICE;
use crate::utils::errors::ServiceError;
use crate::utils::utils::{decode_session, parse_address, with_service, with_wallet};
use tokio::sync::mpsc;
pub use zilpay::background::bg_provider::ProvidersManagement;
pub use zilpay::background::bg_tx::TransactionsManagement;
pub use zilpay::background::bg_wallet::WalletManagement;
use zilpay::background::bg_worker::{JobMessage, WorkerManager};
pub use zilpay::background::{bg_rates::RatesManagement, bg_token::TokensManagement};
pub use zilpay::errors::background::BackgroundError;
pub use zilpay::errors::wallet::WalletErrors;
pub use zilpay::proto::address::Address;
use zilpay::proto::pubkey::PubKey;
use zilpay::proto::signature::Signature;
pub use zilpay::proto::tx::TransactionReceipt;
pub use zilpay::proto::tx::TransactionRequest;
pub use zilpay::proto::U256;
use zilpay::token::ft::FToken;
pub use zilpay::wallet::wallet_storage::StorageOperations;
pub use zilpay::wallet::wallet_transaction::WalletTransaction;

pub async fn send_signed_transactions(
    wallet_index: u8,
    account_index: u8,
    tx: TransactionRequestInfo,
    sig: Vec<u8>,
) -> Result<HistoricalTransactionInfo, String> {
    let tx: TransactionRequest = tx.try_into().map_err(ServiceError::TransactionErrors)?;
    let wallet_index = wallet_index as usize;
    let account_index = account_index as usize;

    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    let core = Arc::clone(&service.core);
    let wallet = core
        .get_wallet_by_index(wallet_index)
        .map_err(ServiceError::BackgroundError)?;
    let wallet_data = wallet
        .get_wallet_data()
        .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
    let sender_account =
        wallet_data
            .accounts
            .get(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(account_index),
            ))?;

    let signed_tx = tx
        .with_signature(sig, &sender_account.pub_key)
        .map_err(ServiceError::TransactionErrors)?;

    let tx = core
        .broadcast_signed_transactions(
            wallet_index as usize,
            account_index as usize,
            vec![signed_tx],
        )
        .await
        .map_err(ServiceError::BackgroundError)?
        .into_iter()
        .next()
        .map(|v| v.into())
        .ok_or(ServiceError::TransactionErrors(
            zilpay::errors::tx::TransactionErrors::InvalidTxHash,
        ))?;

    Ok(tx)
}

pub async fn sign_send_transactions(
    wallet_index: usize,
    account_index: usize,
    password: Option<String>,
    passphrase: Option<String>,
    session_cipher: Option<String>,
    identifiers: Vec<String>,
    tx: TransactionRequestInfo,
) -> Result<HistoricalTransactionInfo, String> {
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    let core = Arc::clone(&service.core);

    let signed_tx = {
        let seed_bytes = if let Some(pass) = password {
            core.unlock_wallet_with_password(&pass, &identifiers, wallet_index)
        } else {
            let session = decode_session(session_cipher)?;
            core.unlock_wallet_with_session(session, &identifiers, wallet_index)
        }
        .map_err(ServiceError::BackgroundError)?;

        let wallet = core
            .get_wallet_by_index(wallet_index)
            .map_err(ServiceError::BackgroundError)?;
        let wallet_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let sender_account =
            wallet_data
                .accounts
                .get(account_index)
                .ok_or(ServiceError::AccountError(
                    account_index,
                    wallet_index,
                    zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(account_index),
                ))?;
        let mut tx = tx.try_into().map_err(ServiceError::TransactionErrors)?;

        match &mut tx {
            TransactionRequest::Zilliqa((zil_tx, _)) => {
                zil_tx.chain_id = sender_account.chain_id as u16;
            }
            TransactionRequest::Ethereum((eth_tx, _)) => {
                eth_tx.chain_id = Some(sender_account.chain_id);
            }
        }

        let signed_tx = wallet
            .sign_transaction(
                tx,
                account_index,
                &seed_bytes,
                passphrase.as_ref().map(|m| m.as_str()),
            )
            .await
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok::<TransactionReceipt, ServiceError>(signed_tx)
    }
    .map_err(Into::<ServiceError>::into)?;

    let tx = core
        .broadcast_signed_transactions(wallet_index, account_index, vec![signed_tx])
        .await
        .map_err(ServiceError::BackgroundError)?
        .into_iter()
        .next()
        .map(|v| v.into())
        .ok_or(ServiceError::TransactionErrors(
            zilpay::errors::tx::TransactionErrors::InvalidTxHash,
        ))?;

    Ok(tx)
}

pub async fn encode_tx_rlp(
    wallet_index: usize,
    account_index: usize,
    tx: TransactionRequestInfo,
) -> Result<Vec<u8>, String> {
    with_wallet(wallet_index, |wallet| {
        let walelt_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let account = walelt_data
            .accounts
            .get(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(account_index),
            ))?;
        let tx: TransactionRequest = tx.try_into().map_err(ServiceError::TransactionErrors)?;

        Ok(tx
            .to_rlp_encode(&account.pub_key)
            .map_err(ServiceError::TransactionErrors)?)
    })
    .await
    .map_err(Into::into)
}

pub async fn prepare_message(
    wallet_index: usize,
    account_index: usize,
    message: String,
) -> Result<Vec<u8>, String> {
    with_service(|core| {
        let hash = core.prepare_message(wallet_index, account_index, &message)?;
        Ok(hash.to_vec())
    })
    .await
    .map_err(Into::into)
}

pub struct Eip712Hashes {
    pub domain_separator: Vec<u8>,
    pub hash_struct_message: Vec<u8>,
}

pub async fn prepare_eip712_message(typed_data_json: String) -> Result<Eip712Hashes, String> {
    with_service(|core| {
        let typed_data = core.prepare_eip712_message(typed_data_json)?;
        let domain_separator = typed_data.domain.separator().to_vec();
        let hash_struct_message = typed_data
            .hash_struct()
            .map_err(|e| BackgroundError::FailDeserializeTypedData(e.to_string()))?
            .to_vec();

        Ok(Eip712Hashes {
            domain_separator,
            hash_struct_message,
        })
    })
    .await
    .map_err(Into::into)
}

pub async fn sign_message(
    wallet_index: usize,
    account_index: usize,
    password: Option<String>,
    passphrase: Option<String>,
    session_cipher: Option<String>,
    identifiers: Vec<String>,
    message: String,
) -> Result<(String, String), String> {
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    let core = Arc::clone(&service.core);

    let signed: (PubKey, Signature) = {
        let seed_bytes = if let Some(pass) = password {
            core.unlock_wallet_with_password(&pass, &identifiers, wallet_index)
        } else {
            let session = decode_session(session_cipher)?;
            core.unlock_wallet_with_session(session, &identifiers, wallet_index)
        }
        .map_err(ServiceError::BackgroundError)?;
        let signed = core
            .sign_message(
                wallet_index,
                account_index,
                &seed_bytes,
                passphrase.as_ref().map(|s| s.as_ref()),
                &message,
            )
            .map_err(ServiceError::BackgroundError)?;

        Ok::<(PubKey, Signature), ServiceError>(signed)
    }
    .map_err(Into::<ServiceError>::into)?;
    let sig = signed.1.to_hex_prefixed();
    let pubkey = signed.0.as_hex_str();

    Ok((pubkey, sig))
}

pub async fn sign_typed_data_eip712(
    wallet_index: usize,
    account_index: usize,
    password: Option<String>,
    passphrase: Option<String>,
    session_cipher: Option<String>,
    identifiers: Vec<String>,
    typed_data_json: String,
) -> Result<(String, String), String> {
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    let core = Arc::clone(&service.core);

    let signed: (PubKey, Signature) = {
        let seed_bytes = if let Some(pass) = password {
            core.unlock_wallet_with_password(&pass, &identifiers, wallet_index)
        } else {
            let session = decode_session(session_cipher)?;
            core.unlock_wallet_with_session(session, &identifiers, wallet_index)
        }
        .map_err(ServiceError::BackgroundError)?;
        let signed = core
            .sign_typed_data_eip712(
                wallet_index,
                account_index,
                &seed_bytes,
                passphrase.as_ref().map(|s| s.as_ref()),
                &typed_data_json,
            )
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok::<(PubKey, Signature), ServiceError>(signed)
    }
    .map_err(Into::<ServiceError>::into)?;
    let sig = signed.1.to_hex_prefixed();
    let pubkey = signed.0.as_hex_str();

    Ok((pubkey, sig))
}

pub async fn get_history(wallet_index: usize) -> Result<Vec<HistoricalTransactionInfo>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let history = wallet
            .get_history()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        let history: Vec<HistoricalTransactionInfo> =
            history.into_iter().map(|tx| tx.into()).rev().collect();

        Ok(history)
    })
    .await
    .map_err(Into::into)
}

pub async fn clear_history(wallet_index: usize) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        wallet
            .clear_history()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[derive(Debug)]
pub struct TokenTransferParamsInfo {
    pub wallet_index: usize,
    pub account_index: usize,
    pub token: FTokenInfo,
    pub amount: String,
    pub recipient: String,
    pub icon: String,
}

pub async fn create_token_transfer(
    params: TokenTransferParamsInfo,
) -> Result<TransactionRequestInfo, String> {
    with_service(|core| {
        let recipient = parse_address(params.recipient)?;
        let amount = U256::from_str_radix(&params.amount, 10)
            .map_err(|e| ServiceError::ParseError("amount".to_string(), e.to_string()))?;
        let wallet = core.get_wallet_by_index(params.wallet_index)?;
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;
        let sender_account =
            data.accounts
                .get(params.account_index)
                .ok_or(ServiceError::AccountError(
                    params.account_index,
                    params.wallet_index,
                    zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(params.account_index),
                ))?;

        if params.token.addr_type != sender_account.addr.prefix_type() {
            return Err(ServiceError::AccountError(
                params.wallet_index,
                params.account_index,
                WalletErrors::InvalidAccountType,
            ));
        }

        let token: FToken = params.token.try_into()?;
        let mut tx = core.build_token_transfer(&token, &sender_account, recipient, amount)?;

        tx.set_icon(params.icon);

        Ok(tx.into())
    })
    .await
    .map_err(Into::into)
}

pub async fn cacl_gas_fee(
    wallet_index: usize,
    account_index: usize,
    params: TransactionRequestInfo,
) -> Result<RequiredTxParamsInfo, String> {
    let chain_hash = params.metadata.chain_hash;
    let gas = {
        let guard = BACKGROUND_SERVICE.read().await;
        let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
        let chain = service
            .core
            .get_provider(chain_hash)
            .map_err(ServiceError::BackgroundError)?;
        let tx: TransactionRequest = params.try_into().map_err(ServiceError::TransactionErrors)?;
        let wallet = service
            .core
            .get_wallet_by_index(wallet_index)
            .map_err(ServiceError::BackgroundError)?;
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let sender_account = data
            .accounts
            .get(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(account_index),
            ))?;

        let mut gas = chain
            .estimate_params_batch(&tx, &sender_account.addr, 4, None)
            .await
            .map_err(ServiceError::NetworkErrors)?;

        if gas.tx_estimate_gas == U256::ZERO {
            match tx {
                TransactionRequest::Zilliqa((tx, _)) => {
                    gas.tx_estimate_gas = U256::from(tx.gas_limit);
                }
                TransactionRequest::Ethereum((tx, _)) => {
                    gas.tx_estimate_gas = tx.gas.map(|gas| U256::from(gas)).unwrap_or(U256::ZERO);
                }
            }
        }

        gas
    };

    Ok(gas.into())
}

pub async fn check_pending_tranasctions(
    wallet_index: usize,
) -> Result<Vec<HistoricalTransactionInfo>, String> {
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;

    let history = service
        .core
        .check_pending_txns(wallet_index)
        .await
        .map_err(ServiceError::BackgroundError)?;
    let history: Vec<HistoricalTransactionInfo> =
        history.into_iter().map(|tx| tx.into()).rev().collect();

    Ok(history)
}

pub async fn start_history_worker(
    wallet_index: usize,
    sink: StreamSink<String>,
) -> Result<(), String> {
    let (tx, mut rx) = mpsc::channel(10);

    {
        let mut guard = BACKGROUND_SERVICE.write().await;
        let service = guard.as_mut().ok_or(ServiceError::NotRunning)?;

        let handle = service
            .core
            .start_txns_track_job(wallet_index, tx)
            .await
            .map_err(|e| e.to_string())?;

        if let Some(block_handle) = &service.block_handle {
            block_handle.abort();
            service.block_handle = None;
        }

        service.history_handle = Some(handle);
    }

    while let Some(msg) = rx.recv().await {
        match msg {
            JobMessage::Tx => {
                sink.add(String::with_capacity(0)).unwrap_or_default();
            }
            JobMessage::Error(e) => {
                sink.add(e).unwrap_or_default();
            }
            _ => break,
        }
    }

    Ok(())
}

pub async fn stop_history_worker() -> Result<(), String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    let service = guard.as_mut().ok_or(ServiceError::NotRunning)?;

    if let Some(history_handle) = &service.history_handle {
        history_handle.abort();

        service.history_handle = None;
    }

    Ok(())
}

```

`rust/src/api/utils.rs`:

```rs
use flutter_rust_bridge::frb;
use sha2::{Digest, Sha256};
pub use zilpay::intl::number::{format_u256, CURRENCY_SYMBOLS};
use zilpay::{background::Mnemonic, config::bip39::EN_WORDS, proto::U256};

#[frb(sync)]
pub fn intl_number_formating(
    value: String,
    decimals: u8,
    locale_str: &str,
    native_symbol_str: &str,
    converted_symbol_str: &str,
    threshold: f64,
    compact: bool,
    converted: f64,
) -> (String, String) {
    let u256_value: U256 = value.parse::<U256>().unwrap_or_default();

    format_u256(
        u256_value,
        decimals,
        locale_str,
        native_symbol_str,
        converted_symbol_str,
        threshold,
        compact,
        converted,
    )
}

pub fn get_currencies_tickets() -> Vec<(String, String)> {
    CURRENCY_SYMBOLS
        .iter()
        .map(|(symbol, ticket)| (symbol.to_string(), ticket.to_string()))
        .collect()
}

pub fn bip39_checksum_valid(words: String) -> bool {
    let mnemonic = match Mnemonic::parse_str(&EN_WORDS, &words) {
        Ok(m) => m,
        Err(_) => return false,
    };
    let checksum = mnemonic.checksum();
    let entropy: Vec<u8> = mnemonic.to_entropy().collect();

    let mut hasher = Sha256::new();
    hasher.update(&entropy);
    let digest = hasher.finalize();

    let word_count = mnemonic.word_count;
    let expected_checksum = digest[0] >> (8 - word_count / 3);

    if checksum == expected_checksum {
        true
    } else {
        false
    }
}

#[frb(sync)]
pub fn to_wei(value: String, decimals: u8) -> Result<(String, u8), String> {
    let big_value = zilpay::intl::wei::to_wei(value, decimals).map_err(|e| e.to_string())?;

    Ok((big_value.to_string(), decimals))
}

#[frb(sync)]
pub fn from_wei(value: String, decimals: u8) -> Result<String, String> {
    let value_float = zilpay::intl::wei::from_wei(value, decimals).map_err(|e| e.to_string())?;

    Ok(value_float)
}

#[test]
fn test_bip39_checksum_valid() {
    const CORRECT_WORDS: &str = "minor convince list alarm tide wasp define poverty valley around clump bamboo please beauty finish fall expose stairs muscle noise stand swamp erase six";
    const INCORRECT_WORDS: &str = "minor convince list alarm tide wasp define poverty valley around clump bamboo please beauty finish fall stairs muscle noise stand swamp erase six expose";

    assert!(bip39_checksum_valid(CORRECT_WORDS.to_string()));
    assert!(!bip39_checksum_valid(INCORRECT_WORDS.to_string()));
}

```

`rust/src/api/wallet.rs`:

```rs
use zilpay::background::bg_provider::ProvidersManagement;
use zilpay::background::bg_storage::StorageManagement;
use zilpay::background::Background;
use zilpay::errors::background::BackgroundError;
use zilpay::errors::token::TokenError;
use zilpay::errors::wallet::WalletErrors;
use zilpay::proto::address::Address;
use zilpay::token::ft::FToken;
use zilpay::wallet::wallet_crypto::WalletCrypto;
use zilpay::wallet::wallet_storage::StorageOperations;
pub use zilpay::{
    background::bg_wallet::WalletManagement, wallet::wallet_account::AccountManagement,
};
pub use zilpay::{
    background::{BackgroundBip39Params, BackgroundSKParams},
    crypto::bip49::DerivationPath,
    proto::{pubkey::PubKey, secret_key::SecretKey},
};

use crate::models::ftoken::FTokenInfo;
use crate::models::keypair::KeyPairInfo;
use crate::models::settings::WalletSettingsInfo;
use crate::utils::utils::{secretkey_from_provider, with_wallet};
use crate::{
    models::wallet::WalletInfo,
    utils::{
        errors::ServiceError,
        utils::{decode_session, with_service, with_service_mut},
    },
};

use super::provider::select_accounts_chain;

pub async fn get_wallets() -> Result<Vec<WalletInfo>, String> {
    with_service(|core| {
        let wallets = core
            .wallets
            .iter()
            .map(|w| w.try_into())
            .collect::<Result<Vec<WalletInfo>, WalletErrors>>()
            .map_err(BackgroundError::WalletError)?;

        Ok(wallets)
    })
    .await
    .map_err(Into::into)
}

pub struct Bip39AddWalletParams {
    pub password: String,
    pub mnemonic_str: String,
    pub mnemonic_check: bool,
    pub accounts: Vec<(usize, String)>,
    pub passphrase: String,
    pub wallet_name: String,
    pub biometric_type: String,
    pub chain_hash: u64,
    pub identifiers: Vec<String>,
}

pub async fn add_bip39_wallet(
    params: Bip39AddWalletParams,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let core_ref: &Background = &*core;
        let provider = core_ref.get_provider(params.chain_hash)?;
        let accounts_bip49 = params
            .accounts
            .into_iter()
            .map(|(i, name)| (provider.get_bip49(i), name))
            .collect::<Vec<(DerivationPath, String)>>();
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let session = core
            .add_bip39_wallet(BackgroundBip39Params {
                ftokens,
                mnemonic_check: params.mnemonic_check,
                wallet_settings: wallet_settings.try_into()?,
                chain_hash: params.chain_hash,
                password: &params.password,
                mnemonic_str: &params.mnemonic_str,
                accounts: &accounts_bip49,
                passphrase: &params.passphrase,
                wallet_name: params.wallet_name,
                biometric_type: params.biometric_type.into(),
                device_indicators: &params.identifiers,
            })
            .map_err(ServiceError::BackgroundError)?;
        let wallet = core.wallets.last().ok_or(ServiceError::FailToSaveWallet)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

pub struct AddSKWalletParams {
    pub sk: String,
    pub password: String,
    pub wallet_name: String,
    pub biometric_type: String,
    pub identifiers: Vec<String>,
    pub chain_hash: u64,
}

pub async fn add_sk_wallet(
    params: AddSKWalletParams,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let provider = core.get_provider(params.chain_hash)?;
        let bip49 = provider.get_bip49(0);
        let secret_key = secretkey_from_provider(&params.sk, bip49)?;
        let session = core.add_sk_wallet(BackgroundSKParams {
            ftokens,
            chain_hash: params.chain_hash,
            secret_key,
            wallet_name: params.wallet_name,
            biometric_type: params.biometric_type.into(),
            password: &params.password,
            device_indicators: &params.identifiers,
            wallet_settings: wallet_settings.try_into()?,
        })?;
        let wallet = core.wallets.last().ok_or(ServiceError::FailToSaveWallet)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

pub struct AddNextBip39AccountParams {
    pub wallet_index: usize,
    pub account_index: usize,
    pub name: String,
    pub passphrase: String,
    pub identifiers: Vec<String>,
    pub password: Option<String>,
    pub session_cipher: Option<String>,
}

pub async fn add_next_bip39_account(params: AddNextBip39AccountParams) -> Result<(), String> {
    with_service_mut(|core| {
        let seed = if let Some(pass) = params.password {
            core.unlock_wallet_with_password(&pass, &params.identifiers, params.wallet_index)
        } else {
            let session = decode_session(params.session_cipher)?;
            core.unlock_wallet_with_session(session, &params.identifiers, params.wallet_index)
        }?;

        let wallet = core.get_wallet_by_index(params.wallet_index)?;
        let wallet_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;
        let selected_account = wallet_data
            .get_selected_account()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;
        let default_chain = core.get_provider(wallet_data.default_chain_hash)?;
        let bip49 = default_chain.get_bip49(params.account_index);

        wallet
            .add_next_bip39_account(
                params.name,
                &bip49,
                &params.passphrase,
                &seed,
                &default_chain.config,
            )
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;

        let mut wallet_data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;

        if let Some(added_account) = wallet_data.accounts.last_mut() {
            added_account.slip_44 = selected_account.slip_44;
            added_account.chain_hash = selected_account.chain_hash;
            added_account.chain_id = selected_account.chain_id;
        }

        wallet
            .save_wallet_data(wallet_data)
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn select_account(wallet_index: usize, account_index: usize) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        wallet
            .select_account(account_index)
            .map_err(|e| ServiceError::AccountError(account_index, wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

pub async fn change_account_name(
    wallet_index: usize,
    account_index: usize,
    new_name: String,
) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let acc = data
            .accounts
            .get_mut(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                WalletErrors::InvalidAccountIndex(account_index),
            ))?;

        acc.name = new_name;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn change_wallet_name(wallet_index: usize, new_name: String) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.wallet_name = new_name;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn delete_wallet(
    wallet_index: usize,
    identifiers: Vec<String>,
    password: Option<String>,
    session_cipher: Option<String>,
) -> Result<(), String> {
    with_service_mut(|core| {
        if let Some(pass) = password {
            core.unlock_wallet_with_password(&pass, &identifiers, wallet_index)
        } else {
            let session = decode_session(session_cipher)?;
            core.unlock_wallet_with_session(session, &identifiers, wallet_index)
        }?;

        core.delete_wallet(wallet_index)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn delete_account(wallet_index: usize, account_index: usize) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        wallet
            .delete_account(account_index)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn set_biometric(
    wallet_index: usize,
    identifiers: Vec<String>,
    password: String,
    session_cipher: Option<String>,
    new_biometric_type: String,
) -> Result<Option<String>, String> {
    with_service(|core| {
        let mb_session = if session_cipher.is_some() {
            Some(decode_session(session_cipher)?)
        } else {
            None
        };
        let session_bytes = core.set_biometric(
            &password,
            mb_session,
            &identifiers,
            wallet_index,
            new_biometric_type.into(),
        )?;

        Ok(session_bytes.map(|v| hex::encode(v)))
    })
    .await
    .map_err(Into::into)
}

pub async fn reveal_keypair(
    wallet_index: usize,
    account_index: usize,
    identifiers: Vec<String>,
    password: String,
    passphrase: Option<String>,
) -> Result<KeyPairInfo, String> {
    with_service(|core| {
        let seed = core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let keypair = wallet
            .reveal_keypair(account_index, &seed, passphrase.as_deref())
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(keypair.into())
    })
    .await
    .map_err(Into::into)
}

pub async fn reveal_bip39_phrase(
    wallet_index: usize,
    identifiers: Vec<String>,
    password: String,
    _passphrase: Option<String>,
) -> Result<String, String> {
    with_service(|core| {
        let seed = core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let m = wallet
            .reveal_mnemonic(&seed)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(m.to_string())
    })
    .await
    .map_err(Into::into)
}

pub async fn zilliqa_swap_chain(wallet_index: usize, account_index: usize) -> Result<(), String> {
    with_service(|core| {
        core.swap_zilliqa_chain(wallet_index, account_index)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

pub async fn zilliqa_get_bech32_base16_address(
    wallet_index: usize,
    account_index: usize,
) -> Result<(String, String), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let account = data
            .accounts
            .get(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                WalletErrors::NoAccounts,
            ))?;

        match account.pub_key {
            PubKey::Secp256k1Sha256(_) => Ok((
                account.addr.get_zil_bech32().unwrap_or_default(),
                account.addr.get_zil_check_sum_addr().unwrap_or_default(),
            )),
            PubKey::Secp256k1Keccak256(pk) => {
                let addr_result = PubKey::Secp256k1Sha256(pk)
                    .get_addr()
                    .map(|addr| {
                        (
                            addr.get_zil_bech32().unwrap_or_default(),
                            addr.get_zil_check_sum_addr().unwrap_or_default(),
                        )
                    })
                    .map_err(|_| ServiceError::DecodePublicKey)?;

                Ok(addr_result)
            }
            _ => Err(ServiceError::DecodePublicKey),
        }
    })
    .await
    .map_err(Into::into)
}

pub async fn get_zil_eth_checksum_addresses(wallet_index: usize) -> Result<Vec<String>, String> {
    with_wallet(wallet_index, |wallet| {
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let addresses = data
            .accounts
            .into_iter()
            .filter_map(|a| match a.pub_key {
                PubKey::Secp256k1Sha256(pk) => PubKey::Secp256k1Keccak256(pk)
                    .get_addr()
                    .ok()
                    .and_then(|a| a.to_eth_checksummed().ok()),
                PubKey::Secp256k1Keccak256(_) => a.addr.to_eth_checksummed().ok(),
                _ => None,
            })
            .collect::<Vec<String>>();

        Ok(addresses)
    })
    .await
    .map_err(Into::into)
}

pub async fn get_zil_bech32_addresses(wallet_index: usize) -> Result<Vec<String>, String> {
    with_wallet(wallet_index, |wallet| {
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let addresses = data
            .accounts
            .into_iter()
            .filter_map(|a| match a.pub_key {
                PubKey::Secp256k1Sha256(_) => a.addr.get_zil_bech32().ok(),
                PubKey::Secp256k1Keccak256(pk) => PubKey::Secp256k1Sha256(pk)
                    .get_addr()
                    .ok()
                    .and_then(|addr| addr.get_zil_bech32().ok()),
                _ => None,
            })
            .collect::<Vec<String>>();

        Ok(addresses)
    })
    .await
    .map_err(Into::into)
}

pub fn zilliqa_legacy_base16_to_bech32(base16: String) -> Result<String, String> {
    let addr = Address::from_zil_base16(&base16).map_err(|e| e.to_string())?;

    Ok(addr.get_zil_bech32().unwrap_or_default())
}

pub async fn zilliqa_get_n_format(
    wallet_index: usize,
    account_index: usize,
) -> Result<String, String> {
    with_wallet(wallet_index, |wallet| {
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let account = data
            .accounts
            .get(account_index)
            .ok_or(WalletErrors::InvalidAccountIndex(account_index))
            .map_err(|e| ServiceError::AccountError(account_index, wallet_index, e))?;

        let address = match account.pub_key {
            PubKey::Secp256k1Sha256(pk) => PubKey::Secp256k1Keccak256(pk)
                .get_addr()
                .ok()
                .and_then(|a| a.to_eth_checksummed().ok()),
            PubKey::Secp256k1Keccak256(_) => account
                .pub_key
                .get_addr()
                .ok()
                .and_then(|a| a.get_zil_bech32().ok()),
            _ => None,
        }
        .ok_or(ServiceError::AccountTypeNotValid)?;

        Ok(address)
    })
    .await
    .map_err(Into::into)
}

pub async fn make_keystore_file(
    wallet_index: usize,
    password: String,
    device_indicators: Vec<String>,
) -> Result<Vec<u8>, String> {
    let chain_hash = with_wallet(wallet_index, |wallet| {
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(data.default_chain_hash)
    })
    .await?;
    select_accounts_chain(wallet_index, chain_hash).await?;

    with_service(|core| {
        let keystore_bytes = core.get_keystore(wallet_index, &password, &device_indicators)?;
        Ok(keystore_bytes)
    })
    .await
    .map_err(Into::into)
}

pub async fn restore_from_keystore(
    keystore_bytes: Vec<u8>,
    device_indicators: Vec<String>,
    password: String,
    biometric_type: String,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let session = core.load_keystore(
            keystore_bytes,
            &password,
            &device_indicators,
            biometric_type.into(),
        )?;
        let wallet = core.wallets.last().ok_or(ServiceError::FailToSaveWallet)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

```

`rust/src/frb_generated.rs`:

```rs
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.10.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -398702815;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__wallet__add_bip39_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_bip39_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::Bip39AddWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_bip39_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__add_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_meta = <crate::models::ftoken::FTokenInfo>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::add_ftoken(api_meta, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__add_ledger_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ledger_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::ledger::LedgerParamsInput>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::add_ledger_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__book__add_new_book_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_new_book_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_net = <usize>::sse_decode(&mut deserializer);
            let api_slip44 = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::add_new_book_address(
                            api_name, api_addr, api_net, api_slip44,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_next_bip39_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_next_bip39_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::AddNextBip39AccountParams>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::add_next_bip39_account(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <crate::models::provider::NetworkConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_provider(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_providers_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_providers_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_providers_list(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_sk_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_sk_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::wallet::AddSKWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_sk_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__bip39_checksum_valid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bip39_checksum_valid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_words = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::utils::bip39_checksum_valid(api_words))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__cacl_gas_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cacl_gas_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_params =
                <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::cacl_gas_fee(
                            api_wallet_index,
                            api_account_index,
                            api_params,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_account_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_account_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::change_account_name(
                            api_wallet_index,
                            api_account_index,
                            api_new_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_wallet_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::change_wallet_name(api_wallet_index, api_new_name)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__check_not_exists_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_not_exists_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_words = <Vec<String>>::sse_decode(&mut deserializer);
            let api__lang = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::methods::check_not_exists_bip39_words(api_words, api__lang),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__check_pending_tranasctions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_pending_tranasctions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::check_pending_tranasctions(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__clear_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::clear_history(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__create_or_update_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_or_update_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <crate::models::provider::NetworkConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::create_or_update_chain(api_provider_config)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__create_token_transfer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_token_transfer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::transaction::TokenTransferParamsInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::create_token_transfer(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__create_update_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_update_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_conn =
                <crate::models::connection::ConnectionInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::create_update_connection(
                            api_wallet_index,
                            api_conn,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::delete_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::delete_wallet(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api_session_cipher,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__encode_tx_rlp_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_tx_rlp",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_tx = <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::encode_tx_rlp(
                            api_wallet_index,
                            api_account_index,
                            api_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__fetch_token_meta_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_token_meta",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::fetch_token_meta(api_addr, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__fetch_tokens_evm_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_tokens_evm_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chain_name = <String>::sse_decode(&mut deserializer);
            let api_chain_id = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::fetch_tokens_evm_list(api_chain_name, api_chain_id)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__fetch_tokens_list_zilliqa_legacy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_tokens_list_zilliqa_legacy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_limit = <u32>::sse_decode(&mut deserializer);
            let api_offset = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::fetch_tokens_list_zilliqa_legacy(
                            api_limit, api_offset,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__from_wei_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "from_wei",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <String>::sse_decode(&mut deserializer);
            let api_decimals = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, String>((move || {
                let output_ok = crate::api::utils::from_wei(api_value, api_decimals)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__methods__gen_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_count = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_bip39_words(api_count)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__methods__gen_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_keypair()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_png_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_png_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_png_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_svg_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_svg_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_svg_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__book__get_address_book_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::get_address_book_list().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_chains_providers_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_chains_providers_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_json_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::provider::get_chains_providers_from_json(api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__book__get_combine_sort_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_combine_sort_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_history = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::get_combine_sort_addresses(
                            api_wallet_index,
                            api_history,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__get_connections_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_connections_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::connections::get_connections_list(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__get_currencies_tickets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_currencies_tickets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::utils::get_currencies_tickets())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__get_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::get_data().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__get_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::get_history(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::cache::get_image_bytes(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::cache::get_image_name(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_provider(api_chain_hash).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_providers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_providers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_providers().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::get_wallets().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_zil_bech32_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_zil_bech32_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::get_zil_bech32_addresses(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_zil_eth_checksum_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_zil_eth_checksum_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::get_zil_eth_checksum_addresses(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::methods::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__utils__intl_number_formating_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "intl_number_formating",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <String>::sse_decode(&mut deserializer);
            let api_decimals = <u8>::sse_decode(&mut deserializer);
            let api_locale_str = <String>::sse_decode(&mut deserializer);
            let api_native_symbol_str = <String>::sse_decode(&mut deserializer);
            let api_converted_symbol_str = <String>::sse_decode(&mut deserializer);
            let api_threshold = <f64>::sse_decode(&mut deserializer);
            let api_compact = <bool>::sse_decode(&mut deserializer);
            let api_converted = <f64>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::utils::intl_number_formating(
                    api_value,
                    api_decimals,
                    &api_locale_str,
                    &api_native_symbol_str,
                    &api_converted_symbol_str,
                    api_threshold,
                    api_compact,
                    api_converted,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__methods__is_crypto_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_crypto_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::methods::is_crypto_address(api_addr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__is_service_running_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_service_running",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::backend::is_service_running().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__keypair_from_sk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_from_sk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sk = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::keypair_from_sk(api_sk)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_old_database_android_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_old_database_android",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::backend::load_old_database_android()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_old_database_ios_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_old_database_ios",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::backend::load_old_database_ios(api_base_dir)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__load_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::load_service(&api_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__make_keystore_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "make_keystore_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_device_indicators = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::make_keystore_file(
                            api_wallet_index,
                            api_password,
                            api_device_indicators,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qrcode__parse_qrcode_str_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_qrcode_str",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::parse_qrcode_str(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__prepare_eip712_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "prepare_eip712_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_typed_data_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::prepare_eip712_message(api_typed_data_json)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__prepare_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "prepare_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::prepare_message(
                            api_wallet_index,
                            api_account_index,
                            api_message,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__provider_req_proxy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "provider_req_proxy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <String>::sse_decode(&mut deserializer);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::provider_req_proxy(api_payload, api_chain_hash)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__remove_connections_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_connections",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_domain = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::remove_connections(
                            api_wallet_index,
                            api_domain,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__book__remove_from_address_book_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_from_address_book",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::book::remove_from_address_book(api_addr).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__remove_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_index = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::remove_provider(api_provider_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__restore_from_keystore_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "restore_from_keystore",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_keystore_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_device_indicators = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_biometric_type = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::restore_from_keystore(
                            api_keystore_bytes,
                            api_device_indicators,
                            api_password,
                            api_biometric_type,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_bip39_phrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_bip39_phrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api__passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_bip39_phrase(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api__passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_keypair(
                            api_wallet_index,
                            api_account_index,
                            api_identifiers,
                            api_password,
                            api_passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__rm_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rm_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_token_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::rm_ftoken(api_wallet_index, api_token_address)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__select_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::select_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__select_accounts_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_accounts_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::select_accounts_chain(
                            api_wallet_index,
                            api_chain_hash,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__send_signed_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_signed_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <u8>::sse_decode(&mut deserializer);
            let api_account_index = <u8>::sse_decode(&mut deserializer);
            let api_tx = <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                &mut deserializer,
            );
            let api_sig = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::send_signed_transactions(
                            api_wallet_index,
                            api_account_index,
                            api_tx,
                            api_sig,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__set_biometric_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_biometric",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_new_biometric_type = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::set_biometric(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api_session_cipher,
                            api_new_biometric_type,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_browser_settings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_browser_settings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_browser_settings =
                <crate::models::settings::BrowserSettingsInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_browser_settings(api_browser_settings)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_default_locale_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_default_locale",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_locale = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_default_locale(api_locale).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_global_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_global_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_global_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_global_notifications(api_global_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_rate_engine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rate_engine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_engine_code = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_rate_engine(
                            api_wallet_index,
                            api_engine_code,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_rate_fetcher_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rate_fetcher",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_currency = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_rate_fetcher(api_wallet_index, api_currency)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_theme_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_theme",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_appearances_code = <u8>::sse_decode(&mut deserializer);
            let api_compact_numbers = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_theme(
                            api_appearances_code,
                            api_compact_numbers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_tokens_list_fetcher_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tokens_list_fetcher",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_tokens_list_fetcher(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ens_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ens",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_ens_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ens(api_wallet_index, api_ens_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ipfs_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ipfs_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_node = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ipfs_node(api_wallet_index, api_node)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_node_ranking_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_node_ranking",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_node_ranking(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_transactions = <bool>::sse_decode(&mut deserializer);
            let api_price = <bool>::sse_decode(&mut deserializer);
            let api_security = <bool>::sse_decode(&mut deserializer);
            let api_balance = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_notifications(
                            api_wallet_index,
                            api_transactions,
                            api_price,
                            api_security,
                            api_balance,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_message(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_message,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_send_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_send_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_tx = <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_send_transactions(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__sign_typed_data_eip712_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sign_typed_data_eip712",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_typed_data_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::sign_typed_data_eip712(
                            api_wallet_index,
                            api_account_index,
                            api_password,
                            api_passphrase,
                            api_session_cipher,
                            api_identifiers,
                            api_typed_data_json,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__start_block_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_block_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_sink = <StreamSink<
                crate::api::backend::BlockEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::backend::start_block_worker(api_wallet_index, api_sink)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__start_history_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_history_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_sink =
                <StreamSink<String, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::start_history_worker(
                            api_wallet_index,
                            api_sink,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__stop_block_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_block_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::stop_block_worker().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__stop_history_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_history_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::stop_history_worker().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__stop_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::stop_service().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__sync_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::sync_balances(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__utils__to_wei_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "to_wei",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <String>::sse_decode(&mut deserializer);
            let api_decimals = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, String>((move || {
                let output_ok = crate::api::utils::to_wei(api_value, api_decimals)?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__backend__try_restore_rkstorage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_restore_rkstorage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_vault_json = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::backend::try_restore_rkstorage(api_vault_json, api_password)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_password_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_password",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_password(
                            api_password,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_session_cipher = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_session(
                            api_session_cipher,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__update_ledger_accounts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_ledger_accounts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_accounts = <Vec<(u8, String, String)>>::sse_decode(&mut deserializer);
            let api_zilliqa_legacy = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::update_ledger_accounts(
                            api_wallet_index,
                            api_accounts,
                            api_zilliqa_legacy,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__update_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::update_rates(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_get_bech32_base16_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_get_bech32_base16_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::zilliqa_get_bech32_base16_address(
                            api_wallet_index,
                            api_account_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_get_n_format_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_get_n_format",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::zilliqa_get_n_format(
                            api_wallet_index,
                            api_account_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_legacy_base16_to_bech32_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_legacy_base16_to_bech32",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base16 = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::wallet::zilliqa_legacy_base16_to_bech32(api_base16)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__zilliqa_swap_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "zilliqa_swap_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::zilliqa_swap_chain(
                            api_wallet_index,
                            api_account_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(usize, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::backend::BlockEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_storageKeys = <Vec<String>>::sse_decode(deserializer);
        return crate::models::transactions::access_list::AccessListItem {
            address: var_address,
            storage_keys: var_storageKeys,
        };
    }
}

impl SseDecode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_addrType = <u8>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_pubKey = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_chainId = <u64>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        let mut var_index = <usize>::sse_decode(deserializer);
        return crate::models::account::AccountInfo {
            addr: var_addr,
            addr_type: var_addrType,
            name: var_name,
            pub_key: var_pubKey,
            chain_hash: var_chainHash,
            chain_id: var_chainId,
            slip_44: var_slip44,
            index: var_index,
        };
    }
}

impl SseDecode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_password = <Option<String>>::sse_decode(deserializer);
        let mut var_sessionCipher = <Option<String>>::sse_decode(deserializer);
        return crate::api::wallet::AddNextBip39AccountParams {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            name: var_name,
            passphrase: var_passphrase,
            identifiers: var_identifiers,
            password: var_password,
            session_cipher: var_sessionCipher,
        };
    }
}

impl SseDecode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::wallet::AddSKWalletParams {
            sk: var_sk,
            password: var_password,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_net = <usize>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        return crate::models::book::AddressBookEntryInfo {
            name: var_name,
            addr: var_addr,
            net: var_net,
            slip44: var_slip44,
        };
    }
}

impl SseDecode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactions = <bool>::sse_decode(deserializer);
        let mut var_price = <bool>::sse_decode(deserializer);
        let mut var_security = <bool>::sse_decode(deserializer);
        let mut var_balance = <bool>::sse_decode(deserializer);
        return crate::models::notification::BackgroundNotificationState {
            transactions: var_transactions,
            price: var_price,
            security: var_security,
            balance: var_balance,
        };
    }
}

impl SseDecode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wallets = <Vec<crate::models::wallet::WalletInfo>>::sse_decode(deserializer);
        let mut var_notificationsWalletStates = <std::collections::HashMap<
            usize,
            crate::models::notification::BackgroundNotificationState,
        >>::sse_decode(deserializer);
        let mut var_notificationsGlobalEnabled = <bool>::sse_decode(deserializer);
        let mut var_locale = <Option<String>>::sse_decode(deserializer);
        let mut var_appearances = <u8>::sse_decode(deserializer);
        let mut var_abbreviatedNumber = <bool>::sse_decode(deserializer);
        let mut var_browserSettings =
            <crate::models::settings::BrowserSettingsInfo>::sse_decode(deserializer);
        let mut var_providers =
            <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(deserializer);
        return crate::models::background::BackgroundState {
            wallets: var_wallets,
            notifications_wallet_states: var_notificationsWalletStates,
            notifications_global_enabled: var_notificationsGlobalEnabled,
            locale: var_locale,
            appearances: var_appearances,
            abbreviated_number: var_abbreviatedNumber,
            browser_settings: var_browserSettings,
            providers: var_providers,
        };
    }
}

impl SseDecode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        return crate::models::transactions::base_token::BaseTokenInfo {
            value: var_value,
            symbol: var_symbol,
            decimals: var_decimals,
        };
    }
}

impl SseDecode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_mnemonicStr = <String>::sse_decode(deserializer);
        let mut var_mnemonicCheck = <bool>::sse_decode(deserializer);
        let mut var_accounts = <Vec<(usize, String)>>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        return crate::api::wallet::Bip39AddWalletParams {
            password: var_password,
            mnemonic_str: var_mnemonicStr,
            mnemonic_check: var_mnemonicCheck,
            accounts: var_accounts,
            passphrase: var_passphrase,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            chain_hash: var_chainHash,
            identifiers: var_identifiers,
        };
    }
}

impl SseDecode for crate::api::backend::BlockEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockNumber = <Option<u64>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::api::backend::BlockEvent {
            block_number: var_blockNumber,
            error: var_error,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::settings::BrowserSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_searchEngineIndex = <u8>::sse_decode(deserializer);
        let mut var_cacheEnabled = <bool>::sse_decode(deserializer);
        let mut var_cookiesEnabled = <bool>::sse_decode(deserializer);
        let mut var_contentBlocking = <u8>::sse_decode(deserializer);
        let mut var_doNotTrack = <bool>::sse_decode(deserializer);
        let mut var_incognitoMode = <bool>::sse_decode(deserializer);
        let mut var_textScalingFactor = <f32>::sse_decode(deserializer);
        let mut var_allowGeolocation = <bool>::sse_decode(deserializer);
        let mut var_allowCamera = <bool>::sse_decode(deserializer);
        let mut var_allowMicrophone = <bool>::sse_decode(deserializer);
        let mut var_allowAutoPlay = <bool>::sse_decode(deserializer);
        return crate::models::settings::BrowserSettingsInfo {
            search_engine_index: var_searchEngineIndex,
            cache_enabled: var_cacheEnabled,
            cookies_enabled: var_cookiesEnabled,
            content_blocking: var_contentBlocking,
            do_not_track: var_doNotTrack,
            incognito_mode: var_incognitoMode,
            text_scaling_factor: var_textScalingFactor,
            allow_geolocation: var_allowGeolocation,
            allow_camera: var_allowCamera,
            allow_microphone: var_allowMicrophone,
            allow_auto_play: var_allowAutoPlay,
        };
    }
}

impl SseDecode for crate::api::book::Category {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_entries = <Vec<crate::api::book::Entry>>::sse_decode(deserializer);
        return crate::api::book::Category {
            name: var_name,
            entries: var_entries,
        };
    }
}

impl SseDecode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_primary = <Option<String>>::sse_decode(deserializer);
        let mut var_secondary = <Option<String>>::sse_decode(deserializer);
        let mut var_background = <Option<String>>::sse_decode(deserializer);
        let mut var_text = <Option<String>>::sse_decode(deserializer);
        return crate::models::connection::ColorsInfo {
            primary: var_primary,
            secondary: var_secondary,
            background: var_background,
            text: var_text,
        };
    }
}

impl SseDecode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_accountIndexes = <Vec<usize>>::sse_decode(deserializer);
        let mut var_favicon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_colors =
            <Option<crate::models::connection::ColorsInfo>>::sse_decode(deserializer);
        let mut var_lastConnected = <u64>::sse_decode(deserializer);
        let mut var_canReadAccounts = <bool>::sse_decode(deserializer);
        let mut var_canRequestSignatures = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTokens = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTransactions = <bool>::sse_decode(deserializer);
        return crate::models::connection::ConnectionInfo {
            domain: var_domain,
            account_indexes: var_accountIndexes,
            favicon: var_favicon,
            title: var_title,
            description: var_description,
            colors: var_colors,
            last_connected: var_lastConnected,
            can_read_accounts: var_canReadAccounts,
            can_request_signatures: var_canRequestSignatures,
            can_suggest_tokens: var_canSuggestTokens,
            can_suggest_transactions: var_canSuggestTransactions,
        };
    }
}

impl SseDecode for crate::api::transaction::Eip712Hashes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_domainSeparator = <Vec<u8>>::sse_decode(deserializer);
        let mut var_hashStructMessage = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::transaction::Eip712Hashes {
            domain_separator: var_domainSeparator,
            hash_struct_message: var_hashStructMessage,
        };
    }
}

impl SseDecode for crate::api::book::Entry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_tag = <Option<String>>::sse_decode(deserializer);
        return crate::api::book::Entry {
            name: var_name,
            address: var_address,
            tag: var_tag,
        };
    }
}

impl SseDecode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_standard = <u16>::sse_decode(deserializer);
        return crate::models::provider::ExplorerInfo {
            name: var_name,
            url: var_url,
            icon: var_icon,
            standard: var_standard,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_addrType = <u8>::sse_decode(deserializer);
        let mut var_logo = <Option<String>>::sse_decode(deserializer);
        let mut var_balances = <std::collections::HashMap<usize, String>>::sse_decode(deserializer);
        let mut var_rate = <f64>::sse_decode(deserializer);
        let mut var_default_ = <bool>::sse_decode(deserializer);
        let mut var_native = <bool>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::models::ftoken::FTokenInfo {
            name: var_name,
            symbol: var_symbol,
            decimals: var_decimals,
            addr: var_addr,
            addr_type: var_addrType,
            logo: var_logo,
            balances: var_balances,
            rate: var_rate,
            default: var_default_,
            native: var_native,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxFee = <u128>::sse_decode(deserializer);
        let mut var_priorityFee = <u128>::sse_decode(deserializer);
        let mut var_baseFee = <u128>::sse_decode(deserializer);
        return crate::models::gas::GasFeeHistoryInfo {
            max_fee: var_maxFee,
            priority_fee: var_priorityFee,
            base_fee: var_baseFee,
        };
    }
}

impl SseDecode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactionHash = <String>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_contractAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_status =
            <crate::models::transactions::history::TransactionStatusInfo>::sse_decode(deserializer);
        let mut var_statusCode = <Option<u8>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_blockNumber = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasUsed = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasLimit = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_blobGasUsed = <Option<u128>>::sse_decode(deserializer);
        let mut var_blobGasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_effectiveGasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_fee = <u128>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        let mut var_sig = <String>::sse_decode(deserializer);
        let mut var_nonce = <u128>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        let mut var_chainType = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::models::transactions::history::HistoricalTransactionInfo {
            transaction_hash: var_transactionHash,
            amount: var_amount,
            sender: var_sender,
            recipient: var_recipient,
            contract_address: var_contractAddress,
            status: var_status,
            status_code: var_statusCode,
            timestamp: var_timestamp,
            block_number: var_blockNumber,
            gas_used: var_gasUsed,
            gas_limit: var_gasLimit,
            gas_price: var_gasPrice,
            blob_gas_used: var_blobGasUsed,
            blob_gas_price: var_blobGasPrice,
            effective_gas_price: var_effectiveGasPrice,
            fee: var_fee,
            icon: var_icon,
            title: var_title,
            error: var_error,
            sig: var_sig,
            nonce: var_nonce,
            token_info: var_tokenInfo,
            chain_type: var_chainType,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_pk = <String>::sse_decode(deserializer);
        return crate::models::keypair::KeyPairInfo {
            sk: var_sk,
            pk: var_pk,
        };
    }
}

impl SseDecode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubKeys = <Vec<(u8, String)>>::sse_decode(deserializer);
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_ledgerId = <String>::sse_decode(deserializer);
        let mut var_accountNames = <Vec<String>>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_zilliqaLegacy = <bool>::sse_decode(deserializer);
        return crate::api::ledger::LedgerParamsInput {
            pub_keys: var_pubKeys,
            wallet_index: var_walletIndex,
            wallet_name: var_walletName,
            ledger_id: var_ledgerId,
            account_names: var_accountNames,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
            zilliqa_legacy: var_zilliqaLegacy,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::access_list::AccessListItem>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::account::AccountInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::book::AddressBookEntryInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::book::Category> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::book::Category>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::connection::ConnectionInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::book::Entry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::book::Entry>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::ExplorerInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::ftoken::FTokenInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::history::HistoricalTransactionInfo>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::NetworkConfigInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u16>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<usize>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(u8, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(u8, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(u8, String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(u8, String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(usize, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::wallet::WalletInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_logo = <String>::sse_decode(deserializer);
        let mut var_chain = <String>::sse_decode(deserializer);
        let mut var_shortName = <String>::sse_decode(deserializer);
        let mut var_rpc = <Vec<String>>::sse_decode(deserializer);
        let mut var_features = <Vec<u16>>::sse_decode(deserializer);
        let mut var_chainId = <u64>::sse_decode(deserializer);
        let mut var_chainIds = <Vec<u64>>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        let mut var_diffBlockTime = <u64>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_ens = <Option<String>>::sse_decode(deserializer);
        let mut var_explorers =
            <Vec<crate::models::provider::ExplorerInfo>>::sse_decode(deserializer);
        let mut var_fallbackEnabled = <bool>::sse_decode(deserializer);
        let mut var_testnet = <Option<bool>>::sse_decode(deserializer);
        let mut var_ftokens = <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(deserializer);
        return crate::models::provider::NetworkConfigInfo {
            name: var_name,
            logo: var_logo,
            chain: var_chain,
            short_name: var_shortName,
            rpc: var_rpc,
            features: var_features,
            chain_id: var_chainId,
            chain_ids: var_chainIds,
            slip_44: var_slip44,
            diff_block_time: var_diffBlockTime,
            chain_hash: var_chainHash,
            ens: var_ens,
            explorers: var_explorers,
            fallback_enabled: var_fallbackEnabled,
            testnet: var_testnet,
            ftokens: var_ftokens,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::base_token::BaseTokenInfo>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::connection::ColorsInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::evm::TransactionRequestEVM>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::scilla::TransactionRequestScilla>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<
                crate::models::transactions::access_list::AccessListItem,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_provider = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_amount = <Option<String>>::sse_decode(deserializer);
        return crate::models::qrcode::QRcodeScanResultInfo {
            recipient: var_recipient,
            provider: var_provider,
            token_address: var_tokenAddress,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_size = <u32>::sse_decode(deserializer);
        let mut var_gapless = <bool>::sse_decode(deserializer);
        let mut var_color = <u32>::sse_decode(deserializer);
        let mut var_eyeShape = <u8>::sse_decode(deserializer);
        let mut var_dataModuleShape = <u8>::sse_decode(deserializer);
        return crate::models::qrcode::QrConfigInfo {
            size: var_size,
            gapless: var_gapless,
            color: var_color,
            eye_shape: var_eyeShape,
            data_module_shape: var_dataModuleShape,
        };
    }
}

impl SseDecode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, u8) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <u8>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (u8, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u8>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (u8, String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u8>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        let mut var_field2 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 =
            <crate::models::notification::BackgroundNotificationState>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::models::gas::RequiredTxParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_maxPriorityFee = <u128>::sse_decode(deserializer);
        let mut var_feeHistory = <crate::models::gas::GasFeeHistoryInfo>::sse_decode(deserializer);
        let mut var_txEstimateGas = <u64>::sse_decode(deserializer);
        let mut var_blobBaseFee = <u128>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        return crate::models::gas::RequiredTxParamsInfo {
            gas_price: var_gasPrice,
            max_priority_fee: var_maxPriorityFee,
            fee_history: var_feeHistory,
            tx_estimate_gas: var_txEstimateGas,
            blob_base_fee: var_blobBaseFee,
            nonce: var_nonce,
        };
    }
}

impl SseDecode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_token = <crate::models::ftoken::FTokenInfo>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_icon = <String>::sse_decode(deserializer);
        return crate::api::transaction::TokenTransferParamsInfo {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            token: var_token,
            amount: var_amount,
            recipient: var_recipient,
            icon: var_icon,
        };
    }
}

impl SseDecode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_hash = <Option<String>>::sse_decode(deserializer);
        let mut var_info = <Option<String>>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_signer = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
            chain_hash: var_chainHash,
            hash: var_hash,
            info: var_info,
            icon: var_icon,
            title: var_title,
            signer: var_signer,
            token_info: var_tokenInfo,
        };
    }
}

impl SseDecode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nonce = <Option<u64>>::sse_decode(deserializer);
        let mut var_from = <Option<String>>::sse_decode(deserializer);
        let mut var_to = <Option<String>>::sse_decode(deserializer);
        let mut var_value = <Option<String>>::sse_decode(deserializer);
        let mut var_gasLimit = <Option<u64>>::sse_decode(deserializer);
        let mut var_data = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_maxFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_maxPriorityFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_chainId = <Option<u64>>::sse_decode(deserializer);
        let mut var_accessList = <Option<
            Vec<crate::models::transactions::access_list::AccessListItem>,
        >>::sse_decode(deserializer);
        let mut var_blobVersionedHashes = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_maxFeePerBlobGas = <Option<u128>>::sse_decode(deserializer);
        return crate::models::transactions::evm::TransactionRequestEVM {
            nonce: var_nonce,
            from: var_from,
            to: var_to,
            value: var_value,
            gas_limit: var_gasLimit,
            data: var_data,
            max_fee_per_gas: var_maxFeePerGas,
            max_priority_fee_per_gas: var_maxPriorityFeePerGas,
            gas_price: var_gasPrice,
            chain_id: var_chainId,
            access_list: var_accessList,
            blob_versioned_hashes: var_blobVersionedHashes,
            max_fee_per_blob_gas: var_maxFeePerBlobGas,
        };
    }
}

impl SseDecode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_metadata = <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_decode(deserializer);
        let mut var_scilla =
            <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_decode(
                deserializer,
            );
        let mut var_evm =
            <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::request::TransactionRequestInfo {
            metadata: var_metadata,
            scilla: var_scilla,
            evm: var_evm,
        };
    }
}

impl SseDecode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainId = <u16>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_gasLimit = <u64>::sse_decode(deserializer);
        let mut var_toAddr = <String>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_data = <String>::sse_decode(deserializer);
        return crate::models::transactions::scilla::TransactionRequestScilla {
            chain_id: var_chainId,
            nonce: var_nonce,
            gas_price: var_gasPrice,
            gas_limit: var_gasLimit,
            to_addr: var_toAddr,
            amount: var_amount,
            code: var_code,
            data: var_data,
        };
    }
}

impl SseDecode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::transactions::history::TransactionStatusInfo::Pending,
            1 => crate::models::transactions::history::TransactionStatusInfo::Confirmed,
            2 => crate::models::transactions::history::TransactionStatusInfo::Rejected,
            _ => unreachable!("Invalid variant for TransactionStatusInfo: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_memory = <u32>::sse_decode(deserializer);
        let mut var_iterations = <u32>::sse_decode(deserializer);
        let mut var_threads = <u32>::sse_decode(deserializer);
        let mut var_secret = <String>::sse_decode(deserializer);
        return crate::models::settings::WalletArgonParamsInfo {
            memory: var_memory,
            iterations: var_iterations,
            threads: var_threads,
            secret: var_secret,
        };
    }
}

impl SseDecode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletType = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_authType = <String>::sse_decode(deserializer);
        let mut var_walletAddress = <String>::sse_decode(deserializer);
        let mut var_accounts = <Vec<crate::models::account::AccountInfo>>::sse_decode(deserializer);
        let mut var_selectedAccount = <usize>::sse_decode(deserializer);
        let mut var_tokens = <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(deserializer);
        let mut var_settings =
            <crate::models::settings::WalletSettingsInfo>::sse_decode(deserializer);
        let mut var_defaultChainHash = <u64>::sse_decode(deserializer);
        return crate::models::wallet::WalletInfo {
            wallet_type: var_walletType,
            wallet_name: var_walletName,
            auth_type: var_authType,
            wallet_address: var_walletAddress,
            accounts: var_accounts,
            selected_account: var_selectedAccount,
            tokens: var_tokens,
            settings: var_settings,
            default_chain_hash: var_defaultChainHash,
        };
    }
}

impl SseDecode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cipherOrders = <Vec<u8>>::sse_decode(deserializer);
        let mut var_argonParams =
            <crate::models::settings::WalletArgonParamsInfo>::sse_decode(deserializer);
        let mut var_currencyConvert = <String>::sse_decode(deserializer);
        let mut var_ipfsNode = <Option<String>>::sse_decode(deserializer);
        let mut var_ensEnabled = <bool>::sse_decode(deserializer);
        let mut var_tokensListFetcher = <bool>::sse_decode(deserializer);
        let mut var_nodeRankingEnabled = <bool>::sse_decode(deserializer);
        let mut var_maxConnections = <u8>::sse_decode(deserializer);
        let mut var_requestTimeoutSecs = <u32>::sse_decode(deserializer);
        let mut var_ratesApiOptions = <u8>::sse_decode(deserializer);
        return crate::models::settings::WalletSettingsInfo {
            cipher_orders: var_cipherOrders,
            argon_params: var_argonParams,
            currency_convert: var_currencyConvert,
            ipfs_node: var_ipfsNode,
            ens_enabled: var_ensEnabled,
            tokens_list_fetcher: var_tokensListFetcher,
            node_ranking_enabled: var_nodeRankingEnabled,
            max_connections: var_maxConnections,
            request_timeout_secs: var_requestTimeoutSecs,
            rates_api_options: var_ratesApiOptions,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__wallet__add_bip39_wallet_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__token__add_ftoken_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__ledger__add_ledger_wallet_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__book__add_new_book_address_impl(port, ptr, rust_vec_len, data_len),
        5 => {
            wire__crate__api__wallet__add_next_bip39_account_impl(port, ptr, rust_vec_len, data_len)
        }
        6 => wire__crate__api__provider__add_provider_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__provider__add_providers_list_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__wallet__add_sk_wallet_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__utils__bip39_checksum_valid_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__transaction__cacl_gas_fee_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__wallet__change_account_name_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__wallet__change_wallet_name_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__methods__check_not_exists_bip39_words_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__transaction__check_pending_tranasctions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        15 => wire__crate__api__transaction__clear_history_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__provider__create_or_update_chain_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        17 => wire__crate__api__transaction__create_token_transfer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__connections__create_update_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__wallet__delete_account_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__wallet__delete_wallet_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__transaction__encode_tx_rlp_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__token__fetch_token_meta_impl(port, ptr, rust_vec_len, data_len),
        23 => {
            wire__crate__api__token__fetch_tokens_evm_list_impl(port, ptr, rust_vec_len, data_len)
        }
        24 => wire__crate__api__token__fetch_tokens_list_zilliqa_legacy_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        26 => wire__crate__api__methods__gen_bip39_words_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__methods__gen_keypair_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__qrcode__gen_png_qrcode_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__qrcode__gen_svg_qrcode_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__book__get_address_book_list_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__provider__get_chains_providers_from_json_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        32 => wire__crate__api__book__get_combine_sort_addresses_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        33 => wire__crate__api__connections__get_connections_list_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        34 => {
            wire__crate__api__utils__get_currencies_tickets_impl(port, ptr, rust_vec_len, data_len)
        }
        35 => wire__crate__api__backend__get_data_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__transaction__get_history_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__cache__get_image_bytes_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__cache__get_image_name_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__provider__get_provider_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__provider__get_providers_impl(port, ptr, rust_vec_len, data_len),
        41 => wire__crate__api__wallet__get_wallets_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__wallet__get_zil_bech32_addresses_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        43 => wire__crate__api__wallet__get_zil_eth_checksum_addresses_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        44 => wire__crate__api__methods__init_app_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__methods__is_crypto_address_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__backend__is_service_running_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__methods__keypair_from_sk_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__backend__load_old_database_android_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        50 => {
            wire__crate__api__backend__load_old_database_ios_impl(port, ptr, rust_vec_len, data_len)
        }
        51 => wire__crate__api__backend__load_service_impl(port, ptr, rust_vec_len, data_len),
        52 => wire__crate__api__wallet__make_keystore_file_impl(port, ptr, rust_vec_len, data_len),
        53 => wire__crate__api__qrcode__parse_qrcode_str_impl(port, ptr, rust_vec_len, data_len),
        54 => wire__crate__api__transaction__prepare_eip712_message_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        55 => {
            wire__crate__api__transaction__prepare_message_impl(port, ptr, rust_vec_len, data_len)
        }
        56 => {
            wire__crate__api__provider__provider_req_proxy_impl(port, ptr, rust_vec_len, data_len)
        }
        57 => wire__crate__api__connections__remove_connections_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        58 => {
            wire__crate__api__book__remove_from_address_book_impl(port, ptr, rust_vec_len, data_len)
        }
        59 => wire__crate__api__provider__remove_provider_impl(port, ptr, rust_vec_len, data_len),
        60 => {
            wire__crate__api__wallet__restore_from_keystore_impl(port, ptr, rust_vec_len, data_len)
        }
        61 => wire__crate__api__wallet__reveal_bip39_phrase_impl(port, ptr, rust_vec_len, data_len),
        62 => wire__crate__api__wallet__reveal_keypair_impl(port, ptr, rust_vec_len, data_len),
        63 => wire__crate__api__token__rm_ftoken_impl(port, ptr, rust_vec_len, data_len),
        64 => wire__crate__api__wallet__select_account_impl(port, ptr, rust_vec_len, data_len),
        65 => wire__crate__api__provider__select_accounts_chain_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        66 => wire__crate__api__transaction__send_signed_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        67 => wire__crate__api__wallet__set_biometric_impl(port, ptr, rust_vec_len, data_len),
        68 => {
            wire__crate__api__settings__set_browser_settings_impl(port, ptr, rust_vec_len, data_len)
        }
        69 => {
            wire__crate__api__settings__set_default_locale_impl(port, ptr, rust_vec_len, data_len)
        }
        70 => wire__crate__api__settings__set_global_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        71 => wire__crate__api__settings__set_rate_engine_impl(port, ptr, rust_vec_len, data_len),
        72 => wire__crate__api__settings__set_rate_fetcher_impl(port, ptr, rust_vec_len, data_len),
        73 => wire__crate__api__settings__set_theme_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__settings__set_tokens_list_fetcher_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        75 => wire__crate__api__settings__set_wallet_ens_impl(port, ptr, rust_vec_len, data_len),
        76 => {
            wire__crate__api__settings__set_wallet_ipfs_node_impl(port, ptr, rust_vec_len, data_len)
        }
        77 => wire__crate__api__settings__set_wallet_node_ranking_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        78 => wire__crate__api__settings__set_wallet_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        79 => wire__crate__api__transaction__sign_message_impl(port, ptr, rust_vec_len, data_len),
        80 => wire__crate__api__transaction__sign_send_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        81 => wire__crate__api__transaction__sign_typed_data_eip712_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        82 => wire__crate__api__backend__start_block_worker_impl(port, ptr, rust_vec_len, data_len),
        83 => wire__crate__api__transaction__start_history_worker_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        84 => wire__crate__api__backend__stop_block_worker_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__transaction__stop_history_worker_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        86 => wire__crate__api__backend__stop_service_impl(port, ptr, rust_vec_len, data_len),
        87 => wire__crate__api__token__sync_balances_impl(port, ptr, rust_vec_len, data_len),
        89 => {
            wire__crate__api__backend__try_restore_rkstorage_impl(port, ptr, rust_vec_len, data_len)
        }
        90 => {
            wire__crate__api__auth__try_unlock_with_password_impl(port, ptr, rust_vec_len, data_len)
        }
        91 => {
            wire__crate__api__auth__try_unlock_with_session_impl(port, ptr, rust_vec_len, data_len)
        }
        92 => {
            wire__crate__api__ledger__update_ledger_accounts_impl(port, ptr, rust_vec_len, data_len)
        }
        93 => wire__crate__api__token__update_rates_impl(port, ptr, rust_vec_len, data_len),
        94 => wire__crate__api__wallet__zilliqa_get_bech32_base16_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        95 => {
            wire__crate__api__wallet__zilliqa_get_n_format_impl(port, ptr, rust_vec_len, data_len)
        }
        96 => wire__crate__api__wallet__zilliqa_legacy_base16_to_bech32_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        97 => wire__crate__api__wallet__zilliqa_swap_chain_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        25 => wire__crate__api__utils__from_wei_impl(ptr, rust_vec_len, data_len),
        45 => wire__crate__api__utils__intl_number_formating_impl(ptr, rust_vec_len, data_len),
        88 => wire__crate__api__utils__to_wei_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::access_list::AccessListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.storage_keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::access_list::AccessListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::access_list::AccessListItem>
    for crate::models::transactions::access_list::AccessListItem
{
    fn into_into_dart(self) -> crate::models::transactions::access_list::AccessListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::account::AccountInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.addr_type.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.pub_key.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.slip_44.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::account::AccountInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::account::AccountInfo>
    for crate::models::account::AccountInfo
{
    fn into_into_dart(self) -> crate::models::account::AccountInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddNextBip39AccountParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.session_cipher.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddNextBip39AccountParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddNextBip39AccountParams>
    for crate::api::wallet::AddNextBip39AccountParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddNextBip39AccountParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddSKWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddSKWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddSKWalletParams>
    for crate::api::wallet::AddSKWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddSKWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::book::AddressBookEntryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.net.into_into_dart().into_dart(),
            self.slip44.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::book::AddressBookEntryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::book::AddressBookEntryInfo>
    for crate::models::book::AddressBookEntryInfo
{
    fn into_into_dart(self) -> crate::models::book::AddressBookEntryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::notification::BackgroundNotificationState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transactions.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
            self.security.into_into_dart().into_dart(),
            self.balance.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::notification::BackgroundNotificationState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::notification::BackgroundNotificationState>
    for crate::models::notification::BackgroundNotificationState
{
    fn into_into_dart(self) -> crate::models::notification::BackgroundNotificationState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::background::BackgroundState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallets.into_into_dart().into_dart(),
            self.notifications_wallet_states
                .into_into_dart()
                .into_dart(),
            self.notifications_global_enabled
                .into_into_dart()
                .into_dart(),
            self.locale.into_into_dart().into_dart(),
            self.appearances.into_into_dart().into_dart(),
            self.abbreviated_number.into_into_dart().into_dart(),
            self.browser_settings.into_into_dart().into_dart(),
            self.providers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::background::BackgroundState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::background::BackgroundState>
    for crate::models::background::BackgroundState
{
    fn into_into_dart(self) -> crate::models::background::BackgroundState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::base_token::BaseTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::base_token::BaseTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::base_token::BaseTokenInfo>
    for crate::models::transactions::base_token::BaseTokenInfo
{
    fn into_into_dart(self) -> crate::models::transactions::base_token::BaseTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::Bip39AddWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.password.into_into_dart().into_dart(),
            self.mnemonic_str.into_into_dart().into_dart(),
            self.mnemonic_check.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::Bip39AddWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::Bip39AddWalletParams>
    for crate::api::wallet::Bip39AddWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::Bip39AddWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::backend::BlockEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_number.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::backend::BlockEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::backend::BlockEvent>
    for crate::api::backend::BlockEvent
{
    fn into_into_dart(self) -> crate::api::backend::BlockEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::BrowserSettingsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.search_engine_index.into_into_dart().into_dart(),
            self.cache_enabled.into_into_dart().into_dart(),
            self.cookies_enabled.into_into_dart().into_dart(),
            self.content_blocking.into_into_dart().into_dart(),
            self.do_not_track.into_into_dart().into_dart(),
            self.incognito_mode.into_into_dart().into_dart(),
            self.text_scaling_factor.into_into_dart().into_dart(),
            self.allow_geolocation.into_into_dart().into_dart(),
            self.allow_camera.into_into_dart().into_dart(),
            self.allow_microphone.into_into_dart().into_dart(),
            self.allow_auto_play.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::BrowserSettingsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::BrowserSettingsInfo>
    for crate::models::settings::BrowserSettingsInfo
{
    fn into_into_dart(self) -> crate::models::settings::BrowserSettingsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::book::Category {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.entries.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::book::Category {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::book::Category> for crate::api::book::Category {
    fn into_into_dart(self) -> crate::api::book::Category {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ColorsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.primary.into_into_dart().into_dart(),
            self.secondary.into_into_dart().into_dart(),
            self.background.into_into_dart().into_dart(),
            self.text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ColorsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ColorsInfo>
    for crate::models::connection::ColorsInfo
{
    fn into_into_dart(self) -> crate::models::connection::ColorsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ConnectionInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.domain.into_into_dart().into_dart(),
            self.account_indexes.into_into_dart().into_dart(),
            self.favicon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.colors.into_into_dart().into_dart(),
            self.last_connected.into_into_dart().into_dart(),
            self.can_read_accounts.into_into_dart().into_dart(),
            self.can_request_signatures.into_into_dart().into_dart(),
            self.can_suggest_tokens.into_into_dart().into_dart(),
            self.can_suggest_transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ConnectionInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ConnectionInfo>
    for crate::models::connection::ConnectionInfo
{
    fn into_into_dart(self) -> crate::models::connection::ConnectionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::transaction::Eip712Hashes {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.domain_separator.into_into_dart().into_dart(),
            self.hash_struct_message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transaction::Eip712Hashes
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::transaction::Eip712Hashes>
    for crate::api::transaction::Eip712Hashes
{
    fn into_into_dart(self) -> crate::api::transaction::Eip712Hashes {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::book::Entry {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.tag.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::book::Entry {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::book::Entry> for crate::api::book::Entry {
    fn into_into_dart(self) -> crate::api::book::Entry {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::ExplorerInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.standard.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::ExplorerInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::ExplorerInfo>
    for crate::models::provider::ExplorerInfo
{
    fn into_into_dart(self) -> crate::models::provider::ExplorerInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::ftoken::FTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.addr_type.into_into_dart().into_dart(),
            self.logo.into_into_dart().into_dart(),
            self.balances.into_into_dart().into_dart(),
            self.rate.into_into_dart().into_dart(),
            self.default.into_into_dart().into_dart(),
            self.native.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::ftoken::FTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::ftoken::FTokenInfo>
    for crate::models::ftoken::FTokenInfo
{
    fn into_into_dart(self) -> crate::models::ftoken::FTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::GasFeeHistoryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_fee.into_into_dart().into_dart(),
            self.priority_fee.into_into_dart().into_dart(),
            self.base_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::gas::GasFeeHistoryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::GasFeeHistoryInfo>
    for crate::models::gas::GasFeeHistoryInfo
{
    fn into_into_dart(self) -> crate::models::gas::GasFeeHistoryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transaction_hash.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
            self.contract_address.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.status_code.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.block_number.into_into_dart().into_dart(),
            self.gas_used.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.blob_gas_used.into_into_dart().into_dart(),
            self.blob_gas_price.into_into_dart().into_dart(),
            self.effective_gas_price.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
            self.sig.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
            self.chain_type.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::HistoricalTransactionInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::history::HistoricalTransactionInfo,
    > for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::HistoricalTransactionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::keypair::KeyPairInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.pk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::keypair::KeyPairInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::keypair::KeyPairInfo>
    for crate::models::keypair::KeyPairInfo
{
    fn into_into_dart(self) -> crate::models::keypair::KeyPairInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ledger::LedgerParamsInput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pub_keys.into_into_dart().into_dart(),
            self.wallet_index.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.ledger_id.into_into_dart().into_dart(),
            self.account_names.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.zilliqa_legacy.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ledger::LedgerParamsInput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ledger::LedgerParamsInput>
    for crate::api::ledger::LedgerParamsInput
{
    fn into_into_dart(self) -> crate::api::ledger::LedgerParamsInput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::NetworkConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.logo.into_into_dart().into_dart(),
            self.chain.into_into_dart().into_dart(),
            self.short_name.into_into_dart().into_dart(),
            self.rpc.into_into_dart().into_dart(),
            self.features.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.chain_ids.into_into_dart().into_dart(),
            self.slip_44.into_into_dart().into_dart(),
            self.diff_block_time.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.ens.into_into_dart().into_dart(),
            self.explorers.into_into_dart().into_dart(),
            self.fallback_enabled.into_into_dart().into_dart(),
            self.testnet.into_into_dart().into_dart(),
            self.ftokens.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::NetworkConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::NetworkConfigInfo>
    for crate::models::provider::NetworkConfigInfo
{
    fn into_into_dart(self) -> crate::models::provider::NetworkConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QRcodeScanResultInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.recipient.into_into_dart().into_dart(),
            self.provider.into_into_dart().into_dart(),
            self.token_address.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QRcodeScanResultInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QRcodeScanResultInfo>
    for crate::models::qrcode::QRcodeScanResultInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QRcodeScanResultInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QrConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.size.into_into_dart().into_dart(),
            self.gapless.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.eye_shape.into_into_dart().into_dart(),
            self.data_module_shape.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QrConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QrConfigInfo>
    for crate::models::qrcode::QrConfigInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QrConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::RequiredTxParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.gas_price.into_into_dart().into_dart(),
            self.max_priority_fee.into_into_dart().into_dart(),
            self.fee_history.into_into_dart().into_dart(),
            self.tx_estimate_gas.into_into_dart().into_dart(),
            self.blob_base_fee.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::gas::RequiredTxParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::RequiredTxParamsInfo>
    for crate::models::gas::RequiredTxParamsInfo
{
    fn into_into_dart(self) -> crate::models::gas::RequiredTxParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::transaction::TokenTransferParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transaction::TokenTransferParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::transaction::TokenTransferParamsInfo>
    for crate::api::transaction::TokenTransferParamsInfo
{
    fn into_into_dart(self) -> crate::api::transaction::TokenTransferParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_hash.into_into_dart().into_dart(),
            self.hash.into_into_dart().into_dart(),
            self.info.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.signer.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::transaction_metadata::TransactionMetadataInfo,
    > for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_into_dart(
        self,
    ) -> crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::evm::TransactionRequestEVM {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.nonce.into_into_dart().into_dart(),
            self.from.into_into_dart().into_dart(),
            self.to.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
            self.max_fee_per_gas.into_into_dart().into_dart(),
            self.max_priority_fee_per_gas.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.access_list.into_into_dart().into_dart(),
            self.blob_versioned_hashes.into_into_dart().into_dart(),
            self.max_fee_per_blob_gas.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::evm::TransactionRequestEVM
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::evm::TransactionRequestEVM>
    for crate::models::transactions::evm::TransactionRequestEVM
{
    fn into_into_dart(self) -> crate::models::transactions::evm::TransactionRequestEVM {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.metadata.into_into_dart().into_dart(),
            self.scilla.into_into_dart().into_dart(),
            self.evm.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::request::TransactionRequestInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::request::TransactionRequestInfo>
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_into_dart(self) -> crate::models::transactions::request::TransactionRequestInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_id.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.to_addr.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.code.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::scilla::TransactionRequestScilla
{
}
impl
    flutter_rust_bridge::IntoIntoDart<crate::models::transactions::scilla::TransactionRequestScilla>
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_into_dart(self) -> crate::models::transactions::scilla::TransactionRequestScilla {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::history::TransactionStatusInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Confirmed => 1.into_dart(),
            Self::Rejected => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::TransactionStatusInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::history::TransactionStatusInfo>
    for crate::models::transactions::history::TransactionStatusInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::TransactionStatusInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletArgonParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.memory.into_into_dart().into_dart(),
            self.iterations.into_into_dart().into_dart(),
            self.threads.into_into_dart().into_dart(),
            self.secret.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletArgonParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletArgonParamsInfo>
    for crate::models::settings::WalletArgonParamsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletArgonParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::wallet::WalletInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_type.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.auth_type.into_into_dart().into_dart(),
            self.wallet_address.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.selected_account.into_into_dart().into_dart(),
            self.tokens.into_into_dart().into_dart(),
            self.settings.into_into_dart().into_dart(),
            self.default_chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::wallet::WalletInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::wallet::WalletInfo>
    for crate::models::wallet::WalletInfo
{
    fn into_into_dart(self) -> crate::models::wallet::WalletInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletSettingsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.cipher_orders.into_into_dart().into_dart(),
            self.argon_params.into_into_dart().into_dart(),
            self.currency_convert.into_into_dart().into_dart(),
            self.ipfs_node.into_into_dart().into_dart(),
            self.ens_enabled.into_into_dart().into_dart(),
            self.tokens_list_fetcher.into_into_dart().into_dart(),
            self.node_ranking_enabled.into_into_dart().into_dart(),
            self.max_connections.into_into_dart().into_dart(),
            self.request_timeout_secs.into_into_dart().into_dart(),
            self.rates_api_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletSettingsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletSettingsInfo>
    for crate::models::settings::WalletSettingsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletSettingsInfo {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(usize, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::backend::BlockEvent, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <Vec<String>>::sse_encode(self.storage_keys, serializer);
    }
}

impl SseEncode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.addr, serializer);
        <u8>::sse_encode(self.addr_type, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.pub_key, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <u64>::sse_encode(self.chain_id, serializer);
        <u32>::sse_encode(self.slip_44, serializer);
        <usize>::sse_encode(self.index, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <Option<String>>::sse_encode(self.password, serializer);
        <Option<String>>::sse_encode(self.session_cipher, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.addr, serializer);
        <usize>::sse_encode(self.net, serializer);
        <u32>::sse_encode(self.slip44, serializer);
    }
}

impl SseEncode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.transactions, serializer);
        <bool>::sse_encode(self.price, serializer);
        <bool>::sse_encode(self.security, serializer);
        <bool>::sse_encode(self.balance, serializer);
    }
}

impl SseEncode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::wallet::WalletInfo>>::sse_encode(self.wallets, serializer);
        <std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>>::sse_encode(self.notifications_wallet_states, serializer);
        <bool>::sse_encode(self.notifications_global_enabled, serializer);
        <Option<String>>::sse_encode(self.locale, serializer);
        <u8>::sse_encode(self.appearances, serializer);
        <bool>::sse_encode(self.abbreviated_number, serializer);
        <crate::models::settings::BrowserSettingsInfo>::sse_encode(
            self.browser_settings,
            serializer,
        );
        <Vec<crate::models::provider::NetworkConfigInfo>>::sse_encode(self.providers, serializer);
    }
}

impl SseEncode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
    }
}

impl SseEncode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.mnemonic_str, serializer);
        <bool>::sse_encode(self.mnemonic_check, serializer);
        <Vec<(usize, String)>>::sse_encode(self.accounts, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
    }
}

impl SseEncode for crate::api::backend::BlockEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.block_number, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::settings::BrowserSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.search_engine_index, serializer);
        <bool>::sse_encode(self.cache_enabled, serializer);
        <bool>::sse_encode(self.cookies_enabled, serializer);
        <u8>::sse_encode(self.content_blocking, serializer);
        <bool>::sse_encode(self.do_not_track, serializer);
        <bool>::sse_encode(self.incognito_mode, serializer);
        <f32>::sse_encode(self.text_scaling_factor, serializer);
        <bool>::sse_encode(self.allow_geolocation, serializer);
        <bool>::sse_encode(self.allow_camera, serializer);
        <bool>::sse_encode(self.allow_microphone, serializer);
        <bool>::sse_encode(self.allow_auto_play, serializer);
    }
}

impl SseEncode for crate::api::book::Category {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Vec<crate::api::book::Entry>>::sse_encode(self.entries, serializer);
    }
}

impl SseEncode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.primary, serializer);
        <Option<String>>::sse_encode(self.secondary, serializer);
        <Option<String>>::sse_encode(self.background, serializer);
        <Option<String>>::sse_encode(self.text, serializer);
    }
}

impl SseEncode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.domain, serializer);
        <Vec<usize>>::sse_encode(self.account_indexes, serializer);
        <Option<String>>::sse_encode(self.favicon, serializer);
        <String>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<crate::models::connection::ColorsInfo>>::sse_encode(self.colors, serializer);
        <u64>::sse_encode(self.last_connected, serializer);
        <bool>::sse_encode(self.can_read_accounts, serializer);
        <bool>::sse_encode(self.can_request_signatures, serializer);
        <bool>::sse_encode(self.can_suggest_tokens, serializer);
        <bool>::sse_encode(self.can_suggest_transactions, serializer);
    }
}

impl SseEncode for crate::api::transaction::Eip712Hashes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.domain_separator, serializer);
        <Vec<u8>>::sse_encode(self.hash_struct_message, serializer);
    }
}

impl SseEncode for crate::api::book::Entry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.address, serializer);
        <Option<String>>::sse_encode(self.tag, serializer);
    }
}

impl SseEncode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <u16>::sse_encode(self.standard, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
        <String>::sse_encode(self.addr, serializer);
        <u8>::sse_encode(self.addr_type, serializer);
        <Option<String>>::sse_encode(self.logo, serializer);
        <std::collections::HashMap<usize, String>>::sse_encode(self.balances, serializer);
        <f64>::sse_encode(self.rate, serializer);
        <bool>::sse_encode(self.default, serializer);
        <bool>::sse_encode(self.native, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.max_fee, serializer);
        <u128>::sse_encode(self.priority_fee, serializer);
        <u128>::sse_encode(self.base_fee, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.transaction_hash, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.sender, serializer);
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.contract_address, serializer);
        <crate::models::transactions::history::TransactionStatusInfo>::sse_encode(
            self.status,
            serializer,
        );
        <Option<u8>>::sse_encode(self.status_code, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <Option<u128>>::sse_encode(self.block_number, serializer);
        <Option<u128>>::sse_encode(self.gas_used, serializer);
        <Option<u128>>::sse_encode(self.gas_limit, serializer);
        <Option<u128>>::sse_encode(self.gas_price, serializer);
        <Option<u128>>::sse_encode(self.blob_gas_used, serializer);
        <Option<u128>>::sse_encode(self.blob_gas_price, serializer);
        <Option<u128>>::sse_encode(self.effective_gas_price, serializer);
        <u128>::sse_encode(self.fee, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
        <String>::sse_encode(self.sig, serializer);
        <u128>::sse_encode(self.nonce, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
        <String>::sse_encode(self.chain_type, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.pk, serializer);
    }
}

impl SseEncode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(u8, String)>>::sse_encode(self.pub_keys, serializer);
        <usize>::sse_encode(self.wallet_index, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.ledger_id, serializer);
        <Vec<String>>::sse_encode(self.account_names, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <bool>::sse_encode(self.zilliqa_legacy, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::access_list::AccessListItem>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::account::AccountInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::book::AddressBookEntryInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::book::Category> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::book::Category>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::connection::ConnectionInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::book::Entry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::book::Entry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::ExplorerInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::ftoken::FTokenInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::history::HistoricalTransactionInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::NetworkConfigInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u16>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <usize>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(u8, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(u8, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(u8, String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(u8, String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(usize, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::wallet::WalletInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.logo, serializer);
        <String>::sse_encode(self.chain, serializer);
        <String>::sse_encode(self.short_name, serializer);
        <Vec<String>>::sse_encode(self.rpc, serializer);
        <Vec<u16>>::sse_encode(self.features, serializer);
        <u64>::sse_encode(self.chain_id, serializer);
        <Vec<u64>>::sse_encode(self.chain_ids, serializer);
        <u32>::sse_encode(self.slip_44, serializer);
        <u64>::sse_encode(self.diff_block_time, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.ens, serializer);
        <Vec<crate::models::provider::ExplorerInfo>>::sse_encode(self.explorers, serializer);
        <bool>::sse_encode(self.fallback_enabled, serializer);
        <Option<bool>>::sse_encode(self.testnet, serializer);
        <Vec<crate::models::ftoken::FTokenInfo>>::sse_encode(self.ftokens, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::base_token::BaseTokenInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::connection::ColorsInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::evm::TransactionRequestEVM>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::scilla::TransactionRequestScilla>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::transactions::access_list::AccessListItem>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.provider, serializer);
        <Option<String>>::sse_encode(self.token_address, serializer);
        <Option<String>>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.size, serializer);
        <bool>::sse_encode(self.gapless, serializer);
        <u32>::sse_encode(self.color, serializer);
        <u8>::sse_encode(self.eye_shape, serializer);
        <u8>::sse_encode(self.data_module_shape, serializer);
    }
}

impl SseEncode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, u8) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <u8>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (u8, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (u8, String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
        <String>::sse_encode(self.2, serializer);
    }
}

impl SseEncode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <crate::models::notification::BackgroundNotificationState>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::models::gas::RequiredTxParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.gas_price, serializer);
        <u128>::sse_encode(self.max_priority_fee, serializer);
        <crate::models::gas::GasFeeHistoryInfo>::sse_encode(self.fee_history, serializer);
        <u64>::sse_encode(self.tx_estimate_gas, serializer);
        <u128>::sse_encode(self.blob_base_fee, serializer);
        <u64>::sse_encode(self.nonce, serializer);
    }
}

impl SseEncode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <crate::models::ftoken::FTokenInfo>::sse_encode(self.token, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.recipient, serializer);
        <String>::sse_encode(self.icon, serializer);
    }
}

impl SseEncode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.hash, serializer);
        <Option<String>>::sse_encode(self.info, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.signer, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.nonce, serializer);
        <Option<String>>::sse_encode(self.from, serializer);
        <Option<String>>::sse_encode(self.to, serializer);
        <Option<String>>::sse_encode(self.value, serializer);
        <Option<u64>>::sse_encode(self.gas_limit, serializer);
        <Option<Vec<u8>>>::sse_encode(self.data, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.max_priority_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.gas_price, serializer);
        <Option<u64>>::sse_encode(self.chain_id, serializer);
        <Option<Vec<crate::models::transactions::access_list::AccessListItem>>>::sse_encode(
            self.access_list,
            serializer,
        );
        <Option<Vec<String>>>::sse_encode(self.blob_versioned_hashes, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_blob_gas, serializer);
    }
}

impl SseEncode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_encode(
            self.metadata,
            serializer,
        );
        <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_encode(
            self.scilla,
            serializer,
        );
        <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_encode(
            self.evm, serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.chain_id, serializer);
        <u64>::sse_encode(self.nonce, serializer);
        <u128>::sse_encode(self.gas_price, serializer);
        <u64>::sse_encode(self.gas_limit, serializer);
        <String>::sse_encode(self.to_addr, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::transactions::history::TransactionStatusInfo::Pending => 0,
                crate::models::transactions::history::TransactionStatusInfo::Confirmed => 1,
                crate::models::transactions::history::TransactionStatusInfo::Rejected => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.memory, serializer);
        <u32>::sse_encode(self.iterations, serializer);
        <u32>::sse_encode(self.threads, serializer);
        <String>::sse_encode(self.secret, serializer);
    }
}

impl SseEncode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_type, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.auth_type, serializer);
        <String>::sse_encode(self.wallet_address, serializer);
        <Vec<crate::models::account::AccountInfo>>::sse_encode(self.accounts, serializer);
        <usize>::sse_encode(self.selected_account, serializer);
        <Vec<crate::models::ftoken::FTokenInfo>>::sse_encode(self.tokens, serializer);
        <crate::models::settings::WalletSettingsInfo>::sse_encode(self.settings, serializer);
        <u64>::sse_encode(self.default_chain_hash, serializer);
    }
}

impl SseEncode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.cipher_orders, serializer);
        <crate::models::settings::WalletArgonParamsInfo>::sse_encode(self.argon_params, serializer);
        <String>::sse_encode(self.currency_convert, serializer);
        <Option<String>>::sse_encode(self.ipfs_node, serializer);
        <bool>::sse_encode(self.ens_enabled, serializer);
        <bool>::sse_encode(self.tokens_list_fetcher, serializer);
        <bool>::sse_encode(self.node_ranking_enabled, serializer);
        <u8>::sse_encode(self.max_connections, serializer);
        <u32>::sse_encode(self.request_timeout_secs, serializer);
        <u8>::sse_encode(self.rates_api_options, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.10.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.10.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;

```

`rust/src/lib.rs`:

```rs
mod frb_generated;
mod tests;

pub mod api;
pub mod models;
pub mod service;
pub mod utils;

```

`rust/src/models/account.rs`:

```rs
use zilpay::wallet::{account::Account, account_type::AccountType};

#[derive(Debug, PartialEq)]
pub struct AccountInfo {
    pub addr: String,
    pub addr_type: u8,
    pub name: String,
    pub pub_key: String,
    pub chain_hash: u64,
    pub chain_id: u64,
    pub slip_44: u32,
    pub index: usize,
}

impl From<&Account> for AccountInfo {
    fn from(account: &Account) -> Self {
        let index = match account.account_type {
            AccountType::Ledger(index) => index,
            AccountType::Bip39HD(index) => index,
            AccountType::PrivateKey(_) => 0,
        };

        AccountInfo {
            index,
            pub_key: account.pub_key.as_hex_str(),
            addr: account.addr.auto_format(),
            addr_type: account.addr.prefix_type(),
            name: account.name.clone(),
            chain_hash: account.chain_hash,
            chain_id: account.chain_id,
            slip_44: account.slip_44,
        }
    }
}

```

`rust/src/models/background.rs`:

```rs
use super::{
    notification::BackgroundNotificationState, provider::NetworkConfigInfo,
    settings::BrowserSettingsInfo, wallet::WalletInfo,
};
use std::collections::HashMap;

pub struct BackgroundState {
    pub wallets: Vec<WalletInfo>,
    pub notifications_wallet_states: HashMap<usize, BackgroundNotificationState>,
    pub notifications_global_enabled: bool,
    pub locale: Option<String>,
    pub appearances: u8,
    pub abbreviated_number: bool,
    pub browser_settings: BrowserSettingsInfo,
    pub providers: Vec<NetworkConfigInfo>,
}

```

`rust/src/models/book.rs`:

```rs
use zilpay::background::book::AddressBookEntry;

#[derive(Debug)]
pub struct AddressBookEntryInfo {
    pub name: String,
    pub addr: String,
    pub net: usize,
    pub slip44: u32,
}

impl From<&AddressBookEntry> for AddressBookEntryInfo {
    fn from(book: &AddressBookEntry) -> Self {
        AddressBookEntryInfo {
            name: book.name.clone(),
            addr: book.addr.auto_format(),
            net: book.net,
            slip44: book.slip44,
        }
    }
}

```

`rust/src/models/connection.rs`:

```rs
pub use zilpay::background::connections::{Connection, ConnectionPermissions, DAppColors};

#[derive(Debug)]
pub struct ColorsInfo {
    pub primary: Option<String>,
    pub secondary: Option<String>,
    pub background: Option<String>,
    pub text: Option<String>,
}

impl From<DAppColors> for ColorsInfo {
    fn from(colors: DAppColors) -> Self {
        ColorsInfo {
            primary: colors.primary,
            secondary: colors.secondary,
            background: colors.background,
            text: colors.text,
        }
    }
}

impl From<ColorsInfo> for DAppColors {
    fn from(colors: ColorsInfo) -> Self {
        DAppColors {
            primary: colors.primary,
            secondary: colors.secondary,
            background: colors.background,
            text: colors.text,
        }
    }
}

#[derive(Debug)]
pub struct ConnectionInfo {
    // Base fields
    pub domain: String,
    pub account_indexes: Vec<usize>,
    pub favicon: Option<String>,
    pub title: String,
    pub description: Option<String>,
    // primary, secondary, background, text
    pub colors: Option<ColorsInfo>,

    pub last_connected: u64, // Unix timestamp

    // permissions
    pub can_read_accounts: bool,
    pub can_request_signatures: bool,
    pub can_suggest_tokens: bool,
    pub can_suggest_transactions: bool,
}

impl From<Connection> for ConnectionInfo {
    fn from(conn: Connection) -> Self {
        ConnectionInfo {
            colors: conn.colors.map(Into::into),
            domain: conn.domain,
            account_indexes: conn.account_indexes.into_iter().collect(),
            favicon: conn.favicon,
            title: conn.title,
            description: conn.description,
            last_connected: conn.last_connected,

            can_read_accounts: conn.permissions.can_read_accounts,
            can_request_signatures: conn.permissions.can_request_signatures,
            can_suggest_tokens: conn.permissions.can_suggest_tokens,
            can_suggest_transactions: conn.permissions.can_suggest_transactions,
        }
    }
}

impl From<ConnectionInfo> for Connection {
    fn from(conn_info: ConnectionInfo) -> Self {
        Connection {
            colors: conn_info.colors.map(Into::into),
            domain: conn_info.domain,
            account_indexes: conn_info.account_indexes.into_iter().collect(),
            favicon: conn_info.favicon,
            title: conn_info.title,
            description: conn_info.description,
            last_connected: conn_info.last_connected,
            permissions: ConnectionPermissions {
                can_read_accounts: conn_info.can_read_accounts,
                can_request_signatures: conn_info.can_request_signatures,
                can_suggest_tokens: conn_info.can_suggest_tokens,
                can_suggest_transactions: conn_info.can_suggest_transactions,
            },
        }
    }
}

```

`rust/src/models/ftoken.rs`:

```rs
use std::collections::HashMap;
use zilpay::{
    errors::token::TokenError,
    proto::{address::Address, U256},
    token::ft::FToken,
};

#[derive(Debug, PartialEq, Clone)]
pub struct FTokenInfo {
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub addr: String,
    pub addr_type: u8,
    pub logo: Option<String>,
    pub balances: HashMap<usize, String>,
    pub rate: f64,
    pub default: bool,
    pub native: bool,
    pub chain_hash: u64,
}

impl From<FToken> for FTokenInfo {
    fn from(ft: FToken) -> Self {
        let balances = ft
            .balances
            .iter()
            .map(|(account_index, balance)| (*account_index, balance.to_string()))
            .collect();

        FTokenInfo {
            balances,
            rate: ft.rate,
            logo: ft.logo,
            addr: ft.addr.auto_format(),
            addr_type: ft.addr.prefix_type(),
            name: ft.name,
            symbol: ft.symbol,
            decimals: ft.decimals,
            default: ft.default,
            native: ft.native,
            chain_hash: ft.chain_hash,
        }
    }
}

impl TryFrom<FTokenInfo> for FToken {
    type Error = TokenError;

    fn try_from(value: FTokenInfo) -> Result<Self, Self::Error> {
        let balances = value
            .balances
            .into_iter()
            .map(|(acount_index, balance_str)| {
                (
                    acount_index,
                    balance_str.parse::<U256>().unwrap_or_default(),
                )
            })
            .collect();

        Ok(Self {
            balances,
            name: value.name,
            symbol: value.symbol,
            decimals: value.decimals,
            addr: Address::from_str_hex(&value.addr).map_err(TokenError::InvalidContractAddress)?,
            rate: value.rate,
            logo: value.logo,
            default: value.default,
            native: value.native,
            chain_hash: value.chain_hash,
        })
    }
}

```

`rust/src/models/gas.rs`:

```rs
pub use zilpay::network::gas_parse::GasFeeHistory;
pub use zilpay::network::gas_parse::RequiredTxParams;

#[derive(Default, Debug)]
pub struct GasFeeHistoryInfo {
    pub max_fee: u128,
    pub priority_fee: u128,
    pub base_fee: u128,
}

impl From<GasFeeHistory> for GasFeeHistoryInfo {
    fn from(value: GasFeeHistory) -> Self {
        Self {
            max_fee: value.max_fee.try_into().unwrap_or_default(),
            priority_fee: value.priority_fee.try_into().unwrap_or_default(),
            base_fee: value.base_fee.try_into().unwrap_or_default(),
        }
    }
}

#[derive(Default, Debug)]
pub struct RequiredTxParamsInfo {
    pub gas_price: u128,
    pub max_priority_fee: u128,
    pub fee_history: GasFeeHistoryInfo,
    pub tx_estimate_gas: u64,
    pub blob_base_fee: u128,
    pub nonce: u64,
}

impl From<RequiredTxParams> for RequiredTxParamsInfo {
    fn from(value: RequiredTxParams) -> Self {
        Self {
            gas_price: value.gas_price.try_into().unwrap_or_default(),
            max_priority_fee: value.max_priority_fee.try_into().unwrap_or_default(),
            fee_history: value.fee_history.into(),
            tx_estimate_gas: value.tx_estimate_gas.try_into().unwrap_or_default(),
            blob_base_fee: value.blob_base_fee.try_into().unwrap_or_default(),
            nonce: value.nonce,
        }
    }
}

```

`rust/src/models/keypair.rs`:

```rs
pub use zilpay::proto::keypair::KeyPair;

pub struct KeyPairInfo {
    pub sk: String,
    pub pk: String,
}

impl From<KeyPair> for KeyPairInfo {
    fn from(value: KeyPair) -> Self {
        match value {
            KeyPair::Secp256k1Sha256((pk, sk)) => Self {
                sk: hex::encode(sk),
                pk: hex::encode(pk),
            },
            KeyPair::Secp256k1Keccak256((pk, sk)) => Self {
                sk: hex::encode(sk),
                pk: hex::encode(pk),
            },
        }
    }
}

```

`rust/src/models/mod.rs`:

```rs
pub mod account;
pub mod background;
pub mod book;
pub mod connection;
pub mod ftoken;
pub mod gas;
pub mod keypair;
pub mod notification;
pub mod provider;
pub mod qrcode;
pub mod settings;
pub mod transactions;
pub mod wallet;

```

`rust/src/models/notification.rs`:

```rs
use zilpay::settings::notifications::NotificationState;

#[derive(Debug)]
pub struct BackgroundNotificationState {
    pub transactions: bool,
    pub price: bool,
    pub security: bool,
    pub balance: bool,
}

impl From<&NotificationState> for BackgroundNotificationState {
    fn from(notify: &NotificationState) -> Self {
        BackgroundNotificationState {
            transactions: notify.transactions,
            price: notify.price,
            security: notify.security,
            balance: notify.balance,
        }
    }
}

impl From<NotificationState> for BackgroundNotificationState {
    fn from(state: NotificationState) -> Self {
        BackgroundNotificationState {
            transactions: state.transactions,
            price: state.price,
            security: state.security,
            balance: state.balance,
        }
    }
}

```

`rust/src/models/provider.rs`:

```rs
use std::{
    collections::HashMap,
    hash::{DefaultHasher, Hash, Hasher},
};

use serde_json::Value;
use zilpay::proto::address::Address;
pub use zilpay::{
    errors::network::NetworkErrors,
    rpc::network_config::{ChainConfig, Explorer},
};

use crate::utils::errors::ServiceError;

use super::ftoken::FTokenInfo;

#[derive(Debug)]
pub struct ExplorerInfo {
    pub name: String,
    pub url: String,
    pub icon: Option<String>,
    pub standard: u16,
}

#[derive(Debug)]
pub struct NetworkConfigInfo {
    pub name: String,
    pub logo: String,
    pub chain: String,
    pub short_name: String,
    pub rpc: Vec<String>,
    pub features: Vec<u16>,
    pub chain_id: u64,
    pub chain_ids: Vec<u64>,
    pub slip_44: u32,
    pub diff_block_time: u64,
    pub chain_hash: u64,
    pub ens: Option<String>,
    pub explorers: Vec<ExplorerInfo>,
    pub fallback_enabled: bool,
    pub testnet: Option<bool>,
    pub ftokens: Vec<FTokenInfo>,
}

impl From<ExplorerInfo> for Explorer {
    fn from(value: ExplorerInfo) -> Self {
        Explorer {
            name: value.name,
            url: value.url,
            icon: value.icon,
            standard: value.standard,
        }
    }
}

impl From<Explorer> for ExplorerInfo {
    fn from(value: Explorer) -> Self {
        Self {
            name: value.name,
            url: value.url,
            icon: value.icon,
            standard: value.standard,
        }
    }
}

impl From<ChainConfig> for NetworkConfigInfo {
    fn from(value: ChainConfig) -> Self {
        let chain_hash = value.hash();
        let chain_id = value.chain_id();
        let explorers = value
            .explorers
            .into_iter()
            .map(ExplorerInfo::from)
            .collect();

        Self {
            chain_id,
            ftokens: value
                .ftokens
                .into_iter()
                .filter_map(|t| t.try_into().ok())
                .collect(),
            logo: value.logo,
            diff_block_time: value.diff_block_time,
            testnet: value.testnet,
            chain_hash,
            name: value.name,
            chain: value.chain,
            short_name: value.short_name,
            chain_ids: value.chain_ids.to_vec(),
            rpc: value.rpc,
            features: value.features,
            slip_44: value.slip_44,
            ens: value.ens.map(|a| a.auto_format()),
            explorers,
            fallback_enabled: value.fallback_enabled,
        }
    }
}

impl TryFrom<NetworkConfigInfo> for ChainConfig {
    type Error = NetworkErrors;

    fn try_from(value: NetworkConfigInfo) -> Result<Self, Self::Error> {
        let chain_ids: [u64; 2] = value
            .chain_ids
            .try_into()
            .map_err(|_| NetworkErrors::InvlaidChainConfig)?;
        let explorers = value.explorers.into_iter().map(Explorer::from).collect();
        let ens = value.ens.and_then(|a| Address::from_str_hex(&a).ok());

        Ok(ChainConfig {
            ftokens: value
                .ftokens
                .into_iter()
                .filter_map(|v| v.try_into().ok())
                .collect(),
            logo: value.logo,
            chain_ids,
            diff_block_time: value.diff_block_time,
            testnet: value.testnet,
            name: value.name,
            chain: value.chain,
            short_name: value.short_name,
            rpc: value.rpc,
            features: value.features,
            slip_44: value.slip_44,
            ens,
            explorers,
            fallback_enabled: value.fallback_enabled,
        })
    }
}

impl NetworkConfigInfo {
    pub fn from_json_value(value: &Value) -> Result<Self, ServiceError> {
        match value {
            Value::Object(obj) => {
                let chain_ids = if let Some(Value::Array(ids)) = obj.get("chainIds") {
                    ids.iter()
                        .filter_map(|id| id.as_u64())
                        .collect::<Vec<u64>>()
                } else {
                    return Err(ServiceError::SerdeSerror(
                        "chainIds is required".to_string(),
                    ));
                };

                let mut hasher = DefaultHasher::new();
                let slip_44 = obj.get("slip44").and_then(|v| v.as_u64()).unwrap_or(0) as u32;
                let num = chain_ids[0] + chain_ids[1];

                num.hash(&mut hasher);
                slip_44.hash(&mut hasher);
                if let Some(chain) = obj.get("chain").and_then(|v| v.as_str()) {
                    chain.hash(&mut hasher);
                }
                let chain_hash = hasher.finish();

                let explorers = if let Some(Value::Array(exp_array)) = obj.get("explorers") {
                    exp_array
                        .iter()
                        .filter_map(|exp| {
                            if let Value::Object(exp_obj) = exp {
                                let name = exp_obj.get("name")?.as_str()?.to_string();
                                let url = exp_obj.get("url")?.as_str()?.to_string();
                                let icon = exp_obj
                                    .get("icon")
                                    .and_then(|v| v.as_str())
                                    .map(String::from);
                                let standard = exp_obj
                                    .get("standard")
                                    .and_then(|v| v.as_str())
                                    .map(|s| {
                                        if s.starts_with("EIP") {
                                            s[3..].parse::<u16>().unwrap_or(0)
                                        } else {
                                            0
                                        }
                                    })
                                    .unwrap_or(0);

                                Some(ExplorerInfo {
                                    name,
                                    url,
                                    icon,
                                    standard,
                                })
                            } else {
                                None
                            }
                        })
                        .collect()
                } else {
                    Vec::new()
                };

                let features = if let Some(Value::Array(feat_array)) = obj.get("features") {
                    feat_array
                        .iter()
                        .filter_map(|f| {
                            if let Some(feature_str) = f.as_str() {
                                if feature_str.starts_with("EIP") {
                                    feature_str[3..].parse::<u16>().ok()
                                } else {
                                    None
                                }
                            } else {
                                None
                            }
                        })
                        .collect()
                } else {
                    Vec::new()
                };

                let ftokens = if let Some(Value::Array(token_array)) = obj.get("ftokens") {
                    token_array
                        .iter()
                        .filter_map(|token| {
                            if let Value::Object(token_obj) = token {
                                let name = token_obj.get("name")?.as_str()?.to_string();
                                let symbol = token_obj.get("symbol")?.as_str()?.to_string();
                                let decimals = token_obj.get("decimals")?.as_u64()? as u8;
                                let addr = token_obj.get("addr")?.as_str()?.to_string();
                                let logo = token_obj
                                    .get("logo")
                                    .and_then(|v| v.as_str())
                                    .map(String::from);
                                let native = token_obj
                                    .get("native")
                                    .and_then(|v| v.as_bool())
                                    .unwrap_or(false);
                                let default = token_obj
                                    .get("default")
                                    .and_then(|v| v.as_bool())
                                    .unwrap_or(false);

                                let addr_type = if addr.starts_with("zil") { 1 } else { 0 };

                                Some(FTokenInfo {
                                    name,
                                    symbol,
                                    decimals,
                                    addr,
                                    addr_type,
                                    logo,
                                    balances: HashMap::new(),
                                    rate: 0f64,
                                    default,
                                    native,
                                    chain_hash,
                                })
                            } else {
                                None
                            }
                        })
                        .collect()
                } else {
                    Vec::with_capacity(0)
                };

                let ens = obj
                    .get("ens")
                    .and_then(|v| v.as_str())
                    .and_then(|str| Some(str.to_string()));

                Ok(NetworkConfigInfo {
                    name: obj
                        .get("name")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(),
                    logo: obj
                        .get("logo")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(),
                    chain: obj
                        .get("chain")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(),
                    short_name: obj
                        .get("shortName")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(),
                    rpc: if let Some(Value::Array(rpc_array)) = obj.get("rpc") {
                        rpc_array
                            .iter()
                            .filter_map(|r| r.as_str().map(String::from))
                            .collect()
                    } else {
                        Vec::with_capacity(0)
                    },
                    features,
                    chain_id: chain_ids.first().copied().unwrap_or(0),
                    chain_ids,
                    slip_44: obj.get("slip44").and_then(|v| v.as_u64()).unwrap_or(0) as u32,
                    diff_block_time: obj
                        .get("diff_block_time")
                        .and_then(|v| v.as_u64())
                        .unwrap_or_default(),
                    chain_hash,
                    ens,
                    explorers,
                    fallback_enabled: true,
                    testnet: obj.get("testnet").and_then(|v| v.as_bool()),
                    ftokens,
                })
            }
            _ => Err(ServiceError::SerdeSerror(
                "Expected JSON object".to_string(),
            )),
        }
    }
}

```

`rust/src/models/qrcode.rs`:

```rs
pub use zilpay::qrcodes::gen::{DataModuleShape, EyeShape, QrConfig};
pub use zilpay::qrcodes::parse::QRcodeScanResult;

pub struct QRcodeScanResultInfo {
    pub recipient: String,
    pub provider: Option<String>,
    pub token_address: Option<String>,
    pub amount: Option<String>,
}

pub struct QrConfigInfo {
    pub size: u32,
    pub gapless: bool,
    pub color: u32,
    pub eye_shape: u8,
    pub data_module_shape: u8,
}

impl From<QrConfig> for QrConfigInfo {
    fn from(value: QrConfig) -> Self {
        Self {
            size: value.size,
            gapless: value.gapless,
            color: value.color,
            eye_shape: value.eye_shape.into(),
            data_module_shape: value.data_module_shape.into(),
        }
    }
}

impl From<QrConfigInfo> for QrConfig {
    fn from(value: QrConfigInfo) -> Self {
        Self {
            size: value.size,
            gapless: value.gapless,
            color: value.color,
            eye_shape: value.eye_shape.into(),
            data_module_shape: value.data_module_shape.into(),
        }
    }
}

impl From<QRcodeScanResult> for QRcodeScanResultInfo {
    fn from(value: QRcodeScanResult) -> Self {
        Self {
            recipient: value.recipient,
            provider: value.provider,
            token_address: value.token_address,
            amount: value.amount,
        }
    }
}

impl From<QRcodeScanResultInfo> for QRcodeScanResult {
    fn from(value: QRcodeScanResultInfo) -> Self {
        Self {
            recipient: value.recipient,
            provider: value.provider,
            token_address: value.token_address,
            amount: value.amount,
        }
    }
}

```

`rust/src/models/settings.rs`:

```rs
pub use zilpay::cipher::options::CipherOrders;
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::settings::SettingsErrors;
pub use zilpay::settings::argon2::ArgonParams;
pub use zilpay::settings::wallet_settings::WalletSettings;
use zilpay::{
    errors::cipher::CipherErrors,
    settings::{
        browser::{BrowserSettings, ContentBlockingLevel},
        wallet_settings::{NetworkSettings, WalletFeatures},
    },
    token_quotes::TokenQuotesAPIOptions,
};

#[derive(Debug, Clone, PartialEq)]
pub struct WalletArgonParamsInfo {
    pub memory: u32,
    pub iterations: u32,
    pub threads: u32,
    pub secret: String,
}

impl From<ArgonParams> for WalletArgonParamsInfo {
    fn from(value: ArgonParams) -> Self {
        WalletArgonParamsInfo {
            memory: value.memory,
            iterations: value.iterations,
            threads: value.threads,
            secret: hex::encode(value.secret),
        }
    }
}

impl TryFrom<WalletArgonParamsInfo> for ArgonParams {
    type Error = SettingsErrors;

    fn try_from(value: WalletArgonParamsInfo) -> Result<Self, Self::Error> {
        let secret: [u8; SHA256_SIZE] = match hex::decode(&value.secret) {
            Ok(hex) => hex
                .try_into()
                .unwrap_or(ArgonParams::hash_secret(&value.secret)),
            Err(_) => ArgonParams::hash_secret(&value.secret),
        };

        Ok(Self {
            secret,
            memory: value.memory,
            iterations: value.iterations,
            threads: value.threads,
        })
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct WalletSettingsInfo {
    pub cipher_orders: Vec<u8>,
    pub argon_params: WalletArgonParamsInfo,
    pub currency_convert: String,
    pub ipfs_node: Option<String>,
    pub ens_enabled: bool,
    pub tokens_list_fetcher: bool,
    pub node_ranking_enabled: bool,
    pub max_connections: u8,
    pub request_timeout_secs: u32,
    pub rates_api_options: u8,
}

impl From<WalletSettings> for WalletSettingsInfo {
    fn from(value: WalletSettings) -> Self {
        WalletSettingsInfo {
            argon_params: value.argon_params.into(),
            cipher_orders: value.cipher_orders.iter().map(|v| v.code()).collect(),
            currency_convert: value.features.currency_convert,
            ipfs_node: value.features.ipfs_node,
            ens_enabled: value.features.ens_enabled,
            tokens_list_fetcher: value.network.tokens_list_fetcher,
            node_ranking_enabled: value.network.node_ranking_enabled,
            max_connections: value.network.max_connections,
            request_timeout_secs: value.network.request_timeout_secs,
            rates_api_options: value.rates_api_options.code(),
        }
    }
}

impl TryFrom<WalletSettingsInfo> for WalletSettings {
    type Error = SettingsErrors;

    fn try_from(value: WalletSettingsInfo) -> Result<Self, Self::Error> {
        Ok(Self {
            rates_api_options: TokenQuotesAPIOptions::from_code(value.rates_api_options),
            cipher_orders: value
                .cipher_orders
                .iter()
                .map(|v| CipherOrders::from_code(*v))
                .collect::<Result<Vec<CipherOrders>, CipherErrors>>()?,
            argon_params: value.argon_params.try_into()?,
            features: WalletFeatures {
                currency_convert: value.currency_convert,
                ens_enabled: value.ens_enabled,
                ipfs_node: value.ipfs_node,
            },
            network: NetworkSettings {
                tokens_list_fetcher: value.tokens_list_fetcher,
                node_ranking_enabled: value.node_ranking_enabled,
                max_connections: value.max_connections,
                request_timeout_secs: value.request_timeout_secs,
            },
        })
    }
}

pub struct BrowserSettingsInfo {
    pub search_engine_index: u8,

    pub cache_enabled: bool,
    pub cookies_enabled: bool,
    pub content_blocking: u8,

    pub do_not_track: bool,
    pub incognito_mode: bool,
    pub text_scaling_factor: f32,

    pub allow_geolocation: bool,
    pub allow_camera: bool,
    pub allow_microphone: bool,
    pub allow_auto_play: bool,
}

impl From<BrowserSettings> for BrowserSettingsInfo {
    fn from(value: BrowserSettings) -> Self {
        BrowserSettingsInfo {
            search_engine_index: value.search_engine_index,
            cache_enabled: value.cache_enabled,
            cookies_enabled: value.cookies_enabled,
            content_blocking: value.content_blocking.code(),
            do_not_track: value.do_not_track,
            incognito_mode: value.incognito_mode,
            text_scaling_factor: value.text_scaling_factor,
            allow_geolocation: value.allow_geolocation,
            allow_camera: value.allow_camera,
            allow_microphone: value.allow_microphone,
            allow_auto_play: value.allow_auto_play,
        }
    }
}

impl From<BrowserSettingsInfo> for BrowserSettings {
    fn from(value: BrowserSettingsInfo) -> Self {
        BrowserSettings {
            search_engine_index: value.search_engine_index,
            cache_enabled: value.cache_enabled,
            cookies_enabled: value.cookies_enabled,
            content_blocking: ContentBlockingLevel::from_code(value.content_blocking),
            do_not_track: value.do_not_track,
            incognito_mode: value.incognito_mode,
            text_scaling_factor: value.text_scaling_factor,
            allow_geolocation: value.allow_geolocation,
            allow_camera: value.allow_camera,
            allow_microphone: value.allow_microphone,
            allow_auto_play: value.allow_auto_play,
        }
    }
}

```

`rust/src/models/transactions/access_list.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

#[derive(Debug, Clone)]
pub struct AccessListItem {
    pub address: String,
    pub storage_keys: Vec<String>,
}

impl From<AlloyAccessListItem> for AccessListItem {
    fn from(value: AlloyAccessListItem) -> Self {
        Self {
            address: value.address.to_string(),
            storage_keys: value
                .storage_keys
                .iter()
                .map(|k| hex::encode(k.0))
                .collect(),
        }
    }
}

impl TryFrom<AccessListItem> for AlloyAccessListItem {
    type Error = TransactionErrors;

    fn try_from(value: AccessListItem) -> Result<Self, Self::Error> {
        Ok(Self {
            address: AlloyAddress::from_str(&value.address).unwrap_or_default(),
            storage_keys: value
                .storage_keys
                .into_iter()
                .map(|key| {
                    let bytes = hex::decode(key).map_err(|_| TransactionErrors::InvalidHash)?;

                    if bytes.len() != SHA256_SIZE {
                        return Err(TransactionErrors::InvalidHash);
                    }

                    let mut array = [0u8; SHA256_SIZE];
                    array.copy_from_slice(&bytes);

                    Ok(array.into())
                })
                .collect::<Result<Vec<_>, _>>()?,
        })
    }
}

```

`rust/src/models/transactions/base_token.rs`:

```rs
pub use zilpay::history::transaction::TokenInfo;

#[derive(Debug, Clone)]
pub struct BaseTokenInfo {
    pub value: String,
    pub symbol: String,
    pub decimals: u8,
}

impl From<TokenInfo> for BaseTokenInfo {
    fn from(value: TokenInfo) -> Self {
        Self {
            value: value.value.to_string(),
            symbol: value.symbol,
            decimals: value.decimals,
        }
    }
}

```

`rust/src/models/transactions/evm.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::access_list::AccessListItem;

#[derive(Debug, Clone)]
pub struct TransactionRequestEVM {
    pub nonce: Option<u64>,
    pub from: Option<String>,
    pub to: Option<String>,
    pub value: Option<String>,
    pub gas_limit: Option<u64>,
    pub data: Option<Vec<u8>>,
    pub max_fee_per_gas: Option<u128>,
    pub max_priority_fee_per_gas: Option<u128>,
    pub gas_price: Option<u128>,
    pub chain_id: Option<u64>,
    pub access_list: Option<Vec<AccessListItem>>,
    pub blob_versioned_hashes: Option<Vec<String>>,
    pub max_fee_per_blob_gas: Option<u128>,
}

impl From<ETHTransactionRequest> for TransactionRequestEVM {
    fn from(value: ETHTransactionRequest) -> Self {
        Self {
            nonce: value.nonce,
            from: value.from.map(|a| a.to_string()),
            to: value
                .to
                .and_then(|k| k.to().cloned())
                .map(|addr| addr.to_string()),
            value: value.value.map(|v| v.to_string()),
            gas_limit: value.gas,
            data: value.input.into_input().map(|b| b.into()),
            max_fee_per_gas: value.max_fee_per_gas,
            max_priority_fee_per_gas: value.max_priority_fee_per_gas,
            gas_price: value.gas_price,
            chain_id: value.chain_id,
            access_list: value
                .access_list
                .map(|list| list.iter().map(|item| item.clone().into()).collect()),
            blob_versioned_hashes: value
                .blob_versioned_hashes
                .map(|hashes| hashes.iter().map(|h| hex::encode(h.0)).collect()),
            max_fee_per_blob_gas: value.max_fee_per_blob_gas,
        }
    }
}

impl TryFrom<TransactionRequestEVM> for ETHTransactionRequest {
    type Error = TransactionErrors;

    fn try_from(value: TransactionRequestEVM) -> Result<Self, Self::Error> {
        Ok(Self {
            from: value
                .from
                .and_then(|addr| AlloyAddress::from_str(&addr).ok()),
            to: match value.to {
                Some(to) => Some(AlloyTxKind::Call(AlloyAddress::from_str(&to).map_err(
                    |_| TransactionErrors::AddressError(AddressError::InvalidETHAddress(to)),
                )?)),
                None => Some(AlloyTxKind::Create),
            },
            gas_price: value.gas_price,
            max_fee_per_gas: value.max_fee_per_gas,
            max_priority_fee_per_gas: value.max_priority_fee_per_gas,
            max_fee_per_blob_gas: value.max_fee_per_blob_gas,
            gas: value.gas_limit,
            value: value.value.and_then(|v| U256::from_str(&v).ok()),
            input: value.data.map(AlloyBytes::from).into(),
            nonce: value.nonce,
            chain_id: value.chain_id,
            access_list: value
                .access_list
                .map(|list| {
                    list.into_iter()
                        .map(|item| item.try_into())
                        .collect::<Result<Vec<AlloyAccessListItem>, _>>()
                })
                .transpose()?
                .map(|v| v.into()),
            blob_versioned_hashes: value
                .blob_versioned_hashes
                .map(|hashes| {
                    hashes
                        .into_iter()
                        .map(|hash| {
                            let bytes =
                                hex::decode(hash).map_err(|_| TransactionErrors::InvalidHash)?;
                            if bytes.len() != SHA256_SIZE {
                                return Err(TransactionErrors::InvalidHash);
                            }
                            let mut array = [0u8; SHA256_SIZE];
                            array.copy_from_slice(&bytes);
                            Ok(array.into())
                        })
                        .collect::<Result<Vec<_>, _>>()
                })
                .transpose()?,
            transaction_type: None,
            sidecar: None,
            authorization_list: None,
        })
    }
}

```

`rust/src/models/transactions/history.rs`:

```rs
use super::base_token::BaseTokenInfo;
use zilpay::history::status::TransactionStatus;
pub use zilpay::history::transaction::HistoricalTransaction;

#[derive(Debug)]
pub enum TransactionStatusInfo {
    Pending,
    Confirmed,
    Rejected,
}

impl From<TransactionStatus> for TransactionStatusInfo {
    fn from(value: TransactionStatus) -> Self {
        match value {
            TransactionStatus::Pending => TransactionStatusInfo::Pending,
            TransactionStatus::Confirmed => TransactionStatusInfo::Confirmed,
            TransactionStatus::Rejected => TransactionStatusInfo::Rejected,
        }
    }
}

#[derive(Debug)]
pub struct HistoricalTransactionInfo {
    pub transaction_hash: String,
    pub amount: String,
    pub sender: String,
    pub recipient: String,
    pub contract_address: Option<String>,
    pub status: TransactionStatusInfo,
    pub status_code: Option<u8>,
    pub timestamp: u64,
    pub block_number: Option<u128>,
    pub gas_used: Option<u128>,
    pub gas_limit: Option<u128>,
    pub gas_price: Option<u128>,
    pub blob_gas_used: Option<u128>,
    pub blob_gas_price: Option<u128>,
    pub effective_gas_price: Option<u128>,
    pub fee: u128,
    pub icon: Option<String>,
    pub title: Option<String>,
    pub error: Option<String>,
    pub sig: String,
    pub nonce: u128,
    pub token_info: Option<BaseTokenInfo>,
    pub chain_type: String,
    pub chain_hash: u64,
}

impl From<HistoricalTransaction> for HistoricalTransactionInfo {
    fn from(value: HistoricalTransaction) -> Self {
        Self {
            sig: value.sig,
            transaction_hash: value.transaction_hash,
            amount: value.amount.to_string(),
            sender: value.sender,
            recipient: value.recipient,
            contract_address: value.contract_address,
            status: value.status.into(),
            status_code: value.status_code,
            timestamp: value.timestamp,
            block_number: value.block_number,
            gas_used: value.gas_used,
            gas_limit: value.gas_limit,
            gas_price: value.gas_price,
            blob_gas_used: value.blob_gas_used,
            blob_gas_price: value.blob_gas_price,
            effective_gas_price: value.effective_gas_price,
            fee: value.fee,
            icon: value.icon,
            title: value.title,
            error: value.error,
            nonce: value.nonce,
            token_info: value.token_info.map(|v| v.into()),
            chain_type: value.chain_type.to_string(),
            chain_hash: value.chain_hash,
        }
    }
}

```

`rust/src/models/transactions/mod.rs`:

```rs
pub mod access_list;
pub mod base_token;
pub mod evm;
pub mod history;
pub mod request;
pub mod scilla;
pub mod transaction_metadata;

```

`rust/src/models/transactions/request.rs`:

```rs
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::evm::TransactionRequestEVM;
use super::scilla::TransactionRequestScilla;
use super::transaction_metadata::TransactionMetadataInfo;

#[derive(Debug, Clone)]
pub struct TransactionRequestInfo {
    pub metadata: TransactionMetadataInfo,
    pub scilla: Option<TransactionRequestScilla>,
    pub evm: Option<TransactionRequestEVM>,
}

impl TryFrom<TransactionRequestInfo> for TransactionRequest {
    type Error = TransactionErrors;

    fn try_from(value: TransactionRequestInfo) -> Result<Self, Self::Error> {
        if let Some(scilla_tx) = value.scilla {
            let tx_req =
                TransactionRequest::Zilliqa((scilla_tx.try_into()?, value.metadata.into()));
            Ok(tx_req)
        } else if let Some(evm_tx) = value.evm {
            let tx_req = TransactionRequest::Ethereum((evm_tx.try_into()?, value.metadata.into()));
            Ok(tx_req)
        } else {
            Err(TransactionErrors::InvalidTxHash)
        }
    }
}

impl From<TransactionRequest> for TransactionRequestInfo {
    fn from(value: TransactionRequest) -> Self {
        let metadata: TransactionMetadataInfo = match value {
            TransactionRequest::Zilliqa((_, ref metadata)) => metadata.to_owned().into(),
            TransactionRequest::Ethereum((_, ref metadata)) => metadata.to_owned().into(),
        };

        match value {
            TransactionRequest::Zilliqa((tx, _)) => Self {
                metadata,
                scilla: Some(tx.into()),
                evm: None,
            },
            TransactionRequest::Ethereum((tx, _)) => Self {
                metadata,
                scilla: None,
                evm: Some(tx.into()),
            },
        }
    }
}

```

`rust/src/models/transactions/scilla.rs`:

```rs
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

#[derive(Debug, Clone)]
pub struct TransactionRequestScilla {
    pub chain_id: u16,
    pub nonce: u64,
    pub gas_price: u128,
    pub gas_limit: u64,
    pub to_addr: String,
    pub amount: u128,
    pub code: String,
    pub data: String,
}

impl From<ZILTransactionRequest> for TransactionRequestScilla {
    fn from(value: ZILTransactionRequest) -> Self {
        Self {
            chain_id: value.chain_id,
            nonce: value.nonce,
            gas_price: value.gas_price,
            gas_limit: value.gas_limit,
            to_addr: value.to_addr.auto_format(),
            amount: value.amount,
            code: String::from_utf8(value.code).unwrap_or_default(),
            data: String::from_utf8(value.data).unwrap_or_default(),
        }
    }
}

impl TryFrom<TransactionRequestScilla> for ZILTransactionRequest {
    type Error = AddressError;

    fn try_from(value: TransactionRequestScilla) -> Result<Self, Self::Error> {
        Ok(Self {
            chain_id: value.chain_id,
            nonce: value.nonce,
            gas_price: value.gas_price,
            gas_limit: value.gas_limit,
            to_addr: Address::from_str_hex(&value.to_addr)?,
            amount: value.amount,
            code: value.code.into_bytes(),
            data: value.data.into_bytes(),
        })
    }
}

```

`rust/src/models/transactions/transaction_metadata.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::base_token::BaseTokenInfo;

#[derive(Debug, Clone)]
pub struct TransactionMetadataInfo {
    pub chain_hash: u64,
    pub hash: Option<String>,
    pub info: Option<String>,
    pub icon: Option<String>,
    pub title: Option<String>,
    pub signer: Option<String>,
    pub token_info: Option<BaseTokenInfo>,
}

impl From<TransactionMetadata> for TransactionMetadataInfo {
    fn from(value: TransactionMetadata) -> Self {
        Self {
            chain_hash: value.chain_hash,
            hash: value.hash,
            info: value.info,
            icon: value.icon,
            title: value.title,
            signer: value.signer.map(|v| v.to_string()),
            token_info: value.token_info.map(|t| BaseTokenInfo {
                value: t.0.to_string(),
                decimals: t.1,
                symbol: t.2,
            }),
        }
    }
}

impl From<TransactionMetadataInfo> for TransactionMetadata {
    fn from(value: TransactionMetadataInfo) -> Self {
        Self {
            chain_hash: value.chain_hash,
            hash: value.hash,
            info: value.info,
            icon: value.icon,
            title: value.title,
            signer: value.signer.and_then(|v| PubKey::from_str(&v).ok()),
            token_info: value.token_info.map(|v| {
                (
                    U256::from_str(&v.value).unwrap_or_default(),
                    v.decimals,
                    v.symbol,
                )
            }),
        }
    }
}

```

`rust/src/models/wallet.rs`:

```rs
use super::{account::AccountInfo, ftoken::FTokenInfo, settings::WalletSettingsInfo};
pub use zilpay::wallet::Wallet;
use zilpay::{errors::wallet::WalletErrors, wallet::wallet_storage::StorageOperations};

#[derive(Debug, PartialEq)]
pub struct WalletInfo {
    pub wallet_type: String,
    pub wallet_name: String,
    pub auth_type: String,
    pub wallet_address: String,
    pub accounts: Vec<AccountInfo>,
    pub selected_account: usize,
    pub tokens: Vec<FTokenInfo>,
    pub settings: WalletSettingsInfo,
    pub default_chain_hash: u64,
}

impl TryFrom<&Wallet> for WalletInfo {
    type Error = WalletErrors;

    fn try_from(w: &Wallet) -> Result<Self, Self::Error> {
        let data = w.get_wallet_data()?;
        let account = data.get_selected_account()?;
        let ftokens: Vec<FTokenInfo> = w
            .get_ftokens()?
            .into_iter()
            .filter_map(|t| {
                if t.chain_hash == account.chain_hash
                    && t.addr.prefix_type() == account.addr.prefix_type()
                {
                    Some(t.into())
                } else {
                    None
                }
            })
            .collect();

        Ok(Self {
            default_chain_hash: data.default_chain_hash,
            auth_type: data.biometric_type.into(),
            wallet_name: data.wallet_name,
            wallet_type: data.wallet_type.to_str(),
            wallet_address: hex::encode(w.wallet_address),
            accounts: data.accounts.iter().map(|v| v.into()).collect(),
            selected_account: data.selected_account,
            tokens: ftokens,
            settings: data.settings.into(),
        })
    }
}

```

`rust/src/service/mod.rs`:

```rs
pub mod service;

```

`rust/src/service/service.rs`:

```rs
use crate::utils::errors::ServiceError;
use lazy_static::lazy_static;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::task::JoinHandle;
use zilpay::background::{bg_storage::StorageManagement, Background};

pub struct ServiceBackground {
    pub running: bool,
    pub block_handle: Option<JoinHandle<()>>,
    pub history_handle: Option<JoinHandle<()>>,
    pub core: Arc<Background>,
}

lazy_static! {
    pub static ref BACKGROUND_SERVICE: RwLock<Option<ServiceBackground>> = RwLock::new(None);
}

impl ServiceBackground {
    pub fn from_path(path: &str) -> Result<Self, ServiceError> {
        let core = Background::from_storage_path(path).map_err(ServiceError::BackgroundError)?;

        Ok(Self {
            core: Arc::new(core),
            running: true,
            block_handle: None,
            history_handle: None,
        })
    }

    pub fn stop(&mut self) {
        self.running = false;
    }

    pub fn get_wallet_mut(
        &mut self,
        wallet_index: usize,
    ) -> Result<&mut zilpay::wallet::Wallet, ServiceError> {
        Arc::get_mut(&mut self.core)
            .ok_or(ServiceError::CoreAccess)?
            .wallets
            .get_mut(wallet_index)
            .ok_or(ServiceError::WalletAccess(wallet_index))
    }
}

```

`rust/src/tests/mod.rs`:

```rs
pub mod wallet;

```

`rust/src/tests/wallet.rs`:

```rs
#[cfg(test)]
mod wallet_tests {
    use std::time::Duration;
    use std::{
        fs::{self},
        path::Path,
        sync::atomic::AtomicU8,
    };

    use tempfile::tempdir;
    use zilpay::config::key::SECRET_KEY_SIZE;
    use zilpay::proto::keypair::KeyPair;
    use zilpay::proto::secret_key::SecretKey;
    use zilpay::{
        background::{bg_provider::ProvidersManagement, bg_wallet::WalletManagement},
        proto::pubkey::PubKey,
        rpc::network_config::ChainConfig,
        wallet::wallet_storage::StorageOperations,
    };

    use crate::api::token::{add_ftoken, fetch_token_meta};
    use crate::api::transaction::{cacl_gas_fee, create_token_transfer, TokenTransferParamsInfo};
    use crate::api::wallet::{add_sk_wallet, AddSKWalletParams};
    use crate::{
        api::{
            backend::{get_data, load_service},
            provider::{get_chains_providers_from_json, select_accounts_chain},
            utils::bip39_checksum_valid,
            wallet::{
                add_bip39_wallet, add_next_bip39_account, delete_account, delete_wallet,
                get_wallets, make_keystore_file, restore_from_keystore, reveal_bip39_phrase,
                reveal_keypair, select_account, zilliqa_get_bech32_base16_address,
                zilliqa_get_n_format, zilliqa_swap_chain, AddNextBip39AccountParams,
                Bip39AddWalletParams,
            },
        },
        models::settings::{WalletArgonParamsInfo, WalletSettingsInfo},
        service::service::BACKGROUND_SERVICE,
        utils::utils::{with_service, with_wallet},
    };
    use lazy_static::lazy_static;

    lazy_static! {
        pub static ref GUARD: AtomicU8 = AtomicU8::new(1);
    }

    async fn wait_for(expected: u8) {
        while GUARD.load(std::sync::atomic::Ordering::Relaxed) != expected {
            tokio::time::sleep(Duration::from_millis(10)).await;
        }
    }

    const PASSWORD: &str = "test_password";
    const INVALID_MNEMONIC_STR: &str =
        "use fit orphan skill memory impose attract mobile delay inch ill trophy";
    const VALID_MNEMONIC_STR: &str =
        "use fit skill orphan memory impose attract mobile delay inch ill trophy";
    const SK: &str = "e8351e8eb0057b809b9c3ea4e9286a6f4f5d9281cddfa77c1f52c3359ce34bad";
    const ZLP_ADDR: &str = "zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4";
    const CDN: &str = "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/zilliqa/%{contract_address}%/%{dark,light}%.webp";
    const BNB_CDN: &str = "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/bnbchain/%{contract_address}%/%{dark,light}%.webp";

    #[tokio::test]
    async fn test_a_init_service() {
        let dir = tempdir().unwrap();
        load_service(dir.path().to_str().unwrap()).await.unwrap();

        let wallet_state = get_data().await.unwrap();

        assert_eq!(wallet_state.wallets.len(), 0);
        assert_eq!(wallet_state.providers.len(), 0);
        assert_eq!(wallet_state.notifications_wallet_states.len(), 0);
        assert_eq!(wallet_state.notifications_global_enabled, false);
        assert_eq!(wallet_state.locale, None);
        assert_eq!(wallet_state.appearances, 0);
        assert_eq!(wallet_state.abbreviated_number, true);

        assert_eq!(wallet_state.browser_settings.search_engine_index, 0);
        assert_eq!(wallet_state.browser_settings.cache_enabled, true);
        assert_eq!(wallet_state.browser_settings.cookies_enabled, true);
        assert_eq!(wallet_state.browser_settings.content_blocking, 1);
        assert_eq!(wallet_state.browser_settings.do_not_track, false);
        assert_eq!(wallet_state.browser_settings.incognito_mode, false);

        let guard = BACKGROUND_SERVICE.read().await;
        let service = guard.as_ref().unwrap();

        assert!(service.running);
        assert!(service.block_handle.is_none());
        assert!(service.history_handle.is_none());

        GUARD.store(2, std::sync::atomic::Ordering::Relaxed);
    }

    #[test]
    fn test_b_validate_mnemonic_valid() {
        let valid_mnemonic =
            "use fit skill orphan memory impose attract mobile delay inch ill trophy".to_string();
        assert!(bip39_checksum_valid(valid_mnemonic));
    }

    #[test]
    fn test_c_validate_mnemonic_invalid() {
        let valid_mnemonic =
            "use fit skill orphan memory impose attract mobile delay inch trophy ill".to_string();
        assert!(!bip39_checksum_valid(valid_mnemonic));
    }

    #[tokio::test]
    async fn test_d_add_chain_provider() {
        wait_for(2).await;

        let path = Path::new("../assets/chains/mainnet-chains.json");
        let content = fs::read_to_string(path).unwrap();
        let providers: Vec<ChainConfig> = get_chains_providers_from_json(content)
            .unwrap()
            .into_iter()
            .map(|c| c.try_into().unwrap())
            .collect();
        let zilliqa_provider_mainnet = providers.first().unwrap();

        assert_eq!(zilliqa_provider_mainnet.name, "Zilliqa");
        assert_eq!(zilliqa_provider_mainnet.chain, "ZIL");
        assert_eq!(zilliqa_provider_mainnet.short_name, "zilliqa");
        assert_eq!(zilliqa_provider_mainnet.diff_block_time, 0);
        assert_eq!(zilliqa_provider_mainnet.rpc.len(), 4);
        assert_eq!(zilliqa_provider_mainnet.rpc[0], "https://api.zilliqa.com");
        assert_eq!(zilliqa_provider_mainnet.chain_ids, [32769, 1]);
        assert_eq!(zilliqa_provider_mainnet.slip_44, 313);
        assert_eq!(zilliqa_provider_mainnet.testnet, None);
        assert_eq!(zilliqa_provider_mainnet.explorers.len(), 2);
        assert_eq!(zilliqa_provider_mainnet.explorers[0].name, "Viewblock");
        assert_eq!(zilliqa_provider_mainnet.fallback_enabled, true);
        assert_eq!(zilliqa_provider_mainnet.ftokens.len(), 2);
        assert_eq!(zilliqa_provider_mainnet.ftokens[0].name, "Zilliqa");
        assert_eq!(zilliqa_provider_mainnet.ftokens[0].symbol, "ZIL");
        assert_eq!(zilliqa_provider_mainnet.ftokens[0].decimals, 18);
        assert_eq!(zilliqa_provider_mainnet.ftokens[0].native, true);
        assert_eq!(zilliqa_provider_mainnet.ftokens[1].decimals, 12);

        let guard = BACKGROUND_SERVICE.read().await;
        let service = guard.as_ref().unwrap();

        service
            .core
            .add_provider(zilliqa_provider_mainnet.clone())
            .unwrap();

        let binance_provider_mainnet = &providers[1];

        assert_eq!(binance_provider_mainnet.name, "Binance");
        assert_eq!(binance_provider_mainnet.chain, "BNB");
        assert_eq!(binance_provider_mainnet.short_name, "bnbchain");
        assert_eq!(binance_provider_mainnet.diff_block_time, 0);
        assert_eq!(binance_provider_mainnet.rpc.len(), 7);
        assert_eq!(
            binance_provider_mainnet.rpc[0],
            "https://bsc-dataseed.bnbchain.org"
        );
        assert_eq!(&binance_provider_mainnet.features, &[155, 1559, 4844]);
        assert_eq!(binance_provider_mainnet.chain_ids, [56, 0]);
        assert_eq!(binance_provider_mainnet.slip_44, 60);
        assert_eq!(binance_provider_mainnet.testnet, None);
        assert_eq!(binance_provider_mainnet.explorers.len(), 1);
        assert_eq!(binance_provider_mainnet.explorers[0].name, "Bscscan");
        assert_eq!(binance_provider_mainnet.fallback_enabled, true);
        assert_eq!(binance_provider_mainnet.ftokens.len(), 1);
        assert_eq!(binance_provider_mainnet.ftokens[0].name, "BinanceCoin");
        assert_eq!(binance_provider_mainnet.ftokens[0].symbol, "BNB");
        assert_eq!(binance_provider_mainnet.ftokens[0].decimals, 18);
        assert_eq!(binance_provider_mainnet.ftokens[0].native, true);

        service
            .core
            .add_provider(binance_provider_mainnet.clone())
            .unwrap();

        let path = Path::new("../assets/chains/testnet-chains.json");
        let content = fs::read_to_string(path).unwrap();
        let providers: Vec<ChainConfig> = get_chains_providers_from_json(content)
            .unwrap()
            .into_iter()
            .map(|c| c.try_into().unwrap())
            .collect();
        let zilliqa_protomainnet_provider = providers.first().unwrap();

        service
            .core
            .add_provider(zilliqa_protomainnet_provider.clone())
            .unwrap();

        GUARD.store(3, std::sync::atomic::Ordering::Relaxed);
    }

    #[tokio::test]
    async fn test_e_create_bip39_wallet_check_mnemonic() {
        wait_for(3).await;

        let params = Bip39AddWalletParams {
            password: PASSWORD.to_string(),
            mnemonic_str: INVALID_MNEMONIC_STR.to_string(),
            mnemonic_check: true,
            accounts: vec![(0, "Account 1".to_string())],
            passphrase: "".to_string(),
            wallet_name: "wallet name".to_string(),
            biometric_type: "faceid".to_string(),
            chain_hash: 0,
            identifiers: vec![String::from("test identifier")],
        };
        let wallet_settings = WalletSettingsInfo {
            cipher_orders: vec![0, 1, 2],
            argon_params: WalletArgonParamsInfo {
                memory: 10,
                iterations: 1,
                threads: 1,
                secret: "".to_string(),
            },
            currency_convert: "BTC".to_string(),
            ipfs_node: None,
            ens_enabled: false,
            tokens_list_fetcher: false,
            node_ranking_enabled: false,
            max_connections: 0,
            request_timeout_secs: 0,
            rates_api_options: 0,
        };
        let ftokens = vec![];

        assert!(add_bip39_wallet(params, wallet_settings, ftokens)
            .await
            .is_err());

        GUARD.store(4, std::sync::atomic::Ordering::Relaxed);
    }

    #[tokio::test]
    async fn test_f_create_bip39_wallet() {
        wait_for(4).await;

        let zil_chain_config = {
            let guard = BACKGROUND_SERVICE.read().await;
            let service = guard.as_ref().unwrap();
            let providers = service.core.get_providers();

            providers[0].config.clone()
        };

        let params = Bip39AddWalletParams {
            password: PASSWORD.to_string(),
            mnemonic_str: VALID_MNEMONIC_STR.to_string(),
            mnemonic_check: true,
            accounts: vec![(0, "Account 1".to_string())],
            passphrase: "".to_string(),
            wallet_name: "ZIlliqa Wallet".to_string(),
            biometric_type: "faceId".to_string(),
            chain_hash: zil_chain_config.hash(),
            identifiers: vec![String::from("test identifier")],
        };
        let wallet_settings = WalletSettingsInfo {
            cipher_orders: vec![0, 1, 2],
            argon_params: WalletArgonParamsInfo {
                memory: 10,
                iterations: 1,
                threads: 1,
                secret: "secret".to_string(),
            },
            currency_convert: "BTC".to_string(),
            ipfs_node: None,
            ens_enabled: false,
            tokens_list_fetcher: false,
            node_ranking_enabled: false,
            max_connections: 0,
            request_timeout_secs: 0,
            rates_api_options: 0,
        };
        let ftokens = vec![];

        let (session, wallet_address) = add_bip39_wallet(params, wallet_settings.clone(), ftokens)
            .await
            .unwrap();

        assert!(!session.is_empty());
        assert!(!wallet_address.is_empty());

        let wallets = get_wallets().await.unwrap();

        assert_eq!(wallets.len(), 1);

        {
            assert_eq!(wallets[0].tokens.len(), 1);
            assert_eq!(wallets[0].tokens[0].chain_hash, zil_chain_config.hash());
            assert_eq!(
                wallets[0].tokens[0].addr,
                "0x0000000000000000000000000000000000000000"
            );
            assert_eq!(wallets[0].tokens[0].decimals, 18);
            assert_eq!(wallets[0].tokens[0].addr_type, 1);
            assert!(wallets[0].tokens[0].native);
        }

        let wallet = wallets.first().unwrap();

        assert_eq!(wallet.wallet_type, "SecretPhrase.false");
        assert_eq!(wallet.wallet_name, "ZIlliqa Wallet");
        assert_eq!(wallet.auth_type, "faceId");
        assert_eq!(wallet.wallet_address, wallet_address);
        assert_eq!(&wallet.wallet_address, &wallet_address);
        assert_eq!(wallet.accounts.len(), 1);
        assert_eq!(wallet.selected_account, 0);
        assert_eq!(wallet.tokens.len(), 1);
        assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());

        let selected_account = &wallet.accounts[wallet.selected_account];

        assert_eq!(selected_account.name, "Account 1");
        assert_eq!(selected_account.index, 0);
        assert_eq!(selected_account.chain_hash, zil_chain_config.hash());
        assert_eq!(selected_account.chain_id, zil_chain_config.chain_id());
        assert_eq!(selected_account.slip_44, zil_chain_config.slip_44);
        assert_eq!(selected_account.addr_type, 1); // Secp256k1Keccak256

        with_service(|core| {
            let wallet = core.get_wallet_by_index(0).unwrap();
            let data = wallet.get_wallet_data().unwrap();
            let selected_account = data.get_selected_account().unwrap();

            match selected_account.pub_key {
                PubKey::Secp256k1Keccak256(_) => {
                    assert!(true);
                }
                _ => {
                    panic!("invalid pubkey type");
                }
            }

            assert_eq!(
                "0103feba86ca2043ac21bcf111f43658d3303f3a0d508e4c01c83e357788937cd234",
                selected_account.pub_key.to_string()
            );
            Ok(())
        })
        .await
        .unwrap();

        let address = zilliqa_get_n_format(0, 0).await.unwrap();

        assert_eq!(address, "zil10yxnd0snkark2mv7p54qc5saevcn4d8eaauhca");

        let (bech32, base16) = zilliqa_get_bech32_base16_address(0, 0).await.unwrap();

        assert_eq!("0x66316a684F83e7265B82C7eFE46f2E47ec074D7d", base16);
        assert_eq!("zil1vcck56z0s0njvkuzclh7gmewglkqwntazq7h2l", bech32);

        zilliqa_swap_chain(0, 0).await.unwrap();

        with_wallet(0, |wallet| {
            let data = wallet.get_wallet_data().unwrap();
            let selected_account = data.get_selected_account().unwrap();

            assert_eq!(
                selected_account.pub_key.to_string(),
                "0003feba86ca2043ac21bcf111f43658d3303f3a0d508e4c01c83e357788937cd234"
            );
            assert_eq!(selected_account.chain_hash, zil_chain_config.hash());
            assert_ne!(selected_account.chain_id, zil_chain_config.chain_id());
            assert_eq!(selected_account.chain_id, zil_chain_config.chain_ids[1]);
            assert_eq!(selected_account.slip_44, zil_chain_config.slip_44);
            assert_eq!(
                selected_account.addr.auto_format(),
                "zil1vcck56z0s0njvkuzclh7gmewglkqwntazq7h2l"
            );

            Ok(())
        })
        .await
        .unwrap();

        let zil_testnet_chain_config = {
            let guard = BACKGROUND_SERVICE.read().await;
            let service = guard.as_ref().unwrap();
            let providers = service.core.get_providers();

            providers[2].config.clone()
        };

        select_accounts_chain(0, zil_testnet_chain_config.hash())
            .await
            .unwrap();

        add_next_bip39_account(AddNextBip39AccountParams {
            wallet_index: 0,
            account_index: 1,
            name: "Second account".to_string(),
            passphrase: String::new(),
            identifiers: vec![String::from("test identifier")],
            password: None,
            session_cipher: Some(session.clone()),
        })
        .await
        .unwrap();

        select_account(0, 1).await.unwrap();

        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        assert_eq!(wallet.tokens.len(), 1);

        with_wallet(0, |wallet| {
            let data = wallet.get_wallet_data().unwrap();
            let selected_account = data.get_selected_account().unwrap();

            assert_eq!(data.selected_account, 1);
            assert_eq!(selected_account.chain_hash, zil_testnet_chain_config.hash());
            assert_eq!(selected_account.name, "Second account");
            assert_eq!(selected_account.account_type.code(), 1);
            assert_eq!(
                selected_account.pub_key.to_string(),
                "010317743c1830dada97f96c51fa439b7a0673700ee38c71ccb117c9f0e974af522e"
            );
            assert_eq!(
                selected_account.chain_id,
                *zil_testnet_chain_config.chain_ids.last().unwrap()
            );
            assert_eq!(selected_account.slip_44, zil_chain_config.slip_44);
            assert_eq!(selected_account.slip_44, zil_chain_config.slip_44);

            Ok(())
        })
        .await
        .unwrap();
        let bsc_chain_config = {
            let guard = BACKGROUND_SERVICE.read().await;
            let service = guard.as_ref().unwrap();
            let providers = service.core.get_providers();

            providers[1].config.clone()
        };

        select_accounts_chain(0, bsc_chain_config.hash())
            .await
            .unwrap();

        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        assert_eq!(wallets.len(), 1);
        assert_eq!(wallet.wallet_type, "SecretPhrase.false");
        assert_eq!(wallet.wallet_name, "ZIlliqa Wallet");
        assert_eq!(wallet.auth_type, "faceId");
        assert_eq!(wallet.wallet_address, wallet_address);
        assert_eq!(wallet.accounts.len(), 2);
        assert_eq!(wallet.selected_account, 1);
        assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());

        {
            assert_eq!(wallet.tokens.len(), 1);

            let token = &wallet.tokens[0];
            assert_eq!(token.name, "BinanceCoin");
            assert_eq!(token.symbol, "BNB");
            assert_eq!(token.decimals, 18);
            assert_eq!(token.addr, "0x0000000000000000000000000000000000000000");
            assert_eq!(token.addr_type, 1);
            assert_eq!(token.logo, Some(BNB_CDN.to_string()));
            assert!(token.balances.is_empty());
            assert_eq!(token.rate, 0.0);
            assert!(!token.default);
            assert!(token.native);
            assert_eq!(token.chain_hash, bsc_chain_config.hash());
        }

        {
            let account1 = &wallet.accounts[0];
            assert_eq!(account1.addr, "0x790D36BE13b747656d9E0D2a0c521DCB313ab4f9");
            assert_eq!(account1.addr_type, 1);
            assert_eq!(account1.name, "Account 1");
            assert_eq!(account1.chain_hash, bsc_chain_config.hash());
            assert_eq!(account1.chain_id, bsc_chain_config.chain_id());
            assert_eq!(account1.slip_44, bsc_chain_config.slip_44);
            assert_eq!(account1.index, 0);

            let account2 = &wallet.accounts[1];
            assert_eq!(account2.addr, "0xab92316Bd8f486C773C80EC88A00721A35f2D1de");
            assert_eq!(account2.addr_type, 1);
            assert_eq!(account2.name, "Second account");
            assert_eq!(account2.chain_hash, bsc_chain_config.hash());
            assert_eq!(account2.chain_id, bsc_chain_config.chain_id());
            assert_eq!(account2.slip_44, bsc_chain_config.slip_44);
            assert_eq!(account2.index, 1);
        }

        {
            assert_eq!(wallet.settings.cipher_orders, vec![0, 1, 2]);

            assert_eq!(wallet.settings.argon_params.memory, 10);
            assert_eq!(wallet.settings.argon_params.iterations, 1);
            assert_eq!(wallet.settings.argon_params.threads, 1);
            assert_eq!(
                wallet.settings.argon_params.secret,
                "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b"
            );

            assert_eq!(wallet.settings.currency_convert, "BTC");
            assert!(wallet.settings.ipfs_node.is_none());

            assert!(!wallet.settings.ens_enabled);
            assert!(!wallet.settings.tokens_list_fetcher);
            assert!(!wallet.settings.node_ranking_enabled);
            assert_eq!(wallet.settings.max_connections, 0);
            assert_eq!(wallet.settings.request_timeout_secs, 0);
            assert_eq!(wallet.settings.rates_api_options, 0);

            // try add next account with binance smart chain network
            add_next_bip39_account(AddNextBip39AccountParams {
                wallet_index: 0,
                account_index: 2,
                name: "account 3".to_string(),
                passphrase: String::new(),
                identifiers: vec![String::from("test identifier")],
                password: None,
                session_cipher: Some(session.clone()),
            })
            .await
            .unwrap();

            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            {
                let account3 = &wallet.accounts[2];

                for acc in &wallet.accounts {
                    assert_eq!(account3.chain_hash, acc.chain_hash);
                    assert_eq!(account3.chain_id, acc.chain_id);
                    assert_eq!(account3.slip_44, acc.slip_44);
                }

                assert_eq!(account3.addr, "0x1DA83F5b443cc87FBdC6ec06E40F4098C1592210");
                assert_eq!(account3.addr_type, 1);
                assert_eq!(account3.name, "account 3");
                assert_eq!(account3.index, 2);
            }

            select_accounts_chain(0, zil_chain_config.hash())
                .await
                .unwrap();
            zilliqa_swap_chain(0, 2).await.unwrap();

            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            {
                let account3 = &wallet.accounts[2];
                assert_eq!(account3.addr, "zil1xancfmqvv6nhwdf8uwy79xd7fr2t94ejqr3xs8");
                assert_eq!(account3.addr_type, 0);
                assert_eq!(account3.name, "account 3");
                assert_eq!(account3.chain_hash, wallet.default_chain_hash);
                assert_eq!(
                    &account3.chain_id,
                    zil_chain_config.chain_ids.last().unwrap()
                );
                assert_eq!(account3.slip_44, zil_chain_config.slip_44);
                assert_eq!(account3.index, 2);
            }

            with_wallet(0, |wallet| {
                let ftokens = wallet.get_ftokens().unwrap();
                assert_eq!(ftokens.len(), 3);
                Ok(())
            })
            .await
            .unwrap();

            let words = reveal_bip39_phrase(
                0,
                vec![String::from("test identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();

            assert_eq!(words, VALID_MNEMONIC_STR);

            let keypair2 = reveal_keypair(
                0,
                2,
                vec![String::from("test identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();
            let keypair0 = reveal_keypair(
                0,
                0,
                vec![String::from("test identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();

            assert_eq!(
                keypair0.pk,
                "03feba86ca2043ac21bcf111f43658d3303f3a0d508e4c01c83e357788937cd234"
            );
            assert_eq!(
                keypair0.sk,
                "9a46a88b33c8c5b0c34532d461cc564dcc499ba74b5327c8a1d4cd145d53af2c"
            );

            assert_eq!(
                keypair2.pk,
                "02e839fb64c54e634678d8ab1432472186012fa9177f8b2ba834793ede02cc503f"
            );
            assert_eq!(
                keypair2.sk,
                "0a82ab0e408290b46b509a9d573ae35302e3017f5f50c57fdd5f4b78c9dea14a"
            );

            delete_account(0, 2).await.unwrap();
            delete_account(0, 1).await.unwrap();

            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            assert_eq!(wallet.accounts.len(), 1);

            let keystore_bytes = make_keystore_file(
                0,
                PASSWORD.to_string(),
                vec![String::from("test identifier")],
            )
            .await
            .unwrap();

            delete_wallet(
                0,
                vec![String::from("test identifier")],
                None,
                Some(session),
            )
            .await
            .unwrap();

            let wallets = get_wallets().await.unwrap();

            assert_eq!(wallets.len(), 0);

            let (_, new_address) = restore_from_keystore(
                keystore_bytes,
                vec![String::from("new identifier")],
                PASSWORD.to_string(),
                "fingerprint".to_string(),
            )
            .await
            .unwrap();
            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            assert_eq!(wallets.len(), 1);
            assert_eq!(wallet.wallet_address, new_address);
            assert_eq!(wallet.wallet_name, "ZIlliqa Wallet");
            assert_eq!(wallet.wallet_type, "SecretPhrase.false");
            assert_eq!(wallet.auth_type, "fingerprint");
            assert_eq!(wallet.selected_account, 0);
            assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());
            assert_eq!(wallet.accounts.len(), 1);

            {
                assert_eq!(
                    wallet.accounts[0].addr,
                    "0x790D36BE13b747656d9E0D2a0c521DCB313ab4f9"
                );
                assert_eq!(wallet.accounts[0].addr_type, 1);
                assert_eq!(wallet.accounts[0].chain_hash, zil_chain_config.hash());
                assert_eq!(wallet.accounts[0].chain_id, zil_chain_config.chain_id());
                assert_eq!(wallet.accounts[0].slip_44, zil_chain_config.slip_44);
                assert_eq!(wallet.accounts[0].index, 0);
            }

            let words = reveal_bip39_phrase(
                0,
                vec![String::from("new identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();

            assert_eq!(words, VALID_MNEMONIC_STR);

            let keypair0 = reveal_keypair(
                0,
                0,
                vec![String::from("new identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();

            assert_eq!(
                keypair0.pk,
                "03feba86ca2043ac21bcf111f43658d3303f3a0d508e4c01c83e357788937cd234"
            );
            assert_eq!(
                keypair0.sk,
                "9a46a88b33c8c5b0c34532d461cc564dcc499ba74b5327c8a1d4cd145d53af2c"
            );
        }

        delete_wallet(
            0,
            vec![String::from("new identifier")],
            Some(PASSWORD.to_string()),
            None,
        )
        .await
        .unwrap();

        GUARD.store(5, std::sync::atomic::Ordering::Relaxed);
    }

    #[tokio::test]
    async fn test_c_create_sk_wallet() {
        wait_for(5).await;
        let zil_chain_config = {
            let guard = BACKGROUND_SERVICE.read().await;
            let service = guard.as_ref().unwrap();
            let providers = service.core.get_providers();

            providers[0].config.clone()
        };
        let params = AddSKWalletParams {
            sk: SK.to_string(),
            password: PASSWORD.to_string(),
            wallet_name: "SK Wallet".to_string(),
            biometric_type: "faceId".to_string(),
            identifiers: vec![String::from("test sk identifier")],
            chain_hash: zil_chain_config.hash(),
        };
        let wallet_settings = WalletSettingsInfo {
            cipher_orders: vec![0, 1],
            argon_params: WalletArgonParamsInfo {
                memory: 10,
                iterations: 1,
                threads: 1,
                secret: "secret".to_string(),
            },
            currency_convert: "BTC".to_string(),
            ipfs_node: None,
            ens_enabled: false,
            tokens_list_fetcher: false,
            node_ranking_enabled: false,
            max_connections: 0,
            request_timeout_secs: 0,
            rates_api_options: 0,
        };
        let ftokens = vec![];
        let (session, wallet_address) = add_sk_wallet(params, wallet_settings, ftokens)
            .await
            .unwrap();
        assert!(!session.is_empty());
        assert!(!wallet_address.is_empty());
        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        {
            assert_eq!(wallets.len(), 1);
            assert_eq!(wallet.wallet_type, "SecretKey");
            assert_eq!(wallet.wallet_name, "SK Wallet");
            assert_eq!(wallet.auth_type, "faceId");
            assert_eq!(wallet.wallet_address, wallet_address);
            assert_eq!(wallet.accounts.len(), 1);
            assert_eq!(wallet.selected_account, 0);
        }

        {
            let account = &wallet.accounts[0];
            assert_eq!(account.name, "SK Wallet");
            assert_eq!(account.index, 0);
            assert_eq!(account.chain_hash, zil_chain_config.hash());
            assert_eq!(account.chain_id, zil_chain_config.chain_id());
            assert_eq!(account.slip_44, zil_chain_config.slip_44);
        }

        {
            assert_eq!(wallet.tokens.len(), 1);
            let evm_token = &wallet.tokens[0];
            assert_eq!(evm_token.name, "Zilliqa");
            assert_eq!(evm_token.symbol, "ZIL");
            assert_eq!(evm_token.decimals, 18);
            assert_eq!(evm_token.addr, "0x0000000000000000000000000000000000000000");
            assert_eq!(evm_token.addr_type, 1);
            assert_eq!(evm_token.logo, Some(CDN.to_string()));
            assert!(evm_token.balances.is_empty());
            assert_eq!(evm_token.rate, 0.0);
            assert!(!evm_token.default);
            assert!(evm_token.native);
            assert_eq!(evm_token.chain_hash, zil_chain_config.hash());

            zilliqa_swap_chain(0, 0).await.unwrap();
            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            let zil_token = &wallet.tokens[0];
            assert_eq!(zil_token.name, "Zilliqa");
            assert_eq!(zil_token.symbol, "ZIL");
            assert_eq!(zil_token.decimals, 12);
            assert_eq!(zil_token.addr, "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");
            assert_eq!(zil_token.addr_type, 0);
            assert_eq!(zil_token.logo, Some(CDN.to_string()));
            assert!(zil_token.balances.is_empty());
            assert_eq!(zil_token.rate, 0.0);
            assert!(!zil_token.default);
            assert!(zil_token.native);
            assert_eq!(zil_token.chain_hash, zil_chain_config.hash());

            zilliqa_swap_chain(0, 0).await.unwrap();
        }

        {
            assert_eq!(wallet.settings.cipher_orders, vec![0, 1]);
            assert_eq!(wallet.settings.argon_params.memory, 10);
            assert_eq!(wallet.settings.argon_params.iterations, 1);
            assert_eq!(wallet.settings.argon_params.threads, 1);
            assert_eq!(
                wallet.settings.argon_params.secret,
                "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b"
            );
            assert_eq!(wallet.settings.currency_convert, "BTC");
            assert!(wallet.settings.ipfs_node.is_none());
            assert!(!wallet.settings.ens_enabled);
            assert!(!wallet.settings.tokens_list_fetcher);
            assert!(!wallet.settings.node_ranking_enabled);
            assert_eq!(wallet.settings.max_connections, 0);
            assert_eq!(wallet.settings.request_timeout_secs, 0);
            assert_eq!(wallet.settings.rates_api_options, 0);
        }

        assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());
        assert_eq!(
            reveal_bip39_phrase(
                0,
                vec![String::from("test sk identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await,
            Err("Wallet error at index: 0: Invalid account type".to_string())
        );

        let keypair = reveal_keypair(
            0,
            0,
            vec![String::from("test sk identifier")],
            PASSWORD.to_string(),
            None,
        )
        .await
        .unwrap();

        assert_eq!(&keypair.sk, SK);
        assert_eq!(
            &keypair.pk,
            "02d2f48dfb27a3e35f1029aeaed8d65a209c45cadde40a73481f2d84ed3c9205b4"
        );
        let bech32 = zilliqa_get_n_format(0, 0).await.unwrap();

        assert_eq!("zil1vqzxx6d24dqd4kc0pr5nv8kqztnwh3shfm2s0m", bech32);

        let bsc_chain_config = {
            let guard = BACKGROUND_SERVICE.read().await;
            let service = guard.as_ref().unwrap();
            let providers = service.core.get_providers();

            providers[1].config.clone()
        };

        select_accounts_chain(0, bsc_chain_config.hash())
            .await
            .unwrap();

        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        {
            let account = &wallet.accounts[0];
            assert_eq!(account.name, "SK Wallet");
            assert_eq!(account.addr, "0x60046369aAab40dADB0F08e9361ec012e6ebC617");
            assert_eq!(account.index, 0);
            assert_eq!(account.chain_hash, bsc_chain_config.hash());
            assert_eq!(account.chain_id, bsc_chain_config.chain_id());
            assert_eq!(account.slip_44, bsc_chain_config.slip_44);
        }

        {
            assert_eq!(wallet.tokens.len(), 1);
            let bnb_token = &wallet.tokens[0];
            assert_eq!(bnb_token.name, "BinanceCoin");
            assert_eq!(bnb_token.symbol, "BNB");
            assert_eq!(bnb_token.decimals, 18);
            assert_eq!(bnb_token.addr, "0x0000000000000000000000000000000000000000");
            assert_eq!(bnb_token.addr_type, 1);
            assert_eq!(bnb_token.logo, Some(BNB_CDN.to_string()));
            assert!(bnb_token.balances.is_empty());
            assert_eq!(bnb_token.rate, 0.0);
            assert!(!bnb_token.default);
            assert!(bnb_token.native);
            assert_eq!(bnb_token.chain_hash, bsc_chain_config.hash());
        }

        assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());

        let keystore_bytes = make_keystore_file(
            0,
            PASSWORD.to_string(),
            vec![String::from("test sk identifier")],
        )
        .await
        .unwrap();

        delete_wallet(
            0,
            vec![String::from("test sk identifier")],
            None,
            Some(session),
        )
        .await
        .unwrap();

        let wallets = get_wallets().await.unwrap();
        assert_eq!(wallets.len(), 0);

        let (_session, _new_address) = restore_from_keystore(
            keystore_bytes,
            vec![String::from("test sk identifier")],
            PASSWORD.to_string(),
            "fingerprint".to_string(),
        )
        .await
        .unwrap();
        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        {
            assert_eq!(wallets.len(), 1);
            assert_eq!(wallet.wallet_type, "SecretKey");
            assert_eq!(wallet.wallet_name, "SK Wallet");
            assert_eq!(wallet.auth_type, "fingerprint");
            assert!(!wallet.wallet_address.is_empty());
            assert_eq!(wallet.accounts.len(), 1);
            assert_eq!(wallet.selected_account, 0);

            let account = &wallet.accounts[0];
            assert_eq!(account.name, "SK Wallet");
            assert_eq!(account.addr, "0x60046369aAab40dADB0F08e9361ec012e6ebC617");
            assert_eq!(account.addr_type, 1);
            assert_eq!(account.index, 0);
            assert_eq!(account.chain_hash, zil_chain_config.hash());
            assert_eq!(account.chain_id, zil_chain_config.chain_id());
            assert_eq!(account.slip_44, zil_chain_config.slip_44);

            assert_eq!(wallet.tokens.len(), 1);

            let evm_token = &wallet.tokens[0];
            assert_eq!(evm_token.name, "Zilliqa");
            assert_eq!(evm_token.symbol, "ZIL");
            assert_eq!(evm_token.decimals, 18);
            assert_eq!(evm_token.addr, "0x0000000000000000000000000000000000000000");
            assert_eq!(evm_token.addr_type, 1);
            assert_eq!(evm_token.logo, Some(CDN.to_string()));
            assert!(evm_token.balances.is_empty());
            assert_eq!(evm_token.rate, 0.0);
            assert!(!evm_token.default);
            assert!(evm_token.native);
            assert_eq!(evm_token.chain_hash, zil_chain_config.hash());

            zilliqa_swap_chain(0, 0).await.unwrap();
            let wallets = get_wallets().await.unwrap();
            let wallet = wallets.first().unwrap();

            let zil_token = &wallet.tokens[0];
            assert_eq!(zil_token.name, "Zilliqa");
            assert_eq!(zil_token.symbol, "ZIL");
            assert_eq!(zil_token.decimals, 12);
            assert_eq!(zil_token.addr, "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz");
            assert_eq!(zil_token.addr_type, 0);
            assert_eq!(zil_token.logo, Some(CDN.to_string()));
            assert!(zil_token.balances.is_empty());
            assert_eq!(zil_token.rate, 0.0);
            assert!(!zil_token.default);
            assert!(zil_token.native);
            assert_eq!(zil_token.chain_hash, zil_chain_config.hash());

            assert_eq!(wallet.settings.cipher_orders, vec![0, 1]);
            assert_eq!(wallet.settings.argon_params.memory, 10);
            assert_eq!(wallet.settings.argon_params.iterations, 1);
            assert_eq!(wallet.settings.argon_params.threads, 1);
            assert_eq!(
                wallet.settings.argon_params.secret,
                "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b"
            );
            assert_eq!(wallet.settings.currency_convert, "BTC");
            assert!(wallet.settings.ipfs_node.is_none());
            assert!(!wallet.settings.ens_enabled);
            assert!(!wallet.settings.tokens_list_fetcher);
            assert!(!wallet.settings.node_ranking_enabled);
            assert_eq!(wallet.settings.max_connections, 0);
            assert_eq!(wallet.settings.request_timeout_secs, 0);
            assert_eq!(wallet.settings.rates_api_options, 0);

            assert_eq!(wallet.default_chain_hash, zil_chain_config.hash());

            let restored_keypair = reveal_keypair(
                0,
                0,
                vec![String::from("test sk identifier")],
                PASSWORD.to_string(),
                None,
            )
            .await
            .unwrap();

            assert_eq!(&restored_keypair.sk, SK);
            assert_eq!(
                &restored_keypair.pk,
                "02d2f48dfb27a3e35f1029aeaed8d65a209c45cadde40a73481f2d84ed3c9205b4"
            );
            zilliqa_swap_chain(0, 0).await.unwrap();
        }

        select_accounts_chain(0, zil_chain_config.hash())
            .await
            .unwrap();
        zilliqa_swap_chain(0, 0).await.unwrap();

        let token = fetch_token_meta(ZLP_ADDR.to_string(), 0).await.unwrap();

        {
            assert_eq!(token.name, "ZilPay wallet");
            assert_eq!(token.symbol, "ZLP");
            assert_eq!(token.decimals, 18);
            assert_eq!(token.addr, ZLP_ADDR);
            assert_eq!(token.addr_type, 0);
            assert_eq!(token.logo, None);
            assert!(token.balances.contains_key(&0));
            assert_eq!(token.balances.get(&0).unwrap(), "0");
            assert_eq!(token.rate, 0.0);
            assert!(!token.default);
            assert!(!token.native);
            assert_eq!(token.chain_hash, zil_chain_config.hash());
        }

        add_ftoken(token.clone(), 0).await.unwrap();

        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        let bytes_sk: [u8; SECRET_KEY_SIZE] = hex::decode(SK).unwrap().try_into().unwrap();
        let sk = SecretKey::Secp256k1Sha256Zilliqa(bytes_sk);
        let keypair = KeyPair::from_secret_key(sk).unwrap();

        assert_eq!(wallet.tokens.len(), 2);

        let tx = create_token_transfer(TokenTransferParamsInfo {
            wallet_index: 0,
            account_index: 0,
            token: wallet.tokens.last().unwrap().clone(),
            amount: "1000000000000000000".to_string(),
            recipient: "zil1wl38cwww2u3g8wzgutxlxtxwwc0rf7jf27zace".to_string(),
            icon: "".to_string(),
        })
        .await
        .unwrap();

        {
            assert_eq!(tx.metadata.chain_hash, zil_chain_config.hash());
            assert_eq!(tx.metadata.hash, None);
            assert_eq!(tx.metadata.info, None);
            assert_eq!(tx.metadata.icon, Some("".to_string()));
            assert_eq!(tx.metadata.title, None);
            assert_eq!(
                tx.metadata.signer,
                Some(keypair.get_pubkey().unwrap().to_string())
            );

            // Assert token info
            let token_info = tx.metadata.token_info.as_ref().unwrap();
            assert_eq!(token_info.value, "1000000000000000000");
            assert_eq!(token_info.symbol, "ZLP");
            assert_eq!(token_info.decimals, 18);

            // Assert Scilla transaction details
            let scilla = tx.scilla.as_ref().unwrap();
            assert_eq!(scilla.chain_id, 1);
            assert_eq!(scilla.nonce, 0);
            assert_eq!(scilla.gas_price, 2000000000);
            assert_eq!(scilla.gas_limit, 2000);
            assert_eq!(scilla.to_addr, token.addr);
            assert_eq!(scilla.amount, 0);
            assert_eq!(scilla.code, "");
            assert_eq!(scilla.data, "{\"_tag\":\"Transfer\",\"params\":[{\"type\":\"ByStr20\",\"value\":\"0x77e27c39ce572283b848e2cdf32cce761e34fa49\",\"vname\":\"to\"},{\"type\":\"Uint128\",\"value\":\"1000000000000000000\",\"vname\":\"amount\"}]}");

            // Assert EVM is None
            assert!(tx.evm.is_none());
        }

        let wallets = get_wallets().await.unwrap();
        let wallet = wallets.first().unwrap();

        assert_eq!(
            wallet.accounts[0].addr,
            "zil1q2yyq6z2sz26p54700e5zpzu3gj070wxt8h75h"
        );
        let diff_addr = zilliqa_get_n_format(0, 0).await.unwrap();

        assert_eq!(diff_addr, "0x60046369aAab40dADB0F08e9361ec012e6ebC617");

        zilliqa_swap_chain(0, 0).await.unwrap();

        let diff_addr = zilliqa_get_n_format(0, 0).await.unwrap();

        assert_eq!(diff_addr, "zil1vqzxx6d24dqd4kc0pr5nv8kqztnwh3shfm2s0m");

        let token = fetch_token_meta("0x2274005778063684fbB1BfA96a2b725dC37D75f9".to_string(), 0)
            .await
            .unwrap();
        let mut tx = create_token_transfer(TokenTransferParamsInfo {
            wallet_index: 0,
            account_index: 0,
            token,
            amount: "1".to_string(),
            recipient: "0xa1B2Ff03F501A4d8278CB75a9075F406A5B8C5Ff".to_string(),
            icon: "".to_string(),
        })
        .await
        .unwrap();

        if let Some(evm) = tx.evm.as_mut() {
            evm.from = Some("0x558d34db1952A45b1CC216F0B39646aA6306D90b".to_string());
        }
        let gas = cacl_gas_fee(0, 0, tx).await.unwrap();

        assert!(gas.gas_price > 0);
        assert!(gas.tx_estimate_gas > 0);
    }
}

```

`rust/src/utils/errors.rs`:

```rs
use thiserror::Error;
use zilpay::errors::keypair::PubKeyError;
pub use zilpay::errors::{
    address::AddressError, background::BackgroundError, cache::CacheError, network::NetworkErrors,
    settings::SettingsErrors, token::TokenError, tx::TransactionErrors, wallet::WalletErrors,
};

#[derive(Debug, Error)]
pub enum ServiceError {
    #[error("Service is not running")]
    NotRunning,

    #[error("Parse {0} error: {1}")]
    ParseError(String, String),

    #[error("Parse {0}")]
    SerdeSerror(String),

    #[error("Failed to acquire lock")]
    MutexLock,

    #[error("Cannot get mutable reference to core")]
    CoreAccess,

    #[error("background Error: {0}")]
    BackgroundError(BackgroundError),

    #[error("Wallet error at index: {0}: {1}")]
    WalletError(usize, WalletErrors),

    #[error("Account error at index: {0}, wallet index at {1}: {2}")]
    AccountError(usize, usize, WalletErrors),

    #[error("address error: {0}")]
    AddressError(AddressError),

    #[error("settings error: {0}")]
    SettingsError(SettingsErrors),

    #[error("Transaction error: {0}")]
    TransactionErrors(TransactionErrors),

    #[error("Failed to access wallet at index {0}")]
    WalletAccess(usize),

    #[error("Failed to access account at index {0} and wallet index at {1}")]
    AccountAccess(usize, usize),

    #[error("not valid account type!")]
    AccountTypeNotValid,

    #[error("Failed to decode session")]
    DecodeSession,

    #[error("Failed to save wallet")]
    FailToSaveWallet,

    #[error("Failed to decode secret key")]
    DecodeSecretKey,

    #[error("Invalid secret key length")]
    InvalidSecretKeyLength,

    #[error("Failed to decode public key")]
    DecodePublicKey,

    #[error("Invalid public key length")]
    InvalidPublicKeyLength,

    #[error("Settings Error: {0}")]
    SettingsErrors(SettingsErrors),

    #[error("Token Error: {0}")]
    TokenError(TokenError),

    #[error("Network Error: {0}")]
    NetworkErrors(NetworkErrors),

    #[error("Cache Error: {0}")]
    CacheError(CacheError),

    #[error("PubKey Error: {0}")]
    PubKeyError(PubKeyError),
}

impl From<BackgroundError> for ServiceError {
    fn from(error: BackgroundError) -> Self {
        ServiceError::BackgroundError(error)
    }
}

impl From<PubKeyError> for ServiceError {
    fn from(error: PubKeyError) -> Self {
        ServiceError::PubKeyError(error)
    }
}

impl From<AddressError> for ServiceError {
    fn from(error: AddressError) -> Self {
        ServiceError::AddressError(error)
    }
}

impl From<CacheError> for ServiceError {
    fn from(error: CacheError) -> Self {
        ServiceError::CacheError(error)
    }
}

impl From<NetworkErrors> for ServiceError {
    fn from(error: NetworkErrors) -> Self {
        ServiceError::NetworkErrors(error)
    }
}

impl From<TransactionErrors> for ServiceError {
    fn from(error: TransactionErrors) -> Self {
        ServiceError::TransactionErrors(error)
    }
}

impl From<SettingsErrors> for ServiceError {
    fn from(error: SettingsErrors) -> Self {
        ServiceError::SettingsErrors(error)
    }
}

impl From<TokenError> for ServiceError {
    fn from(error: TokenError) -> Self {
        ServiceError::TokenError(error)
    }
}

impl From<hex::FromHexError> for ServiceError {
    fn from(_: hex::FromHexError) -> Self {
        ServiceError::DecodeSecretKey
    }
}

impl From<ServiceError> for String {
    fn from(error: ServiceError) -> String {
        error.to_string()
    }
}

```

`rust/src/utils/mod.rs`:

```rs
pub mod errors;
pub mod utils;

```

`rust/src/utils/utils.rs`:

```rs
use std::sync::Arc;
use zilpay::{background::bg_settings::SettingsManagement, crypto::slip44};
pub use zilpay::{
    background::Background,
    config::key::{PUB_KEY_SIZE, SECRET_KEY_SIZE},
    proto::{address::Address, pubkey::PubKey, secret_key::SecretKey},
    wallet::{wallet_data::WalletData, Wallet, WalletAddrType},
};
pub use zilpay::{
    background::{bg_provider::ProvidersManagement, bg_wallet::WalletManagement},
    crypto::bip49::DerivationPath,
    errors::{background::BackgroundError, wallet::WalletErrors},
};

use crate::{
    models::{background::BackgroundState, wallet::WalletInfo},
    service::service::BACKGROUND_SERVICE,
};

use super::errors::ServiceError;

pub fn parse_address(addr: String) -> Result<Address, ServiceError> {
    if addr.starts_with("0x") {
        Address::from_eth_address(&addr).map_err(ServiceError::AddressError)
    } else {
        Address::from_zil_bech32(&addr)
            .or_else(|_| Address::from_eth_address(&addr))
            .map_err(ServiceError::AddressError)
    }
}

pub fn decode_session(session_cipher: Option<String>) -> Result<Vec<u8>, ServiceError> {
    hex::decode(session_cipher.unwrap_or_default()).map_err(|_| ServiceError::DecodeSession)
}

pub fn decode_secret_key(sk: &str) -> Result<[u8; SECRET_KEY_SIZE], ServiceError> {
    let sk = sk.strip_prefix("0x").unwrap_or(sk);
    hex::decode(sk)
        .map_err(|_| ServiceError::DecodeSecretKey)?
        .try_into()
        .map_err(|_| ServiceError::InvalidSecretKeyLength)
}

pub fn pubkey_from_provider(
    pub_key: &str,
    bip49: DerivationPath,
    zilliqa_legacy: bool,
) -> Result<PubKey, ServiceError> {
    let pub_key_bytes = PubKey::from_uncompressed_hex(pub_key)?;

    let pub_key = match (bip49.slip44, zilliqa_legacy) {
        (slip44::ZILLIQA, true) => PubKey::Secp256k1Sha256(pub_key_bytes),
        (slip44::ZILLIQA, false) => PubKey::Secp256k1Keccak256(pub_key_bytes),
        (slip44::ETHEREUM, _) => PubKey::Secp256k1Keccak256(pub_key_bytes),
        (slip44::BITCOIN, _) => PubKey::Secp256k1Bitcoin(pub_key_bytes),
        (slip44::SOLANA, _) => PubKey::Ed25519Solana(pub_key_bytes),
        _ => todo!(),
    };

    Ok(pub_key)
}

pub fn secretkey_from_provider(
    secret_key: &str,
    bip49: DerivationPath,
) -> Result<SecretKey, ServiceError> {
    let sk = secret_key.strip_prefix("0x").unwrap_or(secret_key);
    let secret_key_bytes = decode_secret_key(&sk)?;

    let sk = match bip49.slip44 {
        slip44::ETHEREUM | slip44::ZILLIQA => {
            SecretKey::Secp256k1Keccak256Ethereum(secret_key_bytes)
        }
        _ => todo!(),
    };

    Ok(sk)
}

pub fn get_background_state(service: &Background) -> Result<BackgroundState, ServiceError> {
    let providers = service.get_providers();
    let settings = service.get_global_settings();
    let wallets = service
        .wallets
        .iter()
        .map(|w| w.try_into())
        .collect::<Result<Vec<WalletInfo>, WalletErrors>>()
        .map_err(BackgroundError::WalletError)?;

    let notifications_wallet_states = settings
        .notifications
        .wallet_states
        .iter()
        .map(|(k, v)| (*k, v.into()))
        .collect();

    Ok(BackgroundState {
        wallets,
        notifications_wallet_states,
        browser_settings: settings.browser.clone().into(),
        notifications_global_enabled: settings.notifications.global_enabled,
        locale: settings.locale.clone(),
        appearances: settings.theme.appearances.code(),
        abbreviated_number: settings.theme.compact_numbers,
        providers: providers.into_iter().map(|p| p.config.into()).collect(),
    })
}

pub fn get_last_wallet(service: &Background) -> Result<&Wallet, ServiceError> {
    service.wallets.last().ok_or(ServiceError::FailToSaveWallet)
}

pub async fn with_service<F, T>(f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&zilpay::background::Background) -> Result<T, ServiceError>,
{
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    f(&service.core)
}

pub async fn with_service_mut<F, T>(f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&mut zilpay::background::Background) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;

        f(core)
    } else {
        Err(ServiceError::NotRunning)
    }
}

pub async fn with_wallet_mut<F, T>(wallet_index: usize, f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&mut Wallet) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;

        let wallet = core
            .wallets
            .get_mut(wallet_index)
            .ok_or(ServiceError::WalletAccess(wallet_index))?;

        f(wallet)
    } else {
        Err(ServiceError::NotRunning)
    }
}

pub async fn with_wallet<F, T>(wallet_index: usize, f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&Wallet) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);
        let wallet = core.get_wallet_by_index(wallet_index)?;

        f(wallet)
    } else {
        Err(ServiceError::NotRunning)
    }
}

```