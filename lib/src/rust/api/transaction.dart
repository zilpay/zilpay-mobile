// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/ftoken.dart';
import '../models/gas.dart';
import '../models/transactions/access_list.dart';
import '../models/transactions/base_token.dart';
import '../models/transactions/evm.dart';
import '../models/transactions/history.dart';
import '../models/transactions/request.dart';
import '../models/transactions/scilla.dart';
import '../models/transactions/transaction_metadata.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

Future<HistoricalTransactionInfo> sendSignedTransactions({
  required int walletIndex,
  required int accountIndex,
  required TransactionRequestInfo tx,
  required List<int> sig,
}) => RustLib.instance.api.crateApiTransactionSendSignedTransactions(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  tx: tx,
  sig: sig,
);

Future<HistoricalTransactionInfo> signSendTransactions({
  required BigInt walletIndex,
  required BigInt accountIndex,
  String? password,
  String? passphrase,
  String? sessionCipher,
  required List<String> identifiers,
  required TransactionRequestInfo tx,
}) => RustLib.instance.api.crateApiTransactionSignSendTransactions(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  password: password,
  passphrase: passphrase,
  sessionCipher: sessionCipher,
  identifiers: identifiers,
  tx: tx,
);

Future<Uint8List> encodeTxRlp({
  required BigInt walletIndex,
  required BigInt accountIndex,
  required TransactionRequestInfo tx,
}) => RustLib.instance.api.crateApiTransactionEncodeTxRlp(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  tx: tx,
);

Future<Uint8List> prepareMessage({
  required BigInt walletIndex,
  required BigInt accountIndex,
  required String message,
}) => RustLib.instance.api.crateApiTransactionPrepareMessage(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  message: message,
);

Future<Eip712Hashes> prepareEip712Message({required String typedDataJson}) =>
    RustLib.instance.api.crateApiTransactionPrepareEip712Message(
      typedDataJson: typedDataJson,
    );

Future<(String, String)> signMessage({
  required BigInt walletIndex,
  required BigInt accountIndex,
  String? password,
  String? passphrase,
  String? sessionCipher,
  required List<String> identifiers,
  required String message,
}) => RustLib.instance.api.crateApiTransactionSignMessage(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  password: password,
  passphrase: passphrase,
  sessionCipher: sessionCipher,
  identifiers: identifiers,
  message: message,
);

Future<(String, String)> signTypedDataEip712({
  required BigInt walletIndex,
  required BigInt accountIndex,
  String? password,
  String? passphrase,
  String? sessionCipher,
  required List<String> identifiers,
  required String typedDataJson,
}) => RustLib.instance.api.crateApiTransactionSignTypedDataEip712(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  password: password,
  passphrase: passphrase,
  sessionCipher: sessionCipher,
  identifiers: identifiers,
  typedDataJson: typedDataJson,
);

Future<List<HistoricalTransactionInfo>> getHistory({
  required BigInt walletIndex,
}) => RustLib.instance.api.crateApiTransactionGetHistory(
  walletIndex: walletIndex,
);

Future<void> clearHistory({required BigInt walletIndex}) => RustLib.instance.api
    .crateApiTransactionClearHistory(walletIndex: walletIndex);

Future<TransactionRequestInfo> createTokenTransfer({
  required TokenTransferParamsInfo params,
}) =>
    RustLib.instance.api.crateApiTransactionCreateTokenTransfer(params: params);

Future<RequiredTxParamsInfo> caclGasFee({
  required BigInt walletIndex,
  required BigInt accountIndex,
  required TransactionRequestInfo params,
}) => RustLib.instance.api.crateApiTransactionCaclGasFee(
  walletIndex: walletIndex,
  accountIndex: accountIndex,
  params: params,
);

Future<List<HistoricalTransactionInfo>> checkPendingTranasctions({
  required BigInt walletIndex,
}) => RustLib.instance.api.crateApiTransactionCheckPendingTranasctions(
  walletIndex: walletIndex,
);

Stream<String> startHistoryWorker({required BigInt walletIndex}) => RustLib
    .instance
    .api
    .crateApiTransactionStartHistoryWorker(walletIndex: walletIndex);

Future<void> stopHistoryWorker() =>
    RustLib.instance.api.crateApiTransactionStopHistoryWorker();

class Eip712Hashes {
  final Uint8List domainSeparator;
  final Uint8List hashStructMessage;

  const Eip712Hashes({
    required this.domainSeparator,
    required this.hashStructMessage,
  });

  @override
  int get hashCode => domainSeparator.hashCode ^ hashStructMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Eip712Hashes &&
          runtimeType == other.runtimeType &&
          domainSeparator == other.domainSeparator &&
          hashStructMessage == other.hashStructMessage;
}

class TokenTransferParamsInfo {
  final BigInt walletIndex;
  final BigInt accountIndex;
  final FTokenInfo token;
  final String amount;
  final String recipient;
  final String icon;

  const TokenTransferParamsInfo({
    required this.walletIndex,
    required this.accountIndex,
    required this.token,
    required this.amount,
    required this.recipient,
    required this.icon,
  });

  @override
  int get hashCode =>
      walletIndex.hashCode ^
      accountIndex.hashCode ^
      token.hashCode ^
      amount.hashCode ^
      recipient.hashCode ^
      icon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenTransferParamsInfo &&
          runtimeType == other.runtimeType &&
          walletIndex == other.walletIndex &&
          accountIndex == other.accountIndex &&
          token == other.token &&
          amount == other.amount &&
          recipient == other.recipient &&
          icon == other.icon;
}
