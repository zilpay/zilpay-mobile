// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/ftoken.dart';
import '../models/gas.dart';
import '../models/transactions/access_list.dart';
import '../models/transactions/base_token.dart';
import '../models/transactions/evm.dart';
import '../models/transactions/history.dart';
import '../models/transactions/request.dart';
import '../models/transactions/scilla.dart';
import '../models/transactions/transaction_metadata.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<HistoricalTransactionInfo> signSendTransactions(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        String? password,
        String? passphrase,
        String? sessionCipher,
        required List<String> identifiers,
        required TransactionRequestInfo tx}) =>
    RustLib.instance.api.crateApiTransactionSignSendTransactions(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        password: password,
        passphrase: passphrase,
        sessionCipher: sessionCipher,
        identifiers: identifiers,
        tx: tx);

Future<(String, String)> signMessage(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        String? password,
        String? passphrase,
        String? sessionCipher,
        required List<String> identifiers,
        required String message}) =>
    RustLib.instance.api.crateApiTransactionSignMessage(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        password: password,
        passphrase: passphrase,
        sessionCipher: sessionCipher,
        identifiers: identifiers,
        message: message);

Future<(String, String)> signTypedDataEip712(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        String? password,
        String? passphrase,
        String? sessionCipher,
        required List<String> identifiers,
        required String typedDataJson}) =>
    RustLib.instance.api.crateApiTransactionSignTypedDataEip712(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        password: password,
        passphrase: passphrase,
        sessionCipher: sessionCipher,
        identifiers: identifiers,
        typedDataJson: typedDataJson);

Future<List<HistoricalTransactionInfo>> getHistory(
        {required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTransactionGetHistory(walletIndex: walletIndex);

Future<void> clearHistory({required BigInt walletIndex}) => RustLib.instance.api
    .crateApiTransactionClearHistory(walletIndex: walletIndex);

Future<TransactionRequestInfo> createTokenTransfer(
        {required TokenTransferParamsInfo params}) =>
    RustLib.instance.api.crateApiTransactionCreateTokenTransfer(params: params);

Future<RequiredTxParamsInfo> caclGasFee(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        required TransactionRequestInfo params}) =>
    RustLib.instance.api.crateApiTransactionCaclGasFee(
        walletIndex: walletIndex, accountIndex: accountIndex, params: params);

Future<List<HistoricalTransactionInfo>> checkPendingTranasctions(
        {required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTransactionCheckPendingTranasctions(walletIndex: walletIndex);

Stream<String> startHistoryWorker({required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTransactionStartHistoryWorker(walletIndex: walletIndex);

Future<void> stopHistoryWorker() =>
    RustLib.instance.api.crateApiTransactionStopHistoryWorker();

class TokenTransferParamsInfo {
  final BigInt walletIndex;
  final BigInt accountIndex;
  final FTokenInfo token;
  final String amount;
  final String recipient;
  final String icon;

  const TokenTransferParamsInfo({
    required this.walletIndex,
    required this.accountIndex,
    required this.token,
    required this.amount,
    required this.recipient,
    required this.icon,
  });

  @override
  int get hashCode =>
      walletIndex.hashCode ^
      accountIndex.hashCode ^
      token.hashCode ^
      amount.hashCode ^
      recipient.hashCode ^
      icon.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenTransferParamsInfo &&
          runtimeType == other.runtimeType &&
          walletIndex == other.walletIndex &&
          accountIndex == other.accountIndex &&
          token == other.token &&
          amount == other.amount &&
          recipient == other.recipient &&
          icon == other.icon;
}
