Project Path: ledger

Source Tree:

```txt
ledger
├── common.dart
├── ethereum
│   ├── ethereum_eip712_hashed_message_operation.dart
│   ├── ethereum_ledger_application.dart
│   ├── ethereum_personal_message_operation.dart
│   ├── ethereum_public_key_operation.dart
│   ├── ethereum_transaction_operation.dart
│   ├── models.dart
│   └── utils.dart
└── zilliqa
    ├── zilliqa_ledger_application.dart
    ├── zilliqa_public_key_operation.dart
    ├── zilliqa_sign_hash_operation.dart
    └── zilliqa_sign_tx_operation.dart

```

`ledger/common.dart`:

```dart
class LedgerAccount {
  final String publicKey;
  final String address;
  final int index;

  LedgerAccount({
    required this.publicKey,
    required this.address,
    required this.index,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LedgerAccount &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          index == other.index);

  @override
  int get hashCode => Object.hash(publicKey, index);
}

```

`ledger/ethereum/ethereum_eip712_hashed_message_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumEIP712HashedMessageOperation
    extends LedgerRawOperation<Uint8List> {
  final int accountIndex;
  final Uint8List domainSeparator;
  final Uint8List hashStructMessage;

  EthereumEIP712HashedMessageOperation(
      {this.accountIndex = 0,
      required this.domainSeparator,
      required this.hashStructMessage});

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(0xe0);
    writer.writeUint8(0x0c);
    writer.writeUint8(0x00);
    writer.writeUint8(0x00);

    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    final buffer = Uint8List(1 + paths.length * 4 + 32 + 32);
    var offset = 0;
    buffer[0] = paths.length;
    for (var index = 0; index < paths.length; index++) {
      buffer.buffer
          .asByteData()
          .setUint32(1 + 4 * index, paths[index], Endian.big);
    }
    offset = 1 + 4 * paths.length;
    buffer.setAll(offset, domainSeparator);
    offset += 32;
    buffer.setAll(offset, hashStructMessage);

    final List<int> bufferBytes = buffer.buffer.asUint8List();
    writer.writeUint8(buffer.lengthInBytes);
    writer.write(bufferBytes);

    return [writer.toBytes()];
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    return bytes;
  }
}

```

`ledger/ethereum/ethereum_ledger_application.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/ethereum_eip712_hashed_message_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_personal_message_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_public_key_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_transaction_operation.dart';
import 'package:zilpay/ledger/ethereum/models.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';

class EthereumLedgerApp {
  final LedgerConnection ledger;
  final LedgerTransformer? transformer;

  EthereumLedgerApp(
    this.ledger, {
    this.transformer,
  });

  Future<List<LedgerAccount>> getAccounts(List<int> accountIndices) async {
    final List<LedgerAccount> accounts = [];

    for (final index in accountIndices) {
      final account = await ledger.sendOperation<LedgerAccount>(
        EthereumPublicKeyOperation(accountIndex: index),
        transformer: transformer,
      );
      accounts.add(account);
    }

    return accounts;
  }

  Future<EthLedgerSignature> signPersonalMessage(
    Uint8List message,
    int accountIndex,
  ) async {
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumPersonalMessageOperation(
          accountIndex: accountIndex, message: message),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  Future<EthLedgerSignature> signEIP712HashedMessage(
    Eip712Hashes hashes,
    int accountIndex,
  ) async {
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumEIP712HashedMessageOperation(
        accountIndex: accountIndex,
        domainSeparator: hashes.domainSeparator,
        hashStructMessage: hashes.hashStructMessage,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  Future<EthLedgerSignature> signTransaction(
    TransactionRequestInfo transaction,
    int walletIndex,
    int accountIndex,
  ) async {
    final txRLP = await encodeTxRlp(
      tx: transaction,
      walletIndex: BigInt.from(walletIndex),
      accountIndex: BigInt.from(accountIndex),
    );
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumTransactionOperation(
        accountIndex: accountIndex,
        transaction: txRLP,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  static void _checkResult(Uint8List result) {
    if (result.length != 2) {
      return;
    }

    int status = (result[0] << 8) | result[1];

    switch (status) {
      case 0x9000: // APDU_RESPONSE_OK
        break;

      case 0x5515:
        throw Exception('Device is locked');

      case 0x6967:
        throw Exception('Operation rejected');

      case 0x6985: // APDU_RESPONSE_CONDITION_NOT_SATISFIED
        throw Exception('Condition not satisfied (possibly rejected by user)');

      case 0x0000: // APDU_NO_RESPONSE
        throw Exception('No response from device');

      case 0x6001: // APDU_RESPONSE_MODE_CHECK_FAILED
        throw Exception('Mode check failed');

      case 0x6501: // APDU_RESPONSE_TX_TYPE_NOT_SUPPORTED
        throw Exception('Transaction type not supported');

      case 0x6502: // APDU_RESPONSE_CHAINID_OUT_BUF_SMALL
        throw Exception('Chain ID buffer too small');

      case 0x6800: // APDU_RESPONSE_INTERNAL_ERROR
        throw Exception('Internal device error');

      case 0x6982: // APDU_RESPONSE_SECURITY_NOT_SATISFIED
        throw Exception('Security conditions not satisfied');

      case 0x6983: // APDU_RESPONSE_WRONG_DATA_LENGTH
        throw Exception('Incorrect data length');

      case 0x6984: // APDU_RESPONSE_PLUGIN_NOT_INSTALLED
        throw Exception('Plugin not installed');

      case 0x6a00: // APDU_RESPONSE_ERROR_NO_INFO
        throw Exception('Error with no additional information');

      case 0x6a80: // APDU_RESPONSE_INVALID_DATA
        throw Exception('Invalid data');

      case 0x6a84: // APDU_RESPONSE_INSUFFICIENT_MEMORY
        throw Exception('Insufficient memory');

      case 0x6a88: // APDU_RESPONSE_REF_DATA_NOT_FOUND
        throw Exception('Reference data not found');

      case 0x6b00: // APDU_RESPONSE_INVALID_P1_P2
        throw Exception('Invalid P1 or P2 parameters');

      case 0x6d00: // APDU_RESPONSE_INVALID_INS
        throw Exception('Invalid instruction');

      case 0x6e00: // APDU_RESPONSE_INVALID_CLA
        throw Exception('Invalid class');

      case 0x6f00: // APDU_RESPONSE_UNKNOWN
        throw Exception('Unknown error');

      case 0x911c: // APDU_RESPONSE_CMD_CODE_NOT_SUPPORTED
        throw Exception('Command code not supported');

      default:
        throw Exception(
            'Unknown status code: 0x${status.toRadixString(16).padLeft(4, '0')}');
    }
  }
}

```

`ledger/ethereum/ethereum_personal_message_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumPersonalMessageOperation extends LedgerRawOperation<Uint8List> {
  final int accountIndex;
  final Uint8List message;

  EthereumPersonalMessageOperation(
      {this.accountIndex = 0, required this.message});

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    final output = <Uint8List>[];
    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    int offset = 0;
    while (offset != message.length) {
      final writer = ByteDataWriter();
      writer.writeUint8(0xe0);
      writer.writeUint8(0x08);

      int maxChunkSize = offset == 0 ? 150 - 1 - paths.length * 4 - 4 : 150;
      int chunkSize = offset + maxChunkSize > message.length
          ? message.length - offset
          : maxChunkSize;
      ByteData buffer = ByteData(
          offset == 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);
      if (offset == 0) {
        buffer.setUint8(0, paths.length);
        for (int i = 0; i < paths.length; i++) {
          buffer.setUint32(1 + 4 * i, paths[i], Endian.big);
        }
        buffer.setUint32(1 + 4 * paths.length, message.length, Endian.big);
        buffer.buffer.asUint8List().setAll(1 + 4 * paths.length + 4,
            message.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x00);
      } else {
        buffer.buffer
            .asUint8List()
            .setAll(0, message.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x80);
      }

      writer.writeUint8(0x00);

      final List<int> bufferBytes = buffer.buffer.asUint8List();
      writer.writeUint8(buffer.lengthInBytes);
      writer.write(bufferBytes);

      offset += chunkSize;

      output.add(writer.toBytes());
    }

    return output;
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    return bytes;
  }
}

```

`ledger/ethereum/ethereum_public_key_operation.dart`:

```dart
import 'dart:convert';
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumPublicKeyOperation extends LedgerRawOperation<LedgerAccount> {
  final int accountIndex;

  EthereumPublicKeyOperation({
    this.accountIndex = 0,
  });

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(0xe0); // CLA (class of instruction)
    writer.writeUint8(0x02); // INS (instruction code) - GET_PUBLIC_KEY
    writer.writeUint8(0x00); // P1 parameter
    writer.writeUint8(0x00); // P2 parameter

    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    final int bufferSize = 1 + paths.length * 4;
    final ByteData buffer = ByteData(bufferSize)..setUint8(0, paths.length);
    for (int i = 0; i < paths.length; i++) {
      buffer.setUint32(1 + 4 * i, paths[i], Endian.big);
    }

    final List<int> bufferBytes = buffer.buffer.asUint8List();
    writer.writeUint8(buffer.lengthInBytes); // CDATA length
    writer.write(bufferBytes); // CDATA

    return [writer.toBytes()];
  }

  @override
  Future<LedgerAccount> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    int publicKeyLength = bytes[0];
    int addressLength = bytes[1 + publicKeyLength];
    final publicKey =
        bytesToHex(bytes.sublist(1, 1 + publicKeyLength), include0x: true);
    final address =
        '0x${utf8.decode(bytes.sublist(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength))}';
    return LedgerAccount(
      publicKey: publicKey,
      address: address,
      index: accountIndex,
    );
  }
}

```

`ledger/ethereum/ethereum_transaction_operation.dart`:

```dart
import 'package:flutter/foundation.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumTransactionOperation extends LedgerRawOperation<Uint8List> {
  final int accountIndex;
  final Uint8List transaction;

  EthereumTransactionOperation({
    this.accountIndex = 0,
    required this.transaction,
  });

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    final output = <Uint8List>[];
    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));

    if (paths.isEmpty) {
      throw Exception('Derivation path is empty');
    }

    int offset = 0;

    while (offset < transaction.length) {
      writer = ByteDataWriter();

      writer.writeUint8(0xe0); // CLA
      writer.writeUint8(0x04); // ins (SIGN)

      final bool first = offset == 0;
      final int maxChunkSize = first ? 150 - 1 - paths.length * 4 : 150;
      final int chunkSize = offset + maxChunkSize > transaction.length
          ? transaction.length - offset
          : maxChunkSize;

      if (chunkSize <= 0) {
        throw Exception('Invalid chunk size: $chunkSize at offset $offset');
      }

      final buffer =
          Uint8List(first ? 1 + paths.length * 4 + chunkSize : chunkSize);

      if (first) {
        buffer[0] = paths.length;
        for (var i = 0; i < paths.length; i++) {
          buffer.buffer.asByteData().setUint32(1 + 4 * i, paths[i], Endian.big);
        }
        buffer.setAll(1 + 4 * paths.length,
            transaction.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x00);
      } else {
        buffer.setAll(0, transaction.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x80);
      }

      writer.writeUint8(0x00);
      writer.writeUint8(buffer.lengthInBytes);
      writer.write(buffer);

      final chunkData = writer.toBytes();
      output.add(chunkData);

      offset += chunkSize;
    }

    if (offset != transaction.length) {
      throw Exception(
          'Incomplete data sent: sent $offset of ${transaction.length} bytes');
    }

    return output;
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    return bytes;
  }
}

```

`ledger/ethereum/models.dart`:

```dart
import 'dart:typed_data';

import 'package:zilpay/ledger/ethereum/utils.dart';

class EthLedgerSignature {
  final int v;
  final Uint8List r;
  final Uint8List s;

  EthLedgerSignature({required this.v, required this.r, required this.s});

  String toHexString() {
    if (r.length != 32 || s.length != 32) {
      throw ArgumentError('r and s must be 32 bytes long');
    }

    final buffer = Uint8List(65);
    buffer.setRange(0, 32, r);
    buffer.setRange(32, 64, s);
    buffer[64] = v;

    return bytesToHex(buffer, include0x: true);
  }

  Uint8List toBytes() {
    if (r.length != 32 || s.length != 32) {
      throw ArgumentError('r and s must be 32 bytes long');
    }

    final buffer = Uint8List(65);
    buffer.setRange(0, 32, r);
    buffer.setRange(32, 64, s);
    buffer[64] = v;

    return buffer;
  }

  static EthLedgerSignature fromBytes(Uint8List bytes) {
    if (bytes.length != 65) {
      throw ArgumentError(
          'Bytes must be 65 bytes long to form a valid signature');
    }

    final v = bytes[64];
    final r = Uint8List.sublistView(bytes, 0, 32);
    final s = Uint8List.sublistView(bytes, 32, 64);

    return EthLedgerSignature(v: v, r: r, s: s);
  }

  static EthLedgerSignature fromLedgerResponse(Uint8List bytes) {
    if (bytes.length < 65) {
      throw FormatException('Response too short to contain valid signature');
    }

    int v = bytes[0];
    Uint8List r = Uint8List.sublistView(bytes, 1, 1 + 32);
    Uint8List s = Uint8List.sublistView(bytes, 1 + 32, 1 + 32 + 32);

    return EthLedgerSignature(v: v, r: r, s: s);
  }
}

```

`ledger/ethereum/utils.dart`:

```dart
String getWalletDerivationPath(int accountIndex) {
  if (accountIndex < 0) {
    throw ArgumentError('accountIndex должен быть >= 0');
  }
  return "m/44'/60'/0'/0/$accountIndex";
}

List<int> splitPath(String path) {
  List<int> result = [];
  List<String> components = path.split("/");

  for (var element in components) {
    if (element.isEmpty || element == "m") continue;

    int number = int.tryParse(element.replaceAll("'", "")) ?? 0;

    if (element.length > 1 && element[element.length - 1] == "'") {
      number += 0x80000000;
    }

    result.add(number);
  }

  return result;
}

String bytesToHex(List<int> bytes, {bool include0x = false}) {
  final buffer = StringBuffer();
  if (include0x) {
    buffer.write('0x');
  }

  for (final byte in bytes) {
    buffer.write(byte.toRadixString(16).padLeft(2, '0'));
  }

  return buffer.toString();
}

```

`ledger/zilliqa/zilliqa_ledger_application.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_public_key_operation.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_sign_hash_operation.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_sign_tx_operation.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';

class ZilliqaLedgerApp {
  final LedgerConnection ledger;
  final LedgerTransformer? transformer;

  ZilliqaLedgerApp(
    this.ledger, {
    this.transformer,
  });

  Future<List<LedgerAccount>> getPublicAddress(
    List<int> accountIndices,
  ) async {
    final List<LedgerAccount> accounts = [];

    for (final index in accountIndices) {
      final account = await ledger.sendOperation<LedgerAccount>(
        ZilliqaPublicAddressOperation(index),
        transformer: transformer,
      );

      accounts.add(account);
    }

    return accounts;
  }

  Future<String> signHash(
    Uint8List hashBytes,
    int accountIndex,
  ) async {
    final signature = await ledger.sendOperation<Uint8List>(
      ZilliqaSignHashOperation(
        accountIndex,
        hashBytes,
      ),
      transformer: transformer,
    );

    _checkResult(signature);

    return bytesToHex(signature);
  }

  Future<Uint8List> signTransaction(
    TransactionRequestInfo transaction,
    int walletIndex,
    int accountIndex,
  ) async {
    final protoBuf = await encodeTxRlp(
      tx: transaction,
      walletIndex: BigInt.from(walletIndex),
      accountIndex: BigInt.from(accountIndex),
    );

    final signatureBytes = await ledger.sendOperation<Uint8List>(
      ZilliqaSignTransactionOperation(
        accountIndex: accountIndex,
        transaction: protoBuf,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return signatureBytes.sublist(0, signatureBytes.length - 2);
  }

  static void _checkResult(Uint8List result) {
    if (result.length != 2) {
      return;
    }

    int status = (result[0] << 8) | result[1];

    switch (status) {
      case 0x9000:
        break;
      case 0x5515:
        throw Exception('Device is locked');
      case 0x6967:
        throw Exception('Operation rejected');
      case 0x6985:
        throw Exception('Condition not satisfied (possibly rejected by user)');
      case 0x6a80:
        throw Exception('Invalid data');
      case 0x6f00:
        throw Exception('Unknown error');
      default:
        throw Exception(
            'Unknown status code: 0x${status.toRadixString(16).padLeft(4, '0')}');
    }
  }
}

```

`ledger/zilliqa/zilliqa_public_key_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/common.dart';

class ZilliqaPublicAddressOperation extends LedgerRawOperation<LedgerAccount> {
  static const cla = 0xE0;
  static const ins = 0x02;
  static const pubKeyByteLen = 33;
  static const bech32AddrLen = 39;

  final int accountIndex;

  ZilliqaPublicAddressOperation(this.accountIndex);

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(cla); // CLA
    writer.writeUint8(ins); // INS: getPublicAddress
    writer.writeUint8(0x00); // P1
    writer.writeUint8(0x01); // P2: request public address
    writer.writeUint8(0x04); // Data length (4 bytes for index)
    writer.writeInt32(accountIndex, Endian.little); // Account index

    return [writer.toBytes()];
  }

  @override
  Future<LedgerAccount> read(ByteDataReader reader) async {
    final publicKeyBytes = reader.read(pubKeyByteLen);
    final publicKey = publicKeyBytes
        .map((byte) => byte.toRadixString(16).padLeft(2, '0'))
        .join();

    final addressBytes = reader.read(bech32AddrLen);
    final address = String.fromCharCodes(addressBytes);

    return LedgerAccount(
      publicKey: publicKey,
      address: address,
      index: accountIndex,
    );
  }
}

```

`ledger/zilliqa/zilliqa_sign_hash_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';

class ZilliqaSignHashOperation extends LedgerRawOperation<Uint8List> {
  static const cla = 0xE0;
  static const ins = 0x08;
  static const sigByteLen = 64;

  final int accountIndex;
  final Uint8List hash;

  ZilliqaSignHashOperation(this.accountIndex, this.hash);

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(cla); // CLA
    writer.writeUint8(ins); // INS: signHash
    writer.writeUint8(0x00); // P1
    writer.writeUint8(0x00); // P2

    writer.writeUint8(4 + hash.length);
    writer.writeInt32(accountIndex, Endian.little);
    writer.write(hash);

    return [writer.toBytes()];
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final signatureBytes = reader.read(sigByteLen);

    return signatureBytes;
  }
}

```

`ledger/zilliqa/zilliqa_sign_tx_operation.dart`:

```dart
import 'package:flutter/foundation.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';

class ZilliqaSignTransactionOperation extends LedgerRawOperation<Uint8List> {
  static const cla = 0xE0;
  static const ins = 0x04;
  static const sigByteLen = 64;
  static const streamLen = 128;

  final int accountIndex;
  final Uint8List transaction;

  ZilliqaSignTransactionOperation({
    required this.accountIndex,
    required this.transaction,
  });

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    final List<Uint8List> apduList = [];
    int offset = 0;
    int remainingBytes = transaction.length;

    final firstWriter = ByteDataWriter();
    firstWriter.writeUint8(cla);
    firstWriter.writeUint8(ins);
    firstWriter.writeUint8(0x00);
    firstWriter.writeUint8(0x00);

    final chunkSize = remainingBytes > streamLen ? streamLen : remainingBytes;
    final hostBytesLeft = remainingBytes - chunkSize;

    final indexBytes = ByteData(4)..setInt32(0, accountIndex, Endian.little);
    final hostBytesLeftBytes = ByteData(4)
      ..setInt32(0, hostBytesLeft, Endian.little);
    final txn1SizeBytes = ByteData(4)..setInt32(0, chunkSize, Endian.little);
    final txn1Bytes = transaction.sublist(offset, offset + chunkSize);

    final firstData = Uint8List.fromList([
      ...indexBytes.buffer.asUint8List(),
      ...hostBytesLeftBytes.buffer.asUint8List(),
      ...txn1SizeBytes.buffer.asUint8List(),
      ...txn1Bytes,
    ]);

    firstWriter.writeUint8(firstData.length);
    firstWriter.write(firstData);
    apduList.add(firstWriter.toBytes());

    offset += chunkSize;
    remainingBytes -= chunkSize;

    while (remainingBytes > 0) {
      final subsequentWriter = ByteDataWriter();
      subsequentWriter.writeUint8(cla);
      subsequentWriter.writeUint8(ins);
      subsequentWriter.writeUint8(0x00);
      subsequentWriter.writeUint8(0x00);

      final chunkSizeN =
          remainingBytes > streamLen ? streamLen : remainingBytes;
      final hostBytesLeftN = remainingBytes - chunkSizeN;

      final hostBytesLeftBytesN = ByteData(4)
        ..setInt32(0, hostBytesLeftN, Endian.little);
      final txnNSizeBytes = ByteData(4)..setInt32(0, chunkSizeN, Endian.little);
      final txnNBytes = transaction.sublist(offset, offset + chunkSizeN);

      final subsequentData = Uint8List.fromList([
        ...hostBytesLeftBytesN.buffer.asUint8List(),
        ...txnNSizeBytes.buffer.asUint8List(),
        ...txnNBytes,
      ]);

      subsequentWriter.writeUint8(subsequentData.length);
      subsequentWriter.write(subsequentData);
      apduList.add(subsequentWriter.toBytes());

      offset += chunkSizeN;
      remainingBytes -= chunkSizeN;
    }

    return apduList;
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final response = reader.read(reader.remainingLength);

    return response;
  }
}

```