Project Path: zilpay-mobile

Source Tree:

```
zilpay-mobile
├── test_driver
│   └── integration_test.dart
├── integration_test
│   └── simple_test.dart
├── devtools_options.yaml
├── LICENSE
├── test
│   ├── bridge_test.dart
│   └── widget_test.dart
├── pubspec.lock
├── rust
│   ├── Cargo.toml
│   ├── LICENSE
│   └── src
│       ├── lib.rs
│       ├── utils
│       │   ├── mod.rs
│       │   ├── errors.rs
│       │   └── utils.rs
│       ├── models
│       │   ├── background.rs
│       │   ├── qrcode.rs
│       │   ├── notification.rs
│       │   ├── ftoken.rs
│       │   ├── gas.rs
│       │   ├── provider.rs
│       │   ├── mod.rs
│       │   ├── transactions
│       │   │   ├── request.rs
│       │   │   ├── access_list.rs
│       │   │   ├── transaction_metadata.rs
│       │   │   ├── evm.rs
│       │   │   ├── scilla.rs
│       │   │   ├── mod.rs
│       │   │   ├── history.rs
│       │   │   └── base_token.rs
│       │   ├── wallet.rs
│       │   ├── account.rs
│       │   ├── book.rs
│       │   ├── settings.rs
│       │   ├── connection.rs
│       │   └── keypair.rs
│       ├── api
│       │   ├── cache.rs
│       │   ├── ledger.rs
│       │   ├── qrcode.rs
│       │   ├── transaction.rs
│       │   ├── connections.rs
│       │   ├── token.rs
│       │   ├── backend.rs
│       │   ├── methods.rs
│       │   ├── provider.rs
│       │   ├── auth.rs
│       │   ├── mod.rs
│       │   ├── wallet.rs
│       │   ├── book.rs
│       │   └── settings.rs
│       ├── frb_generated.rs
│       └── service
│           ├── service.rs
│           └── mod.rs
├── flutter_rust_bridge.yaml
├── ios
│   ├── Runner.xcworkspace
│   │   ├── contents.xcworkspacedata
│   │   └── xcshareddata
│   │       ├── IDEWorkspaceChecks.plist
│   │       ├── WorkspaceSettings.xcsettings
│   │       └── swiftpm
│   │           └── configuration
│   ├── RunnerTests
│   │   └── RunnerTests.swift
│   ├── Runner
│   │   ├── Runner-Bridging-Header.h
│   │   ├── Assets.xcassets
│   │   │   ├── LaunchImage.imageset
│   │   │   │   ├── LaunchImage@2x.png
│   │   │   │   ├── LaunchImage@3x.png
│   │   │   │   ├── README.md
│   │   │   │   ├── Contents.json
│   │   │   │   └── LaunchImage.png
│   │   │   └── AppIcon.appiconset
│   │   │       ├── Icon-App-76x76@2x.png
│   │   │       ├── Icon-App-29x29@1x.png
│   │   │       ├── Icon-App-40x40@1x.png
│   │   │       ├── Icon-App-20x20@1x.png
│   │   │       ├── Icon-App-1024x1024@1x.png
│   │   │       ├── Icon-App-83.5x83.5@2x.png
│   │   │       ├── Icon-App-20x20@3x.png
│   │   │       ├── Contents.json
│   │   │       ├── Icon-App-20x20@2x.png
│   │   │       ├── Icon-App-29x29@3x.png
│   │   │       ├── Icon-App-40x40@2x.png
│   │   │       ├── Icon-App-60x60@3x.png
│   │   │       ├── Icon-App-60x60@2x.png
│   │   │       ├── Icon-App-76x76@1x.png
│   │   │       ├── Icon-App-40x40@3x.png
│   │   │       └── Icon-App-29x29@2x.png
│   │   ├── Base.lproj
│   │   │   ├── LaunchScreen.storyboard
│   │   │   └── Main.storyboard
│   │   ├── AppDelegate.swift
│   │   └── Info.plist
│   ├── Runner.xcodeproj
│   │   ├── project.pbxproj
│   │   └── xcshareddata
│   │       └── xcschemes
│   │           └── Runner.xcscheme
│   ├── Flutter
│   │   ├── Debug.xcconfig
│   │   ├── Release.xcconfig
│   │   └── AppFrameworkInfo.plist
│   ├── Podfile
│   └── Podfile.lock
├── README.md
├── pubspec.yaml
├── android
│   ├── app
│   │   ├── build.gradle
│   │   └── src
│   │       ├── profile
│   │       │   └── AndroidManifest.xml
│   │       ├── main
│   │       │   ├── res
│   │       │   │   ├── mipmap-mdpi
│   │       │   │   │   └── ic_launcher.png
│   │       │   │   ├── mipmap-hdpi
│   │       │   │   │   └── ic_launcher.png
│   │       │   │   ├── drawable
│   │       │   │   │   └── launch_background.xml
│   │       │   │   ├── mipmap-xxxhdpi
│   │       │   │   │   └── ic_launcher.png
│   │       │   │   ├── mipmap-xxhdpi
│   │       │   │   │   └── ic_launcher.png
│   │       │   │   ├── values-night
│   │       │   │   │   └── styles.xml
│   │       │   │   ├── values
│   │       │   │   │   └── styles.xml
│   │       │   │   ├── drawable-v21
│   │       │   │   │   └── launch_background.xml
│   │       │   │   └── mipmap-xhdpi
│   │       │   │       └── ic_launcher.png
│   │       │   ├── AndroidManifest.xml
│   │       │   ├── java
│   │       │   │   └── io
│   │       │   │       └── flutter
│   │       │   │           └── plugins
│   │       │   └── kotlin
│   │       │       └── com
│   │       │           └── example
│   │       │               └── zilpay
│   │       │                   └── MainActivity.kt
│   │       └── debug
│   │           └── AndroidManifest.xml
│   ├── key.properties.example
│   ├── gradle
│   │   └── wrapper
│   │       └── gradle-wrapper.properties
│   ├── build.gradle
│   ├── gradle.properties
│   └── settings.gradle
├── lib
│   ├── router.dart
│   ├── mixins
│   │   ├── gas_eip1559.dart
│   │   ├── wallet_type.dart
│   │   ├── qrcode.dart
│   │   ├── colors.dart
│   │   ├── icon.dart
│   │   ├── adaptive_size.dart
│   │   ├── amount.dart
│   │   └── addr.dart
│   ├── config
│   │   ├── ftokens.dart
│   │   ├── argon.dart
│   │   ├── providers.dart
│   │   └── settings.dart
│   ├── modals
│   │   ├── sign_tx.dart
│   │   ├── secret_recovery_modal.dart
│   │   ├── qr_scanner_modal.dart
│   │   ├── backup_confirmation_modal.dart
│   │   ├── manage_connections.dart
│   │   ├── ledger_connect_dialog.dart
│   │   ├── select_address.dart
│   │   ├── manage_tokens.dart
│   │   ├── transfer.dart
│   │   ├── select_token.dart
│   │   ├── password_change.dart
│   │   ├── delete_wallet.dart
│   │   ├── argon2.dart
│   │   ├── add_contect.dart
│   │   ├── add_bip39_modal_page.dart
│   │   ├── wallet_header.dart
│   │   ├── custom_network_modal.dart
│   │   └── node_selection_modal.dart
│   ├── state
│   │   └── app_state.dart
│   ├── main.dart
│   ├── components
│   │   ├── custom_app_bar.dart
│   │   ├── wor_count_selector.dart
│   │   ├── wallet_selector_card.dart
│   │   ├── gas_eip1559.dart
│   │   ├── option_list.dart
│   │   ├── action_button.dart
│   │   ├── token_card.dart
│   │   ├── settings_item.dart
│   │   ├── biometric_switch.dart
│   │   ├── button.dart
│   │   ├── wallet_option.dart
│   │   ├── tile_button.dart
│   │   ├── number_keyboard.dart
│   │   ├── custom_network_option.dart
│   │   ├── async_qrcode.dart
│   │   ├── wallet_card.dart
│   │   ├── toggle_item.dart
│   │   ├── view_item.dart
│   │   ├── network_option_item.dart
│   │   ├── ledger_item.dart
│   │   ├── copy_content.dart
│   │   ├── counter.dart
│   │   ├── token_transfer_amount.dart
│   │   ├── custom_dropdown.dart
│   │   ├── network_tile.dart
│   │   ├── hoverd_svg.dart
│   │   ├── smart_input.dart
│   │   ├── mnemonic_word_input.dart
│   │   ├── token_select_item.dart
│   │   ├── hex_key.dart
│   │   ├── load_button.dart
│   │   ├── bottom_nav_bar.dart
│   │   ├── crypto_list.dart
│   │   ├── wallet_header.dart
│   │   ├── linear_refresh_indicator.dart
│   │   ├── swipe_button.dart
│   │   ├── image_cache.dart
│   │   └── input_amount.dart
│   ├── theme
│   │   └── app_theme.dart
│   ├── pages
│   │   ├── gen_wallet_options.dart
│   │   ├── main_page.dart
│   │   ├── history_page.dart
│   │   ├── setup_cipher.dart
│   │   ├── wallet_restore_options.dart
│   │   ├── restore_bip39.dart
│   │   ├── add_token.dart
│   │   ├── currency_conversion.dart
│   │   ├── reveal_bip39.dart
│   │   ├── reveal_sk.dart
│   │   ├── appearance.dart
│   │   ├── sk_gen.dart
│   │   ├── ledger_connect.dart
│   │   ├── browser_page.dart
│   │   ├── notification.dart
│   │   ├── network.dart
│   │   ├── setup_net.dart
│   │   ├── wallet.dart
│   │   ├── login_page.dart
│   │   ├── password_setup.dart
│   │   ├── receive.dart
│   │   ├── initial_page.dart
│   │   ├── send.dart
│   │   ├── home_page.dart
│   │   ├── security.dart
│   │   ├── locale.dart
│   │   ├── address_book.dart
│   │   ├── gen_bip39.dart
│   │   ├── new_wallet_options.dart
│   │   ├── settings_page.dart
│   │   └── verify_bip39.dart
│   ├── app.dart
│   ├── services
│   │   ├── biometric_service.dart
│   │   ├── secure_storage.dart
│   │   ├── device.dart
│   │   ├── social_media.dart
│   │   └── auth_guard.dart
│   └── src
│       └── rust
│           ├── frb_generated.web.dart
│           ├── models
│           │   ├── provider.dart
│           │   ├── qrcode.dart
│           │   ├── account.dart
│           │   ├── notification.dart
│           │   ├── ftoken.dart
│           │   ├── wallet.dart
│           │   ├── book.dart
│           │   ├── transactions
│           │   │   ├── evm.dart
│           │   │   ├── base_token.dart
│           │   │   ├── transaction_metadata.dart
│           │   │   ├── history.dart
│           │   │   ├── request.dart
│           │   │   ├── access_list.dart
│           │   │   └── scilla.dart
│           │   ├── keypair.dart
│           │   ├── gas.dart
│           │   ├── connection.dart
│           │   ├── background.dart
│           │   └── settings.dart
│           ├── api
│           │   ├── auth.dart
│           │   ├── provider.dart
│           │   ├── backend.dart
│           │   ├── ledger.dart
│           │   ├── qrcode.dart
│           │   ├── methods.dart
│           │   ├── cache.dart
│           │   ├── wallet.dart
│           │   ├── book.dart
│           │   ├── transaction.dart
│           │   ├── connections.dart
│           │   ├── token.dart
│           │   └── settings.dart
│           ├── frb_generated.dart
│           └── frb_generated.io.dart
├── analysis_options.yaml
├── rust_builder
│   ├── macos
│   │   ├── rust_lib_zilpay.podspec
│   │   └── Classes
│   │       └── dummy_file.c
│   ├── cargokit
│   │   ├── run_build_tool.cmd
│   │   ├── run_build_tool.sh
│   │   ├── build_pod.sh
│   │   ├── LICENSE
│   │   ├── cmake
│   │   │   ├── resolve_symlinks.ps1
│   │   │   └── cargokit.cmake
│   │   ├── README
│   │   ├── gradle
│   │   │   └── plugin.gradle
│   │   └── build_tool
│   │       ├── bin
│   │       │   └── build_tool.dart
│   │       ├── pubspec.lock
│   │       ├── README.md
│   │       ├── pubspec.yaml
│   │       ├── lib
│   │       │   ├── build_tool.dart
│   │       │   └── src
│   │       │       ├── util.dart
│   │       │       ├── rustup.dart
│   │       │       ├── builder.dart
│   │       │       ├── build_tool.dart
│   │       │       ├── build_pod.dart
│   │       │       ├── crate_hash.dart
│   │       │       ├── environment.dart
│   │       │       ├── cargo.dart
│   │       │       ├── android_environment.dart
│   │       │       ├── precompile_binaries.dart
│   │       │       ├── build_cmake.dart
│   │       │       ├── build_gradle.dart
│   │       │       ├── verify_binaries.dart
│   │       │       ├── artifacts_provider.dart
│   │       │       ├── logging.dart
│   │       │       ├── options.dart
│   │       │       └── target.dart
│   │       └── analysis_options.yaml
│   ├── ios
│   │   ├── rust_lib_zilpay.podspec
│   │   └── Classes
│   │       └── dummy_file.c
│   ├── README.md
│   ├── pubspec.yaml
│   ├── linux
│   │   └── CMakeLists.txt
│   ├── android
│   │   ├── build.gradle
│   │   ├── settings.gradle
│   │   └── src
│   │       └── main
│   │           └── AndroidManifest.xml
│   └── windows
│       └── CMakeLists.txt
└── assets
    ├── imgs
    │   └── zilpay.svg
    ├── icons
    │   ├── search.svg
    │   ├── right_circle_arrow.svg
    │   ├── face_id.svg
    │   ├── close_eye.svg
    │   ├── disconnect.svg
    │   ├── logout.svg
    │   ├── usb.svg
    │   ├── bincode.svg
    │   ├── puzzle.svg
    │   ├── right_arrow.svg
    │   ├── x.svg
    │   ├── lock.svg
    │   ├── key.svg
    │   ├── qrcode.svg
    │   ├── shield.svg
    │   ├── nav.svg
    │   ├── pin.svg
    │   ├── import.svg
    │   ├── server.svg
    │   ├── ok.svg
    │   ├── biometric.svg
    │   ├── book.svg
    │   ├── wallet.svg
    │   ├── bell.svg
    │   ├── chevron_right.svg
    │   ├── telegram.svg
    │   ├── hash.svg
    │   ├── plus.svg
    │   ├── receive.svg
    │   ├── document.svg
    │   ├── check.svg
    │   ├── warning.svg
    │   ├── buy.svg
    │   ├── flask.svg
    │   ├── down_arrow.svg
    │   ├── info.svg
    │   ├── add.svg
    │   ├── gear.svg
    │   ├── close.svg
    │   ├── ledger.svg
    │   ├── copy.svg
    │   ├── reload.svg
    │   ├── scilla.svg
    │   ├── back.svg
    │   ├── appearance.svg
    │   ├── sell.svg
    │   ├── send.svg
    │   ├── zil.svg
    │   ├── edit.svg
    │   ├── looking.svg
    │   ├── ble.svg
    │   ├── language.svg
    │   ├── currency.svg
    │   ├── ipfs.svg
    │   ├── share.svg
    │   ├── globe.svg
    │   ├── atom.svg
    │   ├── backspace.svg
    │   ├── open_eye.svg
    │   ├── graph.svg
    │   ├── history.svg
    │   ├── fingerprint.svg
    │   ├── minus.svg
    │   ├── gas.svg
    │   ├── documents.svg
    │   ├── swap.svg
    │   └── manage.svg
    └── chains
        ├── testnet-chains.json
        └── mainnet-chains.json

```

`/Users/rinat/projects/zilpay/zilpay-mobile/test_driver/integration_test.dart`:

```dart
import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();

```

`/Users/rinat/projects/zilpay/zilpay-mobile/integration_test/simple_test.dart`:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:zilpay/src/rust/frb_generated.dart';
import 'package:integration_test/integration_test.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  setUpAll(() async => await RustLib.init());
  testWidgets('Can call rust function', (WidgetTester tester) async {});
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/test/bridge_test.dart`:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:zilpay/main.dart';
import 'package:zilpay/src/rust/frb_generated.dart';
import 'package:integration_test/integration_test.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  setUpAll(() async => await RustLib.init());
  testWidgets('Can call rust function', (WidgetTester tester) async {
    print('Attempting to load library from');
    await tester.pumpWidget(const MyApp());
    expect(find.textContaining('Result: `Hello, Tom!`'), findsOneWidget);
  });
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/test/widget_test.dart`:

```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

void main() {
  // testWidgets('Counter increments smoke test', (WidgetTester tester) async {
  //   // Build our app and trigger a frame.
  //   await tester.pumpWidget(const MyApp());
  //
  //   // Verify that our counter starts at 0.
  //   expect(find.text('0'), findsOneWidget);
  //   expect(find.text('1'), findsNothing);
  //
  //   // Tap the '+' icon and trigger a frame.
  //   await tester.tap(find.byIcon(Icons.add));
  //   await tester.pump();
  //
  //   // Verify that our counter has incremented.
  //   expect(find.text('0'), findsNothing);
  //   expect(find.text('1'), findsOneWidget);
  // });
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/Cargo.toml`:

```toml
[package]
name = "rust_lib_zilpay"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "staticlib"]

[dependencies]
flutter_rust_bridge = "=2.6.0"
once_cell = "1.19.0"
lazy_static = "1.5.0"
thiserror = "1.0.63"
hex = "0.4.3"
tokio = { version = "1", features = ["full"] }
zilpay_core = { path = "/Users/rinat/projects/zilpay/zilpay-core" }

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/lib.rs`:

```rs
mod frb_generated;

pub mod api;
pub mod models;
pub mod service;
pub mod utils;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/utils/mod.rs`:

```rs
pub mod errors;
pub mod utils;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/utils/errors.rs`:

```rs
use thiserror::Error;
pub use zilpay::errors::{
    address::AddressError, background::BackgroundError, cache::CacheError, network::NetworkErrors,
    settings::SettingsErrors, token::TokenError, tx::TransactionErrors, wallet::WalletErrors,
};

#[derive(Debug, Error)]
pub enum ServiceError {
    #[error("Service is not running")]
    NotRunning,

    #[error("Parse {0} error: {1}")]
    ParseError(String, String),

    #[error("Failed to acquire lock")]
    MutexLock,

    #[error("Cannot get mutable reference to core")]
    CoreAccess,

    #[error("background Error: {0}")]
    BackgroundError(BackgroundError),

    #[error("Wallet error at index: {0}: {1}")]
    WalletError(usize, WalletErrors),

    #[error("Account error at index: {0}, wallet index at {1}: {2}")]
    AccountError(usize, usize, WalletErrors),

    #[error("address error: {0}")]
    AddressError(AddressError),

    #[error("settings error: {0}")]
    SettingsError(SettingsErrors),

    #[error("Transaction error: {0}")]
    TransactionErrors(TransactionErrors),

    #[error("Failed to access wallet at index {0}")]
    WalletAccess(usize),

    #[error("Failed to access account at index {0} and wallet index at {1}")]
    AccountAccess(usize, usize),

    #[error("not valid account type!")]
    AccountTypeNotValid,

    #[error("Failed to decode session")]
    DecodeSession,

    #[error("Failed to save wallet")]
    FailToSaveWallet,

    #[error("Failed to decode secret key")]
    DecodeSecretKey,

    #[error("Invalid secret key length")]
    InvalidSecretKeyLength,

    #[error("Failed to decode public key")]
    DecodePublicKey,

    #[error("Invalid public key length")]
    InvalidPublicKeyLength,

    #[error("Settings Error: {0}")]
    SettingsErrors(SettingsErrors),

    #[error("Token Error: {0}")]
    TokenError(TokenError),

    #[error("Network Error: {0}")]
    NetworkErrors(NetworkErrors),

    #[error("Cache Error: {0}")]
    CacheError(CacheError),
}

impl From<BackgroundError> for ServiceError {
    fn from(error: BackgroundError) -> Self {
        ServiceError::BackgroundError(error)
    }
}

impl From<AddressError> for ServiceError {
    fn from(error: AddressError) -> Self {
        ServiceError::AddressError(error)
    }
}

impl From<CacheError> for ServiceError {
    fn from(error: CacheError) -> Self {
        ServiceError::CacheError(error)
    }
}

impl From<NetworkErrors> for ServiceError {
    fn from(error: NetworkErrors) -> Self {
        ServiceError::NetworkErrors(error)
    }
}

impl From<TransactionErrors> for ServiceError {
    fn from(error: TransactionErrors) -> Self {
        ServiceError::TransactionErrors(error)
    }
}

impl From<SettingsErrors> for ServiceError {
    fn from(error: SettingsErrors) -> Self {
        ServiceError::SettingsErrors(error)
    }
}

impl From<TokenError> for ServiceError {
    fn from(error: TokenError) -> Self {
        ServiceError::TokenError(error)
    }
}

impl From<hex::FromHexError> for ServiceError {
    fn from(_: hex::FromHexError) -> Self {
        ServiceError::DecodeSecretKey
    }
}

impl From<ServiceError> for String {
    fn from(error: ServiceError) -> String {
        error.to_string()
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/utils/utils.rs`:

```rs
use std::sync::Arc;
use zilpay::crypto::slip44;
pub use zilpay::{
    background::Background,
    config::key::{PUB_KEY_SIZE, SECRET_KEY_SIZE},
    proto::{address::Address, pubkey::PubKey, secret_key::SecretKey},
    wallet::{wallet_data::WalletData, Wallet, WalletAddrType},
};
pub use zilpay::{
    background::{bg_provider::ProvidersManagement, bg_wallet::WalletManagement},
    crypto::bip49::DerivationPath,
    errors::{background::BackgroundError, wallet::WalletErrors},
};

use crate::{
    models::{background::BackgroundState, wallet::WalletInfo},
    service::service::BACKGROUND_SERVICE,
};

use super::errors::ServiceError;

pub fn parse_address(addr: String) -> Result<Address, ServiceError> {
    if addr.starts_with("0x") {
        Address::from_eth_address(&addr).map_err(ServiceError::AddressError)
    } else {
        Address::from_zil_bech32(&addr)
            .or_else(|_| Address::from_eth_address(&addr))
            .map_err(ServiceError::AddressError)
    }
}

pub fn decode_session(session_cipher: Option<String>) -> Result<Vec<u8>, ServiceError> {
    hex::decode(session_cipher.unwrap_or_default()).map_err(|_| ServiceError::DecodeSession)
}

pub fn decode_secret_key(sk: &str) -> Result<[u8; SECRET_KEY_SIZE], ServiceError> {
    let sk = sk.strip_prefix("0x").unwrap_or(sk);
    hex::decode(sk)
        .map_err(|_| ServiceError::DecodeSecretKey)?
        .try_into()
        .map_err(|_| ServiceError::InvalidSecretKeyLength)
}

pub fn pubkey_from_provider(pub_key: &str, bip49: DerivationPath) -> Result<PubKey, ServiceError> {
    let pub_key_bytes = decode_public_key(pub_key)?;

    let pub_key = match bip49.slip44 {
        slip44::ZILLIQA => PubKey::Secp256k1Sha256Zilliqa(pub_key_bytes),
        slip44::ETHEREUM => PubKey::Secp256k1Keccak256Ethereum(pub_key_bytes),
        slip44::BITCOIN => PubKey::Secp256k1Bitcoin(pub_key_bytes),
        slip44::SOLANA => PubKey::Ed25519Solana(pub_key_bytes),
        _ => todo!(),
    };

    Ok(pub_key)
}

pub fn secretkey_from_provider(
    secret_key: &str,
    bip49: DerivationPath,
) -> Result<SecretKey, ServiceError> {
    let sk = secret_key.strip_prefix("0x").unwrap_or(secret_key);
    let secret_key_bytes = decode_secret_key(&sk)?;

    let sk = match bip49.slip44 {
        slip44::ZILLIQA => SecretKey::Secp256k1Sha256Zilliqa(secret_key_bytes),
        slip44::ETHEREUM => SecretKey::Secp256k1Keccak256Ethereum(secret_key_bytes),
        _ => todo!(),
    };

    Ok(sk)
}

pub fn decode_public_key(pub_key: &str) -> Result<[u8; PUB_KEY_SIZE], ServiceError> {
    let pub_key = pub_key.strip_prefix("0x").unwrap_or(pub_key);
    let pub_key_bytes: [u8; PUB_KEY_SIZE] = hex::decode(pub_key)
        .map_err(|_| ServiceError::DecodePublicKey)?
        .try_into()
        .map_err(|_| ServiceError::InvalidPublicKeyLength)?;

    Ok(pub_key_bytes)
}

pub fn get_background_state(service: &Background) -> Result<BackgroundState, ServiceError> {
    let wallets = service
        .wallets
        .iter()
        .map(|w| w.try_into())
        .collect::<Result<Vec<WalletInfo>, WalletErrors>>()
        .map_err(BackgroundError::WalletError)?;
    let providers = service.get_providers();

    let notifications_wallet_states = service
        .settings
        .notifications
        .wallet_states
        .iter()
        .map(|(k, v)| (*k, v.into()))
        .collect();

    Ok(BackgroundState {
        wallets,
        notifications_wallet_states,
        notifications_global_enabled: service.settings.notifications.global_enabled,
        locale: service.settings.locale.to_string(),
        appearances: service.settings.theme.appearances.code(),
        providers: providers.into_iter().map(|p| p.config.into()).collect(),
    })
}

pub fn get_last_wallet(service: &Background) -> Result<&Wallet, ServiceError> {
    service.wallets.last().ok_or(ServiceError::FailToSaveWallet)
}

pub async fn with_service<F, T>(f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&zilpay::background::Background) -> Result<T, ServiceError>,
{
    let guard = BACKGROUND_SERVICE.read().await;
    let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
    f(&service.core)
}

pub async fn with_service_mut<F, T>(f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&mut zilpay::background::Background) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;

        f(core)
    } else {
        Err(ServiceError::NotRunning)
    }
}

pub async fn with_wallet_mut<F, T>(wallet_index: usize, f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&mut Wallet) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;

        let wallet = core
            .wallets
            .get_mut(wallet_index)
            .ok_or(ServiceError::WalletAccess(wallet_index))?;

        f(wallet)
    } else {
        Err(ServiceError::NotRunning)
    }
}

pub async fn with_wallet<F, T>(wallet_index: usize, f: F) -> Result<T, ServiceError>
where
    F: FnOnce(&Wallet) -> Result<T, ServiceError>,
{
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);
        let wallet = core.get_wallet_by_index(wallet_index)?;

        f(wallet)
    } else {
        Err(ServiceError::NotRunning)
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/background.rs`:

```rs
use super::{
    notification::BackgroundNotificationState, provider::NetworkConfigInfo, wallet::WalletInfo,
};
use std::collections::HashMap;

pub struct BackgroundState {
    pub wallets: Vec<WalletInfo>,
    pub notifications_wallet_states: HashMap<usize, BackgroundNotificationState>,
    pub notifications_global_enabled: bool,
    pub locale: String,
    pub appearances: u8,
    pub providers: Vec<NetworkConfigInfo>,
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/qrcode.rs`:

```rs
pub use zilpay::qrcodes::gen::{DataModuleShape, EyeShape, QrConfig};
pub use zilpay::qrcodes::parse::QRcodeScanResult;

pub struct QRcodeScanResultInfo {
    pub recipient: String,
    pub provider: Option<String>,
    pub token_address: Option<String>,
    pub amount: Option<String>,
}

pub struct QrConfigInfo {
    pub size: u32,
    pub gapless: bool,
    pub color: u32,
    pub eye_shape: u8,
    pub data_module_shape: u8,
}

impl From<QrConfig> for QrConfigInfo {
    fn from(value: QrConfig) -> Self {
        Self {
            size: value.size,
            gapless: value.gapless,
            color: value.color,
            eye_shape: value.eye_shape.into(),
            data_module_shape: value.data_module_shape.into(),
        }
    }
}

impl From<QrConfigInfo> for QrConfig {
    fn from(value: QrConfigInfo) -> Self {
        Self {
            size: value.size,
            gapless: value.gapless,
            color: value.color,
            eye_shape: value.eye_shape.into(),
            data_module_shape: value.data_module_shape.into(),
        }
    }
}

impl From<QRcodeScanResult> for QRcodeScanResultInfo {
    fn from(value: QRcodeScanResult) -> Self {
        Self {
            recipient: value.recipient,
            provider: value.provider,
            token_address: value.token_address,
            amount: value.amount,
        }
    }
}

impl From<QRcodeScanResultInfo> for QRcodeScanResult {
    fn from(value: QRcodeScanResultInfo) -> Self {
        Self {
            recipient: value.recipient,
            provider: value.provider,
            token_address: value.token_address,
            amount: value.amount,
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/notification.rs`:

```rs
use zilpay::settings::notifications::NotificationState;

#[derive(Debug)]
pub struct BackgroundNotificationState {
    pub transactions: bool,
    pub price: bool,
    pub security: bool,
    pub balance: bool,
}

impl From<&NotificationState> for BackgroundNotificationState {
    fn from(notify: &NotificationState) -> Self {
        BackgroundNotificationState {
            transactions: notify.transactions,
            price: notify.price,
            security: notify.security,
            balance: notify.balance,
        }
    }
}

impl From<NotificationState> for BackgroundNotificationState {
    fn from(state: NotificationState) -> Self {
        BackgroundNotificationState {
            transactions: state.transactions,
            price: state.price,
            security: state.security,
            balance: state.balance,
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/ftoken.rs`:

```rs
use std::collections::HashMap;
use zilpay::{errors::token::TokenError, proto::address::Address, token::ft::FToken};

#[derive(Debug)]
pub struct FTokenInfo {
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub addr: String,
    pub logo: Option<String>,
    pub balances: HashMap<usize, String>,
    pub default: bool,
    pub native: bool,
    pub chain_hash: u64,
}

impl From<FToken> for FTokenInfo {
    fn from(ft: FToken) -> Self {
        let balances = ft
            .balances
            .iter()
            .map(|(account_index, balance)| (*account_index, balance.to_string()))
            .collect();

        FTokenInfo {
            balances,
            logo: ft.logo,
            addr: ft.addr.auto_format(),
            name: ft.name,
            symbol: ft.symbol,
            decimals: ft.decimals,
            default: ft.default,
            native: ft.native,
            chain_hash: ft.chain_hash,
        }
    }
}

impl TryFrom<FTokenInfo> for FToken {
    type Error = TokenError;

    fn try_from(value: FTokenInfo) -> Result<Self, Self::Error> {
        Ok(Self {
            name: value.name,
            symbol: value.symbol,
            decimals: value.decimals,
            addr: Address::from_str_hex(&value.addr).map_err(TokenError::InvalidContractAddress)?,
            logo: value.logo,
            balances: HashMap::new(),
            default: value.default,
            native: value.native,
            chain_hash: value.chain_hash,
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/gas.rs`:

```rs
pub use zilpay::network::gas_parse::Gas;
pub use zilpay::network::gas_parse::GasFeeHistory;

pub struct GasFeeHistoryInfo {
    pub max_fee: u128,
    pub priority_fee: u128,
    pub base_fee: u128,
}

impl From<GasFeeHistory> for GasFeeHistoryInfo {
    fn from(value: GasFeeHistory) -> Self {
        Self {
            max_fee: value.max_fee.try_into().unwrap_or_default(),
            priority_fee: value.priority_fee.try_into().unwrap_or_default(),
            base_fee: value.base_fee.try_into().unwrap_or_default(),
        }
    }
}

pub struct GasInfo {
    pub gas_price: u128,
    pub max_priority_fee: u128,
    pub fee_history: GasFeeHistoryInfo,
    pub tx_estimate_gas: u64,
    pub blob_base_fee: u128,
}

impl From<Gas> for GasInfo {
    fn from(value: Gas) -> Self {
        Self {
            gas_price: value.gas_price.try_into().unwrap_or_default(),
            max_priority_fee: value.max_priority_fee.try_into().unwrap_or_default(),
            fee_history: value.fee_history.into(),
            tx_estimate_gas: value.tx_estimate_gas.try_into().unwrap_or_default(),
            blob_base_fee: value.blob_base_fee.try_into().unwrap_or_default(),
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/provider.rs`:

```rs
use zilpay::proto::address::Address;
pub use zilpay::{
    errors::network::NetworkErrors,
    rpc::network_config::{ChainConfig, Explorer},
};

pub struct ExplorerInfo {
    pub name: String,
    pub url: String,
    pub icon: Option<String>,
    pub standard: u16,
}

pub struct NetworkConfigInfo {
    pub name: String,
    pub chain: String,
    pub short_name: String,
    pub rpc: Vec<String>,
    pub features: Vec<u16>,
    pub chain_id: u64,
    pub slip_44: u32,
    pub chain_hash: u64,
    pub ens: Option<String>,
    pub explorers: Vec<ExplorerInfo>,
    pub fallback_enabled: bool,
    pub testnet: Option<bool>,
}

impl From<ExplorerInfo> for Explorer {
    fn from(value: ExplorerInfo) -> Self {
        Explorer {
            name: value.name,
            url: value.url,
            icon: value.icon,
            standard: value.standard,
        }
    }
}

impl From<Explorer> for ExplorerInfo {
    fn from(value: Explorer) -> Self {
        Self {
            name: value.name,
            url: value.url,
            icon: value.icon,
            standard: value.standard,
        }
    }
}

impl From<ChainConfig> for NetworkConfigInfo {
    fn from(value: ChainConfig) -> Self {
        let chain_hash = value.hash();
        let explorers = value
            .explorers
            .into_iter()
            .map(ExplorerInfo::from)
            .collect();

        Self {
            testnet: value.testnet,
            chain_hash,
            name: value.name,
            chain: value.chain,
            short_name: value.short_name,
            rpc: value.rpc,
            features: value.features,
            chain_id: value.chain_id,
            slip_44: value.slip_44,
            ens: value.ens.map(|a| a.auto_format()),
            explorers,
            fallback_enabled: value.fallback_enabled,
        }
    }
}

impl From<NetworkConfigInfo> for ChainConfig {
    fn from(value: NetworkConfigInfo) -> Self {
        let explorers = value.explorers.into_iter().map(Explorer::from).collect();
        let ens = value.ens.and_then(|a| Address::from_str_hex(&a).ok());

        ChainConfig {
            testnet: value.testnet,
            name: value.name,
            chain: value.chain,
            short_name: value.short_name,
            rpc: value.rpc,
            features: value.features,
            chain_id: value.chain_id,
            slip_44: value.slip_44,
            ens,
            explorers,
            fallback_enabled: value.fallback_enabled,
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/mod.rs`:

```rs
pub mod account;
pub mod background;
pub mod book;
pub mod connection;
pub mod ftoken;
pub mod gas;
pub mod keypair;
pub mod notification;
pub mod provider;
pub mod qrcode;
pub mod settings;
pub mod transactions;
pub mod wallet;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/request.rs`:

```rs
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::evm::TransactionRequestEVM;
use super::scilla::TransactionRequestScilla;
use super::transaction_metadata::TransactionMetadataInfo;

pub struct TransactionRequestInfo {
    pub metadata: TransactionMetadataInfo,
    pub scilla: Option<TransactionRequestScilla>,
    pub evm: Option<TransactionRequestEVM>,
}

impl TryFrom<TransactionRequestInfo> for TransactionRequest {
    type Error = TransactionErrors;

    fn try_from(value: TransactionRequestInfo) -> Result<Self, Self::Error> {
        if let Some(scilla_tx) = value.scilla {
            let tx_req =
                TransactionRequest::Zilliqa((scilla_tx.try_into()?, value.metadata.into()));
            Ok(tx_req)
        } else if let Some(evm_tx) = value.evm {
            let tx_req = TransactionRequest::Ethereum((evm_tx.try_into()?, value.metadata.into()));
            Ok(tx_req)
        } else {
            Err(TransactionErrors::InvalidTxHash)
        }
    }
}

impl From<TransactionRequest> for TransactionRequestInfo {
    fn from(value: TransactionRequest) -> Self {
        let metadata: TransactionMetadataInfo = match value {
            TransactionRequest::Zilliqa((_, ref metadata)) => metadata.to_owned().into(),
            TransactionRequest::Ethereum((_, ref metadata)) => metadata.to_owned().into(),
        };

        match value {
            TransactionRequest::Zilliqa((tx, _)) => Self {
                metadata,
                scilla: Some(tx.into()),
                evm: None,
            },
            TransactionRequest::Ethereum((tx, _)) => Self {
                metadata,
                scilla: None,
                evm: Some(tx.into()),
            },
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/access_list.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

pub struct AccessListItem {
    pub address: String,
    pub storage_keys: Vec<String>,
}

impl From<AlloyAccessListItem> for AccessListItem {
    fn from(value: AlloyAccessListItem) -> Self {
        Self {
            address: value.address.to_string(),
            storage_keys: value
                .storage_keys
                .iter()
                .map(|k| hex::encode(k.0))
                .collect(),
        }
    }
}

impl TryFrom<AccessListItem> for AlloyAccessListItem {
    type Error = TransactionErrors;

    fn try_from(value: AccessListItem) -> Result<Self, Self::Error> {
        Ok(Self {
            address: AlloyAddress::from_str(&value.address).unwrap_or_default(),
            storage_keys: value
                .storage_keys
                .into_iter()
                .map(|key| {
                    let bytes = hex::decode(key).map_err(|_| TransactionErrors::InvalidHash)?;

                    if bytes.len() != SHA256_SIZE {
                        return Err(TransactionErrors::InvalidHash);
                    }

                    let mut array = [0u8; SHA256_SIZE];
                    array.copy_from_slice(&bytes);

                    Ok(array.into())
                })
                .collect::<Result<Vec<_>, _>>()?,
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/transaction_metadata.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::base_token::BaseTokenInfo;

pub struct TransactionMetadataInfo {
    pub chain_hash: u64,
    pub hash: Option<String>,
    pub info: Option<String>,
    pub icon: Option<String>,
    pub title: Option<String>,
    pub signer: Option<String>,
    pub token_info: Option<BaseTokenInfo>,
}

impl From<TransactionMetadata> for TransactionMetadataInfo {
    fn from(value: TransactionMetadata) -> Self {
        Self {
            chain_hash: value.chain_hash,
            hash: value.hash,
            info: value.info,
            icon: value.icon,
            title: value.title,
            signer: value.signer.map(|v| v.to_string()),
            token_info: value.token_info.map(|t| BaseTokenInfo {
                value: t.0.to_string(),
                decimals: t.1,
                symbol: t.2,
            }),
        }
    }
}

impl From<TransactionMetadataInfo> for TransactionMetadata {
    fn from(value: TransactionMetadataInfo) -> Self {
        Self {
            chain_hash: value.chain_hash,
            hash: value.hash,
            info: value.info,
            icon: value.icon,
            title: value.title,
            signer: value.signer.and_then(|v| PubKey::from_str(&v).ok()),
            token_info: value.token_info.map(|v| {
                (
                    U256::from_str(&v.value).unwrap_or_default(),
                    v.decimals,
                    v.symbol,
                )
            }),
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/evm.rs`:

```rs
use std::str::FromStr;

pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

use super::access_list::AccessListItem;

pub struct TransactionRequestEVM {
    pub nonce: Option<u64>,
    pub from: Option<String>,
    pub to: Option<String>,
    pub value: Option<String>,
    pub gas_limit: Option<u64>,
    pub data: Option<Vec<u8>>,
    pub max_fee_per_gas: Option<u128>,
    pub max_priority_fee_per_gas: Option<u128>,
    pub gas_price: Option<u128>,
    pub chain_id: Option<u64>,
    pub access_list: Option<Vec<AccessListItem>>,
    pub blob_versioned_hashes: Option<Vec<String>>,
    pub max_fee_per_blob_gas: Option<u128>,
}

impl From<ETHTransactionRequest> for TransactionRequestEVM {
    fn from(value: ETHTransactionRequest) -> Self {
        Self {
            nonce: value.nonce,
            from: value.from.map(|a| a.to_string()),
            to: value
                .to
                .and_then(|k| k.to().cloned())
                .map(|addr| addr.to_string()),
            value: value.value.map(|v| v.to_string()),
            gas_limit: value.gas,
            data: value.input.into_input().map(|b| b.into()),
            max_fee_per_gas: value.max_fee_per_gas,
            max_priority_fee_per_gas: value.max_priority_fee_per_gas,
            gas_price: value.gas_price,
            chain_id: value.chain_id,
            access_list: value
                .access_list
                .map(|list| list.iter().map(|item| item.clone().into()).collect()),
            blob_versioned_hashes: value
                .blob_versioned_hashes
                .map(|hashes| hashes.iter().map(|h| hex::encode(h.0)).collect()),
            max_fee_per_blob_gas: value.max_fee_per_blob_gas,
        }
    }
}

impl TryFrom<TransactionRequestEVM> for ETHTransactionRequest {
    type Error = TransactionErrors;

    fn try_from(value: TransactionRequestEVM) -> Result<Self, Self::Error> {
        Ok(Self {
            from: value
                .from
                .and_then(|addr| AlloyAddress::from_str(&addr).ok()),
            to: match value.to {
                Some(to) => Some(AlloyTxKind::Call(AlloyAddress::from_str(&to).map_err(
                    |_| TransactionErrors::AddressError(AddressError::InvalidETHAddress(to)),
                )?)),
                None => Some(AlloyTxKind::Create),
            },
            gas_price: value.gas_price,
            max_fee_per_gas: value.max_fee_per_gas,
            max_priority_fee_per_gas: value.max_priority_fee_per_gas,
            max_fee_per_blob_gas: value.max_fee_per_blob_gas,
            gas: value.gas_limit,
            value: value.value.and_then(|v| U256::from_str(&v).ok()),
            input: value.data.map(AlloyBytes::from).into(),
            nonce: value.nonce,
            chain_id: value.chain_id,
            access_list: value
                .access_list
                .map(|list| {
                    list.into_iter()
                        .map(|item| item.try_into())
                        .collect::<Result<Vec<AlloyAccessListItem>, _>>()
                })
                .transpose()?
                .map(|v| v.into()),
            blob_versioned_hashes: value
                .blob_versioned_hashes
                .map(|hashes| {
                    hashes
                        .into_iter()
                        .map(|hash| {
                            let bytes =
                                hex::decode(hash).map_err(|_| TransactionErrors::InvalidHash)?;
                            if bytes.len() != SHA256_SIZE {
                                return Err(TransactionErrors::InvalidHash);
                            }
                            let mut array = [0u8; SHA256_SIZE];
                            array.copy_from_slice(&bytes);
                            Ok(array.into())
                        })
                        .collect::<Result<Vec<_>, _>>()
                })
                .transpose()?,
            transaction_type: None,
            sidecar: None,
            authorization_list: None,
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/scilla.rs`:

```rs
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::address::AddressError;
pub use zilpay::proto::tx::{TransactionMetadata, TransactionRequest};
pub use zilpay::proto::U256;
pub use zilpay::proto::{address::Address, pubkey::PubKey};
pub use zilpay::proto::{
    AlloyAccessList, AlloyAccessListItem, AlloyAddress, AlloyBytes, AlloyTxKind,
};
pub use zilpay::{
    errors::tx::TransactionErrors,
    proto::{tx::ETHTransactionRequest, zil_tx::ZILTransactionRequest},
};

pub struct TransactionRequestScilla {
    pub chain_id: u16,
    pub nonce: u64,
    pub gas_price: u128,
    pub gas_limit: u64,
    pub to_addr: String,
    pub amount: u128,
    pub code: String,
    pub data: String,
}

impl From<ZILTransactionRequest> for TransactionRequestScilla {
    fn from(value: ZILTransactionRequest) -> Self {
        Self {
            chain_id: value.chain_id,
            nonce: value.nonce,
            gas_price: value.gas_price,
            gas_limit: value.gas_limit,
            to_addr: value.to_addr.auto_format(),
            amount: value.amount,
            code: String::from_utf8(value.code).unwrap_or_default(),
            data: String::from_utf8(value.data).unwrap_or_default(),
        }
    }
}

impl TryFrom<TransactionRequestScilla> for ZILTransactionRequest {
    type Error = AddressError;

    fn try_from(value: TransactionRequestScilla) -> Result<Self, Self::Error> {
        Ok(Self {
            chain_id: value.chain_id,
            nonce: value.nonce,
            gas_price: value.gas_price,
            gas_limit: value.gas_limit,
            to_addr: Address::from_str_hex(&value.to_addr)?,
            amount: value.amount,
            code: value.code.into_bytes(),
            data: value.data.into_bytes(),
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/mod.rs`:

```rs
pub mod access_list;
pub mod base_token;
pub mod evm;
pub mod history;
pub mod request;
pub mod scilla;
pub mod transaction_metadata;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/history.rs`:

```rs
use super::base_token::BaseTokenInfo;
use zilpay::history::status::TransactionStatus;
pub use zilpay::history::transaction::HistoricalTransaction;

pub enum TransactionStatusInfo {
    Pending,
    Confirmed,
    Rejected,
}

impl From<TransactionStatus> for TransactionStatusInfo {
    fn from(value: TransactionStatus) -> Self {
        match value {
            TransactionStatus::Pending => TransactionStatusInfo::Pending,
            TransactionStatus::Confirmed => TransactionStatusInfo::Confirmed,
            TransactionStatus::Rejected => TransactionStatusInfo::Rejected,
        }
    }
}

pub struct HistoricalTransactionInfo {
    pub id: String,
    pub amount: String,
    pub sender: String,
    pub recipient: String,
    pub teg: Option<String>,
    pub status: TransactionStatusInfo,
    pub confirmed: Option<u128>,
    pub timestamp: u64,
    pub fee: u128,
    pub icon: Option<String>,
    pub title: Option<String>,
    pub nonce: u64,
    pub token_info: Option<BaseTokenInfo>,
}

impl From<HistoricalTransaction> for HistoricalTransactionInfo {
    fn from(value: HistoricalTransaction) -> Self {
        Self {
            id: value.id,
            amount: value.amount.to_string(),
            sender: value.sender,
            recipient: value.recipient,
            teg: value.teg,
            status: value.status.into(),
            confirmed: value.confirmed,
            timestamp: value.timestamp,
            fee: value.fee,
            icon: value.icon,
            title: value.title,
            nonce: value.nonce,
            token_info: value.token_info.map(|v| v.into()),
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/transactions/base_token.rs`:

```rs
pub use zilpay::history::transaction::TokenInfo;

pub struct BaseTokenInfo {
    pub value: String,
    pub symbol: String,
    pub decimals: u8,
}

impl From<TokenInfo> for BaseTokenInfo {
    fn from(value: TokenInfo) -> Self {
        Self {
            value: value.value.to_string(),
            symbol: value.symbol,
            decimals: value.decimals,
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/wallet.rs`:

```rs
use super::{account::AccountInfo, ftoken::FTokenInfo, settings::WalletSettingsInfo};
pub use zilpay::wallet::Wallet;
use zilpay::{errors::wallet::WalletErrors, wallet::wallet_storage::StorageOperations};

#[derive(Debug)]
pub struct WalletInfo {
    pub wallet_type: String,
    pub wallet_name: String,
    pub auth_type: String,
    pub wallet_address: String,
    pub accounts: Vec<AccountInfo>,
    pub selected_account: usize,
    pub tokens: Vec<FTokenInfo>,
    pub settings: WalletSettingsInfo,
    pub default_chain_hash: u64,
}

impl TryFrom<&Wallet> for WalletInfo {
    type Error = WalletErrors;

    fn try_from(w: &Wallet) -> Result<Self, Self::Error> {
        let data = w.get_wallet_data()?;
        let ftokens = w.get_ftokens()?;

        Ok(Self {
            default_chain_hash: data.default_chain_hash,
            auth_type: data.biometric_type.into(),
            wallet_name: data.wallet_name,
            wallet_type: data.wallet_type.to_str(),
            wallet_address: hex::encode(w.wallet_address),
            accounts: data.accounts.iter().map(|v| v.into()).collect(),
            selected_account: data.selected_account,
            tokens: ftokens.into_iter().map(|v| v.into()).collect(),
            settings: data.settings.into(),
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/account.rs`:

```rs
use zilpay::wallet::account::Account;

#[derive(Debug)]
pub struct AccountInfo {
    pub addr: String,
    pub name: String,
    pub chain_hash: u64,
    pub index: usize,
}

impl From<&Account> for AccountInfo {
    fn from(account: &Account) -> Self {
        AccountInfo {
            addr: account.addr.auto_format(),
            name: account.name.clone(),
            chain_hash: account.chain_hash,
            index: account.account_type.value(),
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/book.rs`:

```rs
use zilpay::background::book::AddressBookEntry;

#[derive(Debug)]
pub struct AddressBookEntryInfo {
    pub name: String,
    pub addr: String,
    pub net: usize,
}

impl From<&AddressBookEntry> for AddressBookEntryInfo {
    fn from(book: &AddressBookEntry) -> Self {
        AddressBookEntryInfo {
            name: book.name.clone(),
            addr: book.addr.auto_format(),
            net: book.net,
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/settings.rs`:

```rs
pub use zilpay::cipher::options::CipherOrders;
pub use zilpay::config::sha::SHA256_SIZE;
pub use zilpay::errors::settings::SettingsErrors;
pub use zilpay::settings::argon2::ArgonParams;
pub use zilpay::settings::wallet_settings::WalletSettings;
use zilpay::{
    errors::cipher::CipherErrors,
    settings::wallet_settings::{NetworkSettings, WalletFeatures},
};

#[derive(Debug)]
pub struct WalletArgonParamsInfo {
    pub memory: u32,
    pub iterations: u32,
    pub threads: u32,
    pub secret: String,
}

impl From<ArgonParams> for WalletArgonParamsInfo {
    fn from(value: ArgonParams) -> Self {
        WalletArgonParamsInfo {
            memory: value.memory,
            iterations: value.iterations,
            threads: value.threads,
            secret: hex::encode(value.secret),
        }
    }
}

impl TryFrom<WalletArgonParamsInfo> for ArgonParams {
    type Error = SettingsErrors;

    fn try_from(value: WalletArgonParamsInfo) -> Result<Self, Self::Error> {
        let secret: [u8; SHA256_SIZE] = match hex::decode(&value.secret) {
            Ok(hex) => hex
                .try_into()
                .unwrap_or(ArgonParams::hash_secret(&value.secret)),
            Err(_) => ArgonParams::hash_secret(&value.secret),
        };

        Ok(Self {
            secret,
            memory: value.memory,
            iterations: value.iterations,
            threads: value.threads,
        })
    }
}

#[derive(Debug)]
pub struct WalletSettingsInfo {
    pub cipher_orders: Vec<u8>,
    pub argon_params: WalletArgonParamsInfo,
    pub currency_convert: Option<String>,
    pub ipfs_node: Option<String>,
    pub ens_enabled: bool,
    pub gas_control_enabled: bool,
    pub node_ranking_enabled: bool,
    pub max_connections: u8,
    pub request_timeout_secs: u32,
}

impl From<WalletSettings> for WalletSettingsInfo {
    fn from(value: WalletSettings) -> Self {
        WalletSettingsInfo {
            argon_params: value.argon_params.into(),
            cipher_orders: value.cipher_orders.iter().map(|v| v.code()).collect(),
            currency_convert: value.features.currency_convert,
            ipfs_node: value.features.ipfs_node,
            ens_enabled: value.features.ens_enabled,
            gas_control_enabled: value.network.gas_control_enabled,
            node_ranking_enabled: value.network.node_ranking_enabled,
            max_connections: value.network.max_connections,
            request_timeout_secs: value.network.request_timeout_secs,
        }
    }
}

impl TryFrom<WalletSettingsInfo> for WalletSettings {
    type Error = SettingsErrors;

    fn try_from(value: WalletSettingsInfo) -> Result<Self, Self::Error> {
        Ok(Self {
            cipher_orders: value
                .cipher_orders
                .iter()
                .map(|v| CipherOrders::from_code(*v))
                .collect::<Result<Vec<CipherOrders>, CipherErrors>>()?,
            argon_params: value.argon_params.try_into()?,
            features: WalletFeatures {
                currency_convert: value.currency_convert,
                ens_enabled: value.ens_enabled,
                ipfs_node: value.ipfs_node,
            },
            network: NetworkSettings {
                gas_control_enabled: value.gas_control_enabled,
                node_ranking_enabled: value.node_ranking_enabled,
                max_connections: value.max_connections,
                request_timeout_secs: value.request_timeout_secs,
            },
        })
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/connection.rs`:

```rs
pub use zilpay::background::connections::{Connection, ConnectionPermissions, DAppColors};

#[derive(Debug)]
pub struct ColorsInfo {
    pub primary: String,
    pub secondary: Option<String>,
    pub background: Option<String>,
    pub text: Option<String>,
}

impl From<DAppColors> for ColorsInfo {
    fn from(colors: DAppColors) -> Self {
        ColorsInfo {
            primary: colors.primary,
            secondary: colors.secondary,
            background: colors.background,
            text: colors.text,
        }
    }
}

impl From<ColorsInfo> for DAppColors {
    fn from(colors: ColorsInfo) -> Self {
        DAppColors {
            primary: colors.primary,
            secondary: colors.secondary,
            background: colors.background,
            text: colors.text,
        }
    }
}

#[derive(Debug)]
pub struct ConnectionInfo {
    // Base fields
    pub domain: String,
    pub wallet_indexes: Vec<usize>,
    pub favicon: Option<String>,
    pub title: String,
    pub description: Option<String>,
    // primary, secondary, background, text
    pub colors: Option<ColorsInfo>,

    pub last_connected: u64, // Unix timestamp

    // permissions
    pub can_read_accounts: bool,
    pub can_request_signatures: bool,
    pub can_suggest_tokens: bool,
    pub can_suggest_transactions: bool,
}

impl From<Connection> for ConnectionInfo {
    fn from(conn: Connection) -> Self {
        ConnectionInfo {
            colors: conn.colors.map(Into::into),
            domain: conn.domain,
            wallet_indexes: conn.wallet_indexes.into_iter().collect(),
            favicon: conn.favicon,
            title: conn.title,
            description: conn.description,
            last_connected: conn.last_connected,

            can_read_accounts: conn.permissions.can_read_accounts,
            can_request_signatures: conn.permissions.can_request_signatures,
            can_suggest_tokens: conn.permissions.can_suggest_tokens,
            can_suggest_transactions: conn.permissions.can_suggest_transactions,
        }
    }
}

impl From<ConnectionInfo> for Connection {
    fn from(conn_info: ConnectionInfo) -> Self {
        Connection {
            colors: conn_info.colors.map(Into::into),
            domain: conn_info.domain,
            wallet_indexes: conn_info.wallet_indexes.into_iter().collect(),
            favicon: conn_info.favicon,
            title: conn_info.title,
            description: conn_info.description,
            last_connected: conn_info.last_connected,
            permissions: ConnectionPermissions {
                can_read_accounts: conn_info.can_read_accounts,
                can_request_signatures: conn_info.can_request_signatures,
                can_suggest_tokens: conn_info.can_suggest_tokens,
                can_suggest_transactions: conn_info.can_suggest_transactions,
            },
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/models/keypair.rs`:

```rs
pub use zilpay::proto::keypair::KeyPair;

pub struct KeyPairInfo {
    pub sk: String,
    pub pk: String,
}

impl From<KeyPair> for KeyPairInfo {
    fn from(value: KeyPair) -> Self {
        match value {
            KeyPair::Secp256k1Sha256Zilliqa((pk, sk)) => Self {
                sk: hex::encode(sk),
                pk: hex::encode(pk),
            },
            KeyPair::Secp256k1Keccak256Ethereum((pk, sk)) => Self {
                sk: hex::encode(sk),
                pk: hex::encode(pk),
            },
        }
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/cache.rs`:

```rs
use std::path::PathBuf;

pub use zilpay::background::bg_book::AddressBookManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::cache::Cache;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_image_name(dir: String, url: String) -> Result<String, String> {
    let cache = Cache::new(PathBuf::from(dir)).map_err(|e| e.to_string())?;
    let image_name = cache
        .get_image_name(&url)
        .await
        .map_err(|e| e.to_string())?;

    Ok(image_name)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_image_bytes(dir: String, url: String) -> Result<(Vec<u8>, String), String> {
    let cache = Cache::new(PathBuf::from(dir)).map_err(|e| e.to_string())?;
    let image_bytes = cache
        .get_image_bytes(&url)
        .await
        .map_err(|e| e.to_string())?;

    Ok(image_bytes)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/ledger.rs`:

```rs
use zilpay::{
    background::bg_provider::ProvidersManagement, wallet::wallet_storage::StorageOperations,
};
pub use zilpay::{
    background::{bg_wallet::WalletManagement, BackgroundLedgerParams},
    settings::wallet_settings::WalletSettings,
    wallet::wallet_account::AccountManagement,
};
pub use zilpay::{errors::token::TokenError, token::ft::FToken};
pub use zilpay::{proto::pubkey::PubKey, wallet::LedgerParams};

use crate::{
    models::{ftoken::FTokenInfo, settings::WalletSettingsInfo},
    utils::{
        errors::ServiceError,
        utils::{decode_session, get_last_wallet, pubkey_from_provider, with_service_mut},
    },
};

pub struct LedgerParamsInput {
    pub pub_key: String,
    pub wallet_index: usize,
    pub wallet_name: String,
    pub ledger_id: String,
    pub account_name: String,
    pub biometric_type: String,
    pub identifiers: Vec<String>,
    pub chain_hash: u64,
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_ledger_wallet(
    params: LedgerParamsInput,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let provider = core.get_provider(params.chain_hash)?;
        let bip49 = provider.get_bip49(params.wallet_index);
        let pub_key = pubkey_from_provider(&params.pub_key, bip49)?;
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let identifiers = params.identifiers;
        let params = BackgroundLedgerParams {
            ftokens,
            chain_hash: params.chain_hash,
            pub_key,
            account_name: params.account_name,
            wallet_index: params.wallet_index,
            wallet_name: params.wallet_name,
            ledger_id: params.ledger_id.as_bytes().to_vec(),
            biometric_type: params.biometric_type.into(),
            wallet_settings: wallet_settings.try_into()?,
        };

        let session = core
            .add_ledger_wallet(params, WalletSettings::default(), &identifiers)
            .map_err(ServiceError::BackgroundError)?;
        let wallet = get_last_wallet(core)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_ledger_account(
    wallet_index: usize,
    account_index: usize,
    name: String,
    pub_key: String,
    identifiers: &[String],
    session_cipher: Option<String>,
) -> Result<(), String> {
    with_service_mut(|core| {
        let session = decode_session(session_cipher)?;

        core.unlock_wallet_with_session(session, identifiers, wallet_index)?;

        let wallet = core.get_wallet_by_index(wallet_index)?;
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let first_account = data
            .accounts
            .first()
            .ok_or(ServiceError::AccountAccess(0, wallet_index))?;

        let provider = core.get_provider(first_account.chain_hash)?;
        let bip49 = provider.get_bip49(wallet_index);
        let pub_key = pubkey_from_provider(&pub_key, bip49)?;

        wallet
            .add_ledger_account(name, pub_key, account_index, first_account.chain_hash)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/qrcode.rs`:

```rs
use crate::models::qrcode::{QRcodeScanResultInfo, QrConfigInfo};
use zilpay::qrcodes::gen::generate_qr_png;
pub use zilpay::qrcodes::gen::generate_qr_svg;
pub use zilpay::qrcodes::parse::QRcodeScanResult;

#[flutter_rust_bridge::frb(dart_async)]
pub fn gen_svg_qrcode(data: String, config: QrConfigInfo) -> Result<String, String> {
    generate_qr_svg(&data, config.into()).map_err(|e| e.to_string())
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn gen_png_qrcode(data: String, config: QrConfigInfo) -> Result<Vec<u8>, String> {
    generate_qr_png(&data, config.into()).map_err(|e| e.to_string())
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn parse_qrcode_str(data: String) -> Result<QRcodeScanResultInfo, String> {
    let params = data
        .parse::<QRcodeScanResult>()
        .map_err(|e| e.to_string())?;

    Ok(params.into())
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/transaction.rs`:

```rs
use crate::models::gas::GasInfo;
use crate::models::transactions::history::HistoricalTransactionInfo;
use crate::models::transactions::request::TransactionRequestInfo;
use crate::service::service::BACKGROUND_SERVICE;
use crate::utils::errors::ServiceError;
use crate::utils::utils::{parse_address, with_service};

pub use zilpay::background::bg_provider::ProvidersManagement;
pub use zilpay::background::bg_wallet::WalletManagement;
pub use zilpay::background::{bg_rates::RatesManagement, bg_token::TokensManagement};
pub use zilpay::errors::background::BackgroundError;
pub use zilpay::errors::wallet::WalletErrors;
pub use zilpay::proto::address::Address;
pub use zilpay::proto::tx::TransactionRequest;
pub use zilpay::proto::U256;
pub use zilpay::wallet::wallet_storage::StorageOperations;
pub use zilpay::wallet::wallet_transaction::WalletTransaction;

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_requested_transactions(
    wallet_index: usize,
) -> Result<Vec<TransactionRequestInfo>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let request_txns = wallet
            .get_request_txns()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let tx_list: Vec<TransactionRequestInfo> =
            request_txns.iter().map(|tx| tx.clone().into()).collect();

        Ok(tx_list)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn clear_requested_transactions(wallet_index: usize) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;

        wallet
            .clear_request_transaction()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_requested_transactions(
    wallet_index: usize,
    tx: TransactionRequestInfo,
) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let tx = tx.try_into()?;

        wallet
            .add_request_transaction(tx)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_history(wallet_index: usize) -> Result<Vec<HistoricalTransactionInfo>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let history = wallet
            .get_history()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        let history: Vec<HistoricalTransactionInfo> =
            history.iter().map(|tx| tx.clone().into()).collect();

        Ok(history)
    })
    .await
    .map_err(Into::into)
}

pub struct TokenTransferParamsInfo {
    pub wallet_index: usize,
    pub account_index: usize,
    pub token_index: usize,
    pub amount: String,
    pub recipient: String,
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn create_token_transfer(
    params: TokenTransferParamsInfo,
) -> Result<TransactionRequestInfo, String> {
    with_service(|core| {
        let recipient = parse_address(params.recipient)?;
        let amount = U256::from_str_radix(&params.amount, 10)
            .map_err(|e| ServiceError::ParseError("amount".to_string(), e.to_string()))?;

        let wallet = core.get_wallet_by_index(params.wallet_index)?;
        let data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;
        let tokens = wallet
            .get_ftokens()
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;
        let token = tokens
            .get(params.token_index)
            .ok_or(WalletErrors::TokenNotExists(params.token_index))
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))?;

        let sender_account =
            data.accounts
                .get(params.account_index)
                .ok_or(ServiceError::AccountError(
                    params.account_index,
                    params.wallet_index,
                    zilpay::errors::wallet::WalletErrors::InvalidAccountIndex(params.account_index),
                ))?;

        let tx = core.build_token_transfer(
            token,
            sender_account.addr.clone(), //TODO: shit copy bytes.
            recipient,
            amount,
            sender_account.chain_hash,
        )?;

        Ok(tx.into())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn cacl_gas_fee(params: TransactionRequestInfo) -> Result<GasInfo, String> {
    let chain_hash = params.metadata.chain_hash;
    let gas = {
        let guard = BACKGROUND_SERVICE.read().await;
        let service = guard.as_ref().ok_or(ServiceError::NotRunning)?;
        let chain = service
            .core
            .get_provider(chain_hash)
            .map_err(ServiceError::BackgroundError)?;
        let tx: TransactionRequest = params.try_into().map_err(ServiceError::TransactionErrors)?;

        chain
            .estimate_gas_batch(&tx, 4, None)
            .await
            .map_err(ServiceError::NetworkErrors)?
    };

    Ok(gas.into())
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/connections.rs`:

```rs
use crate::{
    models::connection::ConnectionInfo,
    utils::{
        errors::ServiceError,
        utils::{with_service, with_service_mut},
    },
};
pub use zilpay::background::bg_connections::ConnectionManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn create_new_connection(conn: ConnectionInfo) -> Result<(), String> {
    with_service_mut(|core| {
        core.add_connection(conn.into())
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_wallet_to_connection(domain: String, wallet_index: usize) -> Result<(), String> {
    with_service_mut(|core| {
        core.add_wallet_to_connection(domain, wallet_index)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_connections_list() -> Result<Vec<ConnectionInfo>, String> {
    with_service(|core| Ok(core.get_connections().into_iter().map(Into::into).collect()))
        .await
        .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/token.rs`:

```rs
use crate::{
    models::ftoken::FTokenInfo,
    service::service::BACKGROUND_SERVICE,
    utils::{
        errors::ServiceError,
        utils::{parse_address, with_service},
    },
};
use std::sync::Arc;
pub use zilpay::background::{bg_rates::RatesManagement, bg_token::TokensManagement};
pub use zilpay::proto::address::Address;
use zilpay::{
    background::bg_wallet::WalletManagement,
    token::ft::FToken,
    wallet::{wallet_storage::StorageOperations, wallet_token::TokenManagement},
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn sync_balances(wallet_index: usize) -> Result<(), String> {
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;

        core.sync_ftokens_balances(wallet_index)
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn update_rates() -> Result<(), String> {
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);

        core.update_rates()
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_rates() -> Result<String, String> {
    if let Some(service) = BACKGROUND_SERVICE.write().await.as_mut() {
        let core = Arc::get_mut(&mut service.core).ok_or(ServiceError::CoreAccess)?;
        let value = core.get_rates();

        Ok(value.to_string())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn fetch_token_meta(addr: String, wallet_index: usize) -> Result<FTokenInfo, String> {
    if let Some(service) = BACKGROUND_SERVICE.read().await.as_ref() {
        let core = Arc::clone(&service.core);
        let address = parse_address(addr)?;

        let token_meta = core
            .fetch_ftoken_meta(wallet_index, address)
            .await
            .map_err(ServiceError::BackgroundError)?;

        Ok(token_meta.into())
    } else {
        Err(ServiceError::NotRunning.to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_ftoken(meta: FTokenInfo, wallet_index: usize) -> Result<Vec<FTokenInfo>, String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let token: FToken = meta.try_into()?;

        wallet
            .add_ftoken(token)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        let ftokens = wallet
            .get_ftokens()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?
            .into_iter()
            .map(|t| t.into())
            .collect();

        Ok(ftokens)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn rm_ftoken(wallet_index: usize, token_index: usize) -> Result<(), String> {
    with_service(|core| {
        let wallet = core.get_wallet_by_index(wallet_index)?;

        wallet
            .remove_ftoken(token_index)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/backend.rs`:

```rs
pub use zilpay::{
    background::{Background, BackgroundBip39Params, BackgroundSKParams},
    config::key::{PUB_KEY_SIZE, SECRET_KEY_SIZE},
    proto::{address::Address, pubkey::PubKey, secret_key::SecretKey},
    settings::{
        notifications::NotificationState,
        theme::{Appearances, Theme},
    },
    wallet::LedgerParams,
};

use crate::{
    frb_generated::StreamSink,
    models::background::BackgroundState,
    service::service::{ServiceBackground, BACKGROUND_SERVICE},
    utils::utils::{get_background_state, with_service},
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn start_service(path: &str) -> Result<BackgroundState, String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    if guard.is_none() {
        let bg = ServiceBackground::from_path(path)?;
        let state = get_background_state(&bg.core)?;
        *guard = Some(bg);
        Ok(state)
    } else {
        Err("service already running".to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn stop_service() -> Result<(), String> {
    let mut guard = BACKGROUND_SERVICE.write().await;
    if let Some(background) = guard.as_mut() {
        background.stop();
        *guard = None;
        Ok(())
    } else {
        Err("Service is not running".to_string())
    }
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn is_service_running() -> bool {
    BACKGROUND_SERVICE.read().await.is_some()
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn start_worker(_sink: StreamSink<String>) -> Result<(), String> {
    let service = BACKGROUND_SERVICE.read().await;
    if service.is_some() {
        return Err("Service is already running".to_string());
    }
    Ok(())
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_data() -> Result<BackgroundState, String> {
    with_service(get_background_state).await.map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/methods.rs`:

```rs
use crate::{models::keypair::KeyPairInfo, utils::utils::decode_secret_key};
pub use zilpay::background::{bg_crypto::CryptoOperations, Background, Language};
use zilpay::proto::{address::Address, keypair::KeyPair};

#[flutter_rust_bridge::frb(dart_async)]
pub fn gen_bip39_words(count: u8) -> Result<String, String> {
    Background::gen_bip39(count).map_err(|e| e.to_string())
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn check_not_exists_bip39_words(words: Vec<String>, _lang: String) -> Vec<usize> {
    // TODO: add more lang for bip39.
    Background::find_invalid_bip39_words(&words, Language::English)
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn gen_keypair() -> Result<KeyPairInfo, String> {
    let (sk, pk) = Background::gen_keypair().map_err(|e| e.to_string())?;

    Ok(KeyPairInfo { sk, pk })
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn keypair_from_sk(sk: String) -> Result<KeyPairInfo, String> {
    let sk = decode_secret_key(&sk)?;
    let (pk, sk) = KeyPair::from_sk_bytes(sk).map_err(|e| e.to_string())?;

    Ok(KeyPairInfo {
        sk: hex::encode(sk),
        pk: hex::encode(pk),
    })
}

#[flutter_rust_bridge::frb(dart_async)]
pub fn is_crypto_address(addr: String) -> bool {
    let is_zil_bech32 = Address::from_zil_bech32(&addr).is_ok();
    let is_eth_checksum = Address::from_eth_address(&addr).is_ok();
    let is_zil_base16 = Address::from_zil_base16(&addr).is_ok();

    is_zil_bech32 || is_eth_checksum || is_zil_base16
}

#[flutter_rust_bridge::frb(init)]
pub fn init_app() {
    // Default utilities - feel free to customize
    flutter_rust_bridge::setup_default_user_utils();
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/provider.rs`:

```rs
use crate::{models::provider::NetworkConfigInfo, utils::utils::with_service};
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};
use zilpay::{
    background::bg_provider::ProvidersManagement, errors::background::BackgroundError,
    network::provider::NetworkProvider,
};
pub use zilpay::{
    background::bg_settings::SettingsManagement, wallet::wallet_storage::StorageOperations,
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_providers() -> Result<Vec<NetworkConfigInfo>, String> {
    with_service(|core| {
        let providers = core.get_providers();

        Ok(providers
            .into_iter()
            .map(|p| p.config.into())
            .collect::<Vec<NetworkConfigInfo>>())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_provider(chain_hash: u64) -> Result<NetworkConfigInfo, String> {
    with_service(|core| {
        let provider = core.get_provider(chain_hash)?;

        Ok(provider.config.into())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_provider(provider_config: NetworkConfigInfo) -> Result<u64, String> {
    with_service(|core| {
        let config = provider_config.into();
        let hash = core.add_provider(config)?;

        Ok(hash)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_providers_list(provider_config: Vec<NetworkConfigInfo>) -> Result<(), String> {
    with_service(|core| {
        let mut providers = core.get_providers();

        for new_provider in &provider_config {
            if providers
                .iter()
                .any(|existing| existing.config.chain_id == new_provider.chain_id)
            {
                return Err(BackgroundError::ProviderAlreadyExists(
                    new_provider.chain_id,
                ))?;
            }
        }

        for new_conf in provider_config {
            let new_provider = NetworkProvider::new(new_conf.into());

            providers.push(new_provider);
        }

        core.update_providers(providers)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/auth.rs`:

```rs
use crate::utils::utils::{decode_session, with_service_mut};
pub use zilpay::background::bg_wallet::WalletManagement;

#[flutter_rust_bridge::frb(dart_async)]
pub async fn try_unlock_with_session(
    session_cipher: String,
    wallet_index: usize,
    identifiers: Vec<String>,
) -> Result<bool, String> {
    let session = decode_session(Some(session_cipher))?;
    with_service_mut(|core| {
        core.unlock_wallet_with_session(session, &identifiers, wallet_index)?;

        Ok(true)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn try_unlock_with_password(
    password: String,
    wallet_index: usize,
    identifiers: Vec<String>,
) -> Result<bool, String> {
    with_service_mut(|core| {
        core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;

        Ok(true)
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/mod.rs`:

```rs
pub mod auth;
pub mod backend;
pub mod book;
pub mod cache;
pub mod connections;
pub mod ledger;
pub mod methods;
pub mod provider;
pub mod qrcode;
pub mod settings;
pub mod token;
pub mod transaction;
pub mod wallet;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/wallet.rs`:

```rs
use zilpay::background::bg_provider::ProvidersManagement;
use zilpay::background::Background;
use zilpay::errors::background::BackgroundError;
use zilpay::errors::token::TokenError;
use zilpay::errors::wallet::WalletErrors;
use zilpay::token::ft::FToken;
use zilpay::wallet::wallet_crypto::WalletCrypto;
use zilpay::wallet::wallet_storage::StorageOperations;
pub use zilpay::{
    background::bg_wallet::WalletManagement, wallet::wallet_account::AccountManagement,
};
pub use zilpay::{
    background::{BackgroundBip39Params, BackgroundSKParams},
    crypto::bip49::DerivationPath,
    proto::{pubkey::PubKey, secret_key::SecretKey},
};

use crate::models::ftoken::FTokenInfo;
use crate::models::keypair::KeyPairInfo;
use crate::models::settings::WalletSettingsInfo;
use crate::utils::utils::{secretkey_from_provider, with_wallet};
use crate::{
    models::wallet::WalletInfo,
    utils::{
        errors::ServiceError,
        utils::{decode_session, with_service, with_service_mut},
    },
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_wallets() -> Result<Vec<WalletInfo>, String> {
    with_service(|core| {
        let wallets = core
            .wallets
            .iter()
            .map(|w| w.try_into())
            .collect::<Result<Vec<WalletInfo>, WalletErrors>>()
            .map_err(BackgroundError::WalletError)?;

        Ok(wallets)
    })
    .await
    .map_err(Into::into)
}

pub struct Bip39AddWalletParams {
    pub password: String,
    pub mnemonic_str: String,
    pub accounts: Vec<(usize, String)>,
    pub passphrase: String,
    pub wallet_name: String,
    pub biometric_type: String,
    pub chain_hash: u64,
    pub identifiers: Vec<String>,
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_bip39_wallet(
    params: Bip39AddWalletParams,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let core_ref: &Background = &*core;
        let provider = core_ref.get_provider(params.chain_hash)?;
        let accounts_bip49 = params
            .accounts
            .into_iter()
            .map(|(i, name)| (provider.get_bip49(i), name))
            .collect::<Vec<(DerivationPath, String)>>();
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let session = core
            .add_bip39_wallet(BackgroundBip39Params {
                ftokens,
                wallet_settings: wallet_settings.try_into()?,
                chain_hash: params.chain_hash,
                password: &params.password,
                mnemonic_str: &params.mnemonic_str,
                accounts: &accounts_bip49,
                passphrase: &params.passphrase,
                wallet_name: params.wallet_name,
                biometric_type: params.biometric_type.into(),
                device_indicators: &params.identifiers,
            })
            .map_err(ServiceError::BackgroundError)?;
        let wallet = core.wallets.last().ok_or(ServiceError::FailToSaveWallet)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

pub struct AddSKWalletParams {
    pub sk: String,
    pub password: String,
    pub wallet_name: String,
    pub biometric_type: String,
    pub identifiers: Vec<String>,
    pub chain_hash: u64,
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_sk_wallet(
    params: AddSKWalletParams,
    wallet_settings: WalletSettingsInfo,
    ftokens: Vec<FTokenInfo>,
) -> Result<(String, String), String> {
    with_service_mut(|core| {
        let ftokens = ftokens
            .into_iter()
            .map(TryFrom::try_from)
            .collect::<Result<Vec<FToken>, TokenError>>()?;
        let provider = core.get_provider(params.chain_hash)?;
        let bip49 = provider.get_bip49(0);
        let secret_key = secretkey_from_provider(&params.sk, bip49)?;
        let session = core.add_sk_wallet(BackgroundSKParams {
            ftokens,
            chain_hash: params.chain_hash,
            secret_key,
            wallet_name: params.wallet_name,
            biometric_type: params.biometric_type.into(),
            password: &params.password,
            device_indicators: &params.identifiers,
            wallet_settings: wallet_settings.try_into()?,
        })?;
        let wallet = core.wallets.last().ok_or(ServiceError::FailToSaveWallet)?;

        Ok((hex::encode(session), hex::encode(wallet.wallet_address)))
    })
    .await
    .map_err(Into::into)
}

pub struct AddNextBip39AccountParams {
    pub wallet_index: usize,
    pub account_index: usize,
    pub name: String,
    pub passphrase: String,
    pub identifiers: Vec<String>,
    pub password: Option<String>,
    pub session_cipher: Option<String>,
    pub chain_hash: u64,
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_next_bip39_account(params: AddNextBip39AccountParams) -> Result<(), String> {
    with_service_mut(|core| {
        let seed = if let Some(pass) = params.password {
            core.unlock_wallet_with_password(&pass, &params.identifiers, params.wallet_index)
        } else {
            let session = decode_session(params.session_cipher)?;
            core.unlock_wallet_with_session(session, &params.identifiers, params.wallet_index)
        }?;

        let wallet = core.get_wallet_by_index(params.wallet_index)?;
        let provider = core.get_provider(params.chain_hash)?;
        let bip49 = provider.get_bip49(params.account_index);

        wallet
            .add_next_bip39_account(
                params.name,
                &bip49,
                &params.passphrase,
                &seed,
                params.chain_hash,
            )
            .map_err(|e| ServiceError::WalletError(params.wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn select_account(wallet_index: usize, account_index: usize) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        wallet
            .select_account(account_index)
            .map_err(|e| ServiceError::AccountError(account_index, wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn change_account_name(
    wallet_index: usize,
    account_index: usize,
    new_name: String,
) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;
        let acc = data
            .accounts
            .get_mut(account_index)
            .ok_or(ServiceError::AccountError(
                account_index,
                wallet_index,
                WalletErrors::InvalidAccountIndex(account_index),
            ))?;

        acc.name = new_name;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn change_wallet_name(wallet_index: usize, new_name: String) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.wallet_name = new_name;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn delete_wallet(
    wallet_index: usize,
    identifiers: Vec<String>,
    password: Option<String>,
    session_cipher: Option<String>,
) -> Result<(), String> {
    with_service_mut(|core| {
        if let Some(pass) = password {
            core.unlock_wallet_with_password(&pass, &identifiers, wallet_index)
        } else {
            let session = decode_session(session_cipher)?;
            core.unlock_wallet_with_session(session, &identifiers, wallet_index)
        }?;

        core.delete_wallet(wallet_index)?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn delete_account(wallet_index: usize, account_index: usize) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        wallet
            .delete_account(account_index)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(())
    })
    .await
    .map_err(Into::into)
}
#[flutter_rust_bridge::frb(dart_async)]
pub async fn reveal_keypair(
    wallet_index: usize,
    account_index: usize,
    identifiers: Vec<String>,
    password: String,
    passphrase: Option<String>,
) -> Result<KeyPairInfo, String> {
    with_service_mut(|core| {
        let seed = core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let keypair = wallet
            .reveal_keypair(account_index, &seed, passphrase.as_deref())
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(keypair.into())
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn reveal_bip39_phrase(
    wallet_index: usize,
    identifiers: Vec<String>,
    password: String,
    _passphrase: Option<String>,
) -> Result<String, String> {
    with_service_mut(|core| {
        let seed = core.unlock_wallet_with_password(&password, &identifiers, wallet_index)?;
        let wallet = core.get_wallet_by_index(wallet_index)?;
        let m = wallet
            .reveal_mnemonic(&seed)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        Ok(m.to_string())
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/book.rs`:

```rs
use crate::{
    models::book::AddressBookEntryInfo,
    utils::{
        errors::ServiceError,
        utils::{parse_address, with_service, with_service_mut},
    },
};
pub use zilpay::background::bg_book::AddressBookManagement;
pub use zilpay::background::book::AddressBookEntry;
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn add_new_book_address(name: String, addr: String, net: usize) -> Result<(), String> {
    with_service_mut(|core| {
        let address = parse_address(addr)?;
        let book = AddressBookEntry::add(name, address, net);

        core.add_to_address_book(book)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn get_address_book_list() -> Result<Vec<AddressBookEntryInfo>, String> {
    with_service(|core| Ok(core.get_address_book().iter().map(Into::into).collect()))
        .await
        .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/api/settings.rs`:

```rs
use crate::utils::{
    errors::ServiceError,
    utils::{with_service_mut, with_wallet, with_wallet_mut},
};
pub use zilpay::settings::{
    notifications::NotificationState,
    theme::{Appearances, Theme},
};
use zilpay::{
    background::bg_settings::SettingsManagement, wallet::wallet_storage::StorageOperations,
};

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_theme(appearances_code: u8) -> Result<(), String> {
    with_service_mut(|core| {
        let new_theme = Theme {
            appearances: Appearances::from_code(appearances_code)
                .map_err(ServiceError::SettingsError)?,
        };
        core.set_theme(new_theme)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_wallet_notifications(
    wallet_index: usize,
    transactions: bool,
    price: bool,
    security: bool,
    balance: bool,
) -> Result<(), String> {
    with_service_mut(|core| {
        core.set_wallet_notifications(
            wallet_index,
            NotificationState {
                transactions,
                price,
                security,
                balance,
            },
        )
        .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_global_notifications(global_enabled: bool) -> Result<(), String> {
    with_service_mut(|core| {
        core.set_global_notifications(global_enabled)
            .map_err(ServiceError::BackgroundError)
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_rate_fetcher(wallet_index: usize, currency: Option<String>) -> Result<(), String> {
    with_wallet(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.currency_convert = currency;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_wallet_ens(wallet_index: usize, ens_enabled: bool) -> Result<(), String> {
    with_wallet_mut(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.ens_enabled = ens_enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_wallet_ipfs_node(wallet_index: usize, node: Option<String>) -> Result<(), String> {
    with_wallet_mut(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.features.ipfs_node = node;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_wallet_gas_control(wallet_index: usize, enabled: bool) -> Result<(), String> {
    with_wallet_mut(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.network.gas_control_enabled = enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

#[flutter_rust_bridge::frb(dart_async)]
pub async fn set_wallet_node_ranking(wallet_index: usize, enabled: bool) -> Result<(), String> {
    with_wallet_mut(wallet_index, |wallet| {
        let mut data = wallet
            .get_wallet_data()
            .map_err(|e| ServiceError::WalletError(wallet_index, e))?;

        data.settings.network.node_ranking_enabled = enabled;

        wallet
            .save_wallet_data(data)
            .map_err(|e| ServiceError::WalletError(wallet_index, e))
    })
    .await
    .map_err(Into::into)
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/frb_generated.rs`:

```rs
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.6.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1429302511;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__wallet__add_bip39_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_bip39_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::Bip39AddWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_bip39_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__add_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_meta = <crate::models::ftoken::FTokenInfo>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::add_ftoken(api_meta, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__add_ledger_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ledger_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_pub_key = <String>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::add_ledger_account(
                            api_wallet_index,
                            api_account_index,
                            api_name,
                            api_pub_key,
                            &api_identifiers,
                            api_session_cipher,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ledger__add_ledger_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_ledger_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::ledger::LedgerParamsInput>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::ledger::add_ledger_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__book__add_new_book_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_new_book_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_net = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::book::add_new_book_address(api_name, api_addr, api_net)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_next_bip39_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_next_bip39_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::wallet::AddNextBip39AccountParams>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::add_next_bip39_account(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <crate::models::provider::NetworkConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_provider(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__add_providers_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_providers_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_provider_config =
                <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::provider::add_providers_list(api_provider_config).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__add_requested_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_requested_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_tx = <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::add_requested_transactions(
                            api_wallet_index,
                            api_tx,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__add_sk_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_sk_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params = <crate::api::wallet::AddSKWalletParams>::sse_decode(&mut deserializer);
            let api_wallet_settings =
                <crate::models::settings::WalletSettingsInfo>::sse_decode(&mut deserializer);
            let api_ftokens =
                <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::add_sk_wallet(
                            api_params,
                            api_wallet_settings,
                            api_ftokens,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__add_wallet_to_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_wallet_to_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_domain = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::add_wallet_to_connection(
                            api_domain,
                            api_wallet_index,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__cacl_gas_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cacl_gas_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::transaction::cacl_gas_fee(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_account_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_account_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::change_account_name(
                            api_wallet_index,
                            api_account_index,
                            api_new_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__change_wallet_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "change_wallet_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_new_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::change_wallet_name(api_wallet_index, api_new_name)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__check_not_exists_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_not_exists_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_words = <Vec<String>>::sse_decode(&mut deserializer);
            let api__lang = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::methods::check_not_exists_bip39_words(api_words, api__lang),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__clear_requested_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "clear_requested_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::clear_requested_transactions(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__create_new_connection_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_new_connection",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_conn =
                <crate::models::connection::ConnectionInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::connections::create_new_connection(api_conn).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__create_token_transfer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_token_transfer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_params =
                <crate::api::transaction::TokenTransferParamsInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::create_token_transfer(api_params).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::delete_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__delete_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "delete_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            let api_session_cipher = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::delete_wallet(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api_session_cipher,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__fetch_token_meta_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_token_meta",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::fetch_token_meta(api_addr, api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__gen_bip39_words_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_bip39_words",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_count = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_bip39_words(api_count)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__methods__gen_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::gen_keypair()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_png_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_png_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_png_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__gen_svg_qrcode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gen_svg_qrcode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            let api_config = <crate::models::qrcode::QrConfigInfo>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::gen_svg_qrcode(api_data, api_config)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__book__get_address_book_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_address_book_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::book::get_address_book_list().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__connections__get_connections_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_connections_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connections::get_connections_list().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__get_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::get_data().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__get_history_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_history",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::get_history(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::cache::get_image_bytes(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__cache__get_image_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_image_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_dir = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::cache::get_image_name(api_dir, api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_provider_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_provider",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_chain_hash = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_provider(api_chain_hash).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__provider__get_providers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_providers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::provider::get_providers().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__get_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::get_rates().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__transaction__get_requested_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_requested_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::transaction::get_requested_transactions(api_wallet_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__get_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::get_wallets().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::methods::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__methods__is_crypto_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_crypto_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_addr = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::methods::is_crypto_address(api_addr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__backend__is_service_running_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_service_running",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::backend::is_service_running().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__methods__keypair_from_sk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "keypair_from_sk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sk = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::methods::keypair_from_sk(api_sk)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__qrcode__parse_qrcode_str_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_qrcode_str",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::qrcode::parse_qrcode_str(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_bip39_phrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_bip39_phrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api__passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_bip39_phrase(
                            api_wallet_index,
                            api_identifiers,
                            api_password,
                            api__passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__reveal_keypair_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reveal_keypair",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_passphrase = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::wallet::reveal_keypair(
                            api_wallet_index,
                            api_account_index,
                            api_identifiers,
                            api_password,
                            api_passphrase,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__rm_ftoken_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rm_ftoken",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_token_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::token::rm_ftoken(api_wallet_index, api_token_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__wallet__select_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "select_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_account_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::wallet::select_account(api_wallet_index, api_account_index)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_global_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_global_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_global_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_global_notifications(api_global_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_rate_fetcher_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rate_fetcher",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_currency = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_rate_fetcher(api_wallet_index, api_currency)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_theme_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_theme",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_appearances_code = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_theme(api_appearances_code).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ens_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ens",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_ens_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ens(api_wallet_index, api_ens_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_gas_control_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_gas_control",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_gas_control(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_ipfs_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_ipfs_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_node = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::settings::set_wallet_ipfs_node(api_wallet_index, api_node)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_node_ranking_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_node_ranking",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_node_ranking(
                            api_wallet_index,
                            api_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__settings__set_wallet_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_wallet_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_transactions = <bool>::sse_decode(&mut deserializer);
            let api_price = <bool>::sse_decode(&mut deserializer);
            let api_security = <bool>::sse_decode(&mut deserializer);
            let api_balance = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::settings::set_wallet_notifications(
                            api_wallet_index,
                            api_transactions,
                            api_price,
                            api_security,
                            api_balance,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__start_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::start_service(&api_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__start_worker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_worker",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__sink =
                <StreamSink<String, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::start_worker(api__sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__backend__stop_service_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "stop_service",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::backend::stop_service().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__sync_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sync_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::sync_balances(api_wallet_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_password_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_password",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_password = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_password(
                            api_password,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__auth__try_unlock_with_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_unlock_with_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_session_cipher = <String>::sse_decode(&mut deserializer);
            let api_wallet_index = <usize>::sse_decode(&mut deserializer);
            let api_identifiers = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::auth::try_unlock_with_session(
                            api_session_cipher,
                            api_wallet_index,
                            api_identifiers,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__token__update_rates_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_rates",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::token::update_rates().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(usize, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return inner.parse().unwrap();
    }
}

impl SseDecode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_storageKeys = <Vec<String>>::sse_decode(deserializer);
        return crate::models::transactions::access_list::AccessListItem {
            address: var_address,
            storage_keys: var_storageKeys,
        };
    }
}

impl SseDecode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_index = <usize>::sse_decode(deserializer);
        return crate::models::account::AccountInfo {
            addr: var_addr,
            name: var_name,
            chain_hash: var_chainHash,
            index: var_index,
        };
    }
}

impl SseDecode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_password = <Option<String>>::sse_decode(deserializer);
        let mut var_sessionCipher = <Option<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::wallet::AddNextBip39AccountParams {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            name: var_name,
            passphrase: var_passphrase,
            identifiers: var_identifiers,
            password: var_password,
            session_cipher: var_sessionCipher,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::wallet::AddSKWalletParams {
            sk: var_sk,
            password: var_password,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_net = <usize>::sse_decode(deserializer);
        return crate::models::book::AddressBookEntryInfo {
            name: var_name,
            addr: var_addr,
            net: var_net,
        };
    }
}

impl SseDecode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transactions = <bool>::sse_decode(deserializer);
        let mut var_price = <bool>::sse_decode(deserializer);
        let mut var_security = <bool>::sse_decode(deserializer);
        let mut var_balance = <bool>::sse_decode(deserializer);
        return crate::models::notification::BackgroundNotificationState {
            transactions: var_transactions,
            price: var_price,
            security: var_security,
            balance: var_balance,
        };
    }
}

impl SseDecode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_wallets = <Vec<crate::models::wallet::WalletInfo>>::sse_decode(deserializer);
        let mut var_notificationsWalletStates = <std::collections::HashMap<
            usize,
            crate::models::notification::BackgroundNotificationState,
        >>::sse_decode(deserializer);
        let mut var_notificationsGlobalEnabled = <bool>::sse_decode(deserializer);
        let mut var_locale = <String>::sse_decode(deserializer);
        let mut var_appearances = <u8>::sse_decode(deserializer);
        let mut var_providers =
            <Vec<crate::models::provider::NetworkConfigInfo>>::sse_decode(deserializer);
        return crate::models::background::BackgroundState {
            wallets: var_wallets,
            notifications_wallet_states: var_notificationsWalletStates,
            notifications_global_enabled: var_notificationsGlobalEnabled,
            locale: var_locale,
            appearances: var_appearances,
            providers: var_providers,
        };
    }
}

impl SseDecode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        return crate::models::transactions::base_token::BaseTokenInfo {
            value: var_value,
            symbol: var_symbol,
            decimals: var_decimals,
        };
    }
}

impl SseDecode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_mnemonicStr = <String>::sse_decode(deserializer);
        let mut var_accounts = <Vec<(usize, String)>>::sse_decode(deserializer);
        let mut var_passphrase = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        return crate::api::wallet::Bip39AddWalletParams {
            password: var_password,
            mnemonic_str: var_mnemonicStr,
            accounts: var_accounts,
            passphrase: var_passphrase,
            wallet_name: var_walletName,
            biometric_type: var_biometricType,
            chain_hash: var_chainHash,
            identifiers: var_identifiers,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_primary = <String>::sse_decode(deserializer);
        let mut var_secondary = <Option<String>>::sse_decode(deserializer);
        let mut var_background = <Option<String>>::sse_decode(deserializer);
        let mut var_text = <Option<String>>::sse_decode(deserializer);
        return crate::models::connection::ColorsInfo {
            primary: var_primary,
            secondary: var_secondary,
            background: var_background,
            text: var_text,
        };
    }
}

impl SseDecode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_domain = <String>::sse_decode(deserializer);
        let mut var_walletIndexes = <Vec<usize>>::sse_decode(deserializer);
        let mut var_favicon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <String>::sse_decode(deserializer);
        let mut var_description = <Option<String>>::sse_decode(deserializer);
        let mut var_colors =
            <Option<crate::models::connection::ColorsInfo>>::sse_decode(deserializer);
        let mut var_lastConnected = <u64>::sse_decode(deserializer);
        let mut var_canReadAccounts = <bool>::sse_decode(deserializer);
        let mut var_canRequestSignatures = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTokens = <bool>::sse_decode(deserializer);
        let mut var_canSuggestTransactions = <bool>::sse_decode(deserializer);
        return crate::models::connection::ConnectionInfo {
            domain: var_domain,
            wallet_indexes: var_walletIndexes,
            favicon: var_favicon,
            title: var_title,
            description: var_description,
            colors: var_colors,
            last_connected: var_lastConnected,
            can_read_accounts: var_canReadAccounts,
            can_request_signatures: var_canRequestSignatures,
            can_suggest_tokens: var_canSuggestTokens,
            can_suggest_transactions: var_canSuggestTransactions,
        };
    }
}

impl SseDecode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_standard = <u16>::sse_decode(deserializer);
        return crate::models::provider::ExplorerInfo {
            name: var_name,
            url: var_url,
            icon: var_icon,
            standard: var_standard,
        };
    }
}

impl SseDecode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_symbol = <String>::sse_decode(deserializer);
        let mut var_decimals = <u8>::sse_decode(deserializer);
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_logo = <Option<String>>::sse_decode(deserializer);
        let mut var_balances = <std::collections::HashMap<usize, String>>::sse_decode(deserializer);
        let mut var_default_ = <bool>::sse_decode(deserializer);
        let mut var_native = <bool>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::models::ftoken::FTokenInfo {
            name: var_name,
            symbol: var_symbol,
            decimals: var_decimals,
            addr: var_addr,
            logo: var_logo,
            balances: var_balances,
            default: var_default_,
            native: var_native,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxFee = <u128>::sse_decode(deserializer);
        let mut var_priorityFee = <u128>::sse_decode(deserializer);
        let mut var_baseFee = <u128>::sse_decode(deserializer);
        return crate::models::gas::GasFeeHistoryInfo {
            max_fee: var_maxFee,
            priority_fee: var_priorityFee,
            base_fee: var_baseFee,
        };
    }
}

impl SseDecode for crate::models::gas::GasInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_maxPriorityFee = <u128>::sse_decode(deserializer);
        let mut var_feeHistory = <crate::models::gas::GasFeeHistoryInfo>::sse_decode(deserializer);
        let mut var_txEstimateGas = <u64>::sse_decode(deserializer);
        let mut var_blobBaseFee = <u128>::sse_decode(deserializer);
        return crate::models::gas::GasInfo {
            gas_price: var_gasPrice,
            max_priority_fee: var_maxPriorityFee,
            fee_history: var_feeHistory,
            tx_estimate_gas: var_txEstimateGas,
            blob_base_fee: var_blobBaseFee,
        };
    }
}

impl SseDecode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_sender = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_teg = <Option<String>>::sse_decode(deserializer);
        let mut var_status =
            <crate::models::transactions::history::TransactionStatusInfo>::sse_decode(deserializer);
        let mut var_confirmed = <Option<u128>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_fee = <u128>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::history::HistoricalTransactionInfo {
            id: var_id,
            amount: var_amount,
            sender: var_sender,
            recipient: var_recipient,
            teg: var_teg,
            status: var_status,
            confirmed: var_confirmed,
            timestamp: var_timestamp,
            fee: var_fee,
            icon: var_icon,
            title: var_title,
            nonce: var_nonce,
            token_info: var_tokenInfo,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sk = <String>::sse_decode(deserializer);
        let mut var_pk = <String>::sse_decode(deserializer);
        return crate::models::keypair::KeyPairInfo {
            sk: var_sk,
            pk: var_pk,
        };
    }
}

impl SseDecode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubKey = <String>::sse_decode(deserializer);
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_ledgerId = <String>::sse_decode(deserializer);
        let mut var_accountName = <String>::sse_decode(deserializer);
        let mut var_biometricType = <String>::sse_decode(deserializer);
        let mut var_identifiers = <Vec<String>>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        return crate::api::ledger::LedgerParamsInput {
            pub_key: var_pubKey,
            wallet_index: var_walletIndex,
            wallet_name: var_walletName,
            ledger_id: var_ledgerId,
            account_name: var_accountName,
            biometric_type: var_biometricType,
            identifiers: var_identifiers,
            chain_hash: var_chainHash,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::access_list::AccessListItem>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::account::AccountInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::book::AddressBookEntryInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::connection::ConnectionInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::ExplorerInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::ftoken::FTokenInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::history::HistoricalTransactionInfo>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::provider::NetworkConfigInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u16>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<usize>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(usize, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::transactions::request::TransactionRequestInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::models::transactions::request::TransactionRequestInfo>::sse_decode(
                    deserializer,
                ),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::wallet::WalletInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_chain = <String>::sse_decode(deserializer);
        let mut var_shortName = <String>::sse_decode(deserializer);
        let mut var_rpc = <Vec<String>>::sse_decode(deserializer);
        let mut var_features = <Vec<u16>>::sse_decode(deserializer);
        let mut var_chainId = <u64>::sse_decode(deserializer);
        let mut var_slip44 = <u32>::sse_decode(deserializer);
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_ens = <Option<String>>::sse_decode(deserializer);
        let mut var_explorers =
            <Vec<crate::models::provider::ExplorerInfo>>::sse_decode(deserializer);
        let mut var_fallbackEnabled = <bool>::sse_decode(deserializer);
        let mut var_testnet = <Option<bool>>::sse_decode(deserializer);
        return crate::models::provider::NetworkConfigInfo {
            name: var_name,
            chain: var_chain,
            short_name: var_shortName,
            rpc: var_rpc,
            features: var_features,
            chain_id: var_chainId,
            slip_44: var_slip44,
            chain_hash: var_chainHash,
            ens: var_ens,
            explorers: var_explorers,
            fallback_enabled: var_fallbackEnabled,
            testnet: var_testnet,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u128>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::base_token::BaseTokenInfo>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::connection::ColorsInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::evm::TransactionRequestEVM>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::models::transactions::scilla::TransactionRequestScilla>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<
                crate::models::transactions::access_list::AccessListItem,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_provider = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenAddress = <Option<String>>::sse_decode(deserializer);
        let mut var_amount = <Option<String>>::sse_decode(deserializer);
        return crate::models::qrcode::QRcodeScanResultInfo {
            recipient: var_recipient,
            provider: var_provider,
            token_address: var_tokenAddress,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_size = <u32>::sse_decode(deserializer);
        let mut var_gapless = <bool>::sse_decode(deserializer);
        let mut var_color = <u32>::sse_decode(deserializer);
        let mut var_eyeShape = <u8>::sse_decode(deserializer);
        let mut var_dataModuleShape = <u8>::sse_decode(deserializer);
        return crate::models::qrcode::QrConfigInfo {
            size: var_size,
            gapless: var_gapless,
            color: var_color,
            eye_shape: var_eyeShape,
            data_module_shape: var_dataModuleShape,
        };
    }
}

impl SseDecode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 =
            <crate::models::notification::BackgroundNotificationState>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletIndex = <usize>::sse_decode(deserializer);
        let mut var_accountIndex = <usize>::sse_decode(deserializer);
        let mut var_tokenIndex = <usize>::sse_decode(deserializer);
        let mut var_amount = <String>::sse_decode(deserializer);
        let mut var_recipient = <String>::sse_decode(deserializer);
        return crate::api::transaction::TokenTransferParamsInfo {
            wallet_index: var_walletIndex,
            account_index: var_accountIndex,
            token_index: var_tokenIndex,
            amount: var_amount,
            recipient: var_recipient,
        };
    }
}

impl SseDecode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainHash = <u64>::sse_decode(deserializer);
        let mut var_hash = <Option<String>>::sse_decode(deserializer);
        let mut var_info = <Option<String>>::sse_decode(deserializer);
        let mut var_icon = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_signer = <Option<String>>::sse_decode(deserializer);
        let mut var_tokenInfo =
            <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
            chain_hash: var_chainHash,
            hash: var_hash,
            info: var_info,
            icon: var_icon,
            title: var_title,
            signer: var_signer,
            token_info: var_tokenInfo,
        };
    }
}

impl SseDecode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nonce = <Option<u64>>::sse_decode(deserializer);
        let mut var_from = <Option<String>>::sse_decode(deserializer);
        let mut var_to = <Option<String>>::sse_decode(deserializer);
        let mut var_value = <Option<String>>::sse_decode(deserializer);
        let mut var_gasLimit = <Option<u64>>::sse_decode(deserializer);
        let mut var_data = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_maxFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_maxPriorityFeePerGas = <Option<u128>>::sse_decode(deserializer);
        let mut var_gasPrice = <Option<u128>>::sse_decode(deserializer);
        let mut var_chainId = <Option<u64>>::sse_decode(deserializer);
        let mut var_accessList = <Option<
            Vec<crate::models::transactions::access_list::AccessListItem>,
        >>::sse_decode(deserializer);
        let mut var_blobVersionedHashes = <Option<Vec<String>>>::sse_decode(deserializer);
        let mut var_maxFeePerBlobGas = <Option<u128>>::sse_decode(deserializer);
        return crate::models::transactions::evm::TransactionRequestEVM {
            nonce: var_nonce,
            from: var_from,
            to: var_to,
            value: var_value,
            gas_limit: var_gasLimit,
            data: var_data,
            max_fee_per_gas: var_maxFeePerGas,
            max_priority_fee_per_gas: var_maxPriorityFeePerGas,
            gas_price: var_gasPrice,
            chain_id: var_chainId,
            access_list: var_accessList,
            blob_versioned_hashes: var_blobVersionedHashes,
            max_fee_per_blob_gas: var_maxFeePerBlobGas,
        };
    }
}

impl SseDecode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_metadata = <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_decode(deserializer);
        let mut var_scilla =
            <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_decode(
                deserializer,
            );
        let mut var_evm =
            <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_decode(
                deserializer,
            );
        return crate::models::transactions::request::TransactionRequestInfo {
            metadata: var_metadata,
            scilla: var_scilla,
            evm: var_evm,
        };
    }
}

impl SseDecode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chainId = <u16>::sse_decode(deserializer);
        let mut var_nonce = <u64>::sse_decode(deserializer);
        let mut var_gasPrice = <u128>::sse_decode(deserializer);
        let mut var_gasLimit = <u64>::sse_decode(deserializer);
        let mut var_toAddr = <String>::sse_decode(deserializer);
        let mut var_amount = <u128>::sse_decode(deserializer);
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_data = <String>::sse_decode(deserializer);
        return crate::models::transactions::scilla::TransactionRequestScilla {
            chain_id: var_chainId,
            nonce: var_nonce,
            gas_price: var_gasPrice,
            gas_limit: var_gasLimit,
            to_addr: var_toAddr,
            amount: var_amount,
            code: var_code,
            data: var_data,
        };
    }
}

impl SseDecode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::models::transactions::history::TransactionStatusInfo::Pending,
            1 => crate::models::transactions::history::TransactionStatusInfo::Confirmed,
            2 => crate::models::transactions::history::TransactionStatusInfo::Rejected,
            _ => unreachable!("Invalid variant for TransactionStatusInfo: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_memory = <u32>::sse_decode(deserializer);
        let mut var_iterations = <u32>::sse_decode(deserializer);
        let mut var_threads = <u32>::sse_decode(deserializer);
        let mut var_secret = <String>::sse_decode(deserializer);
        return crate::models::settings::WalletArgonParamsInfo {
            memory: var_memory,
            iterations: var_iterations,
            threads: var_threads,
            secret: var_secret,
        };
    }
}

impl SseDecode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_walletType = <String>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_authType = <String>::sse_decode(deserializer);
        let mut var_walletAddress = <String>::sse_decode(deserializer);
        let mut var_accounts = <Vec<crate::models::account::AccountInfo>>::sse_decode(deserializer);
        let mut var_selectedAccount = <usize>::sse_decode(deserializer);
        let mut var_tokens = <Vec<crate::models::ftoken::FTokenInfo>>::sse_decode(deserializer);
        let mut var_settings =
            <crate::models::settings::WalletSettingsInfo>::sse_decode(deserializer);
        let mut var_defaultChainHash = <u64>::sse_decode(deserializer);
        return crate::models::wallet::WalletInfo {
            wallet_type: var_walletType,
            wallet_name: var_walletName,
            auth_type: var_authType,
            wallet_address: var_walletAddress,
            accounts: var_accounts,
            selected_account: var_selectedAccount,
            tokens: var_tokens,
            settings: var_settings,
            default_chain_hash: var_defaultChainHash,
        };
    }
}

impl SseDecode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cipherOrders = <Vec<u8>>::sse_decode(deserializer);
        let mut var_argonParams =
            <crate::models::settings::WalletArgonParamsInfo>::sse_decode(deserializer);
        let mut var_currencyConvert = <Option<String>>::sse_decode(deserializer);
        let mut var_ipfsNode = <Option<String>>::sse_decode(deserializer);
        let mut var_ensEnabled = <bool>::sse_decode(deserializer);
        let mut var_gasControlEnabled = <bool>::sse_decode(deserializer);
        let mut var_nodeRankingEnabled = <bool>::sse_decode(deserializer);
        let mut var_maxConnections = <u8>::sse_decode(deserializer);
        let mut var_requestTimeoutSecs = <u32>::sse_decode(deserializer);
        return crate::models::settings::WalletSettingsInfo {
            cipher_orders: var_cipherOrders,
            argon_params: var_argonParams,
            currency_convert: var_currencyConvert,
            ipfs_node: var_ipfsNode,
            ens_enabled: var_ensEnabled,
            gas_control_enabled: var_gasControlEnabled,
            node_ranking_enabled: var_nodeRankingEnabled,
            max_connections: var_maxConnections,
            request_timeout_secs: var_requestTimeoutSecs,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__wallet__add_bip39_wallet_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__token__add_ftoken_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__ledger__add_ledger_account_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__ledger__add_ledger_wallet_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__book__add_new_book_address_impl(port, ptr, rust_vec_len, data_len),
        6 => {
            wire__crate__api__wallet__add_next_bip39_account_impl(port, ptr, rust_vec_len, data_len)
        }
        7 => wire__crate__api__provider__add_provider_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__provider__add_providers_list_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__transaction__add_requested_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__api__wallet__add_sk_wallet_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__connections__add_wallet_to_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        12 => wire__crate__api__transaction__cacl_gas_fee_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__wallet__change_account_name_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__wallet__change_wallet_name_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__methods__check_not_exists_bip39_words_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        16 => wire__crate__api__transaction__clear_requested_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        17 => wire__crate__api__connections__create_new_connection_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__transaction__create_token_transfer_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__wallet__delete_account_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__wallet__delete_wallet_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__token__fetch_token_meta_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__methods__gen_bip39_words_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__methods__gen_keypair_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__api__qrcode__gen_png_qrcode_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__qrcode__gen_svg_qrcode_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__book__get_address_book_list_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__connections__get_connections_list_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        28 => wire__crate__api__backend__get_data_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__transaction__get_history_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__cache__get_image_bytes_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__cache__get_image_name_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__provider__get_provider_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__provider__get_providers_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__token__get_rates_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__transaction__get_requested_transactions_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => wire__crate__api__wallet__get_wallets_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__methods__init_app_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__methods__is_crypto_address_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__backend__is_service_running_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__methods__keypair_from_sk_impl(port, ptr, rust_vec_len, data_len),
        41 => wire__crate__api__qrcode__parse_qrcode_str_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__wallet__reveal_bip39_phrase_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__wallet__reveal_keypair_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__token__rm_ftoken_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__wallet__select_account_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__settings__set_global_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        47 => wire__crate__api__settings__set_rate_fetcher_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__settings__set_theme_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__settings__set_wallet_ens_impl(port, ptr, rust_vec_len, data_len),
        50 => wire__crate__api__settings__set_wallet_gas_control_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        51 => {
            wire__crate__api__settings__set_wallet_ipfs_node_impl(port, ptr, rust_vec_len, data_len)
        }
        52 => wire__crate__api__settings__set_wallet_node_ranking_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        53 => wire__crate__api__settings__set_wallet_notifications_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        54 => wire__crate__api__backend__start_service_impl(port, ptr, rust_vec_len, data_len),
        55 => wire__crate__api__backend__start_worker_impl(port, ptr, rust_vec_len, data_len),
        56 => wire__crate__api__backend__stop_service_impl(port, ptr, rust_vec_len, data_len),
        57 => wire__crate__api__token__sync_balances_impl(port, ptr, rust_vec_len, data_len),
        58 => {
            wire__crate__api__auth__try_unlock_with_password_impl(port, ptr, rust_vec_len, data_len)
        }
        59 => {
            wire__crate__api__auth__try_unlock_with_session_impl(port, ptr, rust_vec_len, data_len)
        }
        60 => wire__crate__api__token__update_rates_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::access_list::AccessListItem {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.storage_keys.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::access_list::AccessListItem
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::access_list::AccessListItem>
    for crate::models::transactions::access_list::AccessListItem
{
    fn into_into_dart(self) -> crate::models::transactions::access_list::AccessListItem {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::account::AccountInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::account::AccountInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::account::AccountInfo>
    for crate::models::account::AccountInfo
{
    fn into_into_dart(self) -> crate::models::account::AccountInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddNextBip39AccountParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.session_cipher.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddNextBip39AccountParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddNextBip39AccountParams>
    for crate::api::wallet::AddNextBip39AccountParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddNextBip39AccountParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::AddSKWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::AddSKWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::AddSKWalletParams>
    for crate::api::wallet::AddSKWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::AddSKWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::book::AddressBookEntryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.net.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::book::AddressBookEntryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::book::AddressBookEntryInfo>
    for crate::models::book::AddressBookEntryInfo
{
    fn into_into_dart(self) -> crate::models::book::AddressBookEntryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::notification::BackgroundNotificationState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transactions.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
            self.security.into_into_dart().into_dart(),
            self.balance.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::notification::BackgroundNotificationState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::notification::BackgroundNotificationState>
    for crate::models::notification::BackgroundNotificationState
{
    fn into_into_dart(self) -> crate::models::notification::BackgroundNotificationState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::background::BackgroundState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallets.into_into_dart().into_dart(),
            self.notifications_wallet_states
                .into_into_dart()
                .into_dart(),
            self.notifications_global_enabled
                .into_into_dart()
                .into_dart(),
            self.locale.into_into_dart().into_dart(),
            self.appearances.into_into_dart().into_dart(),
            self.providers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::background::BackgroundState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::background::BackgroundState>
    for crate::models::background::BackgroundState
{
    fn into_into_dart(self) -> crate::models::background::BackgroundState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::base_token::BaseTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::base_token::BaseTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::base_token::BaseTokenInfo>
    for crate::models::transactions::base_token::BaseTokenInfo
{
    fn into_into_dart(self) -> crate::models::transactions::base_token::BaseTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::Bip39AddWalletParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.password.into_into_dart().into_dart(),
            self.mnemonic_str.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.passphrase.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::wallet::Bip39AddWalletParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::Bip39AddWalletParams>
    for crate::api::wallet::Bip39AddWalletParams
{
    fn into_into_dart(self) -> crate::api::wallet::Bip39AddWalletParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ColorsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.primary.into_into_dart().into_dart(),
            self.secondary.into_into_dart().into_dart(),
            self.background.into_into_dart().into_dart(),
            self.text.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ColorsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ColorsInfo>
    for crate::models::connection::ColorsInfo
{
    fn into_into_dart(self) -> crate::models::connection::ColorsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::connection::ConnectionInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.domain.into_into_dart().into_dart(),
            self.wallet_indexes.into_into_dart().into_dart(),
            self.favicon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.colors.into_into_dart().into_dart(),
            self.last_connected.into_into_dart().into_dart(),
            self.can_read_accounts.into_into_dart().into_dart(),
            self.can_request_signatures.into_into_dart().into_dart(),
            self.can_suggest_tokens.into_into_dart().into_dart(),
            self.can_suggest_transactions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::connection::ConnectionInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::connection::ConnectionInfo>
    for crate::models::connection::ConnectionInfo
{
    fn into_into_dart(self) -> crate::models::connection::ConnectionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::ExplorerInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.url.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.standard.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::ExplorerInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::ExplorerInfo>
    for crate::models::provider::ExplorerInfo
{
    fn into_into_dart(self) -> crate::models::provider::ExplorerInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::ftoken::FTokenInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.symbol.into_into_dart().into_dart(),
            self.decimals.into_into_dart().into_dart(),
            self.addr.into_into_dart().into_dart(),
            self.logo.into_into_dart().into_dart(),
            self.balances.into_into_dart().into_dart(),
            self.default.into_into_dart().into_dart(),
            self.native.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::ftoken::FTokenInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::ftoken::FTokenInfo>
    for crate::models::ftoken::FTokenInfo
{
    fn into_into_dart(self) -> crate::models::ftoken::FTokenInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::GasFeeHistoryInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_fee.into_into_dart().into_dart(),
            self.priority_fee.into_into_dart().into_dart(),
            self.base_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::gas::GasFeeHistoryInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::GasFeeHistoryInfo>
    for crate::models::gas::GasFeeHistoryInfo
{
    fn into_into_dart(self) -> crate::models::gas::GasFeeHistoryInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::gas::GasInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.gas_price.into_into_dart().into_dart(),
            self.max_priority_fee.into_into_dart().into_dart(),
            self.fee_history.into_into_dart().into_dart(),
            self.tx_estimate_gas.into_into_dart().into_dart(),
            self.blob_base_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::models::gas::GasInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::models::gas::GasInfo>
    for crate::models::gas::GasInfo
{
    fn into_into_dart(self) -> crate::models::gas::GasInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.sender.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
            self.teg.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::HistoricalTransactionInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::history::HistoricalTransactionInfo,
    > for crate::models::transactions::history::HistoricalTransactionInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::HistoricalTransactionInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::keypair::KeyPairInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sk.into_into_dart().into_dart(),
            self.pk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::keypair::KeyPairInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::keypair::KeyPairInfo>
    for crate::models::keypair::KeyPairInfo
{
    fn into_into_dart(self) -> crate::models::keypair::KeyPairInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ledger::LedgerParamsInput {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pub_key.into_into_dart().into_dart(),
            self.wallet_index.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.ledger_id.into_into_dart().into_dart(),
            self.account_name.into_into_dart().into_dart(),
            self.biometric_type.into_into_dart().into_dart(),
            self.identifiers.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::ledger::LedgerParamsInput
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ledger::LedgerParamsInput>
    for crate::api::ledger::LedgerParamsInput
{
    fn into_into_dart(self) -> crate::api::ledger::LedgerParamsInput {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::provider::NetworkConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.chain.into_into_dart().into_dart(),
            self.short_name.into_into_dart().into_dart(),
            self.rpc.into_into_dart().into_dart(),
            self.features.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.slip_44.into_into_dart().into_dart(),
            self.chain_hash.into_into_dart().into_dart(),
            self.ens.into_into_dart().into_dart(),
            self.explorers.into_into_dart().into_dart(),
            self.fallback_enabled.into_into_dart().into_dart(),
            self.testnet.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::provider::NetworkConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::provider::NetworkConfigInfo>
    for crate::models::provider::NetworkConfigInfo
{
    fn into_into_dart(self) -> crate::models::provider::NetworkConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QRcodeScanResultInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.recipient.into_into_dart().into_dart(),
            self.provider.into_into_dart().into_dart(),
            self.token_address.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QRcodeScanResultInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QRcodeScanResultInfo>
    for crate::models::qrcode::QRcodeScanResultInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QRcodeScanResultInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::qrcode::QrConfigInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.size.into_into_dart().into_dart(),
            self.gapless.into_into_dart().into_dart(),
            self.color.into_into_dart().into_dart(),
            self.eye_shape.into_into_dart().into_dart(),
            self.data_module_shape.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::qrcode::QrConfigInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::qrcode::QrConfigInfo>
    for crate::models::qrcode::QrConfigInfo
{
    fn into_into_dart(self) -> crate::models::qrcode::QrConfigInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::transaction::TokenTransferParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_index.into_into_dart().into_dart(),
            self.account_index.into_into_dart().into_dart(),
            self.token_index.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.recipient.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::transaction::TokenTransferParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::transaction::TokenTransferParamsInfo>
    for crate::api::transaction::TokenTransferParamsInfo
{
    fn into_into_dart(self) -> crate::api::transaction::TokenTransferParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_hash.into_into_dart().into_dart(),
            self.hash.into_into_dart().into_dart(),
            self.info.into_into_dart().into_dart(),
            self.icon.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.signer.into_into_dart().into_dart(),
            self.token_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::models::transactions::transaction_metadata::TransactionMetadataInfo,
    > for crate::models::transactions::transaction_metadata::TransactionMetadataInfo
{
    fn into_into_dart(
        self,
    ) -> crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::evm::TransactionRequestEVM {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.nonce.into_into_dart().into_dart(),
            self.from.into_into_dart().into_dart(),
            self.to.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
            self.max_fee_per_gas.into_into_dart().into_dart(),
            self.max_priority_fee_per_gas.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
            self.access_list.into_into_dart().into_dart(),
            self.blob_versioned_hashes.into_into_dart().into_dart(),
            self.max_fee_per_blob_gas.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::evm::TransactionRequestEVM
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::evm::TransactionRequestEVM>
    for crate::models::transactions::evm::TransactionRequestEVM
{
    fn into_into_dart(self) -> crate::models::transactions::evm::TransactionRequestEVM {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.metadata.into_into_dart().into_dart(),
            self.scilla.into_into_dart().into_dart(),
            self.evm.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::request::TransactionRequestInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::request::TransactionRequestInfo>
    for crate::models::transactions::request::TransactionRequestInfo
{
    fn into_into_dart(self) -> crate::models::transactions::request::TransactionRequestInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chain_id.into_into_dart().into_dart(),
            self.nonce.into_into_dart().into_dart(),
            self.gas_price.into_into_dart().into_dart(),
            self.gas_limit.into_into_dart().into_dart(),
            self.to_addr.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.code.into_into_dart().into_dart(),
            self.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::scilla::TransactionRequestScilla
{
}
impl
    flutter_rust_bridge::IntoIntoDart<crate::models::transactions::scilla::TransactionRequestScilla>
    for crate::models::transactions::scilla::TransactionRequestScilla
{
    fn into_into_dart(self) -> crate::models::transactions::scilla::TransactionRequestScilla {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::transactions::history::TransactionStatusInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Confirmed => 1.into_dart(),
            Self::Rejected => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::transactions::history::TransactionStatusInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::transactions::history::TransactionStatusInfo>
    for crate::models::transactions::history::TransactionStatusInfo
{
    fn into_into_dart(self) -> crate::models::transactions::history::TransactionStatusInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletArgonParamsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.memory.into_into_dart().into_dart(),
            self.iterations.into_into_dart().into_dart(),
            self.threads.into_into_dart().into_dart(),
            self.secret.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletArgonParamsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletArgonParamsInfo>
    for crate::models::settings::WalletArgonParamsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletArgonParamsInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::wallet::WalletInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.wallet_type.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.auth_type.into_into_dart().into_dart(),
            self.wallet_address.into_into_dart().into_dart(),
            self.accounts.into_into_dart().into_dart(),
            self.selected_account.into_into_dart().into_dart(),
            self.tokens.into_into_dart().into_dart(),
            self.settings.into_into_dart().into_dart(),
            self.default_chain_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::wallet::WalletInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::wallet::WalletInfo>
    for crate::models::wallet::WalletInfo
{
    fn into_into_dart(self) -> crate::models::wallet::WalletInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::settings::WalletSettingsInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.cipher_orders.into_into_dart().into_dart(),
            self.argon_params.into_into_dart().into_dart(),
            self.currency_convert.into_into_dart().into_dart(),
            self.ipfs_node.into_into_dart().into_dart(),
            self.ens_enabled.into_into_dart().into_dart(),
            self.gas_control_enabled.into_into_dart().into_dart(),
            self.node_ranking_enabled.into_into_dart().into_dart(),
            self.max_connections.into_into_dart().into_dart(),
            self.request_timeout_secs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::settings::WalletSettingsInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::settings::WalletSettingsInfo>
    for crate::models::settings::WalletSettingsInfo
{
    fn into_into_dart(self) -> crate::models::settings::WalletSettingsInfo {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<usize, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(usize, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(
            usize,
            crate::models::notification::BackgroundNotificationState,
        )>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for StreamSink<String, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for u128 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.to_string(), serializer);
    }
}

impl SseEncode for crate::models::transactions::access_list::AccessListItem {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <Vec<String>>::sse_encode(self.storage_keys, serializer);
    }
}

impl SseEncode for crate::models::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.addr, serializer);
        <String>::sse_encode(self.name, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <usize>::sse_encode(self.index, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddNextBip39AccountParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <Option<String>>::sse_encode(self.password, serializer);
        <Option<String>>::sse_encode(self.session_cipher, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::api::wallet::AddSKWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::book::AddressBookEntryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.addr, serializer);
        <usize>::sse_encode(self.net, serializer);
    }
}

impl SseEncode for crate::models::notification::BackgroundNotificationState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.transactions, serializer);
        <bool>::sse_encode(self.price, serializer);
        <bool>::sse_encode(self.security, serializer);
        <bool>::sse_encode(self.balance, serializer);
    }
}

impl SseEncode for crate::models::background::BackgroundState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::wallet::WalletInfo>>::sse_encode(self.wallets, serializer);
        <std::collections::HashMap<usize, crate::models::notification::BackgroundNotificationState>>::sse_encode(self.notifications_wallet_states, serializer);
        <bool>::sse_encode(self.notifications_global_enabled, serializer);
        <String>::sse_encode(self.locale, serializer);
        <u8>::sse_encode(self.appearances, serializer);
        <Vec<crate::models::provider::NetworkConfigInfo>>::sse_encode(self.providers, serializer);
    }
}

impl SseEncode for crate::models::transactions::base_token::BaseTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
    }
}

impl SseEncode for crate::api::wallet::Bip39AddWalletParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.mnemonic_str, serializer);
        <Vec<(usize, String)>>::sse_encode(self.accounts, serializer);
        <String>::sse_encode(self.passphrase, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::connection::ColorsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.primary, serializer);
        <Option<String>>::sse_encode(self.secondary, serializer);
        <Option<String>>::sse_encode(self.background, serializer);
        <Option<String>>::sse_encode(self.text, serializer);
    }
}

impl SseEncode for crate::models::connection::ConnectionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.domain, serializer);
        <Vec<usize>>::sse_encode(self.wallet_indexes, serializer);
        <Option<String>>::sse_encode(self.favicon, serializer);
        <String>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.description, serializer);
        <Option<crate::models::connection::ColorsInfo>>::sse_encode(self.colors, serializer);
        <u64>::sse_encode(self.last_connected, serializer);
        <bool>::sse_encode(self.can_read_accounts, serializer);
        <bool>::sse_encode(self.can_request_signatures, serializer);
        <bool>::sse_encode(self.can_suggest_tokens, serializer);
        <bool>::sse_encode(self.can_suggest_transactions, serializer);
    }
}

impl SseEncode for crate::models::provider::ExplorerInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <u16>::sse_encode(self.standard, serializer);
    }
}

impl SseEncode for crate::models::ftoken::FTokenInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.symbol, serializer);
        <u8>::sse_encode(self.decimals, serializer);
        <String>::sse_encode(self.addr, serializer);
        <Option<String>>::sse_encode(self.logo, serializer);
        <std::collections::HashMap<usize, String>>::sse_encode(self.balances, serializer);
        <bool>::sse_encode(self.default, serializer);
        <bool>::sse_encode(self.native, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for crate::models::gas::GasFeeHistoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.max_fee, serializer);
        <u128>::sse_encode(self.priority_fee, serializer);
        <u128>::sse_encode(self.base_fee, serializer);
    }
}

impl SseEncode for crate::models::gas::GasInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u128>::sse_encode(self.gas_price, serializer);
        <u128>::sse_encode(self.max_priority_fee, serializer);
        <crate::models::gas::GasFeeHistoryInfo>::sse_encode(self.fee_history, serializer);
        <u64>::sse_encode(self.tx_estimate_gas, serializer);
        <u128>::sse_encode(self.blob_base_fee, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::HistoricalTransactionInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.sender, serializer);
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.teg, serializer);
        <crate::models::transactions::history::TransactionStatusInfo>::sse_encode(
            self.status,
            serializer,
        );
        <Option<u128>>::sse_encode(self.confirmed, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <u128>::sse_encode(self.fee, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <u64>::sse_encode(self.nonce, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::models::keypair::KeyPairInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.pk, serializer);
    }
}

impl SseEncode for crate::api::ledger::LedgerParamsInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pub_key, serializer);
        <usize>::sse_encode(self.wallet_index, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.ledger_id, serializer);
        <String>::sse_encode(self.account_name, serializer);
        <String>::sse_encode(self.biometric_type, serializer);
        <Vec<String>>::sse_encode(self.identifiers, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::access_list::AccessListItem> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::access_list::AccessListItem>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::account::AccountInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::account::AccountInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::book::AddressBookEntryInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::book::AddressBookEntryInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::connection::ConnectionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::connection::ConnectionInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::provider::ExplorerInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::ExplorerInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::ftoken::FTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::ftoken::FTokenInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::history::HistoricalTransactionInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::history::HistoricalTransactionInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::provider::NetworkConfigInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::provider::NetworkConfigInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u16>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <usize>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        usize,
        crate::models::notification::BackgroundNotificationState,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                usize,
                crate::models::notification::BackgroundNotificationState,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(usize, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(usize, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::transactions::request::TransactionRequestInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::transactions::request::TransactionRequestInfo>::sse_encode(
                item, serializer,
            );
        }
    }
}

impl SseEncode for Vec<crate::models::wallet::WalletInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::wallet::WalletInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::models::provider::NetworkConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.chain, serializer);
        <String>::sse_encode(self.short_name, serializer);
        <Vec<String>>::sse_encode(self.rpc, serializer);
        <Vec<u16>>::sse_encode(self.features, serializer);
        <u64>::sse_encode(self.chain_id, serializer);
        <u32>::sse_encode(self.slip_44, serializer);
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.ens, serializer);
        <Vec<crate::models::provider::ExplorerInfo>>::sse_encode(self.explorers, serializer);
        <bool>::sse_encode(self.fallback_enabled, serializer);
        <Option<bool>>::sse_encode(self.testnet, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u128> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u128>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::base_token::BaseTokenInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::base_token::BaseTokenInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::connection::ColorsInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::connection::ColorsInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::transactions::evm::TransactionRequestEVM> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::evm::TransactionRequestEVM>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::models::transactions::scilla::TransactionRequestScilla> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::transactions::scilla::TransactionRequestScilla>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::models::transactions::access_list::AccessListItem>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::models::transactions::access_list::AccessListItem>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::models::qrcode::QRcodeScanResultInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.recipient, serializer);
        <Option<String>>::sse_encode(self.provider, serializer);
        <Option<String>>::sse_encode(self.token_address, serializer);
        <Option<String>>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::models::qrcode::QrConfigInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.size, serializer);
        <bool>::sse_encode(self.gapless, serializer);
        <u32>::sse_encode(self.color, serializer);
        <u8>::sse_encode(self.eye_shape, serializer);
        <u8>::sse_encode(self.data_module_shape, serializer);
    }
}

impl SseEncode for (Vec<u8>, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        usize,
        crate::models::notification::BackgroundNotificationState,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <crate::models::notification::BackgroundNotificationState>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (usize, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::transaction::TokenTransferParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.wallet_index, serializer);
        <usize>::sse_encode(self.account_index, serializer);
        <usize>::sse_encode(self.token_index, serializer);
        <String>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.recipient, serializer);
    }
}

impl SseEncode for crate::models::transactions::transaction_metadata::TransactionMetadataInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.chain_hash, serializer);
        <Option<String>>::sse_encode(self.hash, serializer);
        <Option<String>>::sse_encode(self.info, serializer);
        <Option<String>>::sse_encode(self.icon, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.signer, serializer);
        <Option<crate::models::transactions::base_token::BaseTokenInfo>>::sse_encode(
            self.token_info,
            serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::evm::TransactionRequestEVM {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.nonce, serializer);
        <Option<String>>::sse_encode(self.from, serializer);
        <Option<String>>::sse_encode(self.to, serializer);
        <Option<String>>::sse_encode(self.value, serializer);
        <Option<u64>>::sse_encode(self.gas_limit, serializer);
        <Option<Vec<u8>>>::sse_encode(self.data, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.max_priority_fee_per_gas, serializer);
        <Option<u128>>::sse_encode(self.gas_price, serializer);
        <Option<u64>>::sse_encode(self.chain_id, serializer);
        <Option<Vec<crate::models::transactions::access_list::AccessListItem>>>::sse_encode(
            self.access_list,
            serializer,
        );
        <Option<Vec<String>>>::sse_encode(self.blob_versioned_hashes, serializer);
        <Option<u128>>::sse_encode(self.max_fee_per_blob_gas, serializer);
    }
}

impl SseEncode for crate::models::transactions::request::TransactionRequestInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::models::transactions::transaction_metadata::TransactionMetadataInfo>::sse_encode(
            self.metadata,
            serializer,
        );
        <Option<crate::models::transactions::scilla::TransactionRequestScilla>>::sse_encode(
            self.scilla,
            serializer,
        );
        <Option<crate::models::transactions::evm::TransactionRequestEVM>>::sse_encode(
            self.evm, serializer,
        );
    }
}

impl SseEncode for crate::models::transactions::scilla::TransactionRequestScilla {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.chain_id, serializer);
        <u64>::sse_encode(self.nonce, serializer);
        <u128>::sse_encode(self.gas_price, serializer);
        <u64>::sse_encode(self.gas_limit, serializer);
        <String>::sse_encode(self.to_addr, serializer);
        <u128>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::models::transactions::history::TransactionStatusInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::models::transactions::history::TransactionStatusInfo::Pending => 0,
                crate::models::transactions::history::TransactionStatusInfo::Confirmed => 1,
                crate::models::transactions::history::TransactionStatusInfo::Rejected => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::models::settings::WalletArgonParamsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.memory, serializer);
        <u32>::sse_encode(self.iterations, serializer);
        <u32>::sse_encode(self.threads, serializer);
        <String>::sse_encode(self.secret, serializer);
    }
}

impl SseEncode for crate::models::wallet::WalletInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.wallet_type, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <String>::sse_encode(self.auth_type, serializer);
        <String>::sse_encode(self.wallet_address, serializer);
        <Vec<crate::models::account::AccountInfo>>::sse_encode(self.accounts, serializer);
        <usize>::sse_encode(self.selected_account, serializer);
        <Vec<crate::models::ftoken::FTokenInfo>>::sse_encode(self.tokens, serializer);
        <crate::models::settings::WalletSettingsInfo>::sse_encode(self.settings, serializer);
        <u64>::sse_encode(self.default_chain_hash, serializer);
    }
}

impl SseEncode for crate::models::settings::WalletSettingsInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.cipher_orders, serializer);
        <crate::models::settings::WalletArgonParamsInfo>::sse_encode(self.argon_params, serializer);
        <Option<String>>::sse_encode(self.currency_convert, serializer);
        <Option<String>>::sse_encode(self.ipfs_node, serializer);
        <bool>::sse_encode(self.ens_enabled, serializer);
        <bool>::sse_encode(self.gas_control_enabled, serializer);
        <bool>::sse_encode(self.node_ranking_enabled, serializer);
        <u8>::sse_encode(self.max_connections, serializer);
        <u32>::sse_encode(self.request_timeout_secs, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.6.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.6.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/service/service.rs`:

```rs
use crate::{frb_generated::StreamSink, utils::errors::ServiceError};
use lazy_static::lazy_static;
use std::sync::Arc;
use tokio::sync::RwLock;
use zilpay::background::{bg_storage::StorageManagement, Background};

pub struct ServiceBackground {
    pub running: bool,
    pub message_sink: Option<StreamSink<String>>,
    pub core: Arc<Background>,
}

lazy_static! {
    pub static ref BACKGROUND_SERVICE: RwLock<Option<ServiceBackground>> = RwLock::new(None);
}

impl ServiceBackground {
    pub fn from_path(path: &str) -> Result<Self, ServiceError> {
        let core = Background::from_storage_path(path).map_err(ServiceError::BackgroundError)?;

        Ok(Self {
            core: Arc::new(core),
            running: true,
            message_sink: None,
        })
    }

    pub fn stop(&mut self) {
        self.running = false;
    }

    pub fn get_wallet_mut(
        &mut self,
        wallet_index: usize,
    ) -> Result<&mut zilpay::wallet::Wallet, ServiceError> {
        Arc::get_mut(&mut self.core)
            .ok_or(ServiceError::CoreAccess)?
            .wallets
            .get_mut(wallet_index)
            .ok_or(ServiceError::WalletAccess(wallet_index))
    }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust/src/service/mod.rs`:

```rs
pub mod service;

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/router.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/pages/add_token.dart';
import 'package:zilpay/pages/address_book.dart';
import 'package:zilpay/pages/appearance.dart';
import 'package:zilpay/pages/currency_conversion.dart';
import 'package:zilpay/pages/ledger_connect.dart';
import 'package:zilpay/pages/locale.dart';
import 'package:zilpay/pages/network.dart';
import 'package:zilpay/pages/notification.dart';
import 'package:zilpay/pages/password_setup.dart';
import 'package:zilpay/pages/receive.dart';
import 'package:zilpay/pages/restore_bip39.dart';
import 'package:zilpay/pages/reveal_bip39.dart';
import 'package:zilpay/pages/reveal_sk.dart';
import 'package:zilpay/pages/security.dart';
import 'package:zilpay/pages/send.dart';
import 'package:zilpay/pages/setup_cipher.dart';
import 'package:zilpay/pages/setup_net.dart';
import 'package:zilpay/pages/sk_gen.dart';
import 'package:zilpay/pages/verify_bip39.dart';
import 'package:zilpay/pages/wallet.dart';

import 'services/auth_guard.dart';
import 'state/app_state.dart';

import 'pages/main_page.dart';
import 'pages/login_page.dart';
import 'pages/initial_page.dart';
import 'pages/history_page.dart';
import 'pages/browser_page.dart';
import 'pages/settings_page.dart';
import 'pages/new_wallet_options.dart';
import 'pages/gen_wallet_options.dart';
import 'pages/wallet_restore_options.dart';
import './pages/gen_bip39.dart';

class AppRouter {
  final AuthGuard authGuard;
  final AppState appState;

  AppRouter({required this.authGuard, required this.appState});

  Route<dynamic> onGenerateRoute(RouteSettings settings) {
    return MaterialPageRoute(
      settings: settings,
      builder: (context) => _buildRoute(context, settings),
    );
  }

  Widget _buildRoute(BuildContext context, RouteSettings settings) {
    Widget wrapWithProviders(Widget child) {
      return MultiProvider(
        providers: [
          ChangeNotifierProvider.value(value: authGuard),
          ChangeNotifierProvider.value(value: appState),
        ],
        child: child,
      );
    }

    final List<String> setupRoutes = [
      '/pass_setup',
      '/cipher_setup',
      '/net_setup',
      '/gen_bip39',
      '/gen_sk',
      '/verify_bip39',
      '/restore_options',
      '/gen_options',
      '/new_wallet_options',
      '/initial',
      '/ledger_connect',
      '/wallet',
      '/appearance',
      '/restore_bip39',
      '/currency',
      '/notifications',
      '/language',
      '/address-book',
      '/security',
      '/networks',
      '/send',
      '/receive',
      '/add_token',
      '/reveal_sk',
      '/reveal_bip39',
    ];

    if (settings.name == '/ledger_connect') {
      return wrapWithProviders(const LedgerConnectPage());
    }

    if (settings.name == '/' || settings.name == null) {
      if (!authGuard.ready) {
        return wrapWithProviders(const InitialPage());
      } else if (!authGuard.enabled) {
        return wrapWithProviders(const LoginPage());
      } else {
        return wrapWithProviders(const MainPage());
      }
    }

    if (!authGuard.ready) {
      if (setupRoutes.contains(settings.name)) {
        switch (settings.name) {
          case '/pass_setup':
            return wrapWithProviders(const PasswordSetupPage());
          case '/restore_bip39':
            return wrapWithProviders(const RestoreSecretPhrasePage());
          case '/cipher_setup':
            return wrapWithProviders(const CipherSettingsPage());
          case '/net_setup':
            return wrapWithProviders(const SetupNetworkSettingsPage());
          case '/gen_bip39':
            return wrapWithProviders(const SecretPhraseGeneratorPage());
          case '/gen_sk':
            return wrapWithProviders(const SecretKeyGeneratorPage());
          case '/verify_bip39':
            return wrapWithProviders(const SecretPhraseVerifyPage());
          case '/restore_options':
            return wrapWithProviders(const RestoreWalletOptionsPage());
          case '/gen_options':
            return wrapWithProviders(const GenWalletOptionsPage());
          case '/new_wallet_options':
            return wrapWithProviders(const AddWalletOptionsPage());
          case '/initial':
            return wrapWithProviders(const InitialPage());
          default:
            return wrapWithProviders(const InitialPage());
        }
      }
      return wrapWithProviders(const InitialPage());
    }

    if (!authGuard.enabled) {
      if (settings.name == '/login') {
        return wrapWithProviders(const LoginPage());
      }

      if (setupRoutes.contains(settings.name)) {
        switch (settings.name) {
          case '/pass_setup':
            return wrapWithProviders(const PasswordSetupPage());
          case '/cipher_setup':
            return wrapWithProviders(const CipherSettingsPage());
          case '/net_setup':
            return wrapWithProviders(const SetupNetworkSettingsPage());
          case '/gen_sk':
            return wrapWithProviders(const SecretKeyGeneratorPage());
          case '/gen_bip39':
            return wrapWithProviders(const SecretPhraseGeneratorPage());
          case '/verify_bip39':
            return wrapWithProviders(const SecretPhraseVerifyPage());
          case '/restore_bip39':
            return wrapWithProviders(const RestoreSecretPhrasePage());
          case '/restore_options':
            return wrapWithProviders(const RestoreWalletOptionsPage());
          case '/gen_options':
            return wrapWithProviders(const GenWalletOptionsPage());
          case '/new_wallet_options':
            return wrapWithProviders(const AddWalletOptionsPage());
          case '/initial':
            return wrapWithProviders(const InitialPage());
          default:
            return wrapWithProviders(const LoginPage());
        }
      }
      return wrapWithProviders(const LoginPage());
    }

    switch (settings.name) {
      case '/login':
        return wrapWithProviders(const LoginPage());
      case '/':
        return wrapWithProviders(const MainPage());
      case '/receive':
        return wrapWithProviders(const ReceivePage());
      case '/add_token':
        return wrapWithProviders(const AddTokenPage());
      case '/history':
        return wrapWithProviders(const HistoryPage());
      case '/send':
        return wrapWithProviders(const SendTokenPage());
      case '/reveal_sk':
        return wrapWithProviders(const RevealSecretKey());
      case '/reveal_bip39':
        return wrapWithProviders(const RevealSecretPhrase());
      case '/browser':
        return wrapWithProviders(const BrowserPage());
      case '/wallet':
        return wrapWithProviders(const WalletPage());
      case '/appearance':
        return wrapWithProviders(const AppearanceSettingsPage());
      case '/notifications':
        return wrapWithProviders(const NotificationsSettingsPage());
      case '/address-book':
        return wrapWithProviders(const AddressBookPage());
      case '/language':
        return wrapWithProviders(const LanguagePage());
      case '/networks':
        return wrapWithProviders(const NetworkPage());
      case '/security':
        return wrapWithProviders(const SecurityPage());
      case '/settings':
        return wrapWithProviders(const SettingsPage());
      case '/currency':
        return wrapWithProviders(const CurrencyConversionPage());
      case '/pass_setup':
        return wrapWithProviders(const PasswordSetupPage());
      case '/cipher_setup':
        return wrapWithProviders(const CipherSettingsPage());
      case '/net_setup':
        return wrapWithProviders(const SetupNetworkSettingsPage());
      case '/gen_sk':
        return wrapWithProviders(const SecretKeyGeneratorPage());
      case '/gen_bip39':
        return wrapWithProviders(const SecretPhraseGeneratorPage());
      case '/verify_bip39':
        return wrapWithProviders(const SecretPhraseVerifyPage());
      case '/restore_options':
        return wrapWithProviders(const RestoreWalletOptionsPage());
      case '/gen_options':
        return wrapWithProviders(const GenWalletOptionsPage());
      case '/new_wallet_options':
        return wrapWithProviders(const AddWalletOptionsPage());
      case '/restore_bip39':
        return wrapWithProviders(const RestoreSecretPhrasePage());
      case '/initial':
        return wrapWithProviders(const InitialPage());
      default:
        return wrapWithProviders(const MainPage());
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/gas_eip1559.dart`:

```dart
import 'package:zilpay/src/rust/models/ftoken.dart';

enum GasFeeOption { low, market, aggressive }

BigInt calculateMaxPriorityFee(GasFeeOption option, BigInt priorityFee) {
  switch (option) {
    case GasFeeOption.low:
      return BigInt.zero;
    case GasFeeOption.market:
      return priorityFee * BigInt.from(150) ~/ BigInt.from(100);
    case GasFeeOption.aggressive:
      return priorityFee * BigInt.from(300) ~/ BigInt.from(100);
  }
}

BigInt calculateMaxFeePerGas(
  GasFeeOption option,
  BigInt baseFee,
  BigInt priorityFee,
) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);
  switch (option) {
    case GasFeeOption.low:
      return baseFee + maxPriorityFee;
    case GasFeeOption.market:
      return baseFee +
          maxPriorityFee +
          (baseFee * BigInt.from(20) ~/ BigInt.from(100));
    case GasFeeOption.aggressive:
      return baseFee +
          maxPriorityFee +
          (baseFee * BigInt.from(50) ~/ BigInt.from(100));
  }
}

BigInt calculateFeeForOption(
    GasFeeOption option, BigInt baseFee, BigInt priorityFee) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);
  final maxFeePerGas = calculateMaxFeePerGas(option, baseFee, priorityFee);
  final minRequired = baseFee + maxPriorityFee;

  if (maxFeePerGas < minRequired) {
    return minRequired;
  }

  return maxFeePerGas;
}

BigInt calculateEffectiveGasPrice(
    GasFeeOption option, BigInt baseFee, BigInt priorityFee) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);
  final maxFeePerGas = calculateMaxFeePerGas(option, baseFee, priorityFee);

  final availablePriorityFee = maxFeePerGas - baseFee;

  final effectivePriorityFee = maxPriorityFee < availablePriorityFee
      ? maxPriorityFee
      : availablePriorityFee;

  return baseFee + effectivePriorityFee;
}

BigInt calculateTotalGasCost(
    GasFeeOption option, BigInt baseFee, BigInt priorityFee, BigInt gasLimit) {
  final effectiveGasPrice =
      calculateEffectiveGasPrice(option, baseFee, priorityFee);
  return effectiveGasPrice * gasLimit;
}

String formatGasPriceDetail(BigInt price, FTokenInfo token) {
  final gwei = price / BigInt.from(10).pow(9);

  if (gwei < 0.1) {
    return '${price.toString()} Wei';
  } else if (gwei < 1000000) {
    return '${gwei.toStringAsFixed(2)} Gwei';
  } else {
    final eth = price / BigInt.from(10).pow(18);
    return '${eth.toStringAsFixed(6)} ${token.symbol}';
  }
}

String formatGasPrice(BigInt price, int decimals, String symbol) {
  final value = price / BigInt.from(10).pow(decimals);
  return '${value.toStringAsFixed(5)} $symbol';
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/wallet_type.dart`:

```dart
enum WalletType {
  ledger,
  // ignore: constant_identifier_names
  SecretPhrase,
  // ignore: constant_identifier_names
  SecretKey,
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/qrcode.dart`:

```dart
import 'package:zilpay/config/ftokens.dart';

String generateCryptoUrl({
  required String address,
  required String chain,
  String? token,
  String? amount,
}) {
  final buffer = StringBuffer('$chain:$address');

  if (token != null && token != zeroZIL && token != zeroEVM) {
    buffer.write('?token=$token');

    if (amount != null && amount.isNotEmpty && amount != "0") {
      buffer.write('&amount=$amount');
    }
  } else if (amount != null && amount.isNotEmpty && amount != "0") {
    buffer.write('?amount=$amount');
  }

  return buffer.toString();
}

String generateQRSecretData({
  required String chain,
  String? seedPhrase,
  String? privateKey,
}) {
  final params = <String>[];

  if (seedPhrase != null) {
    params.add('seed=$seedPhrase');
  }

  if (privateKey != null) {
    params.add('key=$privateKey');
  }

  return '$chain:?${params.join('&')}';
}

Map<String, String> parseQRSecretData(String qrData) {
  final result = <String, String>{};

  final parts = qrData.split(':?');
  if (parts.length != 2) return result;

  result['chain'] = parts[0];

  final params = parts[1].split('&');
  for (final param in params) {
    final keyValue = param.split('=');
    if (keyValue.length == 2) {
      if (keyValue[0] == 'seed') result['seed'] = keyValue[1];
      if (keyValue[0] == 'key') result['key'] = keyValue[1];
    }
  }

  return result;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/colors.dart`:

```dart
import 'dart:ui';

Color getWalletColor(int index) {
  final colors = [
    const Color(0xFF55A2F2),
    const Color(0xFFFFB347),
    const Color(0xFF4ECFB0),
  ];

  return colors[index % colors.length];
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/icon.dart`:

```dart
import 'package:zilpay/src/rust/models/ftoken.dart';

String cnd =
    "https://raw.githubusercontent.com/spothq/cryptocurrency-icons/master/svg";

String viewTokenIcon(FTokenInfo token, BigInt chainId, String? theme) {
  if (token.native) {
    return chainIcon(token.symbol, theme);
  }

  switch (chainId.toInt()) {
    case 32770: // ZIL
      final color = theme == "Light" ? 'dark' : 'light';
      return 'https://meta.viewblock.io/zilliqa.${token.addr}/logo?t=$color';
    case 56: // BSC
      return "https://pancakeswap.finance/images/tokens/${token.addr}.png";
    case 1: // ETH
      return "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${token.addr}/logo.png";
    default:
      return "";
  }
}

String chainIcon(String symbol, String? theme) {
  if (symbol.startsWith("t")) {
    symbol = symbol.replaceFirst("t", "");
  }

  String color = theme == null
      ? "color"
      : theme == "Light"
          ? 'black'
          : 'white';

  return "$cnd/$color/$symbol.svg".toLowerCase();
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/adaptive_size.dart`:

```dart
import 'package:flutter/material.dart';

class AdaptiveSize {
  static double getAdaptivePadding(
      BuildContext context, double defaultPadding) {
    final size = MediaQuery.of(context).size;

    if (size.width <= 375) {
      return defaultPadding / 2;
    }

    return defaultPadding;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/amount.dart`:

```dart
import 'dart:math';

import 'package:intl/intl.dart';
import 'package:zilpay/state/app_state.dart';

String formatAmount(BigInt amount) {
  final BigInt billion = BigInt.from(1e9);
  final BigInt million = BigInt.from(1e6);

  if (amount >= billion) {
    double result = amount.toDouble() / 1e9;
    return '${result.toStringAsFixed(2)}B';
  } else if (amount >= million) {
    double result = amount.toDouble() / 1e6;
    return '${result.toStringAsFixed(2)}M';
  } else {
    return amount.toDouble().toStringAsFixed(2);
  }
}

BigInt adjustAmount(BigInt rawBalance, int decimals) {
  // Calculate divisor (10 ** decimals)
  BigInt divisor = BigInt.from(10).pow(decimals);

  // Perform the division
  return rawBalance ~/ divisor;
}

double adjustAmountToDouble(BigInt rawBalance, int decimals) {
  if (rawBalance == BigInt.zero) {
    return 0;
  }
  // Calculate divisor (10 ** decimals)
  BigInt divisor = BigInt.from(10).pow(decimals);

  // Convert to double for decimal places
  return rawBalance.toDouble() / divisor.toDouble();
}

String formatBigNumber(double number) {
  final formatter = NumberFormat('#,##0.000', 'en_US');

  return formatter.format(number);
}

String formatCompactNumber(double value) {
  if (value == 0.0) {
    return "0";
  }
  if (value < 1) {
    return value.toStringAsFixed(6);
  }

  final suffixes = ['', 'K', 'M', 'B', 'T'];
  var suffixIndex = 0;

  while (value >= 1000 && suffixIndex < suffixes.length - 1) {
    value /= 1000;
    suffixIndex++;
  }

  if (value % 1 != 0) {
    return '${value.toStringAsFixed(1)}${suffixes[suffixIndex]}';
  } else {
    return '${value.toInt()}${suffixes[suffixIndex]}';
  }
}

String getConvertedAmount(AppState state, double amount) {
  if (state.wallet?.settings.currencyConvert?.isEmpty ?? true) {
    return '-';
  }

  String currency = state.wallet!.settings.currencyConvert!;
  double? converted = state.rates[currency];

  if (converted == null) {
    return '-';
  }

  return formatCompactNumber(converted * amount);
}

BigInt toWei(String amount, int decimals) {
  return BigInt.from(double.parse(amount) * pow(10, decimals));
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/mixins/addr.dart`:

```dart
String shortenAddress(String address, {int leftSize = 6, int rightSize = 3}) {
  if (address.length < (leftSize + rightSize)) {
    return address;
  }

  final left = address.substring(0, leftSize);
  final right = address.substring(address.length - rightSize);

  return '$left..$right';
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/config/ftokens.dart`:

```dart
const zeroEVM = "0x0000000000000000000000000000000000000000";
const zeroZIL = "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz";

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/config/argon.dart`:

```dart
import 'package:zilpay/src/rust/models/settings.dart';

class Argon2DefaultParams {
  static WalletArgonParamsInfo owaspDefault({String secret = ''}) {
    return WalletArgonParamsInfo(
      secret: secret,
      memory: 6553,
      iterations: 2,
      threads: 1,
    );
  }

  static WalletArgonParamsInfo lowMemory({String secret = ''}) {
    return WalletArgonParamsInfo(
      memory: 64 * 1024,
      iterations: 3,
      threads: 1,
      secret: secret,
    );
  }

  static WalletArgonParamsInfo secure({String secret = ''}) {
    return WalletArgonParamsInfo(
      memory: 256 * 1024,
      iterations: 4,
      threads: 4,
      secret: secret,
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/config/providers.dart`:

```dart
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:zilpay/src/rust/models/provider.dart';

extension ChainConverter on Chain {
  NetworkConfigInfo toNetworkConfigInfo() {
    return NetworkConfigInfo(
      testnet: testnet,
      shortName: shortName,
      name: name,
      chain: chain,
      rpc: rpc.map((uri) => uri.toString()).toList(),
      features: Uint16List.fromList(
          features.map((f) => int.parse(f.replaceAll('EIP', ''))).toList()),
      chainId: BigInt.from(chainId),
      slip44: slip44,
      chainHash: BigInt.from(chainId),
      ens: ens?.registry ?? '',
      explorers: explorers
          .map((e) => ExplorerInfo(
                name: e.name,
                url: e.url.toString(),
                icon: e.icon,
                standard: e.standard.hashCode,
              ))
          .toList(),
      fallbackEnabled: true,
    );
  }
}

class Chain {
  Chain({
    required this.name,
    required this.chain,
    required this.rpc,
    required this.features,
    required this.faucets,
    required this.nativeCurrency,
    required this.infoURL,
    required this.shortName,
    required this.chainId,
    required this.networkId,
    required this.slip44,
    required this.explorers,
    this.ens,
    this.testnet,
  });

  bool? testnet;
  final String name;
  final String chain;
  final List<Uri> rpc;
  final List<String> features;
  final List<Uri> faucets;
  final NativeCurrency nativeCurrency;
  final Uri infoURL;
  final String shortName;
  final int chainId;
  final int networkId;
  final int slip44;
  final Ens? ens;
  final List<Explorer> explorers;

  factory Chain.fromJson(Map<String, dynamic> json) {
    return Chain(
      name: json['name'] as String? ?? '',
      chain: json['chain'] as String? ?? '',
      rpc: (json['rpc'] as List<dynamic>?)
              ?.map((e) => Uri.parse(e as String))
              .toList(growable: false) ??
          [],
      features: (json['features'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList(growable: false) ??
          [],
      faucets: (json['faucets'] as List<dynamic>?)
              ?.map((e) => Uri.parse(e as String))
              .toList(growable: false) ??
          [],
      nativeCurrency: NativeCurrency.fromJson(
        json['nativeCurrency'] as Map<String, dynamic>? ?? {},
      ),
      infoURL: Uri.parse(json['infoURL'] as String? ?? ''),
      shortName: json['shortName'] as String? ?? '',
      chainId: json['chainId'] as int? ?? 0,
      networkId: json['networkId'] as int? ?? 0,
      slip44: json['slip44'] as int? ?? 0,
      ens: json['ens'] != null
          ? Ens.fromJson(json['ens'] as Map<String, dynamic>)
          : null,
      explorers: (json['explorers'] as List<dynamic>?)
              ?.map((e) => Explorer.fromJson(e as Map<String, dynamic>))
              .toList(growable: false) ??
          [],
    );
  }
}

class NativeCurrency {
  const NativeCurrency({
    required this.name,
    required this.symbol,
    required this.decimals,
  });

  final String name;
  final String symbol;
  final int decimals;

  factory NativeCurrency.fromJson(Map<String, dynamic> json) {
    return NativeCurrency(
      name: json['name'] as String? ?? '',
      symbol: json['symbol'] as String? ?? '',
      decimals: json['decimals'] as int? ?? 18,
    );
  }

  Map<String, dynamic> toJson() => {
        'name': name,
        'symbol': symbol,
        'decimals': decimals,
      };
}

class Ens {
  const Ens({
    required this.registry,
  });

  final String registry;

  factory Ens.fromJson(Map<String, dynamic> json) {
    return Ens(
      registry: json['registry'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() => {
        'registry': registry,
      };
}

class Explorer {
  const Explorer({
    required this.name,
    required this.url,
    this.icon,
    required this.standard,
  });

  final String name;
  final Uri url;
  final String? icon;
  final String standard;

  factory Explorer.fromJson(Map<String, dynamic> json) {
    return Explorer(
      name: json['name'] as String? ?? '',
      url: Uri.parse(json['url'] as String? ?? ''),
      icon: json['icon'] as String?,
      standard: json['standard'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() => {
        'name': name,
        'url': url.toString(),
        if (icon != null) 'icon': icon,
        'standard': standard,
      };
}

class ChainService {
  static Future<Chain> loadChain(String jsonString) async {
    try {
      final Map<String, dynamic> jsonMap = json.decode(jsonString);
      return Chain.fromJson(jsonMap);
    } catch (e) {
      throw FormatException('Invalid chain JSON format: $e');
    }
  }

  static Future<List<Chain>> loadChains(String jsonString) async {
    try {
      final List<dynamic> jsonList = json.decode(jsonString);
      return jsonList
          .map((dynamic json) => Chain.fromJson(json as Map<String, dynamic>))
          .toList(growable: false);
    } catch (e) {
      throw FormatException('Invalid chains JSON format: $e');
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/secret_recovery_modal.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/state/app_state.dart';
import '../../components/button.dart';
import '../../theme/app_theme.dart';

class SecretRecoveryModal extends StatelessWidget {
  final AppTheme theme;

  const SecretRecoveryModal({
    super.key,
    required this.theme,
  });

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final walletType = appState.wallet!.walletType;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Center(
          child: Container(
            width: 32,
            height: 4,
            margin: const EdgeInsets.only(top: 8, bottom: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
        ),
        Padding(
          padding: EdgeInsets.fromLTRB(
            16,
            0,
            16,
            MediaQuery.of(context).viewInsets.bottom + 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (walletType.contains(WalletType.SecretPhrase.name)) ...[
                _buildOption(
                  title: 'Reveal Secret Recovery Phrase',
                  description: 'If you ever change browsers or move computers, '
                      'you will need this Secret Recovery Phrase to access '
                      'your accounts. Save them somewhere safe and secret.',
                  onPressed: () => _onRevealPhrase(context),
                  buttonText: 'Reveal',
                ),
                const SizedBox(height: 24)
              ],
              if (walletType.contains(WalletType.SecretKey.name) ||
                  walletType.contains(WalletType.SecretPhrase.name)) ...[
                _buildOption(
                  title: 'Show Private Keys',
                  description:
                      'Warning: Never disclose this key. Anyone with your '
                      'private keys can steal any assets held in your account.',
                  onPressed: () => _onShowPrivateKeys(context),
                  buttonText: 'Export',
                ),
                const SizedBox(height: 16),
              ]
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildOption({
    required String title,
    required String description,
    required VoidCallback onPressed,
    required String buttonText,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: TextStyle(
            color: theme.textPrimary,
            fontSize: 18,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          description,
          style: TextStyle(
            color: theme.textSecondary,
            fontSize: 14,
          ),
        ),
        const SizedBox(height: 16),
        SizedBox(
          width: double.infinity,
          child: CustomButton(
            text: buttonText,
            onPressed: onPressed,
            backgroundColor: Colors.red.withValues(alpha: 0.1),
            textColor: Colors.red,
            height: 48,
          ),
        ),
      ],
    );
  }

  void _onRevealPhrase(BuildContext context) {
    Navigator.of(context).pushNamed('/reveal_bip39');
  }

  void _onShowPrivateKeys(BuildContext context) {
    Navigator.of(context).pushNamed('/reveal_sk');
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/qr_scanner_modal.dart`:

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

void showQRScannerModal({
  required BuildContext context,
  required Function(String) onScanned,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return SizedBox(
        height: MediaQuery.of(context).size.height * 0.94,
        child: _QRScannerModalContent(
          onScanned: onScanned,
        ),
      );
    },
  );
}

class _QRScannerModalContent extends StatefulWidget {
  final Function(String) onScanned;

  const _QRScannerModalContent({
    required this.onScanned,
  });

  @override
  State<_QRScannerModalContent> createState() => _QRScannerModalContentState();
}

class _QRScannerModalContentState extends State<_QRScannerModalContent>
    with WidgetsBindingObserver {
  late MobileScannerController controller;
  StreamSubscription<Object?>? _subscription;
  bool hasError = false;
  String errorMessage = '';

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    controller = MobileScannerController(
      formats: [BarcodeFormat.qrCode],
    );

    _initializeScanner();
  }

  Future<void> _initializeScanner() async {
    try {
      _subscription = controller.barcodes.listen(_handleBarcode);
      await controller.start();
      if (!mounted) return;

      setState(() {
        hasError = !controller.value.isInitialized;
        errorMessage = 'Camera permission denied';
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        hasError = true;
        errorMessage = e.toString();
      });
    }
  }

  void _handleBarcode(Object? capture) {
    if (capture == null) return;

    if (capture is BarcodeCapture) {
      final String? code = capture.barcodes.first.rawValue;
      if (code != null) {
        widget.onScanned(code);
        Navigator.pop(context);
      }
    }
  }

  Future<void> _openAppSettings() async {
    if (!mounted) return;
    await controller.stop();

    // ignore: use_build_context_synchronously
    if (Theme.of(context).platform == TargetPlatform.iOS) {
      await openAppSettings();
    } else {
      await openAppSettings();
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    unawaited(_subscription?.cancel());
    _subscription = null;
    controller.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (hasError) return;

    switch (state) {
      case AppLifecycleState.resumed:
        _subscription = controller.barcodes.listen(_handleBarcode);
        unawaited(controller.start());
        break;
      case AppLifecycleState.inactive:
        unawaited(_subscription?.cancel());
        _subscription = null;
        unawaited(controller.stop());
        break;
      default:
        break;
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return Container(
      decoration: const BoxDecoration(
        color: Colors.black,
        borderRadius: BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        children: [
          _buildHeader(theme),
          const SizedBox(height: 20),
          // Modified scanner container
          hasError ? _buildErrorView() : _buildScannerView(theme),
          const SizedBox(height: 30),
        ],
      ),
    );
  }

  Widget _buildHeader(AppTheme theme) {
    return Column(
      children: [
        Container(
          width: 36,
          height: 4,
          margin: const EdgeInsets.symmetric(vertical: 16),
          decoration: BoxDecoration(
            color: Colors.white.withValues(alpha: 0.5),
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Scan',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                ),
              ),
              IconButton(
                  onPressed: () => Navigator.pop(context),
                  icon: SvgPicture.asset(
                    'assets/icons/close.svg',
                    width: 24,
                    height: 24,
                    colorFilter: ColorFilter.mode(
                      theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  )),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildErrorView() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.camera_alt_outlined,
              color: Colors.white54,
              size: 64,
            ),
            const SizedBox(height: 24),
            const Text(
              'Camera Access Required',
              style: TextStyle(
                color: Colors.white,
                fontSize: 20,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 12),
            Text(
              errorMessage,
              textAlign: TextAlign.center,
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 16,
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _openAppSettings,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 12,
                ),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Open Settings',
                style: TextStyle(
                  color: Colors.black,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildScannerView(AppTheme theme) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: MediaQuery.of(context).size.width * 0.8,
            height: MediaQuery.of(context).size.width * 0.8,
            margin: const EdgeInsets.symmetric(horizontal: 24),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(16),
              child: MobileScanner(
                controller: controller,
                overlayBuilder: (context, constraints) {
                  return Container(
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: Colors.white,
                        width: 3,
                      ),
                      borderRadius: BorderRadius.circular(16),
                    ),
                  );
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/backup_confirmation_modal.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

void showBackupConfirmationModal({
  required BuildContext context,
  required Function(bool) onConfirmed,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _BackupConfirmationContent(
          onConfirmed: onConfirmed,
        ),
      );
    },
  );
}

class _BackupConfirmationContent extends StatefulWidget {
  final Function(bool) onConfirmed;

  const _BackupConfirmationContent({
    required this.onConfirmed,
  });

  @override
  State<_BackupConfirmationContent> createState() =>
      _BackupConfirmationContentState();
}

class _BackupConfirmationContentState
    extends State<_BackupConfirmationContent> {
  final Map<String, bool> _confirmations = {
    'I have written down all': false,
    'I have safely stored the backup': false,
    'I am sure I won\'t lose the backup': false,
    'I understand not to share these words with anyone': false,
  };

  void _updateConfirmation(String key, bool value) {
    setState(() {
      _confirmations[key] = value;
    });

    if (_confirmations.values.every((confirmed) => confirmed)) {
      widget.onConfirmed(true);
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              'Backup Confirmation',
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          ..._confirmations.entries.map((entry) => _ConfirmationItem(
                text: entry.key,
                isConfirmed: entry.value,
                onConfirmed: (value) => _updateConfirmation(entry.key, value),
                theme: theme,
              )),
          const SizedBox(height: 24),
        ],
      ),
    );
  }
}

class _ConfirmationItem extends StatelessWidget {
  final String text;
  final bool isConfirmed;
  final Function(bool) onConfirmed;
  final AppTheme theme;

  const _ConfirmationItem({
    required this.text,
    required this.isConfirmed,
    required this.onConfirmed,
    required this.theme,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 2),
      child: Container(
        decoration: BoxDecoration(
          color: isConfirmed
              ? theme.background
              : theme.background.withValues(alpha: 0.2),
          borderRadius: BorderRadius.circular(12),
        ),
        child: CheckboxListTile(
          title: Text(
            text,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
          value: isConfirmed,
          onChanged: (value) => onConfirmed(value!),
          controlAffinity: ListTileControlAffinity.leading,
          activeColor: theme.primaryPurple,
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/manage_connections.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart' as theme;

void showConnectedDappsModal({
  required BuildContext context,
  Function(String)? onDappDisconnect,
}) {
  showModalBottomSheet(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _ConnectedDappsModalContent(
          onDappDisconnect: onDappDisconnect,
        ),
      );
    },
  );
}

class _ConnectedDappsModalContent extends StatefulWidget {
  final Function(String)? onDappDisconnect;

  const _ConnectedDappsModalContent({
    this.onDappDisconnect,
  });

  @override
  State<_ConnectedDappsModalContent> createState() =>
      _ConnectedDappsModalContentState();
}

class _ConnectedDappsModalContentState
    extends State<_ConnectedDappsModalContent> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final appState = Provider.of<AppState>(context);
    final connectedDapps = appState.connections;

    // Calculate container height based on content
    final double headerHeight = 84.0;
    final double searchBarHeight = 80.0;
    final double dappItemHeight = 72.0;
    final double bottomPadding = MediaQuery.of(context).padding.bottom;

    // Calculate total content height
    final double totalContentHeight = headerHeight +
        searchBarHeight +
        (connectedDapps.length * dappItemHeight) +
        bottomPadding;

    // Limit height to 70% of screen height
    final double maxHeight = MediaQuery.of(context).size.height * 0.7;
    final double containerHeight = totalContentHeight.clamp(0.0, maxHeight);

    return Container(
      height: containerHeight,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Drag Handle
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),

          // Search Bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: SmartInput(
              controller: _searchController,
              hint: 'Search DApps',
              onChanged: (value) => setState(() => _searchQuery = value),
              borderColor: theme.textPrimary,
              focusedBorderColor: theme.primaryPurple,
              height: 48,
              fontSize: 16,
              padding: const EdgeInsets.symmetric(horizontal: 16),
            ),
          ),

          // DApps List
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              children: _buildDappItems(theme, appState),
            ),
          ),

          // Bottom Padding
          SizedBox(height: bottomPadding),
        ],
      ),
    );
  }

  List<Widget> _buildDappItems(theme.AppTheme theme, AppState appState) {
    if (appState.wallet == null) {
      return [];
    }

    final filteredDapps = appState.connections
        .where((dapp) =>
            dapp.domain.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            dapp.title.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();

    final List<Widget> items = [];
    for (var i = 0; i < filteredDapps.length; i++) {
      final dapp = filteredDapps[i];
      items.add(
        _DappListItem(
          name: dapp.title,
          url: dapp.domain,
          iconUrl: dapp.favicon ?? "",
          lastConnected: fromLargeBigInt(dapp.lastConnected),
          onDisconnect: () => widget.onDappDisconnect?.call(dapp.domain),
        ),
      );

      // Add divider if not the last item
      if (i < filteredDapps.length - 1) {
        items.add(
          Divider(
            height: 1,
            color: theme.textSecondary.withValues(alpha: 0.1),
          ),
        );
      }
    }

    return items;
  }

  DateTime fromLargeBigInt(BigInt timestamp) {
    return DateTime.fromMillisecondsSinceEpoch(int.parse(timestamp.toString()));
  }
}

class _DappListItem extends StatelessWidget {
  final String name;
  final String url;
  final String iconUrl;
  final DateTime lastConnected;
  final VoidCallback? onDisconnect;

  const _DappListItem({
    required this.name,
    required this.url,
    required this.iconUrl,
    required this.lastConnected,
    this.onDisconnect,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    const double iconSize = 40.0;

    return Container(
      margin: EdgeInsets.zero,
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Container(
            width: iconSize,
            height: iconSize,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: Image.network(
                iconUrl,
                width: iconSize,
                height: iconSize,
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) {
                  return Container(
                    width: iconSize,
                    height: iconSize,
                    decoration: BoxDecoration(
                      color: theme.textSecondary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Center(
                      child: Icon(
                        Icons.link,
                        size: 24,
                        color: theme.textSecondary.withValues(alpha: 0.5),
                      ),
                    ),
                  );
                },
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return Container(
                    width: iconSize,
                    height: iconSize,
                    decoration: BoxDecoration(
                      color: theme.textSecondary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Center(
                      child: SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: theme.textSecondary.withValues(alpha: 0.5),
                          value: loadingProgress.expectedTotalBytes != null
                              ? loadingProgress.cumulativeBytesLoaded /
                                  loadingProgress.expectedTotalBytes!
                              : null,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    height: 1.2,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  url,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                    height: 1.2,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  'Connected ${_formatLastConnected(lastConnected)}',
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 12,
                    height: 1.2,
                  ),
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: onDisconnect,
            icon: SvgPicture.asset(
              'assets/icons/disconnect.svg',
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(theme.danger, BlendMode.srcIn),
            ),
          ),
        ],
      ),
    );
  }

  String _formatLastConnected(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays > 0) {
      return '${difference.inDays}d ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}h ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes}m ago';
    } else {
      return 'just now';
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/ledger_connect_dialog.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:zilpay/components/biometric_switch.dart';
import 'package:zilpay/components/counter.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class LedgerConnectDialog extends StatefulWidget {
  final String? walletName;
  final AuthMethod biometricType;
  final VoidCallback? onClose;
  final Future<void> Function(int, String, bool)? onConnect;

  const LedgerConnectDialog({
    super.key,
    this.onClose,
    this.onConnect,
    this.biometricType = AuthMethod.none,
    this.walletName = 'Ledger',
  });

  @override
  State<LedgerConnectDialog> createState() => _LedgerConnectDialog();
}

class _LedgerConnectDialog extends State<LedgerConnectDialog> {
  final _btnController = RoundedLoadingButtonController();
  final _walletNameController = TextEditingController();

  int _index = 0;
  bool _loading = false;
  bool _useBiometric = false;
  String _errorMessage = '';

  @override
  void initState() {
    super.initState();
    _walletNameController.text = widget.walletName!;
  }

  Future<void> _onConnect() async {
    if (_walletNameController.text.trim().isEmpty) {
      setState(() => _errorMessage = 'Wallet name cannot be empty');
      return;
    }

    if (_walletNameController.text.length > 24) {
      setState(() => _errorMessage = 'Wallet name is too long');
      return;
    }

    if (widget.onConnect != null) {
      try {
        setState(() {
          _loading = true;
          _errorMessage = '';
        });
        _btnController.start();

        await widget.onConnect!(
            _index, _walletNameController.text, _useBiometric);

        _btnController.success();
        await Future.delayed(const Duration(milliseconds: 300));
      } catch (e) {
        setState(() => _errorMessage = e.toString());
        _btnController.error();
        await Future.delayed(const Duration(milliseconds: 500));
      } finally {
        if (mounted) {
          setState(() => _loading = false);
          _btnController.reset();
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final viewInsets = MediaQuery.of(context).viewInsets;
    final screenHeight = MediaQuery.of(context).size.height;
    final maxHeight = screenHeight - (screenHeight * 0.1);

    return AnimatedContainer(
      duration: const Duration(milliseconds: 20),
      padding: EdgeInsets.only(bottom: viewInsets.bottom),
      child: Wrap(
        children: [
          Container(
            constraints: BoxConstraints(
              maxHeight: maxHeight,
            ),
            decoration: BoxDecoration(
              color: theme.background,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(16),
                topRight: Radius.circular(16),
              ),
            ),
            child: SingleChildScrollView(
              physics: const ClampingScrollPhysics(),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const SizedBox(height: 8),
                  Container(
                    width: 36,
                    height: 4,
                    decoration: BoxDecoration(
                      color: Colors.grey[600],
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.all(24),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const SizedBox(height: 16),
                        SmartInput(
                          controller: _walletNameController,
                          hint: "Wallet Name",
                          fontSize: 18,
                          height: 50,
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                          focusedBorderColor: theme.primaryPurple,
                          disabled: _loading,
                          onChanged: (value) {
                            if (_errorMessage.isNotEmpty) {
                              setState(() => _errorMessage = '');
                            }
                          },
                        ),
                        if (_errorMessage.isNotEmpty) ...[
                          const SizedBox(height: 8),
                          Text(
                            _errorMessage,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                              fontWeight: FontWeight.w500,
                            ),
                            textAlign: TextAlign.center,
                          ),
                        ],
                        const SizedBox(height: 16),
                        Counter(
                          iconSize: 32,
                          iconColor: theme.textPrimary,
                          animationDuration: const Duration(milliseconds: 300),
                          numberStyle: TextStyle(
                            fontSize: 32,
                            fontWeight: FontWeight.bold,
                            color: theme.textPrimary,
                          ),
                          initialValue: 0,
                          disabled: _loading,
                          onChanged: !_loading
                              ? (value) {
                                  setState(() {
                                    _index = value;
                                  });
                                }
                              : null,
                        ),
                        const SizedBox(height: 16),
                        BiometricSwitch(
                          biometricType: widget.biometricType,
                          value: _useBiometric,
                          disabled: _loading,
                          onChanged: (value) {
                            setState(() => _useBiometric = value);
                          },
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: double.infinity,
                          child: RoundedLoadingButton(
                            controller: _btnController,
                            onPressed: _onConnect,
                            successIcon: SvgPicture.asset(
                              'assets/icons/ok.svg',
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.textPrimary,
                                BlendMode.srcIn,
                              ),
                            ),
                            child: Text(
                              'Connect',
                              style: TextStyle(
                                color: theme.textPrimary,
                                fontSize: 18,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(height: 16),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/select_address.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/modals/qr_scanner_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/api/qrcode.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart' as theme;

void showAddressSelectModal({
  required BuildContext context,
  required Function(QRcodeScanResultInfo, String) onAddressSelected,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _AddressSelectModalContent(
          onAddressSelected: onAddressSelected,
        ),
      );
    },
  );
}

class _AddressSelectModalContent extends StatefulWidget {
  final Function(QRcodeScanResultInfo, String) onAddressSelected;

  const _AddressSelectModalContent({
    required this.onAddressSelected,
  });

  @override
  State<_AddressSelectModalContent> createState() =>
      _AddressSelectModalContentState();
}

class _AddressSelectModalContentState
    extends State<_AddressSelectModalContent> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final appState = Provider.of<AppState>(context);

    final double headerHeight = 84.0;
    final double searchBarHeight = 80.0;
    final double sectionHeaderHeight = 40.0;
    final double addressItemHeight = 72.0;
    final double bottomPadding = MediaQuery.of(context).padding.bottom;

    // Calculate total height based on all sections
    final double totalContentHeight = headerHeight +
        searchBarHeight +
        (sectionHeaderHeight * 3) + // 3 section headers
        (addressItemHeight *
            (_getFilteredMyAccounts(appState).length +
                _getFilteredAddressBook(appState).length +
                _getFilteredHistory(appState).length)) +
        bottomPadding;

    final double maxHeight = MediaQuery.of(context).size.height * 0.8;
    final double containerHeight = totalContentHeight.clamp(0.0, maxHeight);

    return Container(
      height: containerHeight,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              'Select Address',
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 20,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: SmartInput(
              controller: _searchController,
              hint: 'Search / Address / ENS',
              leftIconPath: 'assets/icons/qrcode.svg',
              onChanged: (value) async {
                bool isAddress = await isCryptoAddress(addr: value);

                if (isAddress) {
                  QRcodeScanResultInfo params =
                      QRcodeScanResultInfo(recipient: value);
                  widget.onAddressSelected(params, "Unknown");
                  if (!mounted) return;
                  // ignore: use_build_context_synchronously
                  Navigator.pop(context);
                } else {
                  setState(() => _searchQuery = value);
                }
              },
              onLeftIconTap: () async {
                showQRScannerModal(
                  context: context,
                  onScanned: _parseQrcodRes,
                );
              },
              borderColor: theme.textPrimary,
              focusedBorderColor: theme.primaryPurple,
              height: 48,
              fontSize: 16,
              padding: const EdgeInsets.symmetric(horizontal: 16),
            ),
          ),
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              children: [
                _buildSection(
                  theme,
                  'My Accounts',
                  _getFilteredMyAccounts(appState),
                ),
                _buildSection(
                  theme,
                  'Address Book',
                  _getFilteredAddressBook(appState),
                ),
                _buildSection(
                  theme,
                  'History',
                  _getFilteredHistory(appState),
                ),
              ],
            ),
          ),
          SizedBox(height: bottomPadding),
        ],
      ),
    );
  }

  Widget _buildSection(
    theme.AppTheme theme,
    String title,
    List<AddressItem> items,
  ) {
    if (items.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: Text(
            title,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        ...List.generate(items.length, (index) {
          final item = items[index];
          return Column(
            children: [
              _buildAddressItem(theme, item),
              if (index < items.length - 1)
                Divider(
                  height: 1,
                  thickness: 1,
                  color: theme.textSecondary.withValues(alpha: 0.1),
                  endIndent: 16,
                ),
            ],
          );
        }),
        const SizedBox(height: 16),
      ],
    );
  }

  Widget _buildAddressItem(theme.AppTheme theme, AddressItem item) {
    return InkWell(
      onTap: () {
        QRcodeScanResultInfo params =
            QRcodeScanResultInfo(recipient: item.address);
        widget.onAddressSelected(params, item.name);
        Navigator.pop(context);
      },
      child: Container(
        height: 72,
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            ClipOval(
              child: SizedBox(
                width: 40,
                height: 40,
                child: Blockies(
                  seed: item.address,
                  color: getWalletColor(0),
                  bgColor: theme.primaryPurple,
                  spotColor: theme.background,
                  size: 8,
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    item.name,
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  Text(
                    shortenAddress(item.address),
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _parseQrcodRes(String data) async {
    try {
      QRcodeScanResultInfo parsed = await parseQrcodeStr(data: data);

      widget.onAddressSelected(parsed, "Unknown");
    } catch (e) {
      debugPrint("error parse qrcode: $e");
    }
  }

  List<AddressItem> _getFilteredMyAccounts(AppState appState) {
    if (appState.wallet == null) {
      return [];
    }

    final accounts = appState.wallet!.accounts;

    return accounts
        .where((account) =>
            account.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            account.addr.toLowerCase().contains(_searchQuery.toLowerCase()))
        .map((account) => AddressItem(
              name: account.name,
              address: account.addr,
            ))
        .toList();
  }

  List<AddressItem> _getFilteredAddressBook(AppState appState) {
    return appState.book
        .where((account) =>
            account.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            account.addr.toLowerCase().contains(_searchQuery.toLowerCase()))
        .map((account) => AddressItem(
              name: account.name,
              address: account.addr,
            ))
        .toList();
  }

  List<AddressItem> _getFilteredHistory(AppState appState) {
    // Implement filtering logic for history
    return []; // Return filtered list of historical addresses
  }
}

class AddressItem {
  final String name;
  final String address;

  AddressItem({
    required this.name,
    required this.address,
  });
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/manage_tokens.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart' as theme;

void showManageTokensModal({
  required BuildContext context,
  VoidCallback? onAddToken,
  Function(String)? onTokenToggle,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _ManageTokensModalContent(
          onAddToken: onAddToken,
        ),
      );
    },
  );
}

class _ManageTokensModalContent extends StatefulWidget {
  final VoidCallback? onAddToken;

  const _ManageTokensModalContent({
    this.onAddToken,
  });

  @override
  State<_ManageTokensModalContent> createState() =>
      _ManageTokensModalContentState();
}

class _ManageTokensModalContentState extends State<_ManageTokensModalContent> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final appState = Provider.of<AppState>(context);
    final tokens = appState.wallet?.tokens ?? [];

    final double headerHeight = 84.0;
    final double searchBarHeight = 80.0; // Search bar + padding
    final double tokenItemHeight = 56.0; // Height per token item
    final double bottomPadding = MediaQuery.of(context).padding.bottom;

    // Calculate total content height
    final double totalContentHeight = headerHeight +
        searchBarHeight +
        (tokens.length * tokenItemHeight) +
        bottomPadding;

    final double maxHeight = MediaQuery.of(context).size.height * 0.7;
    final double containerHeight = totalContentHeight.clamp(0.0, maxHeight);

    return Container(
      height: containerHeight,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: SmartInput(
              controller: _searchController,
              hint: 'Search',
              leftIconPath: 'assets/icons/plus.svg',
              onLeftIconTap: widget.onAddToken,
              onChanged: (value) => setState(() => _searchQuery = value),
              borderColor: theme.textPrimary,
              focusedBorderColor: theme.primaryPurple,
              height: 48,
              fontSize: 16,
              padding: const EdgeInsets.symmetric(horizontal: 16),
            ),
          ),
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              children: _buildTokenItems(theme, appState),
            ),
          ),
          SizedBox(height: bottomPadding),
        ],
      ),
    );
  }

  List<Widget> _buildTokenItems(theme.AppTheme theme, AppState appState) {
    if (appState.wallet == null) {
      return [];
    }

    return appState.wallet!.tokens
        .where((token) =>
            token.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            token.symbol.toLowerCase().contains(_searchQuery.toLowerCase()))
        .map((token) => _TokenListItem(
              symbol: token.symbol,
              name: token.name,
              addr: token.addr,
              isDefault: token.default_,
              iconUrl: viewTokenIcon(
                token,
                appState.chain!.chainId,
                theme.value,
              ),
              onToggle: (value) async {
                if (!value) {
                  final int index = appState.wallet!.tokens
                      .indexWhere((t) => t.addr == token.addr);

                  if (index == -1) {
                    return;
                  }

                  try {
                    await rmFtoken(
                      walletIndex: BigInt.from(appState.selectedWallet),
                      tokenIndex: BigInt.from(index),
                    );
                    await appState.syncData();
                  } catch (e) {
                    debugPrint("remove token error: $e");
                  }
                }
              },
              isEnabled: !token.default_,
            ))
        .toList();
  }
}

class _TokenListItem extends StatelessWidget {
  final String symbol;
  final String name;
  final String addr;
  final String iconUrl;
  final Function(bool)? onToggle;
  final bool isEnabled;
  final bool isDefault;

  const _TokenListItem({
    required this.symbol,
    required this.name,
    required this.addr,
    required this.iconUrl,
    required this.isEnabled,
    required this.isDefault,
    this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    const double iconSize = 32.0;

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Container(
            width: iconSize,
            height: iconSize,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(16),
              child: AsyncImage(
                url: iconUrl,
                width: iconSize,
                height: iconSize,
                fit: BoxFit.contain,
                errorWidget: Blockies(
                  seed: addr,
                  color: getWalletColor(0),
                  bgColor: theme.primaryPurple,
                  spotColor: theme.background,
                  size: 8,
                ),
                loadingWidget: const Center(
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                ),
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Text(
                      symbol,
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                        height: 1.2,
                      ),
                    ),
                    if (isDefault) ...[
                      const SizedBox(width: 8),
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 6,
                          vertical: 2,
                        ),
                        decoration: BoxDecoration(
                          color: theme.textSecondary.withValues(alpha: 0.1),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          'Default',
                          style: TextStyle(
                            color: theme.textSecondary,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  name,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                    height: 1.2,
                  ),
                ),
              ],
            ),
          ),
          Switch(
            value: isDefault ? true : isEnabled,
            onChanged: onToggle,
            activeColor: isDefault ? theme.textSecondary : theme.success,
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/transfer.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/gas_eip1559.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/swipe_button.dart';
import 'package:zilpay/components/token_transfer_amount.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/gas.dart';
import 'package:zilpay/src/rust/models/transactions/evm.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

void showConfirmTransactionModal({
  required BuildContext context,
  required TransactionRequestInfo tx,
  required String to,
  required String amount,
  required int tokenIndex,
  required VoidCallback onConfirm,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (context) => _ConfirmTransactionContent(
      tx: tx,
      tokenIndex: tokenIndex,
      amount: amount,
      to: to,
      onConfirm: onConfirm,
    ),
  );
}

class _ConfirmTransactionContent extends StatefulWidget {
  final TransactionRequestInfo tx;
  final String to;
  final int tokenIndex;
  final String amount;
  final VoidCallback onConfirm;

  const _ConfirmTransactionContent({
    required this.tx,
    required this.amount,
    required this.to,
    required this.tokenIndex,
    required this.onConfirm,
  });

  @override
  State<_ConfirmTransactionContent> createState() =>
      _ConfirmTransactionContentState();
}

class _ConfirmTransactionContentState
    extends State<_ConfirmTransactionContent> {
  GasInfo _gasInfo = GasInfo(
    gasPrice: BigInt.zero,
    maxPriorityFee: BigInt.zero,
    feeHistory: GasFeeHistoryInfo(
      maxFee: BigInt.zero,
      priorityFee: BigInt.zero,
      baseFee: BigInt.zero,
    ),
    txEstimateGas: BigInt.zero,
    blobBaseFee: BigInt.zero,
  );
  bool _loading = false;
  String? _error;
  BigInt _maxPriorityFee = BigInt.zero;

  bool get isEVM => widget.tx.evm != null;
  bool get hasError => _error != null;

  @override
  void initState() {
    super.initState();
    _handleModalOpen();
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 36,
              height: 4,
              margin: const EdgeInsets.symmetric(vertical: 16),
              decoration: BoxDecoration(
                color: theme.textSecondary.withValues(alpha: 0.5),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            if (hasError) _buildErrorMessage(theme),
            _buildTokenLogo(appState),
            const SizedBox(height: 4),
            _buildTransferDetails(appState),
            if (isEVM) ...[
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: GasEIP1559(
                  gasInfo: _gasInfo,
                  disabled: _gasInfo.gasPrice == BigInt.zero || _loading,
                  onChange: (BigInt maxPriorityFee) {
                    setState(() {
                      _maxPriorityFee = maxPriorityFee;
                    });
                  },
                ),
              ),
            ],
            const SizedBox(height: 24),
            _buildConfirmButton(theme),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorMessage(AppTheme theme) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          SvgPicture.asset(
            "assets/icons/warning.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.danger,
              BlendMode.srcIn,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              _error!,
              style: TextStyle(
                color: theme.danger,
                fontSize: 14,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfirmButton(AppTheme theme) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: SwipeButton(
        text: hasError ? "Unable to confirm" : "Confirm",
        onSwipeComplete: hasError
            ? () async {}
            : () async {
                try {
                  setState(() {
                    _loading = true;
                    _error = null;
                  });

                  if (!_hasEnoughBalance()) {
                    throw Exception(
                        'Insufficient balance for this transaction');
                  }

                  if (isEVM) {
                    TransactionRequestEVM newTx = TransactionRequestEVM(
                      nonce: widget.tx.evm!.nonce,
                      from: widget.tx.evm!.from,
                      to: widget.tx.evm!.to,
                      value: widget.tx.evm!.value,
                      data: widget.tx.evm!.data,
                      chainId: widget.tx.evm!.chainId,
                      accessList: widget.tx.evm!.accessList,
                      blobVersionedHashes: widget.tx.evm!.blobVersionedHashes,
                      // Fee
                      maxFeePerBlobGas: widget.tx.evm!.maxFeePerBlobGas,
                      maxPriorityFeePerGas: _maxPriorityFee,
                      gasLimit: _gasInfo.txEstimateGas,
                      gasPrice: _gasInfo.gasPrice,
                      maxFeePerGas:
                          (_gasInfo.feeHistory.baseFee * BigInt.from(2)) +
                              _maxPriorityFee,
                    );

                    print(
                        "maxPriorityFeePerGas: ${newTx.maxPriorityFeePerGas}");
                  } else {
                    await Future<void>.delayed(const Duration(seconds: 2));
                  }

                  widget.onConfirm();
                } catch (e) {
                  setState(() {
                    _error = e.toString();
                  });
                } finally {
                  setState(() {
                    _loading = false;
                  });
                }
              },
      ),
    );
  }

  Widget _buildTokenLogo(AppState state) {
    const double imageSize = 54;
    final theme = state.currentTheme;

    try {
      final token = state.wallet!.tokens
          .firstWhere((t) => t.symbol == widget.tx.metadata.tokenInfo?.symbol);
      final chainId =
          widget.tx.evm?.chainId ?? BigInt.from(widget.tx.scilla?.chainId ?? 0);

      return Container(
        width: imageSize,
        height: imageSize,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          border: Border.all(
            color: theme.primaryPurple.withValues(alpha: 0.1),
            width: 2,
          ),
        ),
        child: ClipOval(
          child: AsyncImage(
            url: viewTokenIcon(
              token,
              chainId,
              theme.value,
            ),
            width: imageSize,
            height: imageSize,
            fit: BoxFit.contain,
          ),
        ),
      );
    } catch (e) {
      setState(() {
        _error = 'Invalid token information';
      });
      return const SizedBox.shrink();
    }
  }

  Widget _buildTransferDetails(AppState appState) {
    try {
      final token = appState.wallet!.tokens[widget.tokenIndex];
      final signer = appState.account;

      if (signer == null) {
        throw Exception('No active account found');
      }

      return Container(
        padding: const EdgeInsets.all(16),
        child: TokenTransferAmount(
          fromAddress: signer.addr,
          fromName: signer.name,
          toAddress: widget.to,
          amount: widget.amount,
          symbol: token.symbol,
        ),
      );
    } catch (e) {
      setState(() {
        _error = 'Failed to load transfer details';
      });
      return const SizedBox.shrink();
    }
  }

  Future<void> _handleModalOpen() async {
    try {
      setState(() {
        _error = null;
      });

      final gas = await caclGasFee(params: widget.tx);

      if (!mounted) return;

      setState(() {
        _gasInfo = gas;
      });
    } catch (e) {
      if (!mounted) return;

      setState(() {
        _error = 'Failed to calculate gas fee: ${e.toString()}';
      });
    }
  }

  bool _hasEnoughBalance() {
    try {
      final appState = Provider.of<AppState>(context, listen: false);
      final token = appState.wallet!.tokens[widget.tokenIndex];
      final selectedAccount = appState.wallet!.selectedAccount;
      final amount = toWei(widget.amount, token.decimals);
      final balance = BigInt.parse(token.balances[selectedAccount] ?? "0");

      return balance >= amount;
    } catch (e) {
      return false;
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/select_token.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/token_select_item.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart' as theme;

void showTokenSelectModal({
  required BuildContext context,
  required Function(int) onTokenSelected,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _TokenSelectModalContent(
          onTokenSelected: onTokenSelected,
        ),
      );
    },
  );
}

class _TokenSelectModalContent extends StatefulWidget {
  final Function(int) onTokenSelected;

  const _TokenSelectModalContent({
    required this.onTokenSelected,
  });

  @override
  State<_TokenSelectModalContent> createState() =>
      _TokenSelectModalContentState();
}

class _TokenSelectModalContentState extends State<_TokenSelectModalContent> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final appState = Provider.of<AppState>(context);
    final tokens = appState.wallet?.tokens ?? [];

    final double headerHeight = 84.0;
    final double searchBarHeight = 80.0;
    final double tokenItemHeight = 72.0;
    final double bottomPadding = MediaQuery.of(context).padding.bottom;

    final double totalContentHeight = headerHeight +
        searchBarHeight +
        (tokens.length * tokenItemHeight) +
        bottomPadding;

    final double maxHeight = MediaQuery.of(context).size.height * 0.7;
    final double containerHeight = totalContentHeight.clamp(0.0, maxHeight);

    return Container(
      height: containerHeight,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: SmartInput(
              controller: _searchController,
              hint: 'Search',
              leftIconPath: 'assets/icons/search.svg',
              onChanged: (value) => setState(() => _searchQuery = value),
              borderColor: theme.textPrimary,
              focusedBorderColor: theme.primaryPurple,
              height: 48,
              fontSize: 16,
              padding: const EdgeInsets.symmetric(horizontal: 16),
            ),
          ),
          Expanded(
            child: ListView.separated(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              itemCount: _getFilteredTokens(appState).length,
              separatorBuilder: (context, index) => Divider(
                height: 1,
                color: theme.textSecondary.withValues(alpha: 0.1),
              ),
              itemBuilder: (context, index) {
                return _buildTokenItem(
                  theme,
                  appState,
                  _getFilteredTokens(appState)[index],
                );
              },
            ),
          ),
          SizedBox(height: bottomPadding),
        ],
      ),
    );
  }

  List<FTokenInfo> _getFilteredTokens(AppState appState) {
    if (appState.wallet == null) {
      return [];
    }

    final tokens = appState.wallet!.tokens;
    return tokens
        .where((token) =>
            token.name.toLowerCase().contains(_searchQuery.toLowerCase()) ||
            token.symbol.toLowerCase().contains(_searchQuery.toLowerCase()))
        .toList();
  }

  Widget _buildTokenItem(
    theme.AppTheme theme,
    AppState appState,
    FTokenInfo token,
  ) {
    final tokens = appState.wallet!.tokens;
    final tokenIndex = tokens.indexOf(token);
    final bigBalance =
        BigInt.parse(token.balances[appState.wallet!.selectedAccount] ?? '0');
    final balance = adjustAmountToDouble(bigBalance, token.decimals);

    return TokenSelectItem(
      addr: token.addr,
      symbol: token.symbol,
      name: token.name,
      balance: balance.toString(),
      iconUrl: viewTokenIcon(
        token,
        appState.chain!.chainId,
        theme.value,
      ),
      onTap: () {
        widget.onTokenSelected(tokenIndex);
        Navigator.pop(context);
      },
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/password_change.dart`:

```dart
import 'package:flutter/material.dart';
import '../../components/button.dart';
import '../../components/smart_input.dart';
import '../../theme/app_theme.dart';

class ChangePasswordModal extends StatefulWidget {
  final AppTheme theme;

  const ChangePasswordModal({
    super.key,
    required this.theme,
  });

  @override
  State<ChangePasswordModal> createState() => _ChangePasswordModalState();
}

class _ChangePasswordModalState extends State<ChangePasswordModal> {
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();

  final _currentPasswordInputKey = GlobalKey<SmartInputState>();
  final _newPasswordInputKey = GlobalKey<SmartInputState>();

  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _disabled = false;
  String _errorMessage = '';

  static const double _inputHeight = 50.0;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    super.dispose();
  }

  bool _validatePasswords() {
    if (_currentPasswordController.text.isEmpty) {
      _currentPasswordInputKey.currentState?.shake();
      setState(() {
        _errorMessage = 'Current password cannot be empty';
        _disabled = false;
      });
      return false;
    }

    if (_newPasswordController.text.length < 6) {
      _newPasswordInputKey.currentState?.shake();
      setState(() {
        _errorMessage = 'Password must be at least 8 characters';
        _disabled = false;
      });
      return false;
    }

    return true;
  }

  void _handleChangePassword(BuildContext context) {
    setState(() {
      _errorMessage = '';
      _disabled = true;
    });

    if (!_validatePasswords()) {
      return;
    }

    // Add password change logic here
    debugPrint('Change password clicked');
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Center(
          child: Container(
            width: 32,
            height: 4,
            margin: const EdgeInsets.only(top: 8, bottom: 16),
            decoration: BoxDecoration(
              color: widget.theme.textSecondary.withValues(alpha: 0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
        ),
        Padding(
          padding: EdgeInsets.fromLTRB(
            16,
            0,
            16,
            MediaQuery.of(context).viewInsets.bottom + 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Change Password',
                style: TextStyle(
                  color: widget.theme.textPrimary,
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Enter your current password and choose a new password to update your wallet security.',
                style: TextStyle(
                  color: widget.theme.textSecondary,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 24),
              SmartInput(
                key: _currentPasswordInputKey,
                controller: _currentPasswordController,
                hint: 'Current Password',
                height: _inputHeight,
                fontSize: 18,
                disabled: _disabled,
                padding: const EdgeInsets.symmetric(horizontal: 20),
                obscureText: _obscureCurrentPassword,
                rightIconPath: _obscureCurrentPassword
                    ? "assets/icons/close_eye.svg"
                    : "assets/icons/open_eye.svg",
                onRightIconTap: () {
                  setState(() {
                    _obscureCurrentPassword = !_obscureCurrentPassword;
                  });
                },
                onChanged: (value) {
                  if (_errorMessage.isNotEmpty) {
                    setState(() {
                      _errorMessage = '';
                    });
                  }
                },
              ),
              const SizedBox(height: 16),
              SmartInput(
                key: _newPasswordInputKey,
                controller: _newPasswordController,
                hint: 'New Password',
                height: _inputHeight,
                fontSize: 18,
                disabled: _disabled,
                padding: const EdgeInsets.symmetric(horizontal: 20),
                obscureText: _obscureNewPassword,
                rightIconPath: _obscureNewPassword
                    ? "assets/icons/close_eye.svg"
                    : "assets/icons/open_eye.svg",
                onRightIconTap: () {
                  setState(() {
                    _obscureNewPassword = !_obscureNewPassword;
                  });
                },
                onChanged: (value) {
                  if (_errorMessage.isNotEmpty) {
                    setState(() {
                      _errorMessage = '';
                    });
                  }
                },
              ),
              if (_errorMessage.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  _errorMessage,
                  style: TextStyle(
                    color: widget.theme.danger,
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: CustomButton(
                  text: 'Change Password',
                  onPressed: () => _handleChangePassword(context),
                  backgroundColor: widget.theme.primaryPurple,
                  textColor: widget.theme.textPrimary,
                  height: 48,
                ),
              ),
              const SizedBox(height: 24),
            ],
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/delete_wallet.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import '../../components/smart_input.dart';

class DeleteWalletModal extends StatefulWidget {
  const DeleteWalletModal({
    super.key,
  });

  @override
  State<DeleteWalletModal> createState() => _DeleteWalletModalState();
}

class _DeleteWalletModalState extends State<DeleteWalletModal> {
  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  bool _obscurePassword = true;
  bool _disabled = false;
  String _errorMessage = '';

  static const double _inputHeight = 50.0;

  @override
  void dispose() {
    _passwordController.dispose();
    super.dispose();
  }

  void _handleDeleteWallet(AppState state) async {
    if (_passwordController.text.isEmpty) {
      return;
    }

    _btnController.start();

    try {
      setState(() {
        _errorMessage = "";
        _disabled = true;
      });

      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      await deleteWallet(
        walletIndex: BigInt.from(state.selectedWallet),
        identifiers: identifiers,
        password: _passwordController.text,
      );
      await state.syncData();
      _btnController.success();
      if (!mounted) return;
      await Navigator.of(context).pushNamed(
        '/login',
      );
    } catch (e) {
      setState(() {
        _errorMessage = "$e";
        _disabled = false;
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Center(
          child: Container(
            width: 32,
            height: 4,
            margin: const EdgeInsets.only(top: 8, bottom: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
        ),
        Padding(
          padding: EdgeInsets.fromLTRB(
            16,
            0,
            16,
            MediaQuery.of(context).viewInsets.bottom + 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Delete Wallet',
                style: TextStyle(
                  color: theme.danger,
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Warning: This action cannot be undone. Your wallet can only be recovered using your secret phrase. If you don\'t have access to it, you will permanently lose all funds associated with this account.',
                style: TextStyle(
                  color: theme.warning,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Please make sure you have access to your secret phrase before proceeding.',
                style: TextStyle(
                  color: theme.danger,
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 24),
              SmartInput(
                key: _passwordInputKey,
                controller: _passwordController,
                hint: 'Enter Password',
                height: _inputHeight,
                fontSize: 18,
                disabled: _disabled,
                padding: const EdgeInsets.symmetric(horizontal: 20),
                obscureText: _obscurePassword,
                rightIconPath: _obscurePassword
                    ? "assets/icons/close_eye.svg"
                    : "assets/icons/open_eye.svg",
                onRightIconTap: () {
                  setState(() {
                    _obscurePassword = !_obscurePassword;
                  });
                },
                onChanged: (value) {
                  if (_errorMessage.isNotEmpty) {
                    setState(() {
                      _errorMessage = '';
                    });
                  }
                },
              ),
              if (_errorMessage.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  _errorMessage,
                  style: TextStyle(
                    color: theme.danger,
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: RoundedLoadingButton(
                  color: theme.danger,
                  onPressed: () => _handleDeleteWallet(appState),
                  controller: _btnController,
                  successIcon: SvgPicture.asset(
                    'assets/icons/ok.svg',
                    width: 24,
                    height: 24,
                    colorFilter: ColorFilter.mode(
                      theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  ),
                  child: Text(
                    'Submit',
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),
            ],
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/argon2.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/config/argon.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';

void showArgonSettingsModal({
  required BuildContext context,
  required Function(WalletArgonParamsInfo) onParamsSelected,
  required WalletArgonParamsInfo argonParams,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _ArgonSettingsModalContent(
          onParamsSelected: onParamsSelected,
          argonParams: argonParams,
        ),
      );
    },
  );
}

class _ArgonSettingsModalContent extends StatefulWidget {
  final Function(WalletArgonParamsInfo) onParamsSelected;
  final WalletArgonParamsInfo argonParams;

  const _ArgonSettingsModalContent({
    required this.onParamsSelected,
    required this.argonParams,
  });

  @override
  State<_ArgonSettingsModalContent> createState() =>
      _ArgonSettingsModalContentState();
}

class _ArgonSettingsModalContentState
    extends State<_ArgonSettingsModalContent> {
  final TextEditingController _secretController = TextEditingController();
  bool _obscurePassword = true;

  late int selectedParamIndex;

  final List<Map<String, String>> argonDescriptions = [
    {
      'title': 'Low Memory',
      'subtitle': '64KB RAM, 3 iterations',
      'description': 'Minimal memory usage, suitable for low-end devices.',
    },
    {
      'title': 'OWASP Default',
      'subtitle': '6.5MB RAM, 2 iterations',
      'description': 'Recommended by OWASP for general use.',
    },
    {
      'title': 'Secure',
      'subtitle': '256MB RAM, 4 iterations',
      'description': 'High security with increased memory and iterations.',
    },
  ];

  @override
  void initState() {
    super.initState();
    // Initialize with the provided argonParams
    selectedParamIndex = _getInitialParamIndex();
    _secretController.text = widget.argonParams.secret;
  }

  int _getInitialParamIndex() {
    // Logic to determine initial index based on provided argonParams
    if (widget.argonParams ==
        Argon2DefaultParams.lowMemory(secret: widget.argonParams.secret)) {
      return 0;
    } else if (widget.argonParams ==
        Argon2DefaultParams.secure(secret: widget.argonParams.secret)) {
      return 2;
    }
    return 1; // OWASP Default
  }

  @override
  void dispose() {
    _secretController.dispose();
    super.dispose();
  }

  WalletArgonParamsInfo _getSelectedParams() {
    final secret = _secretController.text;
    switch (selectedParamIndex) {
      case 0:
        return Argon2DefaultParams.lowMemory(secret: secret);
      case 1:
        return Argon2DefaultParams.owaspDefault(secret: secret);
      case 2:
        return Argon2DefaultParams.secure(secret: secret);
      default:
        return Argon2DefaultParams.owaspDefault(secret: secret);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final bottomPadding = MediaQuery.of(context).padding.bottom;

    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.8,
      ),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              physics: const BouncingScrollPhysics(),
              child: OptionsList(
                options: List.generate(
                  argonDescriptions.length,
                  (index) => OptionItem(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          argonDescriptions[index]['title']!,
                          style: TextStyle(
                            color: theme.textPrimary,
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          argonDescriptions[index]['subtitle']!,
                          style: TextStyle(
                            color: theme.primaryPurple,
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          argonDescriptions[index]['description']!,
                          style: TextStyle(
                            color: theme.textSecondary,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                    isSelected: selectedParamIndex == index,
                    onSelect: () => setState(() => selectedParamIndex = index),
                  ),
                ),
                unselectedOpacity: 0.5,
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: SmartInput(
              controller: _secretController,
              obscureText: _obscurePassword,
              rightIconPath: _obscurePassword
                  ? "assets/icons/close_eye.svg"
                  : "assets/icons/open_eye.svg",
              hint: 'Enter secret (optional)',
              borderColor: theme.textPrimary,
              focusedBorderColor: theme.primaryPurple,
              height: 48,
              fontSize: 16,
              padding: const EdgeInsets.symmetric(horizontal: 16),
              onRightIconTap: () {
                setState(() {
                  _obscurePassword = !_obscurePassword;
                });
              },
            ),
          ),
          Padding(
            padding: EdgeInsets.fromLTRB(16, 0, 16, 8 + bottomPadding),
            child: SizedBox(
              width: double.infinity,
              child: CustomButton(
                text: 'Confirm',
                onPressed: () {
                  widget.onParamsSelected(_getSelectedParams());
                  Navigator.pop(context);
                },
                backgroundColor: theme.primaryPurple,
                borderRadius: 30.0,
                height: 50.0,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/add_contect.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:zilpay/src/rust/api/book.dart';
import 'package:zilpay/state/app_state.dart';
import '../../components/button.dart';
import '../../components/smart_input.dart';
import '../../theme/app_theme.dart';

class AddAddressModal extends StatefulWidget {
  final AppTheme theme;
  final AppState state;

  const AddAddressModal({
    super.key,
    required this.theme,
    required this.state,
  });

  @override
  State<AddAddressModal> createState() => _AddAddressModalState();
}

class _AddAddressModalState extends State<AddAddressModal> {
  final _nameController = TextEditingController();
  final _addressController = TextEditingController();

  final _nameInputKey = GlobalKey<SmartInputState>();
  final _addressInputKey = GlobalKey<SmartInputState>();

  bool _disabled = false;
  String _errorMessage = '';

  static const double _inputHeight = 50.0;

  @override
  void dispose() {
    _nameController.dispose();
    _addressController.dispose();
    super.dispose();
  }

  bool _validateInputs() {
    if (_nameController.text.isEmpty) {
      _nameInputKey.currentState?.shake();
      setState(() {
        _errorMessage = 'Name cannot be empty';
        _disabled = false;
      });
      return false;
    }

    if (_addressController.text.isEmpty) {
      _addressInputKey.currentState?.shake();
      setState(() {
        _errorMessage = 'Address cannot be empty';
        _disabled = false;
      });
      return false;
    }

    return true;
  }

  Future<void> _handleAddAddress(BuildContext context) async {
    setState(() {
      _errorMessage = '';
      _disabled = true;
    });

    if (!_validateInputs()) {
      return;
    }

    try {
      await addNewBookAddress(
        name: _nameController.text,
        addr: _addressController.text,
        net: BigInt.zero, // Detect network from wallet
      );
      await widget.state.syncBook();
      if (!mounted) return;
      Navigator.pop(
        // ignore: use_build_context_synchronously
        context,
      );
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
        _disabled = true;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Center(
          child: Container(
            width: 32,
            height: 4,
            margin: const EdgeInsets.only(top: 16, bottom: 16),
            decoration: BoxDecoration(
              color: widget.theme.textSecondary.withValues(alpha: 0.3),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
        ),
        Padding(
          padding: EdgeInsets.fromLTRB(
            16,
            0,
            16,
            MediaQuery.of(context).viewInsets.bottom + 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Add Contact',
                style: TextStyle(
                  color: widget.theme.textPrimary,
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Enter the contact name and wallet address to add to your address book.',
                style: TextStyle(
                  color: widget.theme.textSecondary,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 24),
              SmartInput(
                key: _nameInputKey,
                controller: _nameController,
                hint: 'Name',
                height: _inputHeight,
                fontSize: 18,
                disabled: _disabled,
                padding: const EdgeInsets.symmetric(horizontal: 20),
                onChanged: (value) {
                  if (_errorMessage.isNotEmpty) {
                    setState(() {
                      _errorMessage = '';
                    });
                  }
                },
              ),
              const SizedBox(height: 8),
              SmartInput(
                key: _addressInputKey,
                controller: _addressController,
                hint: 'Wallet Address',
                height: _inputHeight,
                fontSize: 18,
                disabled: _disabled,
                padding: const EdgeInsets.symmetric(horizontal: 20),
                onChanged: (value) {
                  if (_errorMessage.isNotEmpty) {
                    setState(() {
                      _errorMessage = '';
                    });
                  }
                },
              ),
              if (_errorMessage.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  _errorMessage,
                  style: TextStyle(
                    color: widget.theme.danger,
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: CustomButton(
                  text: 'Add Contact',
                  onPressed: () => _handleAddAddress(context),
                  backgroundColor: widget.theme.primaryPurple,
                  textColor: widget.theme.textPrimary,
                  height: 48,
                ),
              ),
              const SizedBox(height: 24),
            ],
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/add_bip39_modal_page.dart`:

```dart
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:ledger_flutter/ledger_flutter.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:zilliqa_ledger_flutter/zilliqa_ledger_flutter.dart';
import 'package:zilpay/components/counter.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/ledger.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import '../../components/custom_app_bar.dart';
import '../../components/smart_input.dart';

class AddNextBip39AccountContent extends StatefulWidget {
  final VoidCallback onBack;

  const AddNextBip39AccountContent({
    super.key,
    required this.onBack,
  });

  @override
  State<AddNextBip39AccountContent> createState() =>
      _AddNextBip39AccountContentState();
}

class _AddNextBip39AccountContentState
    extends State<AddNextBip39AccountContent> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _passphraseController = TextEditingController();
  final _passwordController = TextEditingController();
  late AppState _appState;
  late AuthGuard _authGuard;

  int _index = 0;
  bool _loading = false;
  bool _obscurePassword = true;
  bool _obscurePassphrase = true;
  String _errorMessage = '';

  final _nameInputKey = GlobalKey<SmartInputState>();
  final _passphraseInputKey = GlobalKey<SmartInputState>();
  final _passwordInputKey = GlobalKey<SmartInputState>();

  @override
  void dispose() {
    _nameController.dispose();
    _passphraseController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _nameController.text = 'Account ${_appState.wallet!.accounts.length + 1}';
    _index = _appState.wallet!.accounts.length + 1;
  }

  bool _validateForm() {
    setState(() => _errorMessage = '');
    bool isValid = true;

    if (_nameController.text.trim().isEmpty) {
      _nameInputKey.currentState?.shake();
      setState(() => _errorMessage = 'Please enter account name');
      return false;
    }

    final bool isPhr = _appState.wallet!.walletType.split(".").last == "true";
    final bool needsPassphrase =
        _appState.wallet!.walletType.contains(WalletType.SecretPhrase.name) &&
            isPhr;

    if (needsPassphrase) {
      if (_passphraseController.text.trim().isEmpty) {
        _passphraseInputKey.currentState?.shake();
        setState(() => _errorMessage = 'Please enter passphrase');
        return false;
      }
    }

    final bool needsPassword =
        _appState.wallet!.authType == AuthMethod.none.name &&
            !_appState.wallet!.walletType.contains(WalletType.ledger.name);

    if (needsPassword) {
      if (_passwordController.text.isEmpty) {
        _passwordInputKey.currentState?.shake();
        setState(() => _errorMessage = 'Please enter password');
        return false;
      }
    }

    return isValid;
  }

  Future<void> _onSubmit() async {
    if (_validateForm()) {
      String session = "";

      try {
        session = await _authGuard.getSession(
            sessionKey: _appState.wallet!.walletAddress);
      } catch (e) {
        debugPrint("gettting session error: $e");
      }

      try {
        setState(() {
          _loading = true;
          _errorMessage = '';
        });
        BigInt chainHash = _appState.account!.chainHash;

        DeviceInfoService device = DeviceInfoService();
        List<String> identifiers = await device.getDeviceIdentifiers();

        if (_appState.wallet!.walletType
            .contains(WalletType.SecretPhrase.name)) {
          AddNextBip39AccountParams params = AddNextBip39AccountParams(
            walletIndex: BigInt.from(_appState.selectedWallet),
            accountIndex: BigInt.from(_index - 1),
            name: _nameController.text,
            passphrase: _passphraseController.text,
            identifiers: identifiers,
            password: _passwordController.text.isEmpty
                ? null
                : _passwordController.text,
            sessionCipher: session.isEmpty ? null : session,
            chainHash: chainHash,
          );

          await addNextBip39Account(
            params: params,
          );
        } else if (_appState.wallet!.walletType
            .contains(WalletType.ledger.name)) {
          final options = LedgerOptions();
          Ledger ledger = Ledger(
            options: options,
            onPermissionRequest: (status) async {
              Map<Permission, PermissionStatus> statuses = await [
                Permission.location,
                Permission.bluetoothScan,
                Permission.bluetoothConnect,
                Permission.bluetoothAdvertise,
              ].request();

              if (status != BleStatus.ready) {
                setState(() => _errorMessage = 'Bluetooth is not ready');
                return false;
              }

              if (statuses.values
                  .where((status) => status.isDenied)
                  .isNotEmpty) {
                setState(
                    () => _errorMessage = 'Required permissions were denied');
                return false;
              }

              return true;
            },
          );
          String uuid = _appState.wallet!.walletType.split(".").last;
          LedgerDevice device = LedgerDevice(
            id: uuid,
            name: _appState.wallet!.walletName,
            connectionType: ConnectionType.ble,
          );

          if (Platform.isAndroid) {
            List<LedgerDevice> devices = await ledger.listUsbDevices();

            final targetDevice = devices.firstWhere(
              (d) => d.id == uuid,
              orElse: () => device,
            );

            device = targetDevice;
          }

          ZilliqaLedgerApp ledgerZilliqa = ZilliqaLedgerApp(ledger);
          ({String publicKey, String address}) key =
              await ledgerZilliqa.getPublicAddress(device, _index - 1);

          await addLedgerAccount(
            walletIndex: BigInt.from(_appState.selectedWallet),
            accountIndex: BigInt.from(_index - 1),
            name: _nameController.text,
            pubKey: key.publicKey,
            identifiers: identifiers,
            sessionCipher: session.isEmpty ? null : session,
          );
        }
        await _appState.syncData();

        widget.onBack();
      } catch (e) {
        setState(() => _errorMessage = e.toString());
      } finally {
        if (mounted) {
          setState(() => _loading = false);
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;
    const inputHeight = 50.0;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    final bool isPhr = _appState.wallet!.walletType.split(".").last == "true";

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        CustomAppBar(
          title: '',
          onBackPressed: _loading ? () {} : widget.onBack,
          actionIcon: _loading
              ? SizedBox(
                  width: 24,
                  height: 24,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor:
                        AlwaysStoppedAnimation<Color>(theme.textPrimary),
                  ),
                )
              : SvgPicture.asset(
                  'assets/icons/plus.svg',
                  width: 30,
                  height: 30,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
          onActionPressed: _loading ? () {} : _onSubmit,
        ),
        Flexible(
          child: SingleChildScrollView(
            padding: EdgeInsets.only(
              left: 16,
              right: 16,
              top: 0,
              bottom: bottomInset > 0 ? bottomInset + 40.0 : 40.0,
            ),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  SmartInput(
                    key: _nameInputKey,
                    controller: _nameController,
                    hint: "Enter account name",
                    height: inputHeight,
                    fontSize: 18,
                    focusedBorderColor: theme.primaryPurple,
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    disabled: _loading,
                    onChanged: (value) => setState(() => _errorMessage = ''),
                  ),
                  SizedBox(height: adaptivePadding),
                  Counter(
                    iconSize: 32,
                    iconColor: theme.textPrimary,
                    minValue: 1,
                    maxValue: 255,
                    animationDuration: const Duration(milliseconds: 300),
                    numberStyle: TextStyle(
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                      color: theme.textPrimary,
                    ),
                    initialValue: _appState.wallet!.accounts.length + 1,
                    disabled: _loading,
                    onChanged: !_loading
                        ? (value) {
                            setState(() {
                              _index = value;
                              _nameController.text = 'Account $value';
                            });
                          }
                        : null,
                  ),
                  if (_appState.wallet!.walletType
                          .contains(WalletType.SecretPhrase.name) &&
                      isPhr) ...[
                    SizedBox(height: adaptivePadding),
                    SmartInput(
                      key: _passphraseInputKey,
                      controller: _passphraseController,
                      hint: "Enter passphrase",
                      height: inputHeight,
                      fontSize: 18,
                      obscureText: _obscurePassphrase,
                      focusedBorderColor: theme.primaryPurple,
                      padding: const EdgeInsets.symmetric(horizontal: 20),
                      disabled: _loading,
                      rightIconPath: _obscurePassphrase
                          ? "assets/icons/close_eye.svg"
                          : "assets/icons/open_eye.svg",
                      onRightIconTap: _loading
                          ? null
                          : () => setState(
                              () => _obscurePassphrase = !_obscurePassphrase),
                      onChanged: (value) => setState(() => _errorMessage = ''),
                    ),
                  ],
                  if (_appState.wallet!.authType == AuthMethod.none.name &&
                      !_appState.wallet!.walletType
                          .contains(WalletType.ledger.name)) ...[
                    SizedBox(height: adaptivePadding),
                    SmartInput(
                      key: _passwordInputKey,
                      controller: _passwordController,
                      hint: "Enter password",
                      height: inputHeight,
                      fontSize: 18,
                      obscureText: _obscurePassword,
                      focusedBorderColor: theme.primaryPurple,
                      padding: const EdgeInsets.symmetric(horizontal: 20),
                      disabled: _loading,
                      rightIconPath: _obscurePassword
                          ? "assets/icons/close_eye.svg"
                          : "assets/icons/open_eye.svg",
                      onRightIconTap: _loading
                          ? null
                          : () => setState(
                              () => _obscurePassword = !_obscurePassword),
                      onChanged: (value) => setState(() => _errorMessage = ''),
                    ),
                  ],
                  if (_errorMessage.isNotEmpty) ...[
                    SizedBox(height: adaptivePadding),
                    Text(
                      _errorMessage,
                      style: TextStyle(
                        color: theme.danger,
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/wallet_header.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:blockies/blockies.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/wallet_card.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/modals/add_bip39_modal_page.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';

void showWalletModal({
  required BuildContext context,
  VoidCallback? onManageWallet,
  Function(int)? onWalletSelect,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return _WalletModalContent(
        onManageWallet: onManageWallet,
      );
    },
  );
}

class _WalletModalContent extends StatefulWidget {
  final VoidCallback? onManageWallet;

  const _WalletModalContent({
    this.onManageWallet,
  });

  @override
  State<_WalletModalContent> createState() => _WalletModalContentState();
}

class _WalletModalContentState extends State<_WalletModalContent> {
  final List<Widget> _contentStack = [];

  void _pushContent(Widget content) {
    setState(() {
      _contentStack.add(content);
    });
  }

  void _popContent() {
    if (_contentStack.isNotEmpty) {
      setState(() {
        _contentStack.removeLast();
      });
    } else {
      Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    if (appState.wallet == null) {
      return Container();
    }

    return PopScope(
      child: GestureDetector(
        onHorizontalDragEnd: (details) {
          if (details.primaryVelocity! > 0) {
            _popContent();
          }
        },
        child: Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: const BorderRadius.vertical(
              top: Radius.circular(20),
            ),
          ),
          child: SingleChildScrollView(
            child: _contentStack.isNotEmpty
                ? _contentStack.last
                : _buildMainContent(context),
          ),
        ),
      ),
    );
  }

  Widget _buildMainContent(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = appState.chain;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: () => Navigator.pop(context),
          child: Container(
            width: 36,
            height: 4,
            margin: EdgeInsets.symmetric(vertical: adaptivePadding),
            decoration: BoxDecoration(
              color: theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
        ),
        GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: widget.onManageWallet,
          child: Column(
            children: [
              if (chain != null)
                Container(
                  width: 50,
                  height: 50,
                  margin: const EdgeInsets.only(bottom: 8),
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: theme.primaryPurple.withValues(alpha: 0.1),
                      width: 2,
                    ),
                  ),
                  child: AsyncImage(
                    url: chainIcon(appState.chain!.chain, null),
                    width: 32,
                    height: 32,
                    fit: BoxFit.contain,
                    errorWidget: Blockies(
                      seed: appState.wallet!.walletAddress,
                      color: getWalletColor(0),
                      bgColor: theme.primaryPurple,
                      spotColor: theme.background,
                      size: 8,
                    ),
                    loadingWidget: const Center(
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                      ),
                    ),
                  ),
                ),
              Text(
                appState.wallet!.walletName,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 24,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
        ConstrainedBox(
          constraints: BoxConstraints(
            maxHeight: MediaQuery.of(context).size.height * 0.5,
          ),
          child: ListView(
            shrinkWrap: true,
            padding: const EdgeInsets.symmetric(
              horizontal: 24,
              vertical: 8,
            ),
            children: appState.wallet!.accounts.asMap().entries.map((entry) {
              final index = entry.key;
              final account = entry.value;
              return WalletCard(
                name: account.name,
                address:
                    shortenAddress(account.addr, leftSize: 8, rightSize: 8),
                onTap: () async {
                  final appState =
                      Provider.of<AppState>(context, listen: false);
                  BigInt walletIndex = BigInt.from(appState.selectedWallet);
                  BigInt accountIndex = BigInt.from(index);

                  try {
                    await appState.updateSelectedAccount(
                        walletIndex, accountIndex);
                  } catch (e) {
                    debugPrint("select wallet error: $e");
                  }
                },
                isSelected:
                    appState.wallet!.selectedAccount == BigInt.from(index),
              );
            }).toList(),
          ),
        ),
        if (!appState.wallet!.walletType.contains(WalletType.SecretKey.name))
          Container(
            height: 64,
            padding: const EdgeInsets.symmetric(
              horizontal: 16,
              vertical: 12,
            ),
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(
                  color: theme.textPrimary.withValues(alpha: 0.1),
                  width: 1,
                ),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                HoverSvgIcon(
                  assetName: "assets/icons/plus.svg",
                  color: theme.textPrimary,
                  width: 40,
                  height: 40,
                  onTap: () {
                    _pushContent(
                      AddNextBip39AccountContent(
                        onBack: _popContent,
                      ),
                    );
                  },
                ),
                if (appState.wallet?.selectedAccount != BigInt.zero)
                  HoverSvgIcon(
                    assetName: "assets/icons/minus.svg",
                    color: theme.danger,
                    width: 40,
                    height: 40,
                    onTap: () async {
                      try {
                        await deleteAccount(
                          walletIndex: BigInt.from(appState.selectedWallet),
                          accountIndex: appState.wallet!.selectedAccount,
                        );
                        await appState.syncData();
                      } catch (e) {
                        debugPrint("try remove account: $e");
                      }
                    },
                  ),
              ],
            ),
          ),
        SizedBox(height: MediaQuery.of(context).padding.bottom),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/custom_network_modal.dart`:

```dart
import 'package:flutter/material.dart';
import '../../components/smart_input.dart';
import '../../components/button.dart';
import '../../theme/app_theme.dart';

void showCustomNetworkModal({
  required BuildContext context,
  required AppTheme theme,
  required Function({
    required String networkName,
    required String rpcUrl,
    required String chainId,
    required String symbol,
    required String explorerUrl,
  }) onSave,
}) {
  showModalBottomSheet<void>(
    context: context,
    backgroundColor: Colors.transparent,
    isScrollControlled: true,
    enableDrag: true,
    isDismissible: true,
    useSafeArea: true,
    barrierColor: Colors.black54,
    builder: (BuildContext context) {
      return Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: _CustomNetworkModalContent(
          theme: theme,
          onSave: onSave,
        ),
      );
    },
  );
}

class _CustomNetworkModalContent extends StatefulWidget {
  final AppTheme theme;
  final Function({
    required String networkName,
    required String rpcUrl,
    required String chainId,
    required String symbol,
    required String explorerUrl,
  }) onSave;

  const _CustomNetworkModalContent({
    required this.theme,
    required this.onSave,
  });

  @override
  State<_CustomNetworkModalContent> createState() =>
      _CustomNetworkModalContentState();
}

class _CustomNetworkModalContentState
    extends State<_CustomNetworkModalContent> {
  final _networkNameController = TextEditingController();
  final _rpcUrlController = TextEditingController();
  final _chainIdController = TextEditingController();
  final _symbolController = TextEditingController();
  final _explorerUrlController = TextEditingController();

  @override
  void dispose() {
    _networkNameController.dispose();
    _rpcUrlController.dispose();
    _chainIdController.dispose();
    _symbolController.dispose();
    _explorerUrlController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bottomPadding = MediaQuery.of(context).padding.bottom;

    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.8,
      ),
      decoration: BoxDecoration(
        color: widget.theme.cardBackground,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 36,
            height: 4,
            margin: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: widget.theme.textSecondary.withValues(alpha: 0.5),
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              physics: const BouncingScrollPhysics(),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildInputField(
                    controller: _networkNameController,
                    hint: 'Enter network name',
                  ),
                  _buildInputField(
                    controller: _rpcUrlController,
                    hint: 'Add a URL',
                  ),
                  _buildInputField(
                    controller: _chainIdController,
                    hint: 'Enter Chain ID',
                  ),
                  _buildInputField(
                    controller: _symbolController,
                    hint: 'Enter symbol',
                  ),
                  _buildInputField(
                    controller: _explorerUrlController,
                    hint: 'Add a URL',
                  ),
                ],
              ),
            ),
          ),
          Padding(
            padding: EdgeInsets.fromLTRB(16, 0, 16, 8 + bottomPadding),
            child: SizedBox(
              width: double.infinity,
              child: CustomButton(
                text: 'Save',
                onPressed: () {
                  widget.onSave(
                    networkName: _networkNameController.text,
                    rpcUrl: _rpcUrlController.text,
                    chainId: _chainIdController.text,
                    symbol: _symbolController.text,
                    explorerUrl: _explorerUrlController.text,
                  );
                  Navigator.pop(context);
                },
                backgroundColor: widget.theme.primaryPurple,
                borderRadius: 30.0,
                height: 50.0,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInputField({
    required TextEditingController controller,
    required String hint,
  }) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SmartInput(
            controller: controller,
            hint: hint,
            borderColor: widget.theme.textSecondary.withValues(alpha: 0.3),
            focusedBorderColor: widget.theme.primaryPurple,
            height: 48,
            fontSize: 16,
            padding: const EdgeInsets.symmetric(horizontal: 16),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/modals/node_selection_modal.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../theme/app_theme.dart';

class NodeData {
  final String name;
  final String url;

  NodeData(this.name, this.url);
}

class NodeSelectionModal extends StatefulWidget {
  final AppTheme theme;
  final bool isMainnet;
  final String selectedMainnetNode;
  final String selectedTestnetNode;
  final Function(String) onNodeSelected;

  const NodeSelectionModal({
    super.key,
    required this.theme,
    required this.isMainnet,
    required this.selectedMainnetNode,
    required this.selectedTestnetNode,
    required this.onNodeSelected,
  });

  @override
  State<NodeSelectionModal> createState() => _NodeSelectionModalState();
}

class _NodeSelectionModalState extends State<NodeSelectionModal> {
  final List<NodeData> mainnetNodes = [
    NodeData('Zilliqa mainnet', 'api.zilliqa.com'),
    NodeData('Zilliqa mainnet backup', 'api-backup.zilliqa.com'),
  ];

  final List<NodeData> testnetNodes = [
    NodeData('Zilliqa testnet', 'dev-api.zilliqa.com'),
    NodeData('Zilliqa testnet backup', 'dev-api-backup.zilliqa.com'),
  ];

  @override
  Widget build(BuildContext context) {
    final nodes = widget.isMainnet ? mainnetNodes : testnetNodes;
    final selectedNode = widget.isMainnet
        ? widget.selectedMainnetNode
        : widget.selectedTestnetNode;

    return Container(
      decoration: BoxDecoration(
        color: widget.theme.cardBackground,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(16),
          topRight: Radius.circular(16),
        ),
      ),
      child: SafeArea(
        child: Column(
          children: [
            // Close indicator
            Center(
              child: Container(
                width: 32,
                height: 4,
                margin: const EdgeInsets.only(top: 8, bottom: 16),
                decoration: BoxDecoration(
                  color: widget.theme.textSecondary.withValues(alpha: 0.3),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: nodes.length,
                itemBuilder: (context, index) {
                  final node = nodes[index];
                  final isSelected = node.url == selectedNode;
                  final isLastItem = index == nodes.length - 1;

                  return _buildNodeItem(
                    widget.theme,
                    node,
                    isSelected,
                    isLastItem,
                    onTap: () {
                      widget.onNodeSelected(node.url);
                      Navigator.pop(context);
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNodeItem(
    AppTheme theme,
    NodeData node,
    bool isSelected,
    bool isLastItem, {
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: !isLastItem
              ? Border(
                  bottom: BorderSide(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    width: 1,
                  ),
                )
              : null,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              node.name,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    node.url,
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ),
                SizedBox(
                  width: 24,
                  height: 24,
                  child: isSelected
                      ? SvgPicture.asset(
                          'assets/icons/ok.svg',
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        )
                      : null,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/state/app_state.dart`:

```dart
import 'dart:convert';
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/src/rust/api/book.dart';
import 'package:zilpay/src/rust/api/connections.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/src/rust/models/background.dart';
import 'package:zilpay/src/rust/models/book.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/theme/app_theme.dart';

class AppState extends ChangeNotifier with WidgetsBindingObserver {
  List<AddressBookEntryInfo> _book = [];
  List<ConnectionInfo> _connections = [];
  Map<String, double> _rates = {};

  late BackgroundState _state;
  late String _cahceDir;
  int _selectedWallet = 0;
  final Brightness _systemBrightness =
      PlatformDispatcher.instance.platformBrightness;

  AppState({
    required BackgroundState state,
    required String cahceDir,
  }) {
    WidgetsBinding.instance.addObserver(this);
    _state = state;
    _cahceDir = cahceDir;
  }

  void setSelectedWallet(int index) {
    _selectedWallet = index;
    notifyListeners();
  }

  String get cahceDir {
    return _cahceDir;
  }

  List<WalletInfo> get wallets {
    return _state.wallets;
  }

  List<ConnectionInfo> get connections {
    return _connections;
  }

  List<AddressBookEntryInfo> get book {
    return _book;
  }

  Map<String, double> get rates {
    return _rates;
  }

  BackgroundState get state {
    return _state;
  }

  AppTheme get currentTheme {
    switch (_state.appearances) {
      case 0:
        return _systemBrightness == Brightness.dark
            ? DarkTheme()
            : LightTheme();
      case 1:
        return DarkTheme();
      case 2:
        return LightTheme();
      default:
        return _systemBrightness == Brightness.dark
            ? DarkTheme()
            : LightTheme();
    }
  }

  WalletInfo? get wallet {
    return _state.wallets[_selectedWallet];
  }

  NetworkConfigInfo? get chain {
    BigInt? hash = account?.chainHash;

    if (hash == null) {
      return null;
    }

    return getChain(hash);
  }

  AccountInfo? get account {
    if (wallet == null) {
      return null;
    }

    int index = wallet!.selectedAccount.toInt();

    return wallet!.accounts[index];
  }

  int get selectedWallet {
    return _selectedWallet;
  }

  get appDocument => null;

  Future<void> syncData() async {
    _state = await getData();
    await syncBook();
    await syncConnections();
    // await syncTokenRates();
    notifyListeners();
  }

  Future<void> syncBook() async {
    _book = await getAddressBookList();

    notifyListeners();
  }

  Future<void> syncTokenRates() async {
    if (wallet?.settings.currencyConvert?.isEmpty ?? true) {
      return;
    }

    try {
      String value = await getRates();

      Map<String, dynamic> rawJson = jsonDecode(value);
      Map<String, double> jsonValue = rawJson
          .map((key, value) => MapEntry(key, double.parse(value.toString())));
      _rates = jsonValue;

      notifyListeners();
    } catch (e) {
      debugPrint("error get rates $e");
    }
  }

  Future<void> updateTokensRates() async {
    if (wallet?.settings.currencyConvert?.isEmpty ?? true) {
      return;
    }

    try {
      await updateRates();
      notifyListeners();
    } catch (e) {
      debugPrint("error fetch rates $e");
    }
  }

  Future<void> syncConnections() async {
    _connections = await getConnectionsList();

    notifyListeners();
  }

  Future<void> updateSelectedAccount(
      BigInt walletIndex, BigInt accountIndex) async {
    await selectAccount(walletIndex: walletIndex, accountIndex: accountIndex);
    await syncData();

    notifyListeners();
  }

  Future<void> setAppearancesCode(int code) async {
    await setTheme(appearancesCode: code);
    _state = await getData();
    notifyListeners();
  }

  NetworkConfigInfo? getChain(BigInt hash) {
    return state.providers.firstWhere((e) => e.chainHash == hash);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/main.dart`:

```dart
import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:flutter/material.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/src/rust/models/background.dart';

import 'services/auth_guard.dart';
import 'state/app_state.dart';

import 'package:zilpay/src/rust/frb_generated.dart';
import 'app.dart';

Future<String> getStoragePath() async {
  final appDocDir = await getApplicationSupportDirectory();
  return appDocDir.path;
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await RustLib.init();

  BackgroundState state;

  try {
    String appDocPath = await getStoragePath();

    String cahceDir = '$appDocPath/icons_cache';
    final directory = Directory(cahceDir);

    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }

    state = await startService(path: "$appDocPath/storage");

    final appState = AppState(
      state: state,
      cahceDir: cahceDir,
    );
    final authGuard = AuthGuard(state: appState);

    runApp(ZilPayApp(authGuard: authGuard, appState: appState));
  } catch (e) {
    debugPrint("try start, Error: $e");
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/custom_app_bar.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String? title;
  final VoidCallback onBackPressed;
  final VoidCallback? onActionPressed;
  final Widget? actionIcon;
  final Widget? actionWidget;

  const CustomAppBar({
    super.key,
    required this.onBackPressed,
    this.title,
    this.onActionPressed,
    this.actionIcon,
    this.actionWidget,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 5.0, vertical: 5.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              icon: SvgPicture.asset(
                'assets/icons/back.svg',
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              onPressed: onBackPressed,
            ),
            if (title != null)
              Expanded(
                child: Text(
                  title!,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            if (actionWidget != null)
              Padding(
                padding: const EdgeInsets.only(right: 8.0),
                child: actionWidget!,
              )
            else if (actionIcon != null && onActionPressed != null)
              IconButton(
                icon: actionIcon!,
                onPressed: onActionPressed,
              )
            else
              const SizedBox(width: 48),
          ],
        ),
      ),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/wor_count_selector.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class WordCountSelector extends StatelessWidget {
  final List<int> wordCounts;
  final int selectedCount;
  final Function(int) onCountChanged;

  const WordCountSelector({
    super.key,
    required this.wordCounts,
    required this.selectedCount,
    required this.onCountChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Container(
        width: double.infinity,
        height: 48,
        decoration: BoxDecoration(
          color: theme.cardBackground,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Stack(
          children: [
            AnimatedAlign(
              alignment: Alignment(
                -1 +
                    2 *
                        (wordCounts.indexOf(selectedCount) /
                            (wordCounts.length - 1)),
                0,
              ),
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
              child: FractionallySizedBox(
                widthFactor: 1 / wordCounts.length,
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.primaryPurple,
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            Row(
              children: List.generate(
                wordCounts.length,
                (index) => Expanded(
                  child: GestureDetector(
                    onTap: () => onCountChanged(wordCounts[index]),
                    behavior: HitTestBehavior.opaque,
                    child: Center(
                      child: AnimatedDefaultTextStyle(
                        duration: const Duration(milliseconds: 300),
                        style: TextStyle(
                          fontSize: 18,
                          color: selectedCount == wordCounts[index]
                              ? Colors.white
                              : theme.textSecondary,
                          fontWeight: selectedCount == wordCounts[index]
                              ? FontWeight.bold
                              : FontWeight.normal,
                        ),
                        child: Text(wordCounts[index].toString()),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/wallet_selector_card.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/modals/select_address.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';

class WalletSelectionCard extends StatefulWidget {
  final String? walletName;
  final String? address;
  final Function(QRcodeScanResultInfo, String) onChange;

  const WalletSelectionCard({
    super.key,
    this.walletName,
    this.address,
    required this.onChange,
  });

  @override
  State<WalletSelectionCard> createState() => _WalletSelectionCardState();
}

class _WalletSelectionCardState extends State<WalletSelectionCard> {
  bool isPressed = false;

  @override
  void initState() {
    super.initState();

    if (widget.address == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showAccountsModal();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return MouseRegion(
      onEnter: (_) => setState(() => isPressed = true),
      onExit: (_) => setState(() => isPressed = false),
      child: GestureDetector(
        onTapDown: (_) => setState(() => isPressed = true),
        onTapUp: (_) => setState(() => isPressed = false),
        onTapCancel: () => setState(() => isPressed = false),
        onTap: _showAccountsModal,
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: isPressed
                ? theme.cardBackground.withValues(alpha: 0.6)
                : Colors.transparent,
            border: Border.all(
              color: theme.textSecondary.withValues(alpha: 0.2),
              width: 1.5,
            ),
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            children: [
              Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.primaryPurple.withValues(alpha: 0.1),
                    width: 1,
                  ),
                ),
                child: ClipOval(
                  child: Blockies(
                    seed: widget.address ?? "",
                    color: getWalletColor(0),
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.walletName ?? "",
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      widget.address ?? "",
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAccountsModal() {
    showAddressSelectModal(
      context: context,
      onAddressSelected: widget.onChange,
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/gas_eip1559.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/gas_eip1559.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/gas.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

extension GasFeeOptionX on GasFeeOption {
  String get title {
    switch (this) {
      case GasFeeOption.low:
        return 'Low';
      case GasFeeOption.market:
        return 'Market';
      case GasFeeOption.aggressive:
        return 'Aggressive';
    }
  }

  String get icon {
    switch (this) {
      case GasFeeOption.low:
        return '🐥';
      case GasFeeOption.market:
        return '🐼';
      case GasFeeOption.aggressive:
        return '👹';
    }
  }

  String get description {
    switch (this) {
      case GasFeeOption.low:
        return 'Slower but cheaper';
      case GasFeeOption.market:
        return 'Recommended';
      case GasFeeOption.aggressive:
        return 'Faster but expensive';
    }
  }

  String get confirmationTime {
    switch (this) {
      case GasFeeOption.low:
        return '~3-5 min';
      case GasFeeOption.market:
        return '~30-60 sec';
      case GasFeeOption.aggressive:
        return '~10-15 sec';
    }
  }
}

class GasEIP1559 extends StatefulWidget {
  final GasInfo gasInfo;
  final Function(BigInt maxPriorityFee) onChange;
  final bool disabled;

  const GasEIP1559({
    super.key,
    required this.gasInfo,
    required this.onChange,
    this.disabled = false,
  });

  @override
  State<GasEIP1559> createState() => _GasEIP1559State();
}

class _GasEIP1559State extends State<GasEIP1559> with TickerProviderStateMixin {
  late final AnimationController _expandController;
  late final Animation<double> _expandAnimation;
  bool _isExpanded = false;
  GasFeeOption _selected = GasFeeOption.market;

  @override
  void initState() {
    super.initState();
    _expandController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _expandAnimation = CurvedAnimation(
      parent: _expandController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _expandController.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(GasEIP1559 oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.gasInfo != widget.gasInfo) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final maxPriorityFee = calculateMaxPriorityFee(
          _selected,
          widget.gasInfo.feeHistory.priorityFee,
        );
        widget.onChange(maxPriorityFee);
      });
    }
  }

  void _handleOptionTap(GasFeeOption option) {
    if (widget.disabled) return;

    if (_selected == option) {
      setState(() {
        _isExpanded = !_isExpanded;
        _isExpanded ? _expandController.forward() : _expandController.reverse();
      });
      return;
    }

    setState(() {
      _selected = option;
      _isExpanded = false;
      _expandController.reverse();
    });

    final maxPriorityFee = calculateMaxPriorityFee(
      option,
      widget.gasInfo.feeHistory.priorityFee,
    );
    widget.onChange(maxPriorityFee);
  }

  Widget _buildGasDetails(AppTheme theme, FTokenInfo token) {
    return Column(
      children: [
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: theme.background,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            children: [
              _buildDetailRow(
                'Estimated Gas:',
                '${widget.gasInfo.txEstimateGas}',
                theme,
              ),
              _buildDetailRow(
                'Base Fee:',
                formatGasPriceDetail(
                  widget.gasInfo.feeHistory.baseFee,
                  token,
                ),
                theme,
              ),
              _buildDetailRow(
                'Priority Fee:',
                formatGasPriceDetail(
                  calculateMaxPriorityFee(
                    _selected,
                    widget.gasInfo.feeHistory.priorityFee,
                  ),
                  token,
                ),
                theme,
              ),
              _buildDetailRow(
                'Max Fee:',
                formatGasPriceDetail(
                  calculateFeeForOption(
                    _selected,
                    widget.gasInfo.feeHistory.baseFee,
                    widget.gasInfo.feeHistory.priorityFee,
                  ),
                  token,
                ),
                theme,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildDetailRow(String label, String value, AppTheme theme) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: TextStyle(
              color: theme.textSecondary
                  .withValues(alpha: widget.disabled ? 0.5 : 1.0),
              fontSize: 12,
            ),
          ),
          Text(
            value,
            style: TextStyle(
              color: theme.textPrimary
                  .withValues(alpha: widget.disabled ? 0.5 : 1.0),
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGasOption({
    required GasFeeOption option,
    required Color textColor,
    required AppState appState,
    required NetworkConfigInfo chain,
    required FTokenInfo token,
  }) {
    final theme = appState.currentTheme;
    final isSelected = _selected == option;

    final totalGasFee = calculateTotalGasCost(
      option,
      widget.gasInfo.feeHistory.baseFee,
      widget.gasInfo.feeHistory.priorityFee,
      widget.gasInfo.txEstimateGas,
    );

    return TweenAnimationBuilder<double>(
      tween: Tween<double>(
        begin: 0.95,
        end: isSelected ? 1.0 : 0.95,
      ),
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeOutQuart,
      builder: (context, value, child) => Transform.scale(
        scale: value,
        child: Opacity(
          opacity: widget.disabled ? 0.5 : 1.0,
          child: GestureDetector(
            onTap: widget.disabled ? null : () => _handleOptionTap(option),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: isSelected
                    ? theme.primaryPurple.withValues(alpha: 0.1)
                    : Colors.transparent,
                borderRadius: BorderRadius.circular(16),
              ),
              child: Column(
                children: [
                  Row(
                    children: [
                      Text(option.icon, style: const TextStyle(fontSize: 24)),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              option.title,
                              style: TextStyle(
                                color: theme.textPrimary,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              option.confirmationTime,
                              style: TextStyle(
                                color: theme.textSecondary,
                                fontSize: 12,
                              ),
                            ),
                          ],
                        ),
                      ),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            formatGasPrice(
                                totalGasFee, token.decimals, token.symbol),
                            style: TextStyle(
                              color: textColor,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            option.description,
                            style: TextStyle(
                              color: theme.textSecondary,
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                  if (isSelected)
                    SizeTransition(
                      sizeFactor: _expandAnimation,
                      child: _buildGasDetails(theme, token),
                    ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final chain = appState.chain!;
    final token = appState.wallet!.tokens.first;

    return Column(
      children: [
        if (_isExpanded || _selected == GasFeeOption.low)
          _buildGasOption(
            option: GasFeeOption.low,
            textColor: theme.warning,
            appState: appState,
            chain: chain,
            token: token,
          ),
        if (_isExpanded || _selected == GasFeeOption.market)
          _buildGasOption(
            option: GasFeeOption.market,
            textColor: theme.textPrimary,
            appState: appState,
            chain: chain,
            token: token,
          ),
        if (_isExpanded || _selected == GasFeeOption.aggressive)
          _buildGasOption(
            option: GasFeeOption.aggressive,
            textColor: theme.danger,
            appState: appState,
            chain: chain,
            token: token,
          ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/option_list.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class OptionItem {
  final Widget child;
  final bool isSelected;
  final VoidCallback onSelect;

  OptionItem({
    required this.child,
    required this.isSelected,
    required this.onSelect,
  });
}

class OptionsList extends StatelessWidget {
  final List<OptionItem> options;
  final double unselectedOpacity;
  final bool disabled;
  final double disabledOpacity;

  const OptionsList({
    super.key,
    required this.options,
    this.unselectedOpacity = 0.5,
    this.disabled = false,
    this.disabledOpacity = 0.5,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    bool hasSelectedOption = options.any((option) => option.isSelected);

    return Column(
      children: options
          .map((option) => Padding(
                padding: const EdgeInsets.symmetric(vertical: 6.0),
                child: AnimatedOpacity(
                  duration: const Duration(milliseconds: 200),
                  opacity: disabled
                      ? disabledOpacity
                      : hasSelectedOption && !option.isSelected
                          ? unselectedOpacity
                          : 1.0,
                  child: GestureDetector(
                    onTap: disabled ? null : option.onSelect,
                    child: TweenAnimationBuilder<double>(
                      duration: const Duration(milliseconds: 300),
                      tween:
                          Tween(begin: 0.0, end: option.isSelected ? 1.0 : 0.0),
                      curve: Curves.easeOutCubic,
                      builder: (context, value, child) {
                        return Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 20, vertical: 16),
                          decoration: BoxDecoration(
                            color: theme.cardBackground,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: Color.lerp(
                                theme.cardBackground,
                                disabled
                                    ? theme.textSecondary
                                    : theme.primaryPurple,
                                value * 0.5,
                              )!,
                              width: 1.5,
                            ),
                          ),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Expanded(
                                child: option.child,
                              ),
                              AnimatedContainer(
                                duration: const Duration(milliseconds: 300),
                                width: 24,
                                height: 24,
                                decoration: BoxDecoration(
                                  shape: BoxShape.circle,
                                  border: Border.all(
                                    color: option.isSelected
                                        ? disabled
                                            ? theme.textSecondary
                                            : theme.primaryPurple
                                        : theme.textSecondary,
                                    width: 2,
                                  ),
                                ),
                                child: Center(
                                  child: AnimatedScale(
                                    duration: const Duration(milliseconds: 200),
                                    scale: option.isSelected ? 1.0 : 0.0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        shape: BoxShape.circle,
                                        color: disabled
                                            ? theme.textSecondary
                                            : theme.primaryPurple,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                ),
              ))
          .toList(),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/action_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomActionButton extends StatefulWidget {
  final String label;
  final String iconPath;
  final VoidCallback onPressed;

  const CustomActionButton({
    super.key,
    required this.label,
    required this.iconPath,
    required this.onPressed,
  });

  @override
  State<CustomActionButton> createState() => CustomActionButtonState();
}

class CustomActionButtonState extends State<CustomActionButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) => setState(() => _isPressed = false),
      onTapCancel: () => setState(() => _isPressed = false),
      onTap: widget.onPressed,
      child: AnimatedOpacity(
        duration: const Duration(milliseconds: 150),
        opacity: _isPressed ? 0.5 : 1.0,
        child: Container(
          width: 70,
          height: 70,
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.2),
                spreadRadius: 1,
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              SvgPicture.asset(
                widget.iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.primaryPurple,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(height: 6),
              Text(
                widget.label,
                style: TextStyle(
                  color: theme.buttonText,
                  fontSize: 11,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/token_card.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/state/app_state.dart';

class TokenCard extends StatefulWidget {
  final String tokenAmount;
  final int tokenDecimals;
  final String tokenName;
  final String tokenSymbol;
  final String tokenAddr;
  final String iconUrl;
  final String currencySymbol;
  final bool showDivider;
  final VoidCallback? onTap;

  const TokenCard({
    super.key,
    required this.tokenAmount,
    required this.tokenDecimals,
    required this.tokenName,
    required this.tokenSymbol,
    required this.tokenAddr,
    required this.iconUrl,
    required this.currencySymbol,
    this.showDivider = true,
    this.onTap,
  });

  @override
  State<TokenCard> createState() => _TokenCardState();
}

class _TokenCardState extends State<TokenCard>
    with SingleTickerProviderStateMixin {
  bool isHovered = false;
  bool isPressed = false;

  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Widget _buildIcon(AppState themeProvider) {
    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color:
              themeProvider.currentTheme.primaryPurple.withValues(alpha: 0.1),
          width: 2,
        ),
      ),
      child: ClipOval(
        child: AsyncImage(
          url: widget.iconUrl,
          width: 32,
          height: 32,
          fit: BoxFit.contain,
          errorWidget: Blockies(
            seed: widget.tokenAddr,
            color: getWalletColor(0),
            bgColor: themeProvider.currentTheme.primaryPurple,
            spotColor: themeProvider.currentTheme.background,
            size: 8,
          ),
          loadingWidget: const Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
            ),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final double tokenAmount = _getAmount();
    final convertedAmount = getConvertedAmount(state, tokenAmount);
    final String amount = formatCompactNumber(tokenAmount);

    return Column(
      children: [
        MouseRegion(
          onEnter: (_) {
            setState(() => isHovered = true);
            _controller.forward(from: 0.5);
          },
          onExit: (_) {
            setState(() => isHovered = false);
            _controller.reverse();
          },
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTapDown: (_) {
              setState(() => isPressed = true);
              _controller.forward();
            },
            onTapUp: (_) {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTapCancel: () {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTap: widget.onTap,
            child: AnimatedBuilder(
              animation: _animation,
              builder: (context, child) => Transform.scale(
                scale: _animation.value,
                child: child,
              ),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 150),
                decoration: const BoxDecoration(),
                child: Padding(
                  padding: EdgeInsets.symmetric(
                    horizontal: adaptivePadding,
                    vertical: adaptivePadding,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            LayoutBuilder(
                              builder: (context, constraints) {
                                return Row(
                                  children: [
                                    Flexible(
                                      child: Text(
                                        widget.tokenName,
                                        style: TextStyle(
                                          color: theme.textPrimary
                                              .withValues(alpha: 0.7),
                                          fontSize: 16,
                                          fontWeight: FontWeight.w500,
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Text(
                                      '(${widget.tokenSymbol})',
                                      style: TextStyle(
                                        color: theme.textSecondary
                                            .withValues(alpha: 0.5),
                                        fontSize: 13,
                                      ),
                                    ),
                                  ],
                                );
                              },
                            ),
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                Flexible(
                                  child: Text(
                                    amount,
                                    style: TextStyle(
                                      color: theme.textPrimary,
                                      fontSize: 20,
                                      fontWeight: FontWeight.w600,
                                      letterSpacing: 0.5,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                                const SizedBox(width: 2),
                                Text(
                                  '$convertedAmount${widget.currencySymbol}',
                                  style: TextStyle(
                                    color: theme.textSecondary
                                        .withValues(alpha: 0.7),
                                    fontSize: 14,
                                    fontWeight: FontWeight.w400,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 12),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white.withValues(alpha: 0.05),
                          shape: BoxShape.circle,
                        ),
                        child: _buildIcon(Provider.of<AppState>(context)),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
        if (widget.showDivider)
          Container(
            height: 1,
            color: theme.textPrimary.withValues(alpha: 0.1),
          ),
      ],
    );
  }

  double _getAmount() {
    try {
      BigInt value = BigInt.parse(widget.tokenAmount);
      return adjustAmountToDouble(value, widget.tokenDecimals);
    } catch (_) {
      return 0;
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/settings_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class SettingsItem extends StatefulWidget {
  final String title;
  final String trailingSvgPath;
  final VoidCallback onTap;
  final bool isFirst;
  final bool isLast;
  final bool isGrouped;

  const SettingsItem({
    super.key,
    required this.title,
    required this.trailingSvgPath,
    required this.onTap,
    this.isFirst = false,
    this.isLast = false,
    this.isGrouped = true,
  });

  @override
  State<SettingsItem> createState() => _SettingsItemState();
}

class _SettingsItemState extends State<SettingsItem> {
  bool _isPressed = false;

  BorderRadius? _getBorderRadius() {
    if (widget.isGrouped) {
      if (widget.isFirst && widget.isLast) {
        return BorderRadius.circular(16);
      } else if (widget.isFirst) {
        return const BorderRadius.vertical(top: Radius.circular(16));
      } else if (widget.isLast) {
        return const BorderRadius.vertical(bottom: Radius.circular(16));
      }
    } else {
      return BorderRadius.circular(16);
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final borderRadius = _getBorderRadius();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) {
        setState(() => _isPressed = false);
        widget.onTap();
      },
      onTapCancel: () => setState(() => _isPressed = false),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: _isPressed
              ? theme.background.withValues(alpha: 1.0)
              : Colors.transparent,
          borderRadius: borderRadius,
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                widget.title,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            SvgPicture.asset(
              widget.trailingSvgPath,
              colorFilter: ColorFilter.mode(
                theme.textSecondary,
                BlendMode.srcIn,
              ),
              width: 24,
              height: 24,
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/biometric_switch.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/state/app_state.dart';

class BiometricSwitch extends StatelessWidget {
  final AuthMethod biometricType;
  final bool value;
  final bool disabled;
  final ValueChanged<bool>? onChanged;

  const BiometricSwitch({
    super.key,
    required this.biometricType,
    required this.value,
    this.disabled = false,
    this.onChanged,
  });

  String get _authMethodText {
    switch (biometricType) {
      case AuthMethod.faceId:
        return 'Enable Face ID';
      case AuthMethod.fingerprint:
        return 'Enable Fingerprint';
      case AuthMethod.biometric:
        return 'Enable Biometric Login';
      case AuthMethod.pinCode:
        return 'Enable Device PIN';
      case AuthMethod.none:
        return '';
    }
  }

  String get _iconPath {
    switch (biometricType) {
      case AuthMethod.faceId:
        return 'assets/icons/face_id.svg';
      case AuthMethod.fingerprint:
        return 'assets/icons/fingerprint.svg';
      case AuthMethod.biometric:
        return 'assets/icons/biometric.svg';
      case AuthMethod.pinCode:
        return 'assets/icons/pin.svg';
      case AuthMethod.none:
        return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    if (biometricType == AuthMethod.none) {
      return const SizedBox.shrink();
    }

    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              SvgPicture.asset(
                _iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                _authMethodText,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          Switch(
            value: value,
            onChanged: disabled ? null : onChanged,
            activeColor: theme.primaryPurple,
            activeTrackColor: theme.primaryPurple.withValues(alpha: 0.4),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/button.dart`:

```dart
import 'package:flutter/widgets.dart';

class CustomButton extends StatefulWidget {
  final String text;
  final VoidCallback? onPressed;
  final double borderRadius;
  final Color textColor;
  final Color backgroundColor;
  final double width;
  final double height;
  final EdgeInsetsGeometry padding;
  final bool disabled;

  const CustomButton({
    super.key,
    required this.text,
    this.onPressed,
    this.borderRadius = 30.0,
    this.textColor = const Color(0xFFFFFFFF),
    this.backgroundColor = const Color(0xFF8A2BE2),
    this.width = double.infinity,
    this.height = 56.0,
    this.padding = const EdgeInsets.symmetric(horizontal: 16.0),
    this.disabled = false,
  });

  @override
  State<CustomButton> createState() => _CustomButtonState();
}

class _CustomButtonState extends State<CustomButton> {
  bool _isHovered = false;
  bool _isFocused = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.disabled ? null : widget.onPressed,
      onTapDown: (_) => setState(() => _isHovered = true),
      onTapUp: (_) => setState(() => _isHovered = false),
      onTapCancel: () => setState(() => _isHovered = false),
      child: Focus(
        onFocusChange: (hasFocus) => setState(() => _isFocused = hasFocus),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          width: widget.width,
          height: widget.height,
          padding: widget.padding,
          decoration: BoxDecoration(
            color: _getBackgroundColor(),
            borderRadius: BorderRadius.circular(widget.borderRadius),
          ),
          child: Center(
            child: Text(
              widget.text,
              style: TextStyle(
                color: widget.disabled
                    ? widget.textColor.withValues(alpha: 0.5)
                    : widget.textColor,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Color _getBackgroundColor() {
    if (widget.disabled) {
      return widget.backgroundColor.withValues(alpha: 0.5);
    } else if (_isHovered || _isFocused) {
      return widget.backgroundColor.withValues(alpha: 0.8);
    } else {
      return widget.backgroundColor;
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/wallet_option.dart`:

```dart
import 'dart:ui';
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/state/app_state.dart';

class WalletOption extends StatelessWidget {
  final String title;
  final String address;
  final bool isSelected;
  final VoidCallback onTap;
  final Widget? icon;
  final List<String>? icons;
  final EdgeInsetsGeometry? padding;

  const WalletOption({
    super.key,
    required this.title,
    required this.address,
    required this.isSelected,
    required this.onTap,
    this.icon,
    this.icons,
    this.padding = const EdgeInsets.all(16.0),
  });

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Container(
        decoration: BoxDecoration(
          color: theme.cardBackground.withValues(alpha: 0.7),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: isSelected ? theme.primaryPurple : Colors.transparent,
            width: 2,
          ),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(16),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
            child: Padding(
              padding: padding!,
              child: Row(
                children: [
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: theme.primaryPurple.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: AsyncImage(
                      url: chainIcon(appState.chain!.chain, null),
                      width: 32,
                      height: 32,
                      fit: BoxFit.contain,
                      errorWidget: Blockies(
                        seed: appState.wallet!.walletAddress,
                        color: getWalletColor(0),
                        bgColor: theme.primaryPurple,
                        spotColor: theme.background,
                        size: 8,
                      ),
                      loadingWidget: const Center(
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          title,
                          style: TextStyle(
                            color: theme.textPrimary,
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          address,
                          style: TextStyle(
                            color: theme.textSecondary,
                            fontSize: 14,
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                  ),
                  if (icons != null) ...[
                    const SizedBox(width: 8),
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: icons!
                          .map((iconPath) => Padding(
                                padding: const EdgeInsets.all(4),
                                child: SvgPicture.asset(
                                  iconPath,
                                  width: 24,
                                  height: 24,
                                  colorFilter: ColorFilter.mode(
                                      isSelected
                                          ? theme.primaryPurple
                                          : theme.textPrimary,
                                      BlendMode.srcIn),
                                ),
                              ))
                          .toList(),
                    ),
                  ],
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/tile_button.dart`:

```dart
import 'package:flutter/widgets.dart';

class TileButton extends StatefulWidget {
  final String? title;
  final Widget icon;
  final VoidCallback onPressed;
  final Color backgroundColor;
  final Color textColor;
  final bool disabled;

  const TileButton({
    super.key,
    required this.icon,
    required this.onPressed,
    this.title,
    this.backgroundColor = const Color(0xFF2C2C2E),
    this.textColor = const Color(0xFF9D4BFF),
    this.disabled = false,
  });

  @override
  State<TileButton> createState() => _TileButtonState();
}

class _TileButtonState extends State<TileButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  bool _isHovered = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.90,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.fastEaseInToSlowEaseOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 1.0,
      end: 0.7,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.fastEaseInToSlowEaseOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    if (!widget.disabled) {
      _controller.forward();
    }
  }

  void _handleTapUp(TapUpDetails details) {
    if (!widget.disabled) {
      _controller.reverse();
      widget.onPressed();
    }
  }

  void _handleTapCancel() {
    if (!widget.disabled) {
      _controller.reverse();
    }
  }

  void _handleHoverChanged(bool isHovered) {
    if (!widget.disabled) {
      setState(() {
        _isHovered = isHovered;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool hasTitle = widget.title != null && widget.title!.isNotEmpty;
    final double containerSize = hasTitle ? 72.0 : 56.0;
    final double iconSize = hasTitle ? 32.0 : 24.0;
    final double borderRadius = hasTitle ? 24.0 : 20.0;

    return MouseRegion(
      onEnter: (_) => _handleHoverChanged(true),
      onExit: (_) => _handleHoverChanged(false),
      cursor: widget.disabled
          ? SystemMouseCursors.forbidden
          : SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: _handleTapDown,
        onTapUp: _handleTapUp,
        onTapCancel: _handleTapCancel,
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: Opacity(
                opacity: widget.disabled ? 0.5 : _opacityAnimation.value,
                child: Container(
                  width: containerSize,
                  height: containerSize,
                  padding: EdgeInsets.zero,
                  decoration: BoxDecoration(
                    color: widget.backgroundColor,
                    borderRadius: BorderRadius.circular(borderRadius),
                    boxShadow: [
                      if (_isHovered && !widget.disabled)
                        BoxShadow(
                          color: widget.textColor.withValues(alpha: 0.1),
                          blurRadius: 8,
                          spreadRadius: 1,
                        ),
                    ],
                  ),
                  child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: iconSize,
                          height: iconSize,
                          child: widget.icon,
                        ),
                        if (hasTitle) ...[
                          const SizedBox(height: 4),
                          Text(
                            widget.title!,
                            style: TextStyle(
                              color: widget.textColor,
                              fontSize: 11,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/number_keyboard.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class NumberKeyboard extends StatefulWidget {
  final Function(int) onKeyPressed;
  final VoidCallback onBackspace;
  final VoidCallback? onDotPress;

  const NumberKeyboard({
    super.key,
    required this.onKeyPressed,
    required this.onBackspace,
    this.onDotPress,
  });

  @override
  NumberKeyboardState createState() => NumberKeyboardState();
}

class NumberKeyboardState extends State<NumberKeyboard>
    with SingleTickerProviderStateMixin {
  String? activeKey;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 1.1).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Widget _buildKey(BuildContext context, String value, {bool isIcon = false}) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final isActive = activeKey == value;

    void handleTap() {
      setState(() => activeKey = value);
      _controller.forward().then((_) => _controller.reverse());
      Future.delayed(const Duration(milliseconds: 200), () {
        setState(() => activeKey = null);
      });

      if (value == '←') {
        widget.onBackspace();
      } else if (value == '.') {
        widget.onDotPress?.call();
      } else {
        widget.onKeyPressed(int.parse(value));
      }
    }

    return GestureDetector(
      onTapDown: (_) {
        setState(() => activeKey = value);
        _controller.forward();
      },
      onTapUp: (_) {
        _controller.reverse();
        setState(() => activeKey = null);
        handleTap();
      },
      onTapCancel: () {
        _controller.reverse();
        setState(() => activeKey = null);
      },
      behavior: HitTestBehavior.opaque,
      child: ScaleTransition(
        scale: isActive ? _scaleAnimation : const AlwaysStoppedAnimation(1.0),
        child: Container(
          width: 80,
          height: 50,
          alignment: Alignment.center,
          child: isIcon
              ? SvgPicture.asset(
                  "assets/icons/backspace.svg",
                  width: 30,
                  height: 30,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary.withValues(alpha: isActive ? 1.0 : 0.5),
                    BlendMode.srcIn,
                  ),
                )
              : Text(
                  value,
                  style: TextStyle(
                    color: theme.textPrimary
                        .withValues(alpha: isActive ? 1.0 : 0.5),
                    fontSize: 32,
                    fontWeight: FontWeight.w500,
                  ),
                ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 20),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['1', '2', '3'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['4', '5', '6'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['7', '8', '9'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildKey(context, '.'),
              _buildKey(context, '0'),
              _buildKey(context, '←', isIcon: true),
            ],
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/custom_network_option.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../../theme/app_theme.dart';

class CustomNetworkOption extends StatelessWidget {
  final AppTheme theme;
  final bool isSelected;
  final String customUrl;
  final VoidCallback onConfigureTap;

  const CustomNetworkOption({
    super.key,
    required this.theme,
    required this.isSelected,
    required this.customUrl,
    required this.onConfigureTap,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: theme.background,
                borderRadius: BorderRadius.circular(8),
              ),
              child: SvgPicture.asset(
                'assets/icons/documents.svg',
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  isSelected ? theme.primaryPurple : theme.textSecondary,
                  BlendMode.srcIn,
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Custom Network',
                    style: TextStyle(
                      color:
                          isSelected ? theme.primaryPurple : theme.textPrimary,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Configure your own network settings',
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: double.infinity,
          child: TextButton(
            onPressed: onConfigureTap,
            style: TextButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
              backgroundColor: isSelected
                  ? theme.background
                  : theme.background.withValues(alpha: 0.5),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
                side: BorderSide(
                  color: isSelected
                      ? theme.primaryPurple
                      : theme.textSecondary.withValues(alpha: 0.5),
                ),
              ),
              splashFactory: NoSplash.splashFactory,
            ),
            child: Text(
              customUrl.isEmpty ? 'Configure Network' : customUrl,
              style: TextStyle(
                color: isSelected
                    ? theme.primaryPurple
                    : theme.textPrimary.withValues(alpha: 0.5),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/async_qrcode.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/qrcode.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';

enum EyeShape {
  square(0),
  circle(1);

  final int value;
  const EyeShape(this.value);
}

enum DataModuleShape {
  square(0),
  circle(1);

  final int value;
  const DataModuleShape(this.value);
}

class AsyncQRcode extends StatefulWidget {
  final int size;
  final String data;
  final EyeShape eyeShape;
  final bool gapless;
  final Color color;
  final DataModuleShape dataModuleShape;
  final BoxFit? fit;
  final Widget? loadingWidget;
  final Widget? errorWidget;

  const AsyncQRcode({
    super.key,
    required this.data,
    required this.color,
    this.size = 200,
    this.gapless = false,
    this.eyeShape = EyeShape.circle,
    this.dataModuleShape = DataModuleShape.circle,
    this.fit = BoxFit.cover,
    this.loadingWidget,
    this.errorWidget,
  });

  @override
  State<AsyncQRcode> createState() => _AsyncQRcodeState();
}

class _AsyncQRcodeState extends State<AsyncQRcode> {
  late final AppState _appState;
  String? _svgString;
  bool _hasError = false;

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
    _loadImage();
  }

  @override
  void didUpdateWidget(AsyncQRcode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.data != widget.data ||
        oldWidget.size != widget.size ||
        oldWidget.gapless != widget.gapless ||
        oldWidget.color != widget.color ||
        oldWidget.eyeShape != widget.eyeShape ||
        oldWidget.dataModuleShape != widget.dataModuleShape) {
      _loadImage();
    }
  }

  Future<void> _loadImage() async {
    try {
      QrConfigInfo config = QrConfigInfo(
        size: widget.size,
        gapless: widget.gapless,
        color: widget.color.value,
        eyeShape: widget.eyeShape.value,
        dataModuleShape: widget.dataModuleShape.value,
      );
      final svg = await genSvgQrcode(data: widget.data, config: config);

      if (mounted) {
        setState(() {
          _svgString = svg;
          _hasError = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _svgString = null;
          _hasError = true;
        });
      }
    }
  }

  Widget _buildImage() {
    if (_hasError) {
      return SizedBox(
        width: widget.size.toDouble(),
        height: widget.size.toDouble(),
        child: widget.errorWidget ??
            Center(
              child: Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: _appState.currentTheme.danger,
                  shape: BoxShape.circle,
                ),
              ),
            ),
      );
    }

    return SvgPicture.string(
      _svgString!,
      width: widget.size.toDouble(),
      height: widget.size.toDouble(),
      fit: widget.fit ?? BoxFit.cover,
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_svgString == null && !_hasError) {
      return SizedBox(
        width: widget.size.toDouble(),
        height: widget.size.toDouble(),
        child: widget.loadingWidget ??
            const Center(
              child: CircularProgressIndicator(),
            ),
      );
    }

    return _buildImage();
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/wallet_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:blockies/blockies.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/state/app_state.dart';

class WalletCard extends StatelessWidget {
  final String name;
  final String address;
  final VoidCallback onTap;
  final bool isSelected;
  final double? width;
  final double? height;
  final double? fontSize;
  final double avatarSize;

  const WalletCard({
    super.key,
    required this.name,
    required this.address,
    required this.onTap,
    this.isSelected = false,
    this.width,
    this.height,
    this.fontSize,
    this.avatarSize = 40,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: isSelected
              ? theme.primaryPurple.withValues(alpha: 0.1)
              : Colors.transparent,
        ),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Container(
                width: avatarSize,
                height: avatarSize,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.primaryPurple.withValues(alpha: 0.1),
                    width: 1,
                  ),
                ),
                child: ClipOval(
                  child: Blockies(
                    seed: address,
                    color: getWalletColor(0),
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      name,
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: fontSize ?? 16,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      address,
                      style: TextStyle(
                        color: theme.textPrimary.withValues(alpha: 0.5),
                        fontSize: (fontSize ?? 16) - 2,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/toggle_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';

class ToggleItem extends StatelessWidget {
  final String title;
  final String subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;

  const ToggleItem({
    super.key,
    required this.title,
    required this.subtitle,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptiveHorizontalPadding =
        AdaptiveSize.getAdaptivePadding(context, 20);
    final adaptiveVerticalPadding =
        AdaptiveSize.getAdaptivePadding(context, 16);

    return Column(
      children: [
        Container(
          padding: EdgeInsets.symmetric(
              horizontal: adaptiveHorizontalPadding,
              vertical: adaptiveVerticalPadding),
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      subtitle,
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
              Switch(
                value: value,
                onChanged: onChanged,
                activeColor: theme.primaryPurple,
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/view_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class WalletListItem extends StatefulWidget {
  final String title;
  final String subtitle;
  final dynamic icon;
  final VoidCallback onTap;
  final bool disabled;

  const WalletListItem({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
    required this.onTap,
    this.disabled = false,
  });

  @override
  State<WalletListItem> createState() => _WalletListItemState();
}

class _WalletListItemState extends State<WalletListItem>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 1.0,
      end: 0.7,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final opacity = widget.disabled ? 0.5 : 1.0;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: GestureDetector(
        onTapDown: widget.disabled ? null : (_) => _controller.forward(),
        onTapUp: widget.disabled ? null : (_) => _controller.reverse(),
        onTapCancel: widget.disabled ? null : () => _controller.reverse(),
        onTap: widget.disabled ? null : widget.onTap,
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: widget.disabled ? 1.0 : _scaleAnimation.value,
              child: Container(
                decoration: BoxDecoration(
                  color: theme.cardBackground.withValues(
                    alpha: widget.disabled ? opacity : _opacityAnimation.value,
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: child,
              ),
            );
          },
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Opacity(opacity: opacity, child: _buildIcon()),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.title,
                        style: TextStyle(
                          color: theme.textPrimary.withValues(alpha: opacity),
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        widget.subtitle,
                        style: TextStyle(
                          color: theme.textSecondary.withValues(alpha: opacity),
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
                Opacity(
                  opacity: opacity,
                  child: SvgPicture.asset(
                    'assets/icons/chevron_right.svg',
                    width: 24,
                    height: 24,
                    colorFilter: ColorFilter.mode(
                      theme.textSecondary,
                      BlendMode.srcIn,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildIcon() {
    if (widget.icon is IconData) {
      return Icon(widget.icon as IconData);
    } else if (widget.icon is Widget) {
      return widget.icon;
    } else if (widget.icon is String) {
      return Image.asset(
        widget.icon,
        width: 24,
        height: 24,
      );
    }
    return Container();
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/network_option_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../../theme/app_theme.dart';

class NetworkOptionItem extends StatelessWidget {
  final AppTheme theme;
  final String name;
  final String chainId;
  final String currentNode;
  final VoidCallback onNodeTap;
  final bool isSelected;
  final String iconPath;

  const NetworkOptionItem({
    super.key,
    required this.theme,
    required this.name,
    required this.chainId,
    required this.currentNode,
    required this.onNodeTap,
    required this.isSelected,
    required this.iconPath,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: theme.background,
                borderRadius: BorderRadius.circular(8),
              ),
              child: SvgPicture.asset(
                iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  isSelected ? theme.primaryPurple : theme.textSecondary,
                  BlendMode.srcIn,
                ),
              ),
            ),
            const SizedBox(width: 12),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: TextStyle(
                    color: isSelected ? theme.primaryPurple : theme.textPrimary,
                    fontSize: 16,
                  ),
                ),
                Text(
                  'Chain ID: $chainId',
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ],
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: double.infinity,
          child: TextButton(
            onPressed: isSelected ? onNodeTap : null,
            style: TextButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
              backgroundColor: isSelected
                  ? theme.background
                  : theme.background.withValues(alpha: 0.5),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
                side: BorderSide(
                  color: isSelected
                      ? theme.primaryPurple
                      : theme.textSecondary.withValues(alpha: 0.5),
                ),
              ),
              splashFactory: NoSplash.splashFactory,
            ),
            child: Text(
              currentNode,
              style: TextStyle(
                color: isSelected
                    ? theme.primaryPurple
                    : theme.textPrimary.withValues(alpha: 0.5),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/ledger_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class LedgerItem extends StatefulWidget {
  final Widget icon;
  final String title;
  final String id;
  final VoidCallback? onTap;
  final bool isSelected;
  final bool isLoading;

  const LedgerItem({
    super.key,
    required this.icon,
    required this.title,
    required this.id,
    this.onTap,
    this.isSelected = false,
    this.isLoading = false,
  });

  @override
  State<LedgerItem> createState() => _LedgerItemState();
}

class _LedgerItemState extends State<LedgerItem>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  bool _isPressed = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    if (widget.onTap == null || widget.isLoading) return;
    setState(() => _isPressed = true);
    _controller.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    if (widget.onTap == null || widget.isLoading) return;
    setState(() => _isPressed = false);
    _controller.reverse();
  }

  void _handleTapCancel() {
    if (widget.onTap == null || widget.isLoading) return;
    setState(() => _isPressed = false);
    _controller.reverse();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      onTapDown: _handleTapDown,
      onTapUp: _handleTapUp,
      onTapCancel: _handleTapCancel,
      onTap: widget.isLoading ? null : widget.onTap,
      child: AnimatedBuilder(
        animation: _scaleAnimation,
        builder: (context, child) => Transform.scale(
          scale: _scaleAnimation.value,
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: widget.isSelected
                  ? theme.primaryPurple.withValues(alpha: 0.1)
                  : theme.cardBackground,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: _getContainerBorderColor(theme),
                width: widget.isSelected ? 2.5 : 2,
              ),
              boxShadow: _isPressed || widget.isLoading
                  ? null
                  : [
                      BoxShadow(
                        color: widget.isSelected
                            ? theme.primaryPurple.withValues(alpha: 0.2)
                            : theme.primaryPurple.withValues(alpha: 0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 4),
                      ),
                    ],
            ),
            child: Row(
              children: [
                widget.isLoading
                    ? SizedBox(
                        width: 30,
                        height: 30,
                        child: CircularProgressIndicator(
                          strokeWidth: 2.5,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            theme.primaryPurple,
                          ),
                        ),
                      )
                    : widget.icon,
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.title,
                        style: TextStyle(
                          color: _getTextColor(theme),
                          fontSize: 18,
                          fontWeight: widget.isSelected
                              ? FontWeight.w800
                              : FontWeight.bold,
                        ),
                      ),
                      Text(
                        widget.id,
                        style: TextStyle(
                          color: widget.isSelected
                              ? theme.primaryPurple.withValues(alpha: 0.8)
                              : theme.textSecondary,
                          fontSize: 10,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),
                if (widget.isSelected && !widget.isLoading) ...[
                  const SizedBox(width: 8),
                  Icon(
                    Icons.check_circle,
                    color: theme.primaryPurple,
                    size: 24,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  Color _getContainerBorderColor(AppTheme theme) {
    if (widget.isLoading) {
      return theme.primaryPurple.withValues(alpha: 0.3);
    }
    if (_isPressed) {
      return theme.primaryPurple.withValues(alpha: 0.7);
    }
    if (widget.isSelected) {
      return theme.primaryPurple;
    }
    return theme.primaryPurple.withValues(alpha: 0.8);
  }

  Color _getTextColor(AppTheme theme) {
    if (widget.isLoading) {
      return theme.textPrimary.withValues(alpha: 0.7);
    }
    if (widget.isSelected) {
      return theme.primaryPurple;
    }
    return theme.textPrimary;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/copy_content.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/state/app_state.dart';

class CopyAddressButton extends StatefulWidget {
  final String address;
  final bool isShort;

  const CopyAddressButton({
    super.key,
    required this.address,
    this.isShort = true,
  });

  @override
  State<CopyAddressButton> createState() => _CopyAddressButtonState();
}

class _CopyAddressButtonState extends State<CopyAddressButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  bool _isCopied = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    _opacityAnimation = Tween<double>(begin: 1.0, end: 0.7).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _copyToClipboard() async {
    await Clipboard.setData(ClipboardData(text: widget.address));
    if (mounted) {
      setState(() {
        _isCopied = true;
      });
      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          setState(() {
            _isCopied = false;
          });
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) => _controller.forward(),
        onTapUp: (_) {
          _controller.reverse();
          _copyToClipboard();
        },
        onTapCancel: () => _controller.reverse(),
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: Opacity(
                opacity: _opacityAnimation.value,
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  child: Wrap(
                    alignment: WrapAlignment.center,
                    crossAxisAlignment: WrapCrossAlignment.center,
                    spacing: 4,
                    runSpacing: 4,
                    children: [
                      Text(
                        widget.isShort
                            ? shortenAddress(widget.address)
                            : widget.address,
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 14,
                        ),
                      ),
                      SvgPicture.asset(
                        _isCopied
                            ? 'assets/icons/check.svg'
                            : 'assets/icons/copy.svg',
                        width: 14,
                        height: 14,
                        colorFilter: ColorFilter.mode(
                          _isCopied ? theme.success : theme.textSecondary,
                          BlendMode.srcIn,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/counter.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CounterIcons {
  static const String minus = '''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle cx="16" cy="16" r="15" fill="none" stroke="currentColor" stroke-width="2"/>
  <line x1="8" y1="16" x2="24" y2="16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
''';

  static const String plus = '''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle cx="16" cy="16" r="15" fill="none" stroke="currentColor" stroke-width="2"/>
  <line x1="8" y1="16" x2="24" y2="16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  <line x1="16" y1="8" x2="16" y2="24" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
''';
}

class Counter extends StatefulWidget {
  final double iconSize;
  final Color? iconColor;
  final TextStyle? numberStyle;
  final Duration animationDuration;
  final int initialValue;
  final ValueChanged<int>? onChanged;
  final bool disabled;
  final int minValue;
  final int maxValue;
  final String? errorText;

  const Counter({
    super.key,
    this.iconSize = 32,
    this.iconColor,
    this.numberStyle,
    this.animationDuration = const Duration(milliseconds: 300),
    this.initialValue = 0,
    this.onChanged,
    this.disabled = false,
    this.minValue = 0,
    this.maxValue = 999999,
    this.errorText,
  }) : assert(initialValue >= minValue && initialValue <= maxValue,
            'Initial value must be between min and max values');

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> with SingleTickerProviderStateMixin {
  late int _count;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _count = widget.initialValue;
    _controller = AnimationController(
      duration: widget.animationDuration,
      vsync: this,
    );

    _scaleAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.0, end: 1.2),
        weight: 50,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.2, end: 1.0),
        weight: 50,
      ),
    ]).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _animate() {
    if (!widget.disabled) {
      _controller.forward(from: 0);
    }
  }

  void _increment() {
    if (!widget.disabled && _count < widget.maxValue) {
      setState(() {
        _count++;
        _animate();
        _errorMessage = null;
        widget.onChanged?.call(_count);
      });
    } else if (!widget.disabled && _count >= widget.maxValue) {
      setState(() {
        _errorMessage = 'Maximum value reached';
      });
    }
  }

  void _decrement() {
    if (!widget.disabled && _count > widget.minValue) {
      setState(() {
        _count--;
        _animate();
        _errorMessage = null;
        widget.onChanged?.call(_count);
      });
    } else if (!widget.disabled && _count <= widget.minValue) {
      setState(() {
        _errorMessage = 'Minimum value reached';
      });
    }
  }

  @override
  void didUpdateWidget(Counter oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialValue != oldWidget.initialValue) {
      setState(() {
        _count = widget.initialValue;
        _errorMessage = null;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Opacity(
      opacity: widget.disabled ? 0.6 : 1.0,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          SizedBox(
            width: double.infinity,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  icon: SvgPicture.string(
                    CounterIcons.minus,
                    width: widget.iconSize,
                    height: widget.iconSize,
                    colorFilter: ColorFilter.mode(
                      _count > widget.minValue && !widget.disabled
                          ? widget.iconColor ?? theme.secondaryPurple
                          : (widget.iconColor ?? theme.secondaryPurple)
                              .withValues(alpha: 0.3),
                      BlendMode.srcIn,
                    ),
                  ),
                  onPressed: widget.disabled
                      ? null
                      : (_count > widget.minValue ? _decrement : null),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: AnimatedBuilder(
                    animation: _scaleAnimation,
                    builder: (context, child) => Transform.scale(
                      scale: _scaleAnimation.value,
                      child: child,
                    ),
                    child: Text(
                      '$_count',
                      style: widget.numberStyle ??
                          TextStyle(
                            fontSize: 14,
                            color: theme.textSecondary,
                            fontWeight: FontWeight.w500,
                          ),
                    ),
                  ),
                ),
                IconButton(
                  icon: SvgPicture.string(
                    CounterIcons.plus,
                    width: widget.iconSize,
                    height: widget.iconSize,
                    colorFilter: ColorFilter.mode(
                      _count < widget.maxValue && !widget.disabled
                          ? widget.iconColor ?? theme.secondaryPurple
                          : (widget.iconColor ?? theme.secondaryPurple)
                              .withValues(alpha: 0.3),
                      BlendMode.srcIn,
                    ),
                  ),
                  onPressed: widget.disabled
                      ? null
                      : (_count < widget.maxValue ? _increment : null),
                ),
              ],
            ),
          ),
          if (_errorMessage != null || widget.errorText != null)
            Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Text(
                _errorMessage ?? widget.errorText ?? '',
                style: TextStyle(
                  color: theme.danger,
                  fontSize: 12,
                  fontWeight: FontWeight.w400,
                ),
                textAlign: TextAlign.center,
              ),
            ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/token_transfer_amount.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class TokenTransferAmount extends StatelessWidget {
  final String fromAddress;
  final String toAddress;
  final String amount;
  final String symbol;
  final String? fromName;
  final String? toName;
  final bool disabled;

  const TokenTransferAmount({
    super.key,
    required this.fromAddress,
    required this.toAddress,
    required this.amount,
    required this.symbol,
    this.fromName,
    this.toName,
    this.disabled = false,
  });

  String _formatAddress(String address) {
    return shortenAddress(address);
  }

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));
  }

  Widget _buildAddressButton(
    BuildContext context,
    String address,
    String? name,
    AppTheme theme,
    TextStyle style,
  ) {
    return Expanded(
      flex: 3,
      child: TextButton(
        onPressed: () => _copyToClipboard(context, address),
        style: TextButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          minimumSize: Size.zero,
          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
          splashFactory: NoSplash.splashFactory,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              name ?? 'Unknown',
              style: style.copyWith(
                fontSize: 8,
                fontWeight: FontWeight.w400,
              ),
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 2),
            Text(
              _formatAddress(address),
              style: style,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;

    final addressStyle = TextStyle(
      fontSize: 10,
      color: theme.textPrimary.withValues(alpha: 0.7),
      letterSpacing: 0.5,
      fontWeight: FontWeight.w500,
    );

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
      decoration: BoxDecoration(
        color: theme.secondaryPurple.withValues(alpha: 0.05),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          _buildAddressButton(
            context,
            fromAddress,
            fromName,
            theme,
            addressStyle,
          ),
          Expanded(
            flex: 4,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: theme.primaryPurple.withValues(alpha: 0.1),
                    shape: BoxShape.circle,
                  ),
                  child: SvgPicture.asset(
                    "assets/icons/right_arrow.svg",
                    width: 24,
                    height: 24,
                    colorFilter: ColorFilter.mode(
                      theme.primaryPurple,
                      BlendMode.srcIn,
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Flexible(
                      child: Text(
                        amount,
                        style: TextStyle(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: theme.textPrimary,
                          letterSpacing: 0.5,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    const SizedBox(width: 4),
                    Text(
                      symbol,
                      style: TextStyle(
                        fontSize: 10,
                        fontWeight: FontWeight.w400,
                        color: theme.textSecondary.withValues(alpha: 0.7),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          _buildAddressButton(
            context,
            toAddress,
            toName,
            theme,
            addressStyle,
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/custom_dropdown.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomDropdown extends StatefulWidget {
  final List<dynamic> items;
  final int selectedItem;
  final Function(int) onChanged;

  const CustomDropdown({
    super.key,
    required this.items,
    required this.selectedItem,
    required this.onChanged,
  });

  @override
  State<CustomDropdown> createState() => _CustomDropdownState();
}

class _CustomDropdownState extends State<CustomDropdown>
    with SingleTickerProviderStateMixin {
  bool _isExpanded = false;
  late OverlayEntry _overlayEntry;
  late AnimationController _animationController;
  late Animation<double> _expandAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 300));
    _expandAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      onTap: _toggleDropdown,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: theme.primaryPurple,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              widget.selectedItem.toString(),
              style: TextStyle(color: theme.textPrimary, fontSize: 16),
            ),
            const SizedBox(width: 8),
            Icon(
              _isExpanded ? Icons.arrow_drop_up : Icons.arrow_drop_down,
              color: Colors.white,
            ),
          ],
        ),
      ),
    );
  }

  void _toggleDropdown() {
    if (_isExpanded) {
      _animationController.reverse().then((_) {
        if (_overlayEntry.mounted) {
          _overlayEntry.remove();
        }
      });
    } else {
      _overlayEntry = _createOverlayEntry();
      Overlay.of(context).insert(_overlayEntry);
      _animationController.forward();
    }
    setState(() {
      _isExpanded = !_isExpanded;
    });
  }

  OverlayEntry _createOverlayEntry() {
    RenderBox renderBox = context.findRenderObject() as RenderBox;
    var size = renderBox.size;
    var offset = renderBox.localToGlobal(Offset.zero);

    return OverlayEntry(
      builder: (context) {
        final theme = Provider.of<AppState>(context).currentTheme;

        return GestureDetector(
          onTap: () => _toggleDropdown(),
          behavior: HitTestBehavior.translucent,
          child: Stack(
            children: [
              Positioned.fill(
                child: Container(
                  color: Colors.transparent,
                ),
              ),
              Positioned(
                left: offset.dx,
                top: offset.dy + size.height,
                width: size.width,
                child: SizeTransition(
                  sizeFactor: _expandAnimation,
                  axisAlignment: 1,
                  child: Material(
                    elevation: 4,
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 4),
                      decoration: BoxDecoration(
                        color: theme.primaryPurple,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Column(
                        children: widget.items.map((item) {
                          return InkWell(
                            onTap: () {
                              widget.onChanged(item);
                              _toggleDropdown();
                            },
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 12, horizontal: 16),
                              child: Text(
                                item.toString(),
                                style: const TextStyle(
                                    color: Colors.white, fontSize: 16),
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/network_tile.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

Widget networkLabel({
  required String text,
  required Color backgroundColor,
  required Color textColor,
}) {
  return Container(
    padding: const EdgeInsets.symmetric(
      horizontal: 8,
      vertical: 2,
    ),
    decoration: BoxDecoration(
      color: backgroundColor.withValues(alpha: 0.1),
      borderRadius: BorderRadius.circular(4),
    ),
    child: Text(
      text,
      style: TextStyle(
        fontSize: 12,
        fontWeight: FontWeight.w500,
        color: textColor,
      ),
    ),
  );
}

class NetworkTile extends StatelessWidget {
  final String? iconUrl;
  final String title;
  final bool isEnabled;
  final bool isAdded;
  final bool isSelected;
  final bool disabled;
  final bool? isTestnet;
  final bool? isDefault;
  final VoidCallback? onTap;
  final VoidCallback? onEdit;
  final VoidCallback? onAdd;

  const NetworkTile({
    super.key,
    required this.title,
    this.iconUrl,
    this.isEnabled = false,
    this.isAdded = false,
    this.isSelected = false,
    this.disabled = false,
    this.isTestnet = false,
    this.isDefault = false,
    this.onTap,
    this.onEdit,
    this.onAdd,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Opacity(
      opacity: disabled ? 0.5 : 1.0,
      child: GestureDetector(
        onTap: (isEnabled && !disabled) ? onTap : null,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: isSelected
                  ? theme.primaryPurple
                  : theme.textSecondary.withValues(alpha: 0.1),
              width: isSelected ? 2 : 1,
            ),
            color: _getBackgroundColor(theme),
          ),
          child: ListTile(
            enabled: isEnabled && !disabled,
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            leading: _buildLeadingIcon(),
            title: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  children: [
                    if (isTestnet != null)
                      networkLabel(
                        text: isTestnet! ? "Testnet" : "Mainnet",
                        backgroundColor:
                            isTestnet! ? theme.warning : theme.success,
                        textColor: isTestnet! ? theme.warning : theme.success,
                      ),
                    if (isTestnet != null && isDefault == true)
                      const SizedBox(width: 8),
                    if (isDefault == true)
                      networkLabel(
                        text: "Default",
                        backgroundColor: theme.primaryPurple,
                        textColor: theme.primaryPurple,
                      ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  title,
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    color: _getTextColor(theme),
                  ),
                ),
              ],
            ),
            trailing: _buildTrailingButton(theme),
          ),
        ),
      ),
    );
  }

  Widget _buildLeadingIcon() {
    if (iconUrl == null) {
      return const SizedBox(
        width: 32,
        height: 32,
        child: Placeholder(
          color: Colors.grey,
        ),
      );
    }

    return SizedBox(
      width: 32,
      height: 32,
      child: AsyncImage(
        url: iconUrl!,
        width: 24,
        height: 24,
        fit: BoxFit.contain,
        loadingWidget: const Center(
          child: CircularProgressIndicator(
            strokeWidth: 2,
          ),
        ),
      ),
    );
  }

  Widget? _buildTrailingButton(AppTheme theme) {
    if (isAdded) {
      return onEdit != null
          ? IconButton(
              icon: SvgPicture.asset(
                "assets/icons/edit.svg",
                width: 20,
                height: 20,
                colorFilter: ColorFilter.mode(
                  _getIconColor(theme),
                  BlendMode.srcIn,
                ),
              ),
              padding: const EdgeInsets.all(8),
              onPressed:
                  (isEnabled && !disabled && onEdit != null) ? onEdit : null,
            )
          : null;
    }

    return onAdd != null
        ? IconButton(
            icon: SvgPicture.asset(
              "assets/icons/plus.svg",
              width: 20,
              height: 20,
              colorFilter: ColorFilter.mode(
                _getIconColor(theme),
                BlendMode.srcIn,
              ),
            ),
            padding: const EdgeInsets.all(8),
            onPressed: (isEnabled && !disabled) ? onAdd : null,
          )
        : null;
  }

  Color? _getBackgroundColor(AppTheme theme) {
    if (!isEnabled) {
      return theme.textSecondary.withValues(alpha: 0.05);
    }
    if (isSelected) {
      return theme.primaryPurple.withValues(alpha: 0.1);
    }
    return theme.textSecondary.withValues(alpha: 0.02);
  }

  Color _getTextColor(AppTheme theme) {
    if (!isEnabled) {
      return theme.textSecondary.withValues(alpha: 0.5);
    }
    return theme.textSecondary;
  }

  Color _getIconColor(AppTheme theme) {
    if (!isEnabled) {
      return theme.textSecondary.withValues(alpha: 0.5);
    }
    return theme.textSecondary;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/hoverd_svg.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class HoverSvgIcon extends StatefulWidget {
  final String assetName;
  final double width;
  final double height;
  final VoidCallback onTap;
  final Color? color;
  final EdgeInsets? padding;

  const HoverSvgIcon({
    super.key,
    required this.assetName,
    required this.width,
    required this.height,
    required this.onTap,
    this.color,
    this.padding = const EdgeInsets.all(8.0),
  });

  @override
  State<HoverSvgIcon> createState() => HoverSvgIconState();
}

class HoverSvgIconState extends State<HoverSvgIcon> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final iconColor = widget.color ?? theme.textPrimary;

    return Container(
      constraints: BoxConstraints(
        minWidth: widget.width + 16,
        minHeight: widget.height + 16,
      ),
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) => setState(() => _isPressed = true),
        onTapUp: (_) => setState(() => _isPressed = false),
        onTapCancel: () => setState(() => _isPressed = false),
        onTap: widget.onTap,
        child: Padding(
          padding: widget.padding!,
          child: Opacity(
            opacity: _isPressed ? 0.5 : 1.0,
            child: SvgPicture.asset(
              widget.assetName,
              width: widget.width,
              height: widget.height,
              colorFilter: ColorFilter.mode(
                iconColor,
                BlendMode.srcIn,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/smart_input.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'dart:math' show pi, sin;

import 'package:zilpay/state/app_state.dart';

class SmartInput extends StatefulWidget {
  final TextEditingController? controller;
  final String? hint;
  final bool obscureText;
  final Function(String)? onChanged;
  final Function()? onLeftIconTap;
  final Function()? onRightIconTap;
  final Function()? onSubmitted;
  final Function(bool)? onFocusChanged;
  final String? leftIconPath;
  final String? rightIconPath;
  final Color? borderColor;
  final Color? focusedBorderColor;
  final double? height;
  final double? width;
  final double? fontSize;
  final EdgeInsets? padding;
  final EdgeInsets? iconPadding;
  final bool disabled;

  const SmartInput({
    super.key,
    this.controller,
    this.hint,
    this.obscureText = false,
    this.onChanged,
    this.onLeftIconTap,
    this.onRightIconTap,
    this.onSubmitted,
    this.onFocusChanged,
    this.leftIconPath,
    this.rightIconPath,
    this.borderColor,
    this.focusedBorderColor,
    this.height = 48,
    this.width,
    this.fontSize = 16,
    this.padding,
    this.iconPadding,
    this.disabled = false,
  });

  @override
  State<SmartInput> createState() => SmartInputState();
}

class SmartInputState extends State<SmartInput>
    with SingleTickerProviderStateMixin {
  late AnimationController _shakeController;
  late Animation<double> _shakeAnimation;
  final FocusNode _focusNode = FocusNode();
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    _shakeController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _shakeAnimation = Tween<double>(begin: 0.0, end: 10.0)
        .chain(CurveTween(curve: const InputShakeCurve()))
        .animate(_shakeController);

    _focusNode.addListener(_handleFocusChange);
  }

  void _handleFocusChange() {
    if (!mounted) return;

    setState(() {
      _isFocused = _focusNode.hasFocus;
    });

    if (widget.onFocusChanged != null) {
      widget.onFocusChanged!(_focusNode.hasFocus);
    }
  }

  void shake() {
    _shakeController.forward().then((_) {
      _shakeController.reset();
    });
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    _shakeController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  double get _iconSize {
    final containerHeight = widget.height ?? 48;
    return containerHeight * 0.416;
  }

  Widget? _buildIcon({
    required String? iconPath,
    required Color color,
    Function()? onTap,
  }) {
    if (iconPath == null) return null;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Padding(
        padding:
            widget.iconPadding ?? const EdgeInsets.symmetric(horizontal: 16),
        child: SvgPicture.asset(
          iconPath,
          width: _iconSize,
          height: _iconSize,
          colorFilter: ColorFilter.mode(
            color,
            BlendMode.srcIn,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    final defaultBorderColor = theme.textSecondary.withValues(alpha: 0.3);
    final defaultFocusedBorderColor = theme.primaryPurple;

    final iconColor = _isFocused
        ? (widget.focusedBorderColor ?? defaultFocusedBorderColor)
        : theme.textSecondary;

    // Get the actual border color based on the widget's state
    Color getBorderColor() {
      if (widget.disabled) {
        return widget.borderColor ?? Colors.transparent;
      }
      if (_isFocused) {
        return widget.focusedBorderColor ?? defaultFocusedBorderColor;
      }
      return widget.borderColor ?? defaultBorderColor;
    }

    return AnimatedBuilder(
      animation: _shakeAnimation,
      builder: (context, child) {
        return Transform.translate(
          offset: Offset(_shakeAnimation.value, 0),
          child: Container(
            height: widget.height,
            width: widget.width,
            decoration: BoxDecoration(
              color: widget.disabled
                  ? theme.cardBackground.withValues(alpha: 0.5)
                  : theme.cardBackground,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: getBorderColor(),
                width: 1.0,
              ),
            ),
            child: Row(
              children: [
                if (widget.leftIconPath != null)
                  _buildIcon(
                        iconPath: widget.leftIconPath,
                        color: iconColor,
                        onTap: widget.disabled ? null : widget.onLeftIconTap,
                      ) ??
                      const SizedBox(),
                Expanded(
                  child: Padding(
                    padding: widget.padding ??
                        EdgeInsets.symmetric(
                          horizontal: widget.leftIconPath == null &&
                                  widget.rightIconPath == null
                              ? 16
                              : 8,
                        ),
                    child: TextFormField(
                      controller: widget.controller,
                      focusNode: _focusNode,
                      obscureText: widget.obscureText,
                      onChanged: widget.onChanged,
                      enabled: !widget.disabled,
                      onFieldSubmitted: (_) {
                        if (!widget.disabled) {
                          widget.onSubmitted?.call();
                        }
                      },
                      style: TextStyle(
                        color: widget.disabled
                            ? theme.textPrimary.withValues(alpha: 0.5)
                            : theme.textPrimary,
                        fontSize: widget.fontSize,
                      ),
                      decoration: InputDecoration(
                        border: InputBorder.none,
                        hintText: widget.hint,
                        hintStyle: TextStyle(
                          color: widget.disabled
                              ? theme.textSecondary.withValues(alpha: 0.5)
                              : theme.textSecondary,
                          fontSize: widget.fontSize,
                        ),
                      ),
                    ),
                  ),
                ),
                if (widget.rightIconPath != null)
                  _buildIcon(
                        iconPath: widget.rightIconPath,
                        color: iconColor,
                        onTap: widget.disabled ? null : widget.onRightIconTap,
                      ) ??
                      const SizedBox(),
              ],
            ),
          ),
        );
      },
    );
  }
}

class InputShakeCurve extends Curve {
  const InputShakeCurve();

  @override
  double transform(double t) {
    return sin(t * pi * 5) * (1 - t);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/mnemonic_word_input.dart`:

```dart
import 'package:provider/provider.dart';
import 'package:flutter/material.dart';
import 'package:zilpay/state/app_state.dart';

class MnemonicWordInput extends StatefulWidget {
  final int index;
  final String word;
  final bool isEditable;
  final Color? borderColor;
  final Color? errorBorderColor;
  final bool hasError;
  final double opacity;
  final Function(int, String)? onChanged;

  const MnemonicWordInput({
    super.key,
    required this.index,
    required this.word,
    this.onChanged,
    this.opacity = 1,
    this.isEditable = false,
    this.borderColor,
    this.errorBorderColor,
    this.hasError = false,
  });

  @override
  State<MnemonicWordInput> createState() => _MnemonicWordInputState();
}

class _MnemonicWordInputState extends State<MnemonicWordInput> {
  late TextEditingController _controller;
  bool _shouldUpdateText = true;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.word);
  }

  @override
  void didUpdateWidget(MnemonicWordInput oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (_shouldUpdateText && widget.word != _controller.text) {
      _controller.text = widget.word;
    }
    _shouldUpdateText = true;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: theme.cardBackground.withValues(alpha: widget.opacity),
        borderRadius: BorderRadius.circular(16),
        border: widget.hasError
            ? Border.all(
                color: widget.errorBorderColor ?? theme.danger,
                width: 1,
              )
            : widget.borderColor != null
                ? Border.all(color: widget.borderColor!, width: 1)
                : null,
      ),
      child: Row(
        children: [
          Text(
            '${widget.index}',
            style: TextStyle(
              color: widget.hasError
                  ? (widget.errorBorderColor ?? theme.danger)
                  : theme.textSecondary,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: TextField(
              controller: _controller,
              style: TextStyle(
                color: widget.hasError
                    ? (widget.errorBorderColor ?? theme.danger)
                    : theme.textPrimary,
              ),
              enabled: widget.isEditable,
              decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                contentPadding: EdgeInsets.zero,
              ),
              onChanged: (value) {
                _shouldUpdateText = false;
                if (widget.onChanged != null) {
                  widget.onChanged!(widget.index, value);
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/token_select_item.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/state/app_state.dart';

class TokenSelectItem extends StatelessWidget {
  final String symbol;
  final String addr;
  final String name;
  final String balance;
  final String iconUrl;
  final VoidCallback onTap;
  final double iconSize;

  const TokenSelectItem({
    super.key,
    required this.addr,
    required this.symbol,
    required this.name,
    required this.balance,
    required this.iconUrl,
    required this.onTap,
    this.iconSize = 40.0,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
        child: Row(
          children: [
            Container(
              width: iconSize,
              height: iconSize,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(iconSize / 2),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(iconSize / 2),
                child: AsyncImage(
                  url: iconUrl,
                  width: iconSize,
                  height: iconSize,
                  fit: BoxFit.contain,
                  errorWidget: Blockies(
                    seed: addr,
                    color: getWalletColor(0),
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                  loadingWidget: const Center(
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    symbol,
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    name,
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  balance,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/hex_key.dart`:

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';

class HexKeyDisplay extends StatefulWidget {
  final String hexKey;
  final String title;

  const HexKeyDisplay({
    super.key,
    required this.hexKey,
    required this.title,
  });

  @override
  State<HexKeyDisplay> createState() => _HexKeyDisplayState();
}

class _HexKeyDisplayState extends State<HexKeyDisplay> {
  List<bool> animationStates = [];
  List<String> currentPairs = [];
  List<String> targetPairs = [];

  @override
  void initState() {
    super.initState();
    _initializePairs();
  }

  void _initializePairs() {
    currentPairs = _getPairs(widget.hexKey);
    targetPairs = List.from(currentPairs);
    animationStates = List.generate(currentPairs.length, (_) => false);
  }

  @override
  void didUpdateWidget(HexKeyDisplay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.hexKey != widget.hexKey) {
      targetPairs = _getPairs(widget.hexKey);
      if (targetPairs.length != currentPairs.length) {
        currentPairs = List.from(targetPairs);
        animationStates = List.generate(currentPairs.length, (_) => false);
      }
      _startAnimation();
    }
  }

  List<String> _getPairs(String key) {
    if (key.isEmpty) return [];

    final cleanKey = key.replaceAll(RegExp(r'[^0-9A-Fa-f]'), '').toUpperCase();
    final pairs = <String>[];
    for (var i = 0; i < cleanKey.length; i += 2) {
      if (i + 2 <= cleanKey.length) {
        pairs.add(cleanKey.substring(i, i + 2));
      }
    }
    return pairs;
  }

  void _startAnimation() {
    if (currentPairs.isEmpty) return;

    double delayMs = 30;
    double acceleration = 1.0; // Factor of animation

    for (var i = 0; i < currentPairs.length; i++) {
      final totalDelay =
          List.generate(i + 1, (index) => delayMs * pow(acceleration, index))
              .reduce((sum, delay) => sum + delay);

      Future.delayed(Duration(milliseconds: totalDelay.round()), () {
        if (mounted) {
          setState(() {
            animationStates[i] = true;
            currentPairs[i] = targetPairs[i];
          });

          Future.delayed(const Duration(milliseconds: 80), () {
            if (mounted) {
              setState(() {
                animationStates[i] = false;
              });
            }
          });
        }
      });
    }
  }

  int _getChunkSize(BuildContext context) {
    final width = MediaQuery.of(context).size.width;

    if (width < 600) return 6;
    if (width < 905) return 8;
    if (width < 1240) return 10;

    return 12;
  }

  List<List<String>> _formatHexKey(BuildContext context) {
    if (currentPairs.isEmpty) return [];

    final chunkSize = _getChunkSize(context);
    final chunks = <List<String>>[];

    for (var i = 0; i < currentPairs.length; i += chunkSize) {
      chunks.add(currentPairs.sublist(
          i,
          i + chunkSize > currentPairs.length
              ? currentPairs.length
              : i + chunkSize));
    }

    return chunks;
  }

  @override
  Widget build(BuildContext context) {
    if (currentPairs.isEmpty) {
      _initializePairs();
    }

    final chunks = _formatHexKey(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    final chunkSize = _getChunkSize(context);
    final containerWidth = (45.0 * chunkSize) + adaptivePadding * 2;

    return Container(
      padding: EdgeInsets.all(adaptivePadding),
      constraints: BoxConstraints(maxWidth: containerWidth),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: EdgeInsets.only(bottom: adaptivePadding),
            child: Text(
              widget.title,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 18,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          ...chunks.asMap().entries.map((chunkEntry) {
            return Padding(
              padding: const EdgeInsets.only(bottom: 6),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: chunkEntry.value.asMap().entries.map((pairEntry) {
                  final globalIndex =
                      chunkEntry.key * _getChunkSize(context) + pairEntry.key;
                  final isAnimating = globalIndex < animationStates.length
                      ? animationStates[globalIndex]
                      : false;

                  return AnimatedContainer(
                    duration: const Duration(milliseconds: 100),
                    width: 45,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      pairEntry.value,
                      style: TextStyle(
                        color: isAnimating
                            ? theme.secondaryPurple
                            : theme.textPrimary,
                        fontSize: 16,
                        fontFamily: 'Courier',
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  );
                }).toList(),
              ),
            );
          }),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/load_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

enum ButtonState { idle, loading, success, error }

class RoundedLoadingButton extends StatefulWidget {
  final RoundedLoadingButtonController controller;
  final VoidCallback? onPressed;
  final Widget child;
  final Color? color;
  final double height;
  final double width;
  final double loaderSize;
  final Color valueColor;
  final double borderRadius;
  final Widget? successIcon;
  final Widget? failedIcon;

  const RoundedLoadingButton({
    super.key,
    required this.controller,
    required this.onPressed,
    required this.child,
    this.color,
    this.height = 56.0,
    this.width = double.infinity,
    this.loaderSize = 24.0,
    this.valueColor = Colors.white,
    this.borderRadius = 30.0,
    this.successIcon,
    this.failedIcon,
  });

  @override
  State<StatefulWidget> createState() => RoundedLoadingButtonState();
}

class RoundedLoadingButtonState extends State<RoundedLoadingButton>
    with TickerProviderStateMixin {
  late AnimationController _buttonController;
  late AnimationController _checkButtonController;
  late Animation<double> _bounceAnimation;
  late Animation<double> _squeezeAnimation;
  late double _actualWidth;
  late ValueNotifier<ButtonState> _stateNotifier;

  @override
  void initState() {
    super.initState();

    _buttonController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _checkButtonController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _bounceAnimation = Tween<double>(begin: 0, end: widget.height).animate(
      CurvedAnimation(
        parent: _checkButtonController,
        curve: Curves.elasticOut,
      ),
    )..addListener(() {
        setState(() {});
      });

    _actualWidth = 0;
    _stateNotifier = widget.controller._stateNotifier;
    widget.controller._addListeners(_start, _stop, _success, _error, _reset);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return LayoutBuilder(
      builder: (context, constraints) {
        _actualWidth = widget.width == double.infinity
            ? constraints.maxWidth
            : widget.width;

        _squeezeAnimation = Tween<double>(
          begin: _actualWidth,
          end: widget.height,
        ).animate(
          CurvedAnimation(
            parent: _buttonController,
            curve: Curves.easeInOutCirc,
          ),
        )..addListener(() {
            setState(() {});
          });

        Widget successIcon = Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: theme.primaryPurple,
            borderRadius: BorderRadius.circular(_bounceAnimation.value / 2),
          ),
          width: _bounceAnimation.value,
          height: _bounceAnimation.value,
          child: _bounceAnimation.value > 20
              ? widget.successIcon ??
                  Icon(
                    Icons.check,
                    color: widget.valueColor,
                  )
              : null,
        );

        Widget errorIcon = Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: Colors.red,
            borderRadius: BorderRadius.circular(_bounceAnimation.value / 2),
          ),
          width: _bounceAnimation.value,
          height: _bounceAnimation.value,
          child: _bounceAnimation.value > 20
              ? widget.failedIcon ??
                  Icon(
                    Icons.close,
                    color: widget.valueColor,
                  )
              : null,
        );

        Widget loader = SizedBox(
          height: widget.loaderSize,
          width: widget.loaderSize,
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation<Color>(widget.valueColor),
            strokeWidth: 2.0,
          ),
        );

        Widget childContent = ValueListenableBuilder<ButtonState>(
          valueListenable: _stateNotifier,
          builder: (context, state, _) {
            return AnimatedSwitcher(
              duration: const Duration(milliseconds: 200),
              child: state == ButtonState.loading ? loader : widget.child,
            );
          },
        );

        final button = ElevatedButton(
          style: ElevatedButton.styleFrom(
            minimumSize: Size(_squeezeAnimation.value, widget.height),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(widget.borderRadius),
            ),
            backgroundColor: widget.color ?? theme.primaryPurple,
            elevation: 0,
            padding: const EdgeInsets.all(0),
          ),
          onPressed: widget.onPressed,
          child: childContent,
        );

        return AnimatedBuilder(
          animation: _buttonController,
          builder: (context, child) {
            return SizedBox(
              height: widget.height,
              child: ValueListenableBuilder<ButtonState>(
                valueListenable: _stateNotifier,
                builder: (context, state, _) {
                  return Center(
                    child: state == ButtonState.error
                        ? errorIcon
                        : state == ButtonState.success
                            ? successIcon
                            : SizedBox(
                                width: _squeezeAnimation.value,
                                child: button,
                              ),
                  );
                },
              ),
            );
          },
        );
      },
    );
  }

  @override
  void dispose() {
    _buttonController.dispose();
    _checkButtonController.dispose();
    super.dispose();
  }

  void _start() {
    if (!mounted) return;
    _stateNotifier.value = ButtonState.loading;
    _buttonController.forward();
  }

  void _stop() {
    if (!mounted) return;
    _stateNotifier.value = ButtonState.idle;
    _buttonController.reverse();
  }

  void _success() {
    if (!mounted) return;
    _stateNotifier.value = ButtonState.success;
    _checkButtonController.forward();
  }

  void _error() {
    if (!mounted) return;
    _stateNotifier.value = ButtonState.error;
    _checkButtonController.forward();
  }

  void _reset() {
    if (!mounted) return;
    _stateNotifier.value = ButtonState.idle;
    _buttonController.reverse();
    _checkButtonController.reset();
  }
}

class RoundedLoadingButtonController {
  VoidCallback? _startListener;
  VoidCallback? _stopListener;
  VoidCallback? _successListener;
  VoidCallback? _errorListener;
  VoidCallback? _resetListener;

  final ValueNotifier<ButtonState> _stateNotifier =
      ValueNotifier(ButtonState.idle);

  void _addListeners(
    VoidCallback startListener,
    VoidCallback stopListener,
    VoidCallback successListener,
    VoidCallback errorListener,
    VoidCallback resetListener,
  ) {
    _startListener = startListener;
    _stopListener = stopListener;
    _successListener = successListener;
    _errorListener = errorListener;
    _resetListener = resetListener;
  }

  ButtonState get currentState => _stateNotifier.value;

  void start() {
    if (_startListener != null) _startListener!();
  }

  void stop() {
    if (_stopListener != null) _stopListener!();
  }

  void success() {
    if (_successListener != null) _successListener!();
  }

  void error() {
    if (_errorListener != null) _errorListener!();
  }

  void reset() {
    if (_resetListener != null) _resetListener!();
  }

  void dispose() {
    _stateNotifier.dispose();
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/bottom_nav_bar.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'dart:ui';
import 'package:zilpay/state/app_state.dart';

class CustomBottomNavigationBar extends StatelessWidget {
  final List<CustomBottomNavigationBarItem> items;
  final int currentIndex;
  final Function(int) onTap;

  const CustomBottomNavigationBar({
    super.key,
    required this.items,
    required this.currentIndex,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return ClipRect(
      child: BackdropFilter(
        filter: ImageFilter.blur(
          sigmaX: 10.0,
          sigmaY: 10.0,
        ),
        child: SizedBox(
          height: 80,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: items.asMap().entries.map((entry) {
              int index = entry.key;
              CustomBottomNavigationBarItem item = entry.value;
              return Expanded(
                child: GestureDetector(
                  behavior: HitTestBehavior.opaque,
                  onTap: () => onTap(index),
                  child: Container(
                    color: Colors.transparent,
                    child: SvgPicture.asset(
                      item.iconPath,
                      colorFilter: ColorFilter.mode(
                        index == currentIndex
                            ? theme.primaryPurple
                            : theme.textSecondary,
                        BlendMode.srcIn,
                      ),
                      width: 40,
                      height: 40,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ),
      ),
    );
  }
}

class CustomBottomNavigationBarItem {
  final String iconPath;

  CustomBottomNavigationBarItem({required this.iconPath});
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/crypto_list.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CryptoList extends StatelessWidget {
  final List<CryptoListItem> items;

  const CryptoList({super.key, required this.items});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: items.length,
        separatorBuilder: (context, index) => Divider(
          color: theme.textSecondary.withValues(alpha: 0.2),
          height: 1,
        ),
        itemBuilder: (context, index) {
          return items[index];
        },
      ),
    );
  }
}

class CryptoListItem extends StatelessWidget {
  final String name;
  final String balance;
  final String balanceInUsd;
  final List<Widget> icons;

  const CryptoListItem({
    super.key,
    required this.name,
    required this.balance,
    required this.balanceInUsd,
    required this.icons,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  balanceInUsd,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                balance,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 4),
              Row(
                children: icons,
              ),
            ],
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/wallet_header.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:zilpay/components/copy_content.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/modals/wallet_header.dart';

class WalletHeader extends StatefulWidget {
  final String walletName;
  final String walletAddress;
  final Color primaryPurple;
  final Color background;
  final Color textPrimary;
  final Function()? onTap;

  const WalletHeader({
    super.key,
    required this.walletName,
    required this.walletAddress,
    required this.primaryPurple,
    required this.background,
    required this.textPrimary,
    this.onTap,
  });

  @override
  State<WalletHeader> createState() => _WalletHeaderState();
}

class _WalletHeaderState extends State<WalletHeader>
    with SingleTickerProviderStateMixin {
  double _opacity = 1.0;
  bool _isAnimated = true;

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _isAnimated = false;
      _opacity = 0.5;
    });
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() {
      _isAnimated = true;
      _opacity = 1.0;
    });
  }

  void _handleTapCancel() {
    setState(() {
      _isAnimated = true;
      _opacity = 1.0;
    });
  }

  void _showWalletModal() {
    showWalletModal(
      context: context,
      onManageWallet: () {
        Navigator.pushNamed(context, '/login');
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.end,
      children: [
        GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTapDown: _handleTapDown,
          onTapUp: _handleTapUp,
          onTapCancel: _handleTapCancel,
          onTap: () {
            _showWalletModal();
            widget.onTap?.call();
          },
          child: AnimatedOpacity(
            opacity: _opacity,
            duration: Duration(milliseconds: _isAnimated ? 150 : 0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: 34,
                  height: 34,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: widget.primaryPurple.withValues(alpha: 0.1),
                      width: 2,
                    ),
                  ),
                  child: ClipOval(
                    child: Blockies(
                      seed: widget.walletAddress,
                      color: getWalletColor(0),
                      bgColor: widget.primaryPurple,
                      spotColor: widget.background,
                      size: 8,
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  widget.walletName,
                  style: TextStyle(
                    color: widget.textPrimary,
                    fontSize: 24,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(width: 8),
        CopyAddressButton(
          address: widget.walletAddress,
        ),
      ],
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/linear_refresh_indicator.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class LinearRefreshIndicator extends StatefulWidget {
  final double pulledExtent;
  final double refreshTriggerPullDistance;
  final double refreshIndicatorExtent;

  const LinearRefreshIndicator({
    super.key,
    required this.pulledExtent,
    required this.refreshTriggerPullDistance,
    required this.refreshIndicatorExtent,
  });

  @override
  State<LinearRefreshIndicator> createState() => _LinearRefreshIndicatorState();
}

class _LinearRefreshIndicatorState extends State<LinearRefreshIndicator>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  bool _hasStartedLoading = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 1.0,
      end: 0.1,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));
  }

  @override
  void didUpdateWidget(LinearRefreshIndicator oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.pulledExtent >= widget.refreshTriggerPullDistance &&
        !_hasStartedLoading) {
      _hasStartedLoading = true;
      _controller.forward();
    }

    if (widget.pulledExtent < widget.refreshTriggerPullDistance) {
      _hasStartedLoading = false;
      _controller.reset();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final double progress =
        (widget.pulledExtent / widget.refreshTriggerPullDistance)
            .clamp(0.0, 1.0);

    return SizedBox(
      height: widget.refreshIndicatorExtent,
      child: Center(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.6,
          height: 2.0,
          child: AnimatedBuilder(
            animation: _animation,
            builder: (context, child) {
              return Center(
                child: Container(
                  height: 2.0,
                  width: (MediaQuery.of(context).size.width * 0.6) *
                      progress *
                      _animation.value,
                  decoration: BoxDecoration(
                    color: theme.primaryPurple,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/swipe_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class SwipeButton extends StatefulWidget {
  final double width;
  final double height;
  final String text;
  final Future<void> Function() onSwipeComplete;

  const SwipeButton({
    super.key,
    this.width = 300.0,
    this.height = 56.0,
    required this.text,
    required this.onSwipeComplete,
  });

  @override
  State<SwipeButton> createState() => _SwipeButtonState();
}

class _SwipeButtonState extends State<SwipeButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  double _dragExtent = 0.0;
  bool _isDragging = false;
  bool _isLoading = false;
  double _shrinkWidth = 0.0;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _shrinkWidth = widget.width;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onDragUpdate(DragUpdateDetails details) {
    if (_isLoading) return;
    setState(() {
      _isDragging = true;
      _dragExtent += details.delta.dx;
      _dragExtent = _dragExtent.clamp(0.0, widget.width - height);
    });
  }

  void _onDragEnd(DragEndDetails details) async {
    if (_isLoading) return;
    if (_dragExtent >= widget.width - height) {
      setState(() {
        _isLoading = true;
      });

      for (var i = 0; i < 30; i++) {
        await Future.delayed(const Duration(milliseconds: 10));
        setState(() {
          _shrinkWidth = widget.width - (i * (widget.width - height) / 30);
        });
      }

      await widget.onSwipeComplete();

      setState(() {
        _isLoading = false;
        _shrinkWidth = widget.width;
      });
    }

    setState(() {
      _isDragging = false;
      _dragExtent = 0.0;
    });
    _controller.reverse();
  }

  double get height => widget.height;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 10),
      width: _shrinkWidth,
      height: height,
      decoration: BoxDecoration(
        color: theme.primaryPurple,
        borderRadius: BorderRadius.circular(height / 2),
      ),
      child: Stack(
        children: [
          if (!_isLoading)
            Center(
              child: Text(
                widget.text,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          if (_isLoading)
            Center(
              child: SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(
                  color: theme.textPrimary,
                  strokeWidth: 3,
                ),
              ),
            ),
          if (!_isLoading)
            GestureDetector(
              onHorizontalDragUpdate: _onDragUpdate,
              onHorizontalDragEnd: _onDragEnd,
              child: Container(
                margin: const EdgeInsets.all(4),
                child: Stack(
                  children: [
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Container(
                        width:
                            _isDragging ? _dragExtent + height - 8 : height - 8,
                        height: height - 8,
                        decoration: BoxDecoration(
                          borderRadius: BorderRadius.circular((height - 8) / 2),
                          gradient: LinearGradient(
                            colors: [
                              theme.secondaryPurple.withValues(alpha: 0.1),
                              theme.secondaryPurple,
                            ],
                            stops: const [0.0, 0.9],
                            begin: Alignment.centerLeft,
                            end: Alignment.centerRight,
                          ),
                        ),
                        child: Row(
                          children: [
                            if (_isDragging)
                              Expanded(
                                child: ClipRRect(
                                  borderRadius:
                                      BorderRadius.circular((height - 8) / 2),
                                ),
                              ),
                            Container(
                              width: height - 8,
                              height: height - 8,
                              decoration: BoxDecoration(
                                color: theme.secondaryPurple,
                                borderRadius:
                                    BorderRadius.circular((height - 8) / 2),
                                boxShadow: [
                                  BoxShadow(
                                    color:
                                        theme.background.withValues(alpha: 0.3),
                                    blurRadius: 4,
                                    offset: const Offset(0, 0),
                                  ),
                                ],
                              ),
                              child: SvgPicture.asset(
                                "assets/icons/right_circle_arrow.svg",
                                width: widget.width,
                                height: widget.height,
                                colorFilter: ColorFilter.mode(
                                  theme.background,
                                  BlendMode.srcIn,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/image_cache.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/cache.dart';
import 'package:zilpay/state/app_state.dart';

class AsyncImage extends StatefulWidget {
  final String url;
  final double? width;
  final double? height;
  final BoxFit? fit;
  final Widget? loadingWidget;
  final Widget? errorWidget;

  const AsyncImage({
    super.key,
    required this.url,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.loadingWidget,
    this.errorWidget,
  });

  @override
  State<AsyncImage> createState() => _AsyncImageState();
}

class _AsyncImageState extends State<AsyncImage> {
  late final AppState _appState;
  Uint8List? _cachedImageBytes;
  String? _cachedImageExt;
  bool _isLoading = true;
  bool _hasError = false;

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
    _loadImage();
  }

  Future<void> _loadImage() async {
    if (_cachedImageBytes != null && _cachedImageExt != null) return;

    setState(() {
      _isLoading = true;
      _hasError = false;
    });

    try {
      final (bytes, ext) = await getImageBytes(
        dir: _appState.cahceDir,
        url: widget.url,
      );

      if (mounted) {
        setState(() {
          _cachedImageBytes = bytes;
          _cachedImageExt = ext;
          _isLoading = false;
          _hasError = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _cachedImageBytes = null;
          _cachedImageExt = null;
          _isLoading = false;
          _hasError = true;
        });
      }
    }
  }

  Widget _buildImage() {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    if (_hasError) {
      return SizedBox(
        width: widget.width,
        height: widget.height,
        child: widget.errorWidget ??
            Center(
              child: Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: theme.danger,
                  shape: BoxShape.circle,
                ),
              ),
            ),
      );
    }

    if (_cachedImageExt == 'svg') {
      return SvgPicture.memory(
        _cachedImageBytes!,
        width: widget.width,
        height: widget.height,
        fit: widget.fit ?? BoxFit.cover,
      );
    }

    return Image.memory(
      _cachedImageBytes!,
      width: widget.width,
      height: widget.height,
      fit: widget.fit,
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return SizedBox(
        width: widget.width,
        height: widget.height,
        child: widget.loadingWidget ??
            const Center(
              child: CircularProgressIndicator(),
            ),
      );
    }

    return _buildImage();
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/components/input_amount.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/modals/select_token.dart';
import 'package:zilpay/state/app_state.dart';

class TokenAmountCard extends StatefulWidget {
  final String amount;
  final String convertAmount;
  final int tokenIndex;
  final bool showMax;
  final Function(String) onMaxTap;
  final Function(int) onTokenSelected;

  const TokenAmountCard({
    super.key,
    this.amount = "0",
    this.convertAmount = "0",
    this.tokenIndex = 0,
    this.showMax = true,
    required this.onMaxTap,
    required this.onTokenSelected,
  });

  @override
  State<TokenAmountCard> createState() => _TokenAmountCardState();
}

class _TokenAmountCardState extends State<TokenAmountCard> {
  Key _imageKey = UniqueKey();

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final token = appState.wallet!.tokens[widget.tokenIndex];
    final bigBalance =
        BigInt.parse(token.balances[appState.wallet!.selectedAccount] ?? '0');
    final balance = adjustAmountToDouble(bigBalance, token.decimals);
    final chain = appState.chain!;

    const double amountHeight = 40.0;
    const double convertHeight = 20.0;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.transparent,
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.2),
          width: 1.5,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(
                      height: amountHeight,
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Text(
                          widget.amount,
                          style: TextStyle(
                            color: theme.textPrimary,
                            fontSize:
                                _calculateFontSize(context, widget.amount),
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ),
                    SizedBox(
                      height: convertHeight,
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Text(
                          widget.convertAmount,
                          style: TextStyle(
                            color: theme.textPrimary.withValues(alpha: 0.7),
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              GestureDetector(
                onTap: () {
                  showTokenSelectModal(
                    context: context,
                    onTokenSelected: (int index) {
                      widget.onTokenSelected(index);
                      _imageKey = UniqueKey();
                    },
                  );
                },
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: theme.textPrimary.withValues(alpha: 0.2),
                      width: 1.5,
                    ),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: 24,
                        height: 24,
                        decoration: BoxDecoration(
                          border: Border.all(
                            color: theme.textPrimary.withValues(alpha: 0.2),
                            width: 1.5,
                          ),
                          borderRadius: BorderRadius.circular(24),
                        ),
                        child: AsyncImage(
                          key: _imageKey,
                          url: viewTokenIcon(
                            token,
                            chain.chainId,
                            theme.value,
                          ),
                          width: 30,
                          height: 30,
                          fit: BoxFit.contain,
                          errorWidget: Blockies(
                            seed: token.addr,
                            color: getWalletColor(0),
                            bgColor: theme.primaryPurple,
                            spotColor: theme.background,
                            size: 8,
                          ),
                          loadingWidget: const Center(
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Text(
                        token.symbol,
                        style: TextStyle(
                          color: theme.textPrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              if (_getAmount() > balance)
                SvgPicture.asset(
                  "assets/icons/warning.svg",
                  width: 15,
                  height: 15,
                  colorFilter: ColorFilter.mode(
                    theme.warning.withValues(alpha: 0.7),
                    BlendMode.srcIn,
                  ),
                ),
              const SizedBox(width: 4),
              Text(
                balance.toString(),
                style: TextStyle(
                  color: theme.textPrimary.withValues(alpha: 0.7),
                  fontSize: 14,
                ),
              ),
              if (widget.showMax) ...[
                const SizedBox(width: 8),
                GestureDetector(
                  onTap: () => widget.onMaxTap(balance.toString()),
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: theme.textPrimary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Text(
                      'Max',
                      style: TextStyle(
                        color: theme.textPrimary.withValues(alpha: 0.7),
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
    );
  }

  double _getAmount() {
    try {
      return double.parse(widget.amount);
    } catch (e) {
      return 0;
    }
  }

  double _calculateFontSize(BuildContext context, String text) {
    final screenWidth = MediaQuery.of(context).size.width;
    const baseSize = 30.0;
    const minSize = 13.0;
    final charCount = text.length;

    if (charCount <= 8) {
      return baseSize;
    }

    final fontSize = (screenWidth * 0.12) / ((charCount - 8) * 0.5);

    return fontSize.clamp(minSize, baseSize);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/theme/app_theme.dart`:

```dart
import 'package:flutter/material.dart';

abstract class AppTheme {
  String value = "Dark";

  Color get primaryPurple;
  Color get secondaryPurple;
  Color get background;
  Color get cardBackground;
  Color get textPrimary;
  Color get textSecondary;
  Color get buttonBackground;
  Color get buttonText;
  Color get danger;
  Color get success;
  Color get warning;

  Color get gradientStart;
  Color get gradientMiddle;
  Color get gradientEnd;
}

class DarkTheme implements AppTheme {
  @override
  String value = "Dark";

  @override
  Color get primaryPurple => const Color(0xFF8A2BE2);
  @override
  Color get secondaryPurple => const Color(0xFFB23AEE);
  @override
  Color get background => Colors.black;
  @override
  Color get cardBackground => const Color(0xFF0D1117);
  @override
  Color get textPrimary => Colors.white;
  @override
  Color get textSecondary => const Color(0xFFB3B3B3);
  @override
  Color get buttonBackground => const Color(0xFF3A3A3A);
  @override
  Color get buttonText => const Color(0xFFE0E0E0);
  @override
  Color get danger => const Color(0xFFE94560);
  @override
  Color get success => const Color(0xFF4CAF50);
  @override
  Color get warning => const Color(0xFFFF9800);

  @override
  Color get gradientStart => const Color(0xFF4A0E4E);
  @override
  Color get gradientMiddle => const Color(0xFF220A23);
  @override
  Color get gradientEnd => Colors.black;
}

class LightTheme implements AppTheme {
  @override
  String value = "Light";

  @override
  Color get primaryPurple => const Color(0xFF6A1B9A);
  @override
  Color get secondaryPurple => const Color(0xFF9C27B0);
  @override
  Color get background => const Color(0xFFF5F5F5);
  @override
  Color get cardBackground => Colors.white;
  @override
  Color get textPrimary => const Color(0xFF212121);
  @override
  Color get textSecondary => const Color(0xFF757575);
  @override
  Color get buttonBackground => const Color(0xFFE0E0E0);
  @override
  Color get buttonText => const Color(0xFF212121);
  @override
  Color get danger => const Color(0xFFD32F2F);
  @override
  Color get success => const Color(0xFF2E7D32);
  @override
  Color get warning => const Color(0xFFFB8C00);

  @override
  Color get gradientStart => const Color(0xFFE6E6FA);
  @override
  Color get gradientMiddle => const Color(0xFFD8BFD8);
  @override
  Color get gradientEnd => const Color(0xFFF0F8FF);
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/gen_wallet_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class GenWalletOptionsPage extends StatelessWidget {
  const GenWalletOptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: SvgPicture.asset(
            'assets/icons/back.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.secondaryPurple,
              BlendMode.srcIn,
            ),
          ),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title:
            Text('Generate Wallet', style: TextStyle(color: theme.textPrimary)),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              WalletListItem(
                title: 'BIP39',
                subtitle: 'Generate Mnemonic phrase',
                icon: SvgPicture.asset(
                  'assets/icons/document.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_bip39');
                },
              ),
              WalletListItem(
                disabled: true,
                title: 'SLIP-0039',
                subtitle: 'Generate Mnemonic phrase with share',
                icon: SvgPicture.asset(
                  'assets/icons/puzzle.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {/* Handle SLIP-0039 generation */},
              ),
              WalletListItem(
                title: 'Private Key',
                subtitle: 'Generate just one private key',
                icon: SvgPicture.asset(
                  'assets/icons/bincode.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_sk');
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/main_page.dart`:

```dart
import 'package:flutter/material.dart';
import '../components/bottom_nav_bar.dart';
import './home_page.dart';
import './history_page.dart';
import './browser_page.dart';

class MainPage extends StatefulWidget {
  const MainPage({super.key});

  @override
  State<MainPage> createState() => MainPageState();
}

class MainPageState extends State<MainPage> {
  int _selectedIndex = 0;

  static final List<Widget> _pages = <Widget>[
    const HomePage(),
    const HistoryPage(),
    const BrowserPage()
  ];

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBody: true,
      body: _pages.elementAt(_selectedIndex),
      bottomNavigationBar: CustomBottomNavigationBar(
        items: [
          CustomBottomNavigationBarItem(iconPath: 'assets/icons/wallet.svg'),
          CustomBottomNavigationBarItem(iconPath: 'assets/icons/history.svg'),
          CustomBottomNavigationBarItem(iconPath: 'assets/icons/nav.svg'),
        ],
        currentIndex: _selectedIndex,
        onTap: _onItemTapped,
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/history_page.dart`:

```dart
import 'package:flutter/material.dart';

class HistoryPage extends StatelessWidget {
  const HistoryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const SafeArea(
      child: Column(
        children: [Center(child: Text('history Page'))],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/setup_cipher.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';

import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/config/argon.dart';
import 'package:zilpay/config/providers.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/argon2.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';

class CipherSettingsPage extends StatefulWidget {
  const CipherSettingsPage({
    super.key,
  });

  @override
  State<CipherSettingsPage> createState() => _CipherSettingsPageState();
}

class _CipherSettingsPageState extends State<CipherSettingsPage> {
  List<String>? _bip39List;
  Chain? _chain;
  KeyPairInfo? _keys;
  WalletArgonParamsInfo _argonParams = Argon2DefaultParams.owaspDefault();

  int selectedCipherIndex = 2;
  bool optionsDisabled = false;

  final List<Map<String, String>> cipherDescriptions = [
    {
      'title': 'Standard Encryption',
      'subtitle': 'AES-256',
      'description':
          'Basic level encryption suitable for most users. Uses AES-256 algorithm - current industry standard.',
    },
    {
      'title': 'Enhanced Security',
      'subtitle': 'AES-256 + TwoFish',
      'description':
          'Recommended. Double layer encryption using AES-256 and TwoFish for enhanced security.',
    },
    {
      'title': 'Post-Quantum Protection',
      'subtitle': 'AES-256 + NTRU-Prime',
      'description':
          'Highest security level with quantum resistance. Combines AES-256 with NTRU-Prime algorithm.',
    },
  ];

  void _onAdvancedPressed() {
    showArgonSettingsModal(
      context: context,
      onParamsSelected: (WalletArgonParamsInfo params) {
        setState(() {
          _argonParams = params;
        });
      },
      argonParams: _argonParams,
    );
  }

  @override
  void reassemble() {
    super.reassemble();
    setState(() {
      optionsDisabled = false;
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final bip39 = args?['bip39'] as List<String>?;
    final chain = args?['chain'] as Chain?;
    final keys = args?['keys'] as KeyPairInfo?;

    if (bip39 == null && chain == null && keys == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = bip39;
        _chain = chain;
        _keys = keys;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: 'Setup Encryption',
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Padding(
                            padding: EdgeInsets.symmetric(vertical: 0),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.end,
                              children: [
                                TextButton(
                                  onPressed: _onAdvancedPressed,
                                  style: ButtonStyle(
                                    overlayColor:
                                        const WidgetStatePropertyAll<Color>(
                                            Colors.transparent),
                                    foregroundColor:
                                        WidgetStateProperty.resolveWith<Color>(
                                      (Set<WidgetState> states) {
                                        if (states
                                            .contains(WidgetState.pressed)) {
                                          return theme.primaryPurple
                                              .withValues(alpha: 0.7);
                                        }
                                        return theme.primaryPurple;
                                      },
                                    ),
                                  ),
                                  child: Text(
                                    'Advanced',
                                    style: TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          OptionsList(
                            disabled: optionsDisabled,
                            options: List.generate(
                              cipherDescriptions.length,
                              (index) => OptionItem(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      cipherDescriptions[index]['title']!,
                                      style: TextStyle(
                                        color: theme.textPrimary,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      cipherDescriptions[index]['subtitle']!,
                                      style: TextStyle(
                                        color: theme.primaryPurple,
                                        fontSize: 14,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      cipherDescriptions[index]['description']!,
                                      style: TextStyle(
                                        color: theme.textSecondary,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ],
                                ),
                                isSelected: selectedCipherIndex == index,
                                onSelect: () =>
                                    setState(() => selectedCipherIndex = index),
                              ),
                            ),
                            unselectedOpacity: 0.5,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.all(adaptivePadding),
                  child: Column(
                    children: [
                      if (selectedCipherIndex == 2)
                        Padding(
                          padding: EdgeInsets.only(bottom: adaptivePadding),
                          child: Text(
                            'Post-quantum encryption might affect performance',
                            style: TextStyle(
                              color: theme.textSecondary,
                              fontSize: 14,
                              fontStyle: FontStyle.italic,
                            ),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      CustomButton(
                        text: 'Confirm',
                        onPressed: () {
                          Navigator.of(context).pushNamed(
                            '/pass_setup',
                            arguments: {
                              'bip39': _bip39List,
                              'chain': _chain,
                              'keys': _keys,
                              'cipher': _getCipherOrders(),
                              'argon2': _argonParams
                            },
                          );
                        },
                        backgroundColor: theme.primaryPurple,
                        borderRadius: 30.0,
                        height: 50.0,
                      )
                    ],
                  ),
                )
              ],
            ),
          ),
        ),
      ),
    );
  }

  Uint8List _getCipherOrders() {
    // TODO: TwoFish is not supporting yet
    //
    switch (selectedCipherIndex) {
      case 0:
        return Uint8List.fromList([0]); // AESGCM256 only
      case 1:
        return Uint8List.fromList(
            [0, 1]); // AESGCM256 + TwoFish // TODO: is not supporte yet
      case 2:
        return Uint8List.fromList([0, 1]); // AESGCM256 + TwoFish + NTRUP1277
      default:
        return Uint8List.fromList([0, 1]); // AESGCM256 + TwoFish + NTRUP1277
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/wallet_restore_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/config/providers.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/modals/qr_scanner_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class RestoreWalletOptionsPage extends StatelessWidget {
  const RestoreWalletOptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: SvgPicture.asset(
            'assets/icons/back.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.secondaryPurple,
              BlendMode.srcIn,
            ),
          ),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title:
            Text('Restore Wallet', style: TextStyle(color: theme.textPrimary)),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              WalletListItem(
                title: 'BIP39',
                subtitle: 'Restore with Mnemonic phrase',
                icon: SvgPicture.asset(
                  'assets/icons/document.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/restore_bip39');
                },
              ),
              WalletListItem(
                disabled: true,
                title: 'SLIP-0039',
                subtitle: 'Restore with Shared Mnemonic phrase',
                icon: SvgPicture.asset(
                  'assets/icons/puzzle.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {/* Handle SLIP-0039 restoration */},
              ),
              WalletListItem(
                title: 'Private Key',
                subtitle: 'Restore with private key',
                icon: SvgPicture.asset(
                  'assets/icons/bincode.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {/* Handle private key restoration */},
              ),
              WalletListItem(
                title: 'QRcode',
                subtitle: 'Restore wallet by QRcode scanning',
                icon: SvgPicture.asset(
                  'assets/icons/qrcode.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  showQRScannerModal(
                    context: context,
                    onScanned: (String qrData) async {
                      final values = parseQRSecretData(qrData);
                      String? shortName = values['chain'];
                      String? seed = values['seed'];
                      String? key = values['key'];

                      if (shortName == null) {
                        Navigator.pop(context);
                        return;
                      }

                      final String mainnetJsonData = await rootBundle
                          .loadString('assets/chains/mainnet-chains.json');
                      final List<Chain> mainnetChains =
                          await ChainService.loadChains(mainnetJsonData);

                      if (!mainnetChains
                          .any((chain) => chain.shortName == shortName)) {
                        Navigator.pop(context);
                        return;
                      }

                      if (seed != null) {
                        try {
                          final nonEmptyWords = seed
                              .split(" ")
                              .where((word) => word.isNotEmpty)
                              .toList();

                          if (nonEmptyWords.isEmpty) {
                            Navigator.pop(context);

                            return;
                          }

                          List<int> errorIndexes =
                              (await checkNotExistsBip39Words(
                            words: nonEmptyWords,
                            lang: 'english',
                          ))
                                  .map((e) => e.toInt())
                                  .toList();

                          if (errorIndexes.isEmpty) {
                            Navigator.of(context).pushNamed('/net_setup',
                                arguments: {
                                  'bip39': nonEmptyWords,
                                  'shortName': shortName
                                });
                          } else {
                            // TODO: maybe error hanlder.
                            Navigator.pop(context);
                          }
                        } catch (e) {
                          debugPrint("error: $e");
                        }
                      } else if (key != null) {
                        try {
                          KeyPairInfo keys = await keypairFromSk(sk: key);
                          Navigator.of(context).pushNamed('/net_setup',
                              arguments: {
                                'keys': keys,
                                'shortName': shortName
                              });
                          return;
                        } catch (e) {
                          debugPrint("error: $e");
                          Navigator.pop(context);
                          return;
                        }
                      } else {
                        Navigator.pop(context);
                      }
                    },
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/restore_bip39.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:math' as math;
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/components/wor_count_selector.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/state/app_state.dart';

class RestoreSecretPhrasePage extends StatefulWidget {
  const RestoreSecretPhrasePage({super.key});

  @override
  State<RestoreSecretPhrasePage> createState() =>
      _RestoreSecretPhrasePageState();
}

class _RestoreSecretPhrasePageState extends State<RestoreSecretPhrasePage> {
  late List<String> _words;
  List<int> _wordsErrorIndexes = [];
  bool _isFormValid = false;
  int _count = 12;
  final List<int> _allowedCounts = const [12, 15, 18, 21, 24];

  @override
  void initState() {
    super.initState();
    _words = List.filled(_count, '');
  }

  Future<void> _handleCheckWords() async {
    try {
      final nonEmptyWords = _words.where((word) => word.isNotEmpty).toList();
      if (nonEmptyWords.isEmpty) return;

      List<int> errorIndexes = (await checkNotExistsBip39Words(
        words: nonEmptyWords,
        lang: 'english',
      ))
          .map((e) => e.toInt())
          .toList();

      final List<int> adjustedIndexes = [];
      var currentIndex = 0;

      for (int i = 0; i < _words.length; i++) {
        if (_words[i].isNotEmpty) {
          if (errorIndexes.contains(currentIndex)) {
            adjustedIndexes.add(i);
          }
          currentIndex++;
        }
      }

      if (mounted) {
        setState(() {
          _wordsErrorIndexes = adjustedIndexes;
          _validateForm();
        });
      }
    } catch (e) {
      debugPrint('Error checking words: $e');
    }
  }

  void _handleWordChange(int index, String word) {
    final trimmedWord = word.trim().toLowerCase();
    final currentIndex = index - 1;

    if (word.contains(' ')) {
      _handlePhrasePaste(word, currentIndex);
      return;
    }

    _words[currentIndex] = trimmedWord;
    if (_wordsErrorIndexes.contains(currentIndex)) {
      _wordsErrorIndexes.remove(currentIndex);
    }
    _validateForm();

    if (trimmedWord.isNotEmpty) {
      Future.microtask(() => _handleCheckWords());
    }
  }

  void _handlePhrasePaste(String phrase, int startIndex) {
    final words = phrase.trim().split(RegExp(r'\s+'));

    int targetCount = _count;
    for (int allowedCount in _allowedCounts) {
      if (words.length <= allowedCount) {
        targetCount = allowedCount;
        break;
      }
    }

    if (targetCount != _count) {
      _handleCountChanged(targetCount, autoAdjust: true);
    }

    for (var i = 0; i < words.length && (startIndex + i) < targetCount; i++) {
      if (words[i].isNotEmpty) {
        _words[startIndex + i] = words[i].toLowerCase();
      }
    }

    _validateForm();

    if (words.isNotEmpty) {
      Future.microtask(() => _handleCheckWords());
    }
  }

  void _validateForm() {
    final isValid =
        _words.every((word) => word.isNotEmpty) && _wordsErrorIndexes.isEmpty;
    if (isValid != _isFormValid) {
      setState(() {
        _isFormValid = isValid;
      });
    }
  }

  void _handleCountChanged(int newCount, {bool autoAdjust = false}) {
    if (mounted) {
      setState(() {
        _count = newCount;
        final newWords = List<String>.filled(newCount, '');
        for (var i = 0; i < math.min(_words.length, newCount); i++) {
          newWords[i] = _words[i];
        }
        _words = newWords;
        _wordsErrorIndexes = [];
        _validateForm();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: 'Restore Wallet',
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 16),
                        WordCountSelector(
                          wordCounts: _allowedCounts,
                          selectedCount: _count,
                          onCountChanged: (count) => _handleCountChanged(count),
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: ListView.builder(
                            physics: const BouncingScrollPhysics(),
                            itemCount: _count,
                            itemBuilder: (context, index) {
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 8.0),
                                child: MnemonicWordInput(
                                  key: ValueKey('word_$index'),
                                  index: index + 1,
                                  word: _words[index],
                                  isEditable: true,
                                  onChanged: _handleWordChange,
                                  borderColor: theme.buttonText,
                                  hasError: _wordsErrorIndexes.contains(index),
                                  errorBorderColor: theme.danger,
                                ),
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16),
                          child: CustomButton(
                            text: 'Restore',
                            onPressed: () {
                              Navigator.of(context).pushNamed('/net_setup',
                                  arguments: {'bip39': _words});
                            },
                            backgroundColor: theme.primaryPurple,
                            borderRadius: 30.0,
                            height: 56.0,
                            disabled: !_isFormValid,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/add_token.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/token_card.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';

class AddTokenPage extends StatefulWidget {
  const AddTokenPage({super.key});

  @override
  State<AddTokenPage> createState() => _AddTokenPageState();
}

class _AddTokenPageState extends State<AddTokenPage> {
  static const double _borderRadius = 12.0;
  static const double _fontSize = 16.0;
  static const double _inputHeight = 50.0;

  final TextEditingController _tokenTextController = TextEditingController();
  List<FTokenInfo> tokens = [];
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void dispose() {
    _tokenTextController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: 'Add Token',
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: CustomScrollView(
                slivers: [
                  SliverPadding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    sliver: SliverList(
                      delegate: SliverChildListDelegate([
                        const SizedBox(height: 24),
                        _buildInputSection(theme, appState),
                        if (_errorMessage != null) _buildErrorMessage(theme),
                        const SizedBox(height: 32),
                        if (tokens.isNotEmpty)
                          _buildTokensList(theme, appState),
                      ]),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
      resizeToAvoidBottomInset: true,
    );
  }

  Widget _buildErrorMessage(AppTheme theme) {
    return Padding(
      padding: const EdgeInsets.only(left: 16, top: 8),
      child: Text(
        _errorMessage ?? '',
        style: TextStyle(
          color: theme.danger,
          fontSize: 14,
        ),
      ),
    );
  }

  Widget _buildInputSection(AppTheme theme, AppState appState) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            'Token Information',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: _fontSize,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(_borderRadius),
          ),
          child: Column(
            children: [
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                child: SmartInput(
                  controller: _tokenTextController,
                  onChanged: (value) async {
                    // Clear error message when user starts typing
                    if (_errorMessage != null) {
                      setState(() {
                        _errorMessage = null;
                      });
                    }
                    await _onChange(value, appState.selectedWallet);
                  },
                  hint: "Address, name, symbol",
                  height: _inputHeight,
                  borderColor: Colors.transparent,
                  focusedBorderColor: Colors.transparent,
                  fontSize: _fontSize,
                  disabled: _isLoading,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTokensList(AppTheme theme, AppState appState) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Container(
      padding: EdgeInsets.all(adaptivePadding),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(_borderRadius),
      ),
      child: Column(
        children: [
          for (int i = 0; i < tokens.length; i++)
            TokenCard(
              currencySymbol: appState.wallet!.settings.currencyConvert ?? "",
              tokenAmount:
                  tokens[i].balances[appState.wallet?.selectedAccount] ?? "0",
              tokenAddr: tokens[i].addr,
              tokenDecimals: tokens[i].decimals,
              tokenName: tokens[i].name,
              tokenSymbol: tokens[i].symbol,
              showDivider: i < tokens.length - 1,
              iconUrl: viewTokenIcon(
                tokens[i],
                appState.chain!.chainId,
                theme.value,
              ),
              onTap: () => _onAddToken(
                i,
                appState.selectedWallet,
                appState,
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _onAddToken(
    int tokenIndex,
    int walletIndex,
    AppState appState,
  ) async {
    try {
      setState(() {
        _errorMessage = null;
      });

      FTokenInfo meta = tokens[tokenIndex];
      await addFtoken(
        meta: meta,
        walletIndex: BigInt.from(walletIndex),
      );
      await appState.syncData();
      if (!mounted) return;
      Navigator.pop(context);
    } catch (e) {
      setState(() {
        _errorMessage = 'Failed to add token: ${e.toString()}';
      });
      debugPrint("error: $e");
    }
  }

  Future<void> _onChange(String value, int walletIndex) async {
    if (value.length >= 42) {
      setState(() {
        _isLoading = true;
        _errorMessage = null;
      });

      try {
        FTokenInfo meta = await fetchTokenMeta(
          addr: value,
          walletIndex: BigInt.from(walletIndex),
        );

        setState(() {
          if (!tokens.any((token) => token.addr == meta.addr)) {
            tokens = [meta, ...tokens];
          }
        });
      } catch (e) {
        setState(() {
          _errorMessage = 'Invalid token address or network error';
        });
        debugPrint("error: $e");
      } finally {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/currency_conversion.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';

class CurrencyConversionPage extends StatefulWidget {
  const CurrencyConversionPage({super.key});

  @override
  State<CurrencyConversionPage> createState() => _CurrencyConversionPageState();
}

class _CurrencyConversionPageState extends State<CurrencyConversionPage> {
  late List<Currency> currencies = [];

  String selectedCurrency = 'btc';

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final state = Provider.of<AppState>(context, listen: false);

      setState(() {
        currencies =
            state.rates.keys.map((code) => Currency(code, '')).toList();
      });

      if (state.wallet?.settings.currencyConvert != null) {
        setState(() {
          selectedCurrency = state.wallet!.settings.currencyConvert!;
        });
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final bool isRateFetchEnabled =
        state.wallet!.settings.currencyConvert != null;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: CustomAppBar(
                    title: 'Primary Currency',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                _buildRateFetchOption(state),
                Expanded(
                  child: Opacity(
                    opacity: isRateFetchEnabled ? 1.0 : 0.5,
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: AbsorbPointer(
                        absorbing: !isRateFetchEnabled,
                        child: ListView.builder(
                          physics: const BouncingScrollPhysics(),
                          itemCount: currencies.length,
                          itemBuilder: (context, index) {
                            final currency = currencies[index];
                            final isSelected = currency.code.toLowerCase() ==
                                selectedCurrency.toLowerCase();

                            return _buildCurrencyItem(
                              theme,
                              currency,
                              isSelected,
                              onTap: () async {
                                setState(() {
                                  selectedCurrency = currency.code;
                                });

                                await setRateFetcher(
                                  walletIndex:
                                      BigInt.from(state.selectedWallet),
                                  currency: selectedCurrency,
                                );

                                await state.syncData();
                              },
                            );
                          },
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildRateFetchOption(AppState state) {
    final theme = state.currentTheme;

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Enable rate fetcher',
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              Switch(
                value: state.wallet!.settings.currencyConvert != null,
                onChanged: (value) async {
                  if (value) {
                    await setRateFetcher(
                      walletIndex: BigInt.from(state.selectedWallet),
                      currency: selectedCurrency,
                    );
                  } else {
                    await setRateFetcher(
                      walletIndex: BigInt.from(state.selectedWallet),
                      currency: value ? selectedCurrency : null,
                    );
                  }

                  await state.syncData();
                },
                activeColor: theme.primaryPurple,
                activeTrackColor: theme.primaryPurple.withValues(alpha: 0.5),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            'The wallet will fetch rates and makes request to ZilPay server',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCurrencyItem(
    AppTheme theme,
    Currency currency,
    bool isSelected, {
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 56,
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color: theme.textSecondary.withValues(alpha: 0.1),
              width: 1,
            ),
          ),
        ),
        child: Row(
          children: [
            SizedBox(
              width: 60,
              child: Text(
                currency.code.toUpperCase(),
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            Expanded(
              child: Text(
                currency.name,
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: 16,
                ),
              ),
            ),
            SizedBox(
              width: 24,
              height: 24,
              child: isSelected
                  ? SvgPicture.asset(
                      'assets/icons/ok.svg',
                      colorFilter: ColorFilter.mode(
                        theme.primaryPurple,
                        BlendMode.srcIn,
                      ),
                    )
                  : null,
            ),
          ],
        ),
      ),
    );
  }
}

class Currency {
  final String code;
  final String name;

  Currency(this.code, this.name);
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/reveal_bip39.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/theme/app_theme.dart';

class RevealSecretPhrase extends StatefulWidget {
  const RevealSecretPhrase({super.key});

  @override
  State<RevealSecretPhrase> createState() => _RevealSecretPhraseState();
}

class _RevealSecretPhraseState extends State<RevealSecretPhrase> {
  bool isCopied = false;
  bool isAuthenticated = false;
  bool hasError = false;
  String? errorMessage;
  bool _obscurePassword = true;
  String? seedPhrase;

  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  @override
  void initState() {
    _secureScreen();
    super.initState();
  }

  @override
  void dispose() {
    ScreenProtector.preventScreenshotOff();
    ScreenProtector.protectDataLeakageOff();
    ScreenProtector.protectDataLeakageWithBlurOff();
    super.dispose();
  }

  Future<void> _secureScreen() async {
    await ScreenProtector.preventScreenshotOn();
    await ScreenProtector.protectDataLeakageOn();
    await ScreenProtector.protectDataLeakageWithBlur();
  }

  void _onPasswordSubmit(BigInt walletIndex) async {
    _btnController.start();
    try {
      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      await tryUnlockWithPassword(
        password: _passwordController.text,
        walletIndex: walletIndex,
        identifiers: identifiers,
      );

      String phrase = await revealBip39Phrase(
        walletIndex: walletIndex,
        identifiers: identifiers,
        password: _passwordController.text,
      );

      setState(() {
        seedPhrase = phrase;
        isAuthenticated = true;
        hasError = false;
        errorMessage = null;
      });
      _btnController.success();
    } catch (e) {
      setState(() {
        isAuthenticated = false;
        hasError = true;
        errorMessage = "invalid password, error: $e";
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = state.currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: 'Reveal Secret Phrase',
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    _buildScamAlert(theme),
                    if (!isAuthenticated) ...[
                      SmartInput(
                        key: _passwordInputKey,
                        controller: _passwordController,
                        hint: "Password",
                        fontSize: 18,
                        height: 50,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        obscureText: _obscurePassword,
                        onSubmitted: () => _onPasswordSubmit(
                          BigInt.from(state.selectedWallet),
                        ),
                        rightIconPath: _obscurePassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: () => setState(
                            () => _obscurePassword = !_obscurePassword),
                      ),
                      if (hasError && errorMessage != null)
                        Container(
                          margin: const EdgeInsets.only(top: 8),
                          child: Text(
                            errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: RoundedLoadingButton(
                          controller: _btnController,
                          onPressed: () => _onPasswordSubmit(
                            BigInt.from(state.selectedWallet),
                          ),
                          successIcon: SvgPicture.asset(
                            'assets/icons/ok.svg',
                            width: 24,
                            height: 24,
                            colorFilter: ColorFilter.mode(
                              theme.textPrimary,
                              BlendMode.srcIn,
                            ),
                          ),
                          child: Text(
                            'Submit',
                            style: TextStyle(
                              color: theme.textPrimary,
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    ],
                    if (isAuthenticated && seedPhrase != null) ...[
                      _buildQrCode(theme),
                      _buildPhraseDisplay(theme),
                      SizedBox(height: adaptivePadding),
                      TileButton(
                        icon: SvgPicture.asset(
                          isCopied
                              ? "assets/icons/check.svg"
                              : "assets/icons/copy.svg",
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        ),
                        onPressed: () => _handleCopy(seedPhrase ?? ""),
                        backgroundColor: theme.cardBackground,
                        textColor: theme.primaryPurple,
                      ),
                      SizedBox(height: adaptivePadding),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        padding: EdgeInsets.only(bottom: adaptivePadding),
                        child: CustomButton(
                          text: 'Done',
                          onPressed: () => Navigator.pop(context),
                          backgroundColor: theme.primaryPurple,
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildScamAlert(AppTheme theme) {
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.danger),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Icon(
                Icons.warning_amber_rounded,
                color: theme.danger,
                size: 24,
              ),
              const SizedBox(width: 8),
              Text(
                'SCAM ALERT',
                style: TextStyle(
                  color: theme.danger,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            'Never share your secret phrase with anyone. Never input it on any website.',
            style: TextStyle(
              color: theme.danger,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPhraseDisplay(AppTheme theme) {
    final List<String> words = seedPhrase?.split(' ') ?? [];
    final int itemsPerRow = 3;
    final int rowCount = (words.length / itemsPerRow).ceil();

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: theme.secondaryPurple),
      ),
      child: Column(
        children: List.generate(rowCount, (rowIndex) {
          final startIndex = rowIndex * itemsPerRow;
          final endIndex = (startIndex + itemsPerRow).clamp(0, words.length);

          return Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Row(
              children: List.generate(
                endIndex - startIndex,
                (index) => Expanded(
                  child: Container(
                    margin: EdgeInsets.only(
                      right: index != itemsPerRow - 1 ? 8 : 0,
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    decoration: BoxDecoration(
                      color: theme.background,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      '${startIndex + index + 1}. ${words[startIndex + index]}',
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 10,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildQrCode(AppTheme theme) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = state.chain!;

    return Container(
      margin: EdgeInsets.symmetric(vertical: adaptivePadding),
      child: Center(
        child: AsyncQRcode(
          data: generateQRSecretData(
            chain: chain.shortName,
            seedPhrase: seedPhrase,
          ),
          size: 160,
          color: theme.danger,
          eyeShape: EyeShape.circle,
          dataModuleShape: DataModuleShape.circle,
          loadingWidget: CircularProgressIndicator(
            color: theme.danger,
          ),
        ),
      ),
    );
  }

  Future<void> _handleCopy(String phrase) async {
    await Clipboard.setData(ClipboardData(text: phrase));
    setState(() {
      isCopied = true;
    });

    await Future<void>.delayed(const Duration(seconds: 1));

    setState(() {
      isCopied = false;
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/reveal_sk.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/hex_key.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class RevealSecretKey extends StatefulWidget {
  const RevealSecretKey({super.key});

  @override
  State<RevealSecretKey> createState() => _RevealSecretKeyState();
}

class _RevealSecretKeyState extends State<RevealSecretKey> {
  bool isCopied = false;
  bool isAuthenticated = false;
  bool hasError = false;
  String? errorMessage;
  bool _obscurePassword = true;
  KeyPairInfo? keys;

  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  @override
  void initState() {
    _secureScreen();
    super.initState();
  }

  @override
  void dispose() {
    ScreenProtector.preventScreenshotOff();
    ScreenProtector.protectDataLeakageOff();
    ScreenProtector.protectDataLeakageWithBlurOff();
    super.dispose();
  }

  Future<void> _secureScreen() async {
    await ScreenProtector.preventScreenshotOn();
    await ScreenProtector.protectDataLeakageOn();
    await ScreenProtector.protectDataLeakageWithBlur();
  }

  void _onPasswordSubmit(BigInt walletIndex, BigInt accountIndex) async {
    _btnController.start();
    try {
      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      await tryUnlockWithPassword(
        password: _passwordController.text,
        walletIndex: walletIndex,
        identifiers: identifiers,
      );
      KeyPairInfo keypair = await revealKeypair(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        identifiers: identifiers,
        password: _passwordController.text,
      );

      setState(() {
        keys = keypair;
        isAuthenticated = true;
        hasError = false;
        errorMessage = null;
      });
      _btnController.success();
    } catch (e) {
      setState(() {
        isAuthenticated = false;
        hasError = true;
        errorMessage = "invalid password, error: $e";
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = state.currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: 'Reveal Secret Key',
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    _buildScamAlert(theme),
                    if (!isAuthenticated) ...[
                      SmartInput(
                        key: _passwordInputKey,
                        controller: _passwordController,
                        hint: "Password",
                        fontSize: 18,
                        height: 50,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        obscureText: _obscurePassword,
                        onSubmitted: () => _onPasswordSubmit(
                          BigInt.from(state.selectedWallet),
                          state.wallet!.selectedAccount,
                        ),
                        rightIconPath: _obscurePassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: () => setState(
                            () => _obscurePassword = !_obscurePassword),
                      ),
                      if (hasError && errorMessage != null)
                        Container(
                          margin: const EdgeInsets.only(top: 8),
                          child: Text(
                            errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: RoundedLoadingButton(
                          controller: _btnController,
                          onPressed: () => _onPasswordSubmit(
                            BigInt.from(state.selectedWallet),
                            state.wallet!.selectedAccount,
                          ),
                          successIcon: SvgPicture.asset(
                            'assets/icons/ok.svg',
                            width: 24,
                            height: 24,
                            colorFilter: ColorFilter.mode(
                              theme.textPrimary,
                              BlendMode.srcIn,
                            ),
                          ),
                          child: Text(
                            'Submit',
                            style: TextStyle(
                              color: theme.textPrimary,
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    ],
                    if (isAuthenticated) ...[
                      if (keys != null) ...[
                        _buildQrCode(theme),
                        HexKeyDisplay(
                          hexKey: keys!.sk,
                          title: "",
                        )
                      ],
                      SizedBox(height: adaptivePadding),
                      TileButton(
                        icon: SvgPicture.asset(
                          isCopied
                              ? "assets/icons/check.svg"
                              : "assets/icons/copy.svg",
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        ),
                        onPressed: () => _handleCopy(keys?.sk ?? ""),
                        backgroundColor: theme.cardBackground,
                        textColor: theme.primaryPurple,
                      ),
                      SizedBox(height: adaptivePadding),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        padding: EdgeInsets.only(bottom: adaptivePadding),
                        child: CustomButton(
                          text: 'Done',
                          onPressed: () => Navigator.pop(context),
                          backgroundColor: theme.primaryPurple,
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildScamAlert(AppTheme theme) {
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.danger),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Icon(
                Icons.warning_amber_rounded,
                color: theme.danger,
                size: 24,
              ),
              const SizedBox(width: 8),
              Text(
                'SCAM ALERT',
                style: TextStyle(
                  color: theme.danger,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            'Never share your secret key with anyone. Never input it on any website.',
            style: TextStyle(
              color: theme.danger,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildQrCode(AppTheme theme) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = state.chain!;

    return Container(
      margin: EdgeInsets.symmetric(vertical: adaptivePadding),
      child: Center(
        child: AsyncQRcode(
          data: generateQRSecretData(
            chain: chain.shortName,
            privateKey: keys?.sk,
          ),
          size: 160,
          color: theme.danger,
          eyeShape: EyeShape.circle,
          dataModuleShape: DataModuleShape.circle,
          loadingWidget: CircularProgressIndicator(
            color: theme.danger,
          ),
        ),
      ),
    );
  }

  Future<void> _handleCopy(String key) async {
    await Clipboard.setData(ClipboardData(text: key));
    setState(() {
      isCopied = true;
    });

    await Future<void>.delayed(const Duration(seconds: 1));

    setState(() {
      isCopied = false;
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/appearance.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';

class AppearanceSettingsPage extends StatefulWidget {
  const AppearanceSettingsPage({super.key});

  @override
  State<AppearanceSettingsPage> createState() => _AppearanceSettingsPageState();
}

class _AppearanceSettingsPageState extends State<AppearanceSettingsPage> {
  int selectedThemeIndex = 0;
  bool optionsDisabled = false;

  final List<Map<String, String>> themeDescriptions = [
    {
      'title': 'Device settings',
      'subtitle': 'System default',
      'description':
          "Default to your device's appearance. Your wallet theme will automatically adjust based on your system settings.",
    },
    {
      'title': 'Dark Mode',
      'subtitle': 'Always dark',
      'description':
          'Keep the dark theme enabled at all times, regardless of your device settings.',
    },
    {
      'title': 'Light mode',
      'subtitle': 'Always light',
      'description':
          'Keep the light theme enabled at all times, regardless of your device settings.',
    },
  ];

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final themeProvider = Provider.of<AppState>(context, listen: false);

      setState(() {
        selectedThemeIndex = themeProvider.state.appearances;
      });
    });
  }

  // Handle theme selection
  Future<void> _handleThemeSelection(int index) async {
    final stateProvider = Provider.of<AppState>(context, listen: false);
    await stateProvider.setAppearancesCode(index);

    setState(() {
      selectedThemeIndex = index;
    });
  }

  @override
  void reassemble() {
    super.reassemble();
    setState(() {
      optionsDisabled = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: 'Appearance Settings',
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          OptionsList(
                            disabled: optionsDisabled,
                            options: List.generate(
                              themeDescriptions.length,
                              (index) => OptionItem(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      themeDescriptions[index]['title']!,
                                      style: TextStyle(
                                        color: theme.textPrimary,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      themeDescriptions[index]['subtitle']!,
                                      style: TextStyle(
                                        color: theme.primaryPurple,
                                        fontSize: 14,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      themeDescriptions[index]['description']!,
                                      style: TextStyle(
                                        color: theme.textSecondary,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ],
                                ),
                                isSelected: selectedThemeIndex == index,
                                onSelect: () => _handleThemeSelection(index),
                              ),
                            ),
                            unselectedOpacity: 0.5,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/sk_gen.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/hex_key.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/backup_confirmation_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';

class SecretKeyGeneratorPage extends StatefulWidget {
  const SecretKeyGeneratorPage({super.key});

  @override
  State<SecretKeyGeneratorPage> createState() => _CreateAccountPageState();
}

class _CreateAccountPageState extends State<SecretKeyGeneratorPage> {
  KeyPairInfo _keyPair = KeyPairInfo(sk: "", pk: "");
  bool _hasBackupWords = false;
  bool isCopied = false;

  @override
  void initState() {
    super.initState();
    _regenerateKeys();
  }

  Future<void> _regenerateKeys() async {
    KeyPairInfo keyPair = await genKeypair();
    setState(() {
      _hasBackupWords = false;
      _keyPair = keyPair;
    });
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: 'Secret Key',
              onBackPressed: () => Navigator.pop(context),
              actionIcon: SvgPicture.asset(
                'assets/icons/reload.svg',
                width: 30,
                height: 30,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              onActionPressed: _regenerateKeys,
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    Expanded(
                      flex: 4,
                      child: SingleChildScrollView(
                        child: Column(
                          children: [
                            HexKeyDisplay(
                              hexKey: _keyPair.sk,
                              title: "Private Key",
                            ),
                            const SizedBox(height: 16),
                            HexKeyDisplay(
                              hexKey: _keyPair.pk,
                              title: "Public Key",
                            ),
                          ],
                        ),
                      ),
                    ),
                    SizedBox(
                      height: MediaQuery.of(context).size.height * 0.3,
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          TileButton(
                            icon: SvgPicture.asset(
                              isCopied
                                  ? "assets/icons/check.svg"
                                  : "assets/icons/copy.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            disabled: false,
                            onPressed: () async {
                              await _handleCopy(_keyPair.sk);
                            },
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                          Container(
                            constraints: const BoxConstraints(maxWidth: 480),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Theme(
                                  data: Theme.of(context).copyWith(
                                    splashFactory: NoSplash.splashFactory,
                                    highlightColor: Colors.transparent,
                                  ),
                                  child: CheckboxListTile(
                                    title: Text(
                                      'I have backup secret key',
                                      style:
                                          TextStyle(color: theme.textSecondary),
                                    ),
                                    value: _hasBackupWords,
                                    onChanged: (_) {
                                      if (!_hasBackupWords) {
                                        showBackupConfirmationModal(
                                          context: context,
                                          onConfirmed: (confirmed) {
                                            setState(() {
                                              _hasBackupWords = confirmed;
                                            });
                                          },
                                        );
                                      }
                                    },
                                    controlAffinity:
                                        ListTileControlAffinity.leading,
                                    activeColor: theme.primaryPurple,
                                  ),
                                ),
                                CustomButton(
                                  text: 'Next',
                                  onPressed: () {
                                    Navigator.of(context).pushNamed(
                                      '/net_setup',
                                      arguments: {'keys': _keyPair},
                                    );
                                  },
                                  backgroundColor: theme.primaryPurple,
                                  borderRadius: 30.0,
                                  height: 56.0,
                                  disabled: !_hasBackupWords,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _handleCopy(String address) async {
    await Clipboard.setData(ClipboardData(text: address));
    setState(() {
      isCopied = true;
    });
    await Future<void>.delayed(const Duration(seconds: 2));
    setState(() {
      isCopied = false;
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/ledger_connect.dart`:

```dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:ledger_flutter/ledger_flutter.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:zilliqa_ledger_flutter/zilliqa_ledger_flutter.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/ledger_item.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/config/argon.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/ledger_connect_dialog.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/ledger.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';

class LedgerConnectPage extends StatefulWidget {
  const LedgerConnectPage({super.key});

  @override
  State<LedgerConnectPage> createState() => _LedgerConnectPageState();
}

class _LedgerConnectPageState extends State<LedgerConnectPage> {
  late Ledger _ledger;
  final AuthService _authService = AuthService();
  List<AuthMethod> _authMethods = [AuthMethod.none];

  final _btnController = RoundedLoadingButtonController();
  late AuthGuard _authGuard;
  late AppState _appState;

  List<LedgerDevice> _devices = [];
  bool _isScanning = false;
  bool _isConnecting = false;
  int _selected = -1;
  String? _error;

  @override
  void initState() {
    super.initState();

    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initLedger();
      _checkAuthMethods();
      Future.delayed(const Duration(milliseconds: 1000), () {
        _startScanning();
      });
    });
  }

  @override
  void dispose() {
    _btnController.dispose();
    _ledger.close(ConnectionType.ble);

    if (Platform.isAndroid) {
      _ledger.close(ConnectionType.usb);
    }

    super.dispose();
  }

  Future<void> _checkAuthMethods() async {
    final methods = await _authService.getAvailableAuthMethods();
    setState(() {
      _authMethods = methods;
    });
  }

  void _initLedger() {
    try {
      final options = LedgerOptions(
        maxScanDuration: const Duration(milliseconds: 5000),
      );

      _ledger = Ledger(
        options: options,
        onPermissionRequest: (status) async {
          Map<Permission, PermissionStatus> statuses = await [
            Permission.location,
            Permission.bluetoothScan,
            Permission.bluetoothConnect,
            Permission.bluetoothAdvertise,
          ].request();

          if (status != BleStatus.ready) {
            setState(() => _error = 'Bluetooth is not ready');
            return false;
          }

          if (statuses.values.where((status) => status.isDenied).isNotEmpty) {
            setState(() => _error = 'Required permissions were denied');
            return false;
          }

          return true;
        },
      );
    } catch (e) {
      setState(() => _error = 'Failed to initialize Ledger: $e');
    }
  }

  Future<void> _startScanning() async {
    if (_isScanning) return;

    setState(() {
      _isScanning = true;
      _devices.clear();
      _error = null;
    });

    try {
      if (Platform.isAndroid) {
        List<LedgerDevice> devices = await _ledger.listUsbDevices();
        if (devices.isNotEmpty) {
          setState(() => _devices = devices);
        }
      }

      _ledger.scan().listen(
        (device) {
          setState(() => _devices.add(device));
        },
        onDone: () {
          setState(() => _isScanning = false);
        },
        onError: (e) {
          setState(() {
            _isScanning = false;
            _error = 'Scanning error: $e';
          });
        },
      );
    } catch (e) {
      setState(() {
        _isScanning = false;
        _error = 'Failed to start scanning: $e';
      });
    }
  }

  Future<void> _selectDevice(int index) async {
    setState(() {
      _isConnecting = true;
      _error = null;
    });

    try {
      LedgerDevice device = _devices[index];
      await _ledger.connect(device);

      _showConnectDialog();
    } catch (e) {
      setState(() => _error = 'Connection error: $e');
    } finally {
      setState(() => _isConnecting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: '',
                  onBackPressed: () => Navigator.pop(context),
                  actionIcon: SvgPicture.asset(
                    'assets/icons/reload.svg',
                    width: 30,
                    height: 30,
                    colorFilter: ColorFilter.mode(
                      theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  ),
                  onActionPressed: _startScanning,
                ),
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Text(
                        _isScanning
                            ? 'Looking for devices'
                            : 'Available devices',
                        style: TextStyle(
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                          color: theme.textPrimary,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        _isScanning
                            ? 'Please make sure your Ledger device is unlocked'
                            : _devices.isEmpty
                                ? 'No devices found. Pull to refresh or tap reload'
                                : 'Select a device to connect',
                        style: TextStyle(
                          fontSize: 14,
                          fontWeight: FontWeight.w100,
                          color: theme.textSecondary,
                        ),
                      ),
                      if (_error != null) ...[
                        const SizedBox(height: 16),
                        Text(
                          _error!,
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.red,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                Expanded(
                  child: RefreshIndicator(
                    onRefresh: _startScanning,
                    child: ListView.builder(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      itemCount: _devices.length,
                      itemBuilder: (context, index) {
                        final device = _devices[index];
                        String icon =
                            device.connectionType == ConnectionType.usb
                                ? "assets/icons/usb.svg"
                                : "assets/icons/ble.svg";

                        return Column(
                          children: [
                            LedgerItem(
                              onTap: _isConnecting
                                  ? null
                                  : () {
                                      setState(() => _selected = index);
                                      _selectDevice(index);
                                    },
                              isLoading: _isConnecting && _selected == index,
                              icon: SvgPicture.asset(
                                icon,
                                width: 30,
                                height: 30,
                                colorFilter: ColorFilter.mode(
                                  theme.textPrimary,
                                  BlendMode.srcIn,
                                ),
                              ),
                              title: device.name,
                              id: device.id,
                            ),
                            const SizedBox(height: 8),
                          ],
                        );
                      },
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _showConnectDialog() {
    LedgerDevice device = _devices[_selected];
    AuthMethod preferredAuth = _authMethods.contains(AuthMethod.none)
        ? AuthMethod.none
        : _authMethods[0];

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      enableDrag: true,
      isDismissible: true,
      builder: (context) => LedgerConnectDialog(
        walletName: device.name,
        biometricType: preferredAuth,
        onClose: () => Navigator.pop(context),
        onConnect: (int index, String name, bool useBiometric) async {
          if (useBiometric) {
            final authenticated = await _authService.authenticate(
              allowPinCode: true,
              reason: 'Please authenticate to enable quick access',
            );

            if (!authenticated) {
              throw "Fail biometric";
            }
          }

          LedgerDevice ledgerDevice = _devices[_selected];
          ZilliqaLedgerApp ledgerZilliqa = ZilliqaLedgerApp(_ledger);

          ({String publicKey, String address}) key =
              await ledgerZilliqa.getPublicAddress(ledgerDevice, index);

          DeviceInfoService device = DeviceInfoService();
          List<String> identifiers = await device.getDeviceIdentifiers();

          LedgerParamsInput params = LedgerParamsInput(
            pubKey: key.publicKey,
            walletIndex: BigInt.from(index),
            walletName: name,
            ledgerId: ledgerDevice.id,
            accountName: "Ledger $index",
            biometricType:
                useBiometric ? preferredAuth.name : AuthMethod.none.name,
            identifiers: identifiers,
            chainHash: BigInt.zero, // TODO: add provider index.
          );

          // TODO: setup default settings.
          WalletSettingsInfo settings = WalletSettingsInfo(
            // AESGCM256 = 0,
            // NTRUP1277 = 1,
            cipherOrders: Uint8List.fromList([0, 1]),
            argonParams: Argon2DefaultParams.lowMemory(),
            currencyConvert: "BTC",
            ipfsNode: "dweb.link",
            ensEnabled: true,
            gasControlEnabled: true,
            nodeRankingEnabled: true,
            maxConnections: 5,
            requestTimeoutSecs: 30,
          );
          List<FTokenInfo> ftokens =
              List<FTokenInfo>.empty(); // TODO: add ftokens default .

          (String, String) session = await addLedgerWallet(
            params: params,
            walletSettings: settings,
            ftokens: ftokens,
          );

          await _appState.syncData();
          _appState.setSelectedWallet(_appState.wallets.length - 1);
          await _authGuard.setSession(session.$2, session.$1);

          final navContext = context;

          if (mounted) {
            // ignore: use_build_context_synchronously
            Navigator.of(navContext).pushNamed(
              '/',
            );
          }
        },
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/browser_page.dart`:

```dart
import 'package:flutter/material.dart';

class BrowserPage extends StatelessWidget {
  const BrowserPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const SafeArea(
      child: Column(
        children: [Center(child: Text('Browser Page'))],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/notification.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:blockies/blockies.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/models/notification.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/theme/app_theme.dart';
import '../components/custom_app_bar.dart';
import '../mixins/colors.dart';
import '../state/app_state.dart';

class NotificationsSettingsPage extends StatefulWidget {
  const NotificationsSettingsPage({super.key});

  @override
  State<NotificationsSettingsPage> createState() =>
      _NotificationsSettingsPageState();
}

class _NotificationsSettingsPageState extends State<NotificationsSettingsPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _initializeServices();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _initializeServices() {}

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: 'Notifications',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _buildPushNotificationsSection(state, adaptivePadding),
                        const SizedBox(height: 24),
                        _buildWalletsSection(theme, adaptivePadding),
                        SizedBox(height: adaptivePadding),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildPushNotificationsSection(
      AppState state, double adaptivePadding) {
    final theme = state.currentTheme;

    return Container(
      margin: EdgeInsets.symmetric(horizontal: adaptivePadding),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'Push notifications',
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
              Switch(
                value: state.state.notificationsGlobalEnabled,
                onChanged: (value) async {
                  await setGlobalNotifications(globalEnabled: value);
                  await state.syncData();
                },
                activeColor: theme.primaryPurple,
                activeTrackColor: theme.primaryPurple.withValues(alpha: 0.5),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            'Get notifications when you receive TON, tokens and NFTs. Notifications from connected apps.',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWalletsSection(AppTheme theme, double adaptivePadding) {
    return Consumer<AppState>(
      builder: (context, appState, _) {
        final isGlobalEnabled = appState.state.notificationsGlobalEnabled;

        return Padding(
          padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
          child: Opacity(
            opacity: isGlobalEnabled ? 1.0 : 0.5,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Wallets',
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Notifications from wallets',
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 16,
                  ),
                ),
                SizedBox(height: adaptivePadding),
                Container(
                  decoration: BoxDecoration(
                    color: theme.cardBackground,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: AbsorbPointer(
                    absorbing: !isGlobalEnabled,
                    child: ListView.builder(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      itemCount: appState.wallets.length,
                      itemBuilder: (context, index) => _buildWalletItem(
                        appState,
                        appState.wallets[index],
                        index,
                        isLastItem: index == appState.wallets.length - 1,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildWalletItem(
    AppState state,
    WalletInfo wallet,
    int index, {
    bool isLastItem = false,
  }) {
    final theme = state.currentTheme;
    final BackgroundNotificationState? walletNotify =
        state.state.notificationsWalletStates[BigInt.from(index)];

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        border: !isLastItem
            ? Border(
                bottom: BorderSide(
                  color: theme.textSecondary.withValues(alpha: 0.1),
                  width: 1,
                ),
              )
            : null,
      ),
      child: Row(
        children: [
          SizedBox(
            width: 40,
            height: 40,
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: Blockies(
                seed: wallet.walletAddress,
                color: getWalletColor(index),
                bgColor: theme.primaryPurple,
                spotColor: theme.background,
                size: 8,
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              wallet.walletName.isEmpty
                  ? "Wallet ${index + 1}"
                  : wallet.walletName,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Switch(
            value: walletNotify != null ? walletNotify.transactions : false,
            onChanged: (value) async {
              await setWalletNotifications(
                walletIndex: BigInt.from(index),
                transactions: value,
                price: false, // TODO: maybe set in future
                security: false,
                balance: false,
              );
              await state.syncData();
            },
            activeColor: theme.primaryPurple,
            activeTrackColor: theme.primaryPurple.withValues(alpha: 0.5),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/network.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/network_tile.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/config/providers.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/modals/custom_network_modal.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import '../components/custom_app_bar.dart';

class NetworkPage extends StatefulWidget {
  const NetworkPage({super.key});

  @override
  State<NetworkPage> createState() => _NetworkPageState();
}

class _NetworkPageState extends State<NetworkPage> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  final List<NetworkItem> addedNetworks = [];
  final List<NetworkItem> potentialNetworks = [];

  @override
  void initState() {
    super.initState();
    _loadNetworks();
  }

  bool isLoading = true;
  String? errorMessage;
  String? _shortName;

  Future<void> _loadNetworks() async {
    try {
      final storedProviders = await getProviders();
      final String mainnetJsonData =
          await rootBundle.loadString('assets/chains/mainnet-chains.json');
      final String testnetJsonData =
          await rootBundle.loadString('assets/chains/testnet-chains.json');

      final List<Chain> mainnetChains =
          await ChainService.loadChains(mainnetJsonData);
      final List<Chain> testnetChains =
          await ChainService.loadChains(testnetJsonData);

      setState(() {
        potentialNetworks.clear();
        addedNetworks.clear();

        addedNetworks.addAll(
          storedProviders.map((provider) => NetworkItem(
                configInfo: provider,
                icon: chainIcon(provider.chain, null),
                isEnabled: true,
                isAdded: true,
              )),
        );

        final addedChainIds =
            addedNetworks.map((network) => network.configInfo.chainId).toSet();

        // TODO: add check slip44 and make sure this is works right.
        potentialNetworks.addAll([
          ...mainnetChains
              .where((chain) =>
                  !addedChainIds.contains(BigInt.from(chain.chainId)))
              .map((chain) {
            chain.testnet = false;
            return NetworkItem(
              configInfo: chain.toNetworkConfigInfo(),
              icon: chainIcon(chain.chain, null),
              isEnabled: true,
              isAdded: false,
            );
          }),
          ...testnetChains
              .where((chain) =>
                  !addedChainIds.contains(BigInt.from(chain.chainId)))
              .map((chain) {
            chain.testnet = true;
            return NetworkItem(
              configInfo: chain.toNetworkConfigInfo(),
              icon: chainIcon(chain.chain, null),
              isEnabled: true,
              isAdded: false,
            );
          }),
        ]);

        isLoading = false;

        if (_shortName != null) {
          int addedIndex = addedNetworks
              .indexWhere((network) => network.configInfo.name == _shortName);
          if (addedIndex >= 0) {
            _handleNetworkSelect(addedNetworks[addedIndex].configInfo);
          } else {
            int potentialIndex = potentialNetworks
                .indexWhere((network) => network.configInfo.name == _shortName);
            if (potentialIndex >= 0) {
              _handleNetworkSelect(
                  potentialNetworks[potentialIndex].configInfo);
            }
          }
        }
      });
    } catch (e) {
      setState(() {
        isLoading = false;
        errorMessage = 'Failed to load network chains: $e';
      });
      debugPrint('Error loading chains: $e');
    }
  }

  List<NetworkItem> _getFilteredNetworks(List<NetworkItem> networks) {
    if (_searchQuery.isEmpty) return networks;
    return networks
        .where((network) => network.configInfo.name
            .toLowerCase()
            .contains(_searchQuery.toLowerCase()))
        .toList();
  }

  void _handleNetworkSelect(NetworkConfigInfo network) async {
    debugPrint('Selected network: ${network.name}');
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Widget _buildNetworkSection(
    String title,
    List<NetworkItem> networks,
    AppState state,
  ) {
    if (networks.isEmpty) return const SizedBox.shrink();
    final theme = state.currentTheme;
    final provider = state.chain!;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: theme.textSecondary.withValues(alpha: 0.7),
          ),
        ),
        const SizedBox(height: 16),
        ...networks.map((network) => Padding(
              padding: const EdgeInsets.only(bottom: 8),
              child: NetworkTile(
                iconUrl: network.icon ?? "",
                title: network.configInfo.name,
                isTestnet: network.configInfo.testnet,
                isEnabled: network.isEnabled,
                isAdded: network.isAdded,
                isDefault: state.wallet?.defaultChainHash ==
                    network.configInfo.chainHash,
                isSelected:
                    provider.chainHash == network.configInfo.chainHash &&
                        provider.chainId == network.configInfo.chainId,
                disabled: provider.slip44 != network.configInfo.slip44,
                onTap: () => _handleNetworkSelect(network.configInfo),
                onAdd: network.isAdded
                    ? null
                    : () async {
                        await addProvider(providerConfig: network.configInfo);
                        await state.syncData();
                        await _loadNetworks();
                      },
                onEdit: network.isAdded
                    ? () {
                        debugPrint(
                            'Editing network: ${network.configInfo.name}');
                      }
                    : null,
              ),
            )),
      ],
    );
  }

  Widget _buildErrorMessage() {
    if (errorMessage == null) return const SizedBox.shrink();

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Text(
        errorMessage!,
        style: const TextStyle(
          color: Colors.red,
          fontSize: 14,
        ),
      ),
    );
  }

  Widget _buildLoadingIndicator() {
    return const Center(
      child: CircularProgressIndicator(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    final filteredAddedNetworks = _getFilteredNetworks(addedNetworks);
    final filteredPotentialNetworks = _getFilteredNetworks(potentialNetworks);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: Container(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Container(
                  padding: EdgeInsets.symmetric(
                    horizontal: adaptivePadding,
                    vertical: 16,
                  ),
                  child: CustomAppBar(
                    title: 'Select a network',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: SmartInput(
                    controller: _searchController,
                    hint: 'Search',
                    leftIconPath: 'assets/icons/search.svg',
                    onChanged: (value) => setState(() => _searchQuery = value),
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                  ),
                ),
                if (errorMessage != null) _buildErrorMessage(),
                Expanded(
                  child: isLoading
                      ? _buildLoadingIndicator()
                      : SingleChildScrollView(
                          physics: const BouncingScrollPhysics(),
                          padding: EdgeInsets.symmetric(
                            horizontal: adaptivePadding,
                            vertical: 24,
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              _buildNetworkSection(
                                'Added Networks',
                                filteredAddedNetworks,
                                state,
                              ),
                              if (filteredAddedNetworks.isNotEmpty &&
                                  filteredPotentialNetworks.isNotEmpty)
                                const SizedBox(height: 24),
                              _buildNetworkSection(
                                'Available Networks',
                                filteredPotentialNetworks,
                                state,
                              ),
                            ],
                          ),
                        ),
                ),
                Container(
                  padding: EdgeInsets.all(adaptivePadding),
                  width: double.infinity,
                  child: CustomButton(
                    text: 'Add a custom network',
                    onPressed: () {
                      showCustomNetworkModal(
                        context: context,
                        theme: theme,
                        onSave: ({
                          required String networkName,
                          required String rpcUrl,
                          required String chainId,
                          required String symbol,
                          required String explorerUrl,
                        }) {
                          debugPrint('New custom network: $networkName');
                        },
                      );
                    },
                    backgroundColor: theme.primaryPurple,
                    borderRadius: 30.0,
                    height: 50.0,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class NetworkItem {
  final NetworkConfigInfo configInfo;
  final String? icon;
  final bool isEnabled;
  final bool isAdded;

  NetworkItem({
    required this.configInfo,
    required this.icon,
    this.isEnabled = false,
    this.isAdded = false,
  });
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/setup_net.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/config/providers.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class SetupNetworkSettingsPage extends StatefulWidget {
  const SetupNetworkSettingsPage({super.key});

  @override
  State<SetupNetworkSettingsPage> createState() =>
      _SetupNetworkSettingsPageState();
}

class _SetupNetworkSettingsPageState extends State<SetupNetworkSettingsPage> {
  List<String>? _bip39List;
  KeyPairInfo? _keys;
  bool isLoading = true;
  String? errorMessage;
  String? _shortName;
  bool isTestnet = false;

  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  int selectedNetworkIndex = 0;
  bool optionsDisabled = false;
  List<Chain> mainnetNetworks = [];
  List<Chain> testnetNetworks = [];

  @override
  void initState() {
    super.initState();
    _loadChains();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final bip39 = args?['bip39'] as List<String>?;
    final keys = args?['keys'] as KeyPairInfo?;
    final shortName = args?['shortName'] as String?;

    if (bip39 == null && keys == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = bip39;
        _keys = keys;
        _shortName = shortName;
      });
    }
  }

  List<Chain> get filteredNetworks {
    final networks = isTestnet ? testnetNetworks : mainnetNetworks;
    if (_searchQuery.isEmpty) {
      return networks;
    }
    return networks.where((network) {
      final searchLower = _searchQuery.toLowerCase();
      return network.name.toLowerCase().contains(searchLower) ||
          network.chain.toLowerCase().contains(searchLower) ||
          network.chainId.toString().contains(searchLower);
    }).toList();
  }

  Future<void> _loadChains() async {
    try {
      final String mainnetJsonData =
          await rootBundle.loadString('assets/chains/mainnet-chains.json');
      final String testnetJsonData =
          await rootBundle.loadString('assets/chains/testnet-chains.json');

      final List<Chain> mainnetChains =
          await ChainService.loadChains(mainnetJsonData);
      final List<Chain> testnetChains =
          await ChainService.loadChains(testnetJsonData);

      setState(() {
        mainnetNetworks = mainnetChains;
        testnetNetworks = testnetChains;
        isLoading = false;

        if (_shortName != null) {
          final networks = isTestnet ? testnetNetworks : mainnetNetworks;
          int foundIndex =
              networks.indexWhere((network) => network.shortName == _shortName);
          if (foundIndex > 0) {
            selectedNetworkIndex = foundIndex;
          }
        }
      });
    } catch (e) {
      setState(() {
        isLoading = false;
        errorMessage = 'Failed to load network chains: $e';
      });
      debugPrint('Error loading chains: $e');
    }
  }

  OptionItem _buildNetworkItem(Chain chain, AppTheme theme, int index) {
    return OptionItem(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Expanded(
                child: Text(
                  chain.name,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: isTestnet
                      ? theme.warning.withValues(alpha: 0.2)
                      : theme.success.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  isTestnet ? 'Testnet' : 'Mainnet',
                  style: TextStyle(
                    color: isTestnet ? theme.warning : theme.success,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Text(
            'Chain ID: ${chain.chainId}',
            style: TextStyle(
              color: theme.primaryPurple,
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'Token: ${chain.chain}',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 14,
            ),
          ),
          if (chain.explorers.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(
              'Explorer: ${chain.explorers.first.name}',
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
          const SizedBox(height: 8),
        ],
      ),
      isSelected: selectedNetworkIndex == index,
      onSelect: () => setState(() => selectedNetworkIndex = index),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    if (isLoading) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  actionWidget: Row(
                    children: [
                      Text(
                        'Testnet',
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Switch(
                        value: isTestnet,
                        onChanged: (value) {
                          setState(() {
                            isTestnet = value;
                            selectedNetworkIndex = 0;
                          });
                        },
                        activeColor: theme.primaryPurple,
                      ),
                    ],
                  ),
                  onBackPressed: () => Navigator.pop(context),
                ),
                Padding(
                  padding: EdgeInsets.all(adaptivePadding),
                  child: SmartInput(
                    controller: _searchController,
                    hint: 'Search',
                    leftIconPath: 'assets/icons/search.svg',
                    onChanged: (value) => setState(() => _searchQuery = value),
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                  ),
                ),
                if (errorMessage != null)
                  Padding(
                    padding: EdgeInsets.all(adaptivePadding),
                    child: Text(
                      errorMessage!,
                      style: TextStyle(
                        color: theme.danger,
                        fontSize: 14,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  )
                else if (filteredNetworks.isEmpty)
                  Expanded(
                    child: Center(
                      child: Text(
                        mainnetNetworks.isEmpty && testnetNetworks.isEmpty
                            ? 'No networks available'
                            : 'No networks found for "$_searchQuery"',
                      ),
                    ),
                  )
                else
                  Expanded(
                    child: SingleChildScrollView(
                      physics: const BouncingScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            OptionsList(
                              disabled: optionsDisabled,
                              options: List.generate(
                                filteredNetworks.length,
                                (index) => _buildNetworkItem(
                                  filteredNetworks[index],
                                  theme,
                                  index,
                                ),
                              ),
                              unselectedOpacity: 0.5,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                Padding(
                  padding: EdgeInsets.all(adaptivePadding),
                  child: CustomButton(
                    text: 'Next',
                    onPressed: filteredNetworks.isEmpty
                        ? () {}
                        : () {
                            final chain = isTestnet
                                ? testnetNetworks[selectedNetworkIndex]
                                : mainnetNetworks[selectedNetworkIndex];

                            if (isTestnet) {
                              chain.testnet = true;
                            }

                            Navigator.of(context).pushNamed(
                              '/cipher_setup',
                              arguments: {
                                'bip39': _bip39List,
                                'keys': _keys,
                                'chain': chain,
                                'isTestnet': isTestnet,
                              },
                            );
                          },
                    backgroundColor: theme.primaryPurple,
                    borderRadius: 30.0,
                    height: 56.0,
                  ),
                )
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/wallet.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/modals/delete_wallet.dart';
import 'package:zilpay/modals/manage_connections.dart';
import 'package:zilpay/modals/secret_recovery_modal.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';

class WalletPreferenceItem {
  final String title;
  final String iconPath;
  final bool hasSwitch;
  final bool switchValue;
  final Function(bool)? onChanged;
  final VoidCallback? onTap;

  WalletPreferenceItem({
    required this.title,
    required this.iconPath,
    this.hasSwitch = false,
    this.switchValue = false,
    this.onChanged,
    this.onTap,
  });
}

class WalletPage extends StatefulWidget {
  const WalletPage({super.key});

  @override
  State<WalletPage> createState() => _WalletPageState();
}

class _WalletPageState extends State<WalletPage> {
  final TextEditingController _walletNameController = TextEditingController();
  static const double _avatarSize = 80.0;
  static const double _borderRadius = 12.0;
  static const double _iconSize = 24.0;
  static const double _fontSize = 16.0;

  @override
  void initState() {
    super.initState();
    final appState = Provider.of<AppState>(context, listen: false);
    _walletNameController.text = appState.wallet!.walletName;
  }

  @override
  void dispose() {
    _walletNameController.dispose();
    super.dispose();
  }

  void _handleDappDisconnect(String url) {
    // final appState = Provider.of<app_state.AppState>(context, listen: false);
    // Implement disconnect logic here
    debugPrint('Disconnecting DApp: $url');
  }

  List<WalletPreferenceItem> _getPreferenceItems(
      BuildContext context, AppTheme theme) {
    final appState = Provider.of<AppState>(context);

    return [
      WalletPreferenceItem(
        title: 'Use Face ID',
        iconPath: 'assets/icons/face_id.svg',
        hasSwitch: true,
        switchValue: true,
        onChanged: (value) => debugPrint("enable face id $value"),
      ),
      WalletPreferenceItem(
        title: 'Zilliqa legacy',
        iconPath: 'assets/icons/scilla.svg',
        hasSwitch: true,
        switchValue: true,
        onChanged: (value) => debugPrint("enable Zilliqa legacy mode"),
      ),
      WalletPreferenceItem(
          title: 'Manage connections',
          iconPath: 'assets/icons/globe.svg',
          onTap: () {
            if (appState.connections.isNotEmpty) {
              showConnectedDappsModal(
                context: context,
                onDappDisconnect: _handleDappDisconnect,
              );
            }
          }),
      if (!appState.wallet!.walletType.contains(WalletType.ledger.name))
        WalletPreferenceItem(
          title: 'Backup',
          iconPath: 'assets/icons/key.svg',
          onTap: () {
            if (!appState.wallet!.walletType.contains(WalletType.ledger.name)) {
              _handleBackup(theme);
            }
          },
        ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: '',
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: CustomScrollView(
                slivers: [
                  SliverPadding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    sliver: SliverList(
                      delegate: SliverChildListDelegate([
                        Center(child: _buildWalletHeader(theme, appState)),
                        const SizedBox(height: 16),
                        _buildWalletNameInput(theme, appState),
                        const SizedBox(height: 32),
                        _buildPreferencesSection(theme),
                      ]),
                    ),
                  ),
                  SliverFillRemaining(
                    hasScrollBody: false,
                    fillOverscroll: true,
                    child: Padding(
                      padding: EdgeInsets.only(
                        left: adaptivePadding,
                        right: adaptivePadding,
                        bottom: 24 + MediaQuery.of(context).viewInsets.bottom,
                      ),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          _buildRemoveWalletButton(theme),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
      resizeToAvoidBottomInset: true,
    );
  }

  Widget _buildWalletHeader(AppTheme theme, AppState appState) {
    return SizedBox(
      width: _avatarSize,
      height: _avatarSize,
      child: Container(
        decoration: BoxDecoration(
          color: theme.background,
          borderRadius: BorderRadius.circular(_avatarSize / 2),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(_avatarSize / 2),
          child: Transform.scale(
            scale: 1.0,
            child: Blockies(
              seed: appState.account!.addr,
              color: getWalletColor(0),
              bgColor: theme.primaryPurple,
              spotColor: theme.background,
              size: 8,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildWalletNameInput(AppTheme theme, AppState state) {
    return SmartInput(
      controller: _walletNameController,
      hint: 'Wallet name',
      onSubmitted: () async {
        if (_walletNameController.text.isNotEmpty) {
          await changeWalletName(
            walletIndex: BigInt.from(state.selectedWallet),
            newName: _walletNameController.text,
          );
          await state.syncData();
        }
      },
      height: 50,
      rightIconPath: "assets/icons/edit.svg",
      borderColor: theme.cardBackground,
      focusedBorderColor: theme.primaryPurple,
      fontSize: _fontSize,
    );
  }

  Widget _buildPreferencesSection(AppTheme theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            'Wallet preferences',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: _fontSize,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(_borderRadius),
          ),
          child: Column(
            children: _buildPreferenceItems(theme),
          ),
        ),
      ],
    );
  }

  List<Widget> _buildPreferenceItems(AppTheme theme) {
    final items = _getPreferenceItems(context, theme);
    final List<Widget> widgets = [];

    for (var i = 0; i < items.length; i++) {
      widgets.add(_buildPreferenceItem(theme, items[i]));
      if (i < items.length - 1) {
        widgets.add(Divider(
          height: 1,
          color: theme.textSecondary.withValues(alpha: 0.1),
        ));
      }
    }

    return widgets;
  }

  Widget _buildPreferenceItem(AppTheme theme, WalletPreferenceItem item) {
    final appState = Provider.of<AppState>(context);

    return GestureDetector(
      onTap: item.onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            SvgPicture.asset(
              item.iconPath,
              width: _iconSize,
              height: _iconSize,
              colorFilter: ColorFilter.mode(
                theme.textPrimary,
                BlendMode.srcIn,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                item.title,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: _fontSize,
                ),
              ),
            ),
            if (item.hasSwitch)
              Switch(
                value: item.switchValue,
                onChanged: item.onChanged,
                activeColor: theme.primaryPurple,
              )
            else if (item.title == 'Manage connections')
              Text(
                '${appState.connections.length}',
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: _fontSize,
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildRemoveWalletButton(AppTheme theme) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () async {
        showModalBottomSheet(
          context: context,
          isScrollControlled: true,
          backgroundColor: theme.cardBackground,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          builder: (context) => DeleteWalletModal(),
        );
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: Colors.red.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(_borderRadius),
        ),
        child: Row(
          children: [
            const SizedBox(width: 16),
            const Expanded(
              child: Text(
                'Delete Wallet',
                style: TextStyle(
                  color: Colors.red,
                  fontSize: _fontSize,
                ),
              ),
            ),
            SvgPicture.asset(
              'assets/icons/logout.svg',
              colorFilter: const ColorFilter.mode(
                Colors.red,
                BlendMode.srcIn,
              ),
              width: _iconSize,
              height: _iconSize,
            ),
          ],
        ),
      ),
    );
  }

  void _handleBackup(AppTheme theme) {
    showModalBottomSheet<void>(
      context: context,
      backgroundColor: theme.cardBackground,
      isScrollControlled: true,
      builder: (context) => SecretRecoveryModal(
        theme: theme,
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/login_page.dart`:

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/svg.dart';
import 'package:blockies/blockies.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/models/wallet.dart';

import '../components/load_button.dart';
import '../components/smart_input.dart';
import '../components/wallet_option.dart';
import '../mixins/adaptive_size.dart';
import '../mixins/colors.dart';
import '../mixins/wallet_type.dart';
import '../services/auth_guard.dart';
import '../services/biometric_service.dart';
import '../services/device.dart';
import '../state/app_state.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  // Controllers
  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();
  final AuthService _authService = AuthService();

  // Services
  late final AuthGuard _authGuard;
  late final AppState _appState;

  // State
  bool _obscurePassword = true;
  bool _obscureButton = true;
  int _selectedWallet = -1;

  @override
  void initState() {
    super.initState();
    _initializeServices();
  }

  void _initializeServices() {
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _btnController.dispose();
    super.dispose();
  }

  // Navigation
  void _navigateToHome() {
    _appState.setSelectedWallet(_selectedWallet);
    Navigator.of(context).pushNamed('/');
  }

  void _navigateToNewWallet() {
    Navigator.pushNamed(context, '/new_wallet_options');
  }

  // Authentication Logic
  Future<bool> _authenticateWithSession(
      String session, int walletIndex, List<String> identifiers) async {
    try {
      bool unlocked = await tryUnlockWithSession(
        sessionCipher: session,
        walletIndex: BigInt.from(walletIndex),
        identifiers: identifiers,
      );

      if (unlocked) {
        await _appState.syncData();
        _authGuard.setEnabled(true);
        return true;
      }
    } catch (e) {
      debugPrint('Session authentication error: $e');
    }
    return false;
  }

  Future<bool> _authenticateWithPassword(
    String password,
    int walletIndex,
    List<String> identifiers,
  ) async {
    try {
      bool unlocked = await tryUnlockWithPassword(
        password: password,
        walletIndex: BigInt.from(walletIndex),
        identifiers: identifiers,
      );

      if (unlocked) {
        await _appState.syncData();
        _authGuard.setEnabled(true);
        return true;
      }
    } catch (e) {
      debugPrint('Password authentication error: $e');
    }
    return false;
  }

  Future<bool> _authenticateWithBiometrics() async {
    try {
      return await _authService.authenticate(
        allowPinCode: true,
        reason: 'Please authenticate',
      );
    } catch (e) {
      debugPrint('Biometric authentication error: $e');
      return false;
    }
  }

  // Authentication Flow
  Future<void> _handleAuthentication() async {
    if (_selectedWallet == -1) return;

    final wallet = _appState.wallets[_selectedWallet];
    final device = DeviceInfoService();
    final identifiers = await device.getDeviceIdentifiers();

    _btnController.start();

    try {
      bool isAuthenticated = false;

      if (wallet.walletType.contains(WalletType.ledger.name)) {
        final session =
            await _authGuard.getSession(sessionKey: wallet.walletAddress);
        isAuthenticated = await _authenticateWithSession(
          session,
          _selectedWallet,
          identifiers,
        );
      } else if (wallet.authType != AuthMethod.none.name &&
          _passwordController.text.isEmpty) {
        final biometricAuth = await _authenticateWithBiometrics();
        if (biometricAuth) {
          final session =
              await _authGuard.getSession(sessionKey: wallet.walletAddress);
          isAuthenticated = await _authenticateWithSession(
            session,
            _selectedWallet,
            identifiers,
          );
        }
      } else if (_passwordController.text.isNotEmpty) {
        isAuthenticated = await _authenticateWithPassword(
          _passwordController.text,
          _selectedWallet,
          identifiers,
        );
      } else {
        _btnController.reset();
        return;
      }

      if (isAuthenticated) {
        _btnController.reset();
        _navigateToHome();
      } else {
        _handleAuthenticationError();
      }
    } catch (e) {
      debugPrint("unlock $e");
      _handleAuthenticationError();
    }
  }

  void _handleAuthenticationError() {
    _btnController.error();
    if (_passwordController.text.isNotEmpty) {
      _passwordInputKey.currentState?.shake();
    }
    Timer(const Duration(seconds: 1), () => _btnController.reset());
  }

  // UI Components
  Widget _buildBackground(Size screenSize) {
    return Positioned(
      child: SizedBox(
        height: screenSize.height * 0.6,
        child: Transform.scale(
          scale: 1.4,
          child: SvgPicture.asset(
            'assets/imgs/zilpay.svg',
            fit: BoxFit.cover,
            width: screenSize.width,
            height: screenSize.height * 0.6,
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(AppState theme) {
    return Padding(
      padding: EdgeInsets.all(AdaptiveSize.getAdaptivePadding(context, 16)),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Spacer(),
          IconButton(
            onPressed: _navigateToNewWallet,
            icon: SvgPicture.asset(
              'assets/icons/plus.svg',
              width: 32,
              height: 32,
              colorFilter: ColorFilter.mode(
                theme.currentTheme.textPrimary,
                BlendMode.srcIn,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWalletList(AppState theme) {
    return Expanded(
      child: ListView.builder(
        physics: const BouncingScrollPhysics(),
        padding: EdgeInsets.symmetric(
          horizontal: AdaptiveSize.getAdaptivePadding(context, 16),
        ),
        itemCount: _appState.wallets.length,
        itemBuilder: (context, index) => _buildWalletItem(index, theme),
      ),
    );
  }

  Widget _buildWalletItem(int index, AppState theme) {
    final wallet = _appState.wallets[index];

    if (!_obscureButton && _selectedWallet != index) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: EdgeInsets.only(top: index > 0 ? 4 : 0),
      child: WalletOption(
        title: wallet.walletName.isEmpty
            ? "Wallet ${index + 1}"
            : wallet.walletName,
        address: wallet.walletAddress,
        isSelected: _selectedWallet == index,
        padding: const EdgeInsets.all(16),
        onTap: () {
          setState(() => _selectedWallet = index);
          _handleAuthentication();
        },
        icons: _getWalletIcons(wallet),
        icon: _buildWalletIcon(wallet, index, theme),
      ),
    );
  }

  List<String> _getWalletIcons(WalletInfo wallet) {
    return [
      if (wallet.walletType.contains(WalletType.ledger.name))
        'assets/icons/ledger.svg',
      if (wallet.walletType.contains(WalletType.SecretPhrase.name))
        'assets/icons/document.svg',
      if (wallet.walletType.contains(WalletType.SecretKey.name))
        'assets/icons/bincode.svg',
      if (wallet.authType == AuthMethod.faceId.name) 'assets/icons/face_id.svg',
      if (wallet.authType == AuthMethod.fingerprint.name)
        'assets/icons/fingerprint.svg',
      if (wallet.authType == AuthMethod.biometric.name)
        'assets/icons/biometric.svg',
      if (wallet.authType == AuthMethod.pinCode.name) 'assets/icons/pin.svg',
    ];
  }

  Widget _buildWalletIcon(WalletInfo wallet, int index, AppState state) {
    final token = wallet.tokens[0];

    return Container(
      padding: const EdgeInsets.all(4),
      child: AsyncImage(
        url: viewTokenIcon(
          token,
          state.chain!.chainId,
          state.currentTheme.value,
        ),
        width: 32,
        height: 32,
        fit: BoxFit.contain,
        errorWidget: Blockies(
          seed: wallet.walletAddress,
          color: getWalletColor(index),
          bgColor: state.currentTheme.primaryPurple,
          spotColor: state.currentTheme.background,
          size: 8,
        ),
        loadingWidget: const Center(
          child: CircularProgressIndicator(
            strokeWidth: 2,
          ),
        ),
      ),
    );
  }

  Widget _buildLoginForm(AppState theme) {
    final isLedgerWallet = _selectedWallet != -1 &&
        _appState.wallets[_selectedWallet].walletType == WalletType.ledger.name;

    return Padding(
      padding: EdgeInsets.all(AdaptiveSize.getAdaptivePadding(context, 16)),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SmartInput(
            key: _passwordInputKey,
            controller: _passwordController,
            hint: "Password",
            fontSize: 18,
            height: 50,
            disabled: _selectedWallet == -1 || isLedgerWallet,
            padding: const EdgeInsets.symmetric(horizontal: 20),
            focusedBorderColor: theme.currentTheme.primaryPurple,
            obscureText: _obscurePassword,
            onFocusChanged: (isFocused) =>
                setState(() => _obscureButton = !isFocused),
            rightIconPath: _obscurePassword
                ? "assets/icons/close_eye.svg"
                : "assets/icons/open_eye.svg",
            onRightIconTap: () =>
                setState(() => _obscurePassword = !_obscurePassword),
          ),
          const SizedBox(height: 8),
          if (_obscureButton) _buildUnlockButton(theme),
        ],
      ),
    );
  }

  Widget _buildUnlockButton(AppState theme) {
    return SizedBox(
      width: double.infinity,
      child: RoundedLoadingButton(
        controller: _btnController,
        onPressed: _handleAuthentication,
        successIcon: SvgPicture.asset(
          'assets/icons/ok.svg',
          width: 24,
          height: 24,
          colorFilter: ColorFilter.mode(
            theme.currentTheme.textPrimary,
            BlendMode.srcIn,
          ),
        ),
        child: Text(
          'Unlock',
          style: TextStyle(
            color: theme.currentTheme.textPrimary,
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context);
    final screenSize = MediaQuery.of(context).size;

    return Scaffold(
      backgroundColor: theme.currentTheme.background,
      body: Stack(
        children: [
          _buildBackground(screenSize),
          SafeArea(
            child: Center(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 480),
                child: Column(
                  children: [
                    _buildHeader(theme),
                    Text(
                      'Welcome back',
                      style: TextStyle(
                        color: theme.currentTheme.textPrimary,
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),
                    _buildWalletList(theme),
                    _buildLoginForm(theme),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/password_setup.dart`:

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/components/biometric_switch.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/config/ftokens.dart';
import 'package:zilpay/config/providers.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart' show AppState;

class PasswordSetupPage extends StatefulWidget {
  const PasswordSetupPage({super.key});

  @override
  State<PasswordSetupPage> createState() => _PasswordSetupPageState();
}

class _PasswordSetupPageState extends State<PasswordSetupPage> {
  List<String>? _bip39List;
  Chain? _chain;
  WalletArgonParamsInfo? _argon2;
  Uint8List? _cipher;
  KeyPairInfo? _keys;

  final AuthService _authService = AuthService();
  late AuthGuard _authGuard;
  late AppState _appState;

  List<AuthMethod> _authMethods = [AuthMethod.none];
  bool _useDeviceAuth = false;

  String _errorMessage = '';
  bool _disabled = false;
  bool _focused = false;

  final _btnController = RoundedLoadingButtonController();

  final _walletNameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _confirmPasswordInputKey = GlobalKey<SmartInputState>();

  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final bip39 = args?['bip39'] as List<String>?;
    final chain = args?['chain'] as Chain?;
    final keys = args?['keys'] as KeyPairInfo?;
    final cipher = args?['cipher'] as Uint8List?;
    final argon2 = args?['argon2'] as WalletArgonParamsInfo?;

    if (bip39 == null && chain == null && cipher == null && keys == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = bip39;
        _chain = chain;
        _keys = keys;
        _cipher = cipher;
        _argon2 = argon2;
      });
    }

    // Set wallet name based on type
    if (bip39 != null) {
      _walletNameController.text =
          'Seed Wallet ${_appState.wallets.length + 1}';
    } else if (keys != null) {
      _walletNameController.text = 'Key Wallet ${_appState.wallets.length + 1}';
    } else {
      _walletNameController.text = 'Wallet ${_appState.wallets.length + 1}';
    }
  }

  @override
  void initState() {
    super.initState();

    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);

    if (_bip39List != null) {
      _walletNameController.text =
          'Seed Wallet ${_appState.wallets.length + 1}';
    } else if (_keys != null) {
      _walletNameController.text = 'Key Wallet ${_appState.wallets.length + 1}';
    } else {
      _walletNameController.text = 'Wallet ${_appState.wallets.length + 1}';
    }

    _checkAuthMethods();
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _walletNameController.dispose();
    _btnController.dispose();

    super.dispose();
  }

  bool _validatePasswords() {
    if (_walletNameController.text.trim().isEmpty) {
      setState(() {
        _errorMessage = 'Wallet name cannot be empty';
        _disabled = false;
      });
      return false;
    }

    if (_walletNameController.text.length > 24) {
      setState(() {
        _errorMessage = 'Wallet name is too long';
        _disabled = false;
      });
      return false;
    }

    if (_passwordController.text.length < 6) {
      _passwordInputKey.currentState?.shake();

      setState(() {
        _errorMessage = 'Password must be at least 8 characters';
        _disabled = false;
      });

      return false;
    }

    if (_passwordController.text != _confirmPasswordController.text) {
      _confirmPasswordInputKey.currentState?.shake();

      setState(() {
        _disabled = false;
        _errorMessage = 'Passwords do not match';
      });

      return false;
    }

    return true;
  }

  void _createWallet() async {
    setState(() {
      _errorMessage = '';
      _disabled = true;
    });

    if (!_validatePasswords()) {
      _btnController.reset();
      return;
    }

    try {
      final BigInt? chainHash;
      List<NetworkConfigInfo> chains = await getProviders();
      final matches = chains
          .where(
            (chain) =>
                chain.chainId == BigInt.from(_chain!.chainId) &&
                chain.slip44 == _chain!.slip44,
          )
          .toList();

      if (matches.isEmpty) {
        NetworkConfigInfo networkInfo = _chain!.toNetworkConfigInfo();
        chainHash = await addProvider(providerConfig: networkInfo);
      } else {
        chainHash = matches.first.chainHash;
      }

      if (_useDeviceAuth) {
        final authenticated = await _authService.authenticate(
          allowPinCode: true,
          reason: 'Please authenticate to enable quick access',
        );

        setState(() => _useDeviceAuth = authenticated);

        if (!authenticated) {
          setState(() {
            _disabled = true;
          });

          return;
        }
      }

      _btnController.start();

      DeviceInfoService device = DeviceInfoService();
      List<String> identifiers = await device.getDeviceIdentifiers();

      AuthMethod biometricType = AuthMethod.none;

      if (_useDeviceAuth) {
        biometricType = _authMethods[0];
      }

      (String, String) session;

      WalletSettingsInfo settings = WalletSettingsInfo(
        cipherOrders: _cipher!,
        argonParams: _argon2!,
        currencyConvert: "BTC",
        ipfsNode: "dweb.link",
        ensEnabled: true,
        gasControlEnabled: true,
        nodeRankingEnabled: true,
        maxConnections: 5,
        requestTimeoutSecs: 30,
      );
      FTokenInfo ftoken = FTokenInfo(
        name: _chain!.nativeCurrency.name,
        symbol: _chain!.nativeCurrency.symbol,
        decimals: _chain!.nativeCurrency.decimals,
        addr: zeroEVM, // TODO: depends of chain check the address.
        balances: {},
        default_: true,
        native: true,
        chainHash: chainHash,
      );

      if (_bip39List != null) {
        Bip39AddWalletParams params = Bip39AddWalletParams(
          password: _passwordController.text,
          mnemonicStr: _bip39List!.join(' '),
          accounts: [
            (BigInt.zero, "Account 0")
          ], // TODO: add interface for change Account name
          passphrase: "", // TODO: maybe make it
          walletName: _walletNameController.text,
          biometricType: biometricType.name,
          identifiers: identifiers,
          chainHash: chainHash,
        );

        session = await addBip39Wallet(
          params: params,
          walletSettings: settings,
          ftokens: [ftoken],
        );
      } else if (_keys != null) {
        AddSKWalletParams params = AddSKWalletParams(
          sk: _keys!.sk,
          password: _passwordController.text,
          walletName: _walletNameController.text,
          biometricType: biometricType.name,
          identifiers: identifiers,
          chainHash: chainHash,
        );

        session = await addSkWallet(
          params: params,
          walletSettings: settings,
          ftokens: [ftoken],
        );
      } else {
        throw "Invalid Wallet gen method";
      }

      if (_useDeviceAuth) {
        await _authGuard.setSession(session.$2, session.$1);
      }

      await _appState.syncData();
      _appState.setSelectedWallet(_appState.wallets.length - 1);
      _btnController.success();

      if (!mounted) return;
      Navigator.of(context).pushNamed(
        '/',
      );
    } catch (e) {
      setState(() {
        _disabled = false;
        _errorMessage = e.toString();
      });
      _btnController.error();

      Timer(const Duration(seconds: 1), () {
        _btnController.reset();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final screenWidth = MediaQuery.of(context).size.width;
    const inputHeight = 50.0;

    final shouldHideButton = screenWidth <= 480 && _focused;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
              child: Column(
                children: [
                  CustomAppBar(
                    title: '',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                  Expanded(
                    child: Center(
                      child: SingleChildScrollView(
                        physics: const BouncingScrollPhysics(),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(
                              'Create Password',
                              style: TextStyle(
                                color: theme.textPrimary,
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            SizedBox(height: adaptivePadding),
                            SmartInput(
                              controller: _walletNameController,
                              hint: "Wallet Name",
                              fontSize: 18,
                              height: inputHeight,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 20),
                              focusedBorderColor: theme.primaryPurple,
                              disabled: _disabled,
                              onFocusChanged: (isFocused) {
                                setState(() {
                                  _focused = isFocused;
                                });
                              },
                              onChanged: (value) {
                                if (_errorMessage != '') {
                                  setState(() {
                                    _errorMessage = '';
                                  });
                                }
                              },
                            ),
                            SizedBox(height: adaptivePadding),
                            SmartInput(
                              key: _passwordInputKey,
                              controller: _passwordController,
                              hint: "Password",
                              fontSize: 18,
                              height: inputHeight,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 20),
                              focusedBorderColor: theme.primaryPurple,
                              disabled: _disabled,
                              obscureText: _obscurePassword,
                              rightIconPath: _obscurePassword
                                  ? "assets/icons/close_eye.svg"
                                  : "assets/icons/open_eye.svg",
                              onChanged: (value) {
                                if (_errorMessage != '') {
                                  setState(() {
                                    _errorMessage = '';
                                  });
                                }
                              },
                              onFocusChanged: (isFocused) {
                                setState(() {
                                  _focused = isFocused;
                                });
                              },
                              onRightIconTap: () {
                                setState(() {
                                  _obscurePassword = !_obscurePassword;
                                });
                              },
                            ),
                            SizedBox(height: adaptivePadding),
                            SmartInput(
                              key: _confirmPasswordInputKey,
                              controller: _confirmPasswordController,
                              hint: "Confirm Password",
                              height: inputHeight,
                              fontSize: 18,
                              disabled: _disabled,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 20),
                              obscureText: _obscureConfirmPassword,
                              rightIconPath: _obscureConfirmPassword
                                  ? "assets/icons/close_eye.svg"
                                  : "assets/icons/open_eye.svg",
                              onRightIconTap: () {
                                setState(() {
                                  _obscureConfirmPassword =
                                      !_obscureConfirmPassword;
                                });
                              },
                              onFocusChanged: (isFocused) {
                                setState(() {
                                  _focused = isFocused;
                                });
                              },
                              onChanged: (value) {
                                if (_errorMessage != '') {
                                  setState(() {
                                    _errorMessage = '';
                                  });
                                }
                              },
                            ),
                            const SizedBox(height: 8),
                            Text(
                              _errorMessage,
                              style: TextStyle(
                                color: theme.danger,
                                fontSize: 14,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                            BiometricSwitch(
                              biometricType: _authMethods.first,
                              value: _useDeviceAuth,
                              disabled: _disabled,
                              onChanged: (value) async {
                                setState(() => _useDeviceAuth = value);
                              },
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  if (!shouldHideButton)
                    Padding(
                      padding: EdgeInsets.only(bottom: adaptivePadding),
                      child: RoundedLoadingButton(
                        controller: _btnController,
                        onPressed: _createWallet,
                        successIcon: SvgPicture.asset(
                          'assets/icons/ok.svg',
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(
                            theme.textPrimary,
                            BlendMode.srcIn,
                          ),
                        ),
                        child: Text(
                          'Create Password',
                          style: TextStyle(
                            color: theme.textPrimary,
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _checkAuthMethods() async {
    final methods = await _authService.getAvailableAuthMethods();
    setState(() {
      _authMethods = methods;
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/receive.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/modals/select_token.dart';
import 'package:zilpay/src/rust/api/qrcode.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class ReceivePage extends StatefulWidget {
  const ReceivePage({super.key});

  @override
  State<ReceivePage> createState() => _ReceivePageState();
}

class _ReceivePageState extends State<ReceivePage> {
  bool isCopied = false;
  bool isPressedToken = false;
  int selectedToken = 0;
  String amount = "0";
  Key _imageKey = UniqueKey();

  final TextEditingController _accountNameController = TextEditingController();
  final TextEditingController _amountController = TextEditingController();

  @override
  void initState() {
    super.initState();
    final appState = Provider.of<AppState>(context, listen: false);

    _amountController.text = amount;
    _accountNameController.text = appState.account?.name ?? "";
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  Future<void> handleCopy(String address) async {
    await Clipboard.setData(ClipboardData(text: address));
    setState(() {
      isCopied = true;
    });

    await Future<void>.delayed(const Duration(seconds: 2));

    setState(() {
      isCopied = false;
    });
  }

  void handlePressedChanged(bool pressed) {
    setState(() {
      isPressedToken = pressed;
    });
  }

  void handleSelectToken() {
    showTokenSelectModal(
      context: context,
      onTokenSelected: (index) {
        setState(() {
          selectedToken = index;
          _imageKey = UniqueKey();
        });
      },
    );
  }

  Future<void> handleShare(
    FTokenInfo token,
    String addr,
    AppTheme theme,
    NetworkConfigInfo chain,
  ) async {
    QrConfigInfo config = QrConfigInfo(
      size: 600,
      gapless: false,
      color: theme.primaryPurple.value,
      eyeShape: EyeShape.circle.value,
      dataModuleShape: DataModuleShape.circle.value,
    );
    String data = generateCryptoUrl(
      address: addr,
      chain: chain.shortName,
      token: token.addr,
      amount: amount,
    );

    try {
      final pngBytes = await genPngQrcode(data: data, config: config);
      final xFile = XFile.fromData(
        pngBytes,
        mimeType: 'image/png',
        name: 'qrcode.png',
      );
      await Share.shareXFiles(
        [xFile],
        text: '$addr, amount: $amount',
      );
    } catch (e) {
      debugPrint("error share: $e");
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = appState.chain!;
    final token = appState.wallet?.tokens[selectedToken];

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: 'Receive',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        children: [
                          Container(
                            width: double.infinity,
                            constraints: const BoxConstraints(maxWidth: 400),
                            child: Column(
                              children: [
                                Container(
                                  margin: EdgeInsets.symmetric(
                                      vertical: adaptivePadding),
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: theme.warning.withValues(alpha: 0.1),
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  child: Row(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      SvgPicture.asset(
                                        "assets/icons/warning.svg",
                                        width: 24,
                                        height: 24,
                                        colorFilter: ColorFilter.mode(
                                          theme.warning,
                                          BlendMode.srcIn,
                                        ),
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Text(
                                          'Only send ${chain.name}(${token?.symbol}) assets to this address. Other assets will be lost forever.',
                                          style: TextStyle(
                                            color: theme.warning,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                Container(
                                  width: double.infinity,
                                  padding: EdgeInsets.all(adaptivePadding),
                                  decoration: BoxDecoration(
                                    color: theme.cardBackground,
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      _buildTokenSelector(theme, token),
                                      const SizedBox(height: 24),
                                      if (token != null &&
                                          appState.account != null)
                                        SizedBox(
                                          width: 220,
                                          height: 220,
                                          child: AsyncQRcode(
                                            data: generateCryptoUrl(
                                              address: appState.account!.addr,
                                              chain: chain.shortName,
                                              token: token.addr,
                                              amount: amount,
                                            ),
                                            color: theme.primaryPurple,
                                            size: 220,
                                            fit: BoxFit.contain,
                                          ),
                                        ),
                                      const SizedBox(height: 16),
                                      Text(
                                        appState.account?.addr ?? "",
                                        style: TextStyle(
                                          color: theme.textSecondary,
                                          fontSize: 12,
                                        ),
                                        textAlign: TextAlign.center,
                                      ),
                                    ],
                                  ),
                                ),
                                const SizedBox(height: 16),
                                SmartInput(
                                  controller: _accountNameController,
                                  hint: 'Account name',
                                  onSubmitted: () async {
                                    if (_accountNameController
                                        .text.isNotEmpty) {
                                      await changeAccountName(
                                        walletIndex: BigInt.from(
                                            appState.selectedWallet),
                                        accountIndex:
                                            appState.wallet!.selectedAccount,
                                        newName: _accountNameController.text,
                                      );
                                      await appState.syncData();
                                    }
                                  },
                                  height: 50,
                                  rightIconPath: "assets/icons/edit.svg",
                                  borderColor: theme.cardBackground,
                                  focusedBorderColor: theme.primaryPurple,
                                  fontSize: 14,
                                ),
                                const SizedBox(height: 16),
                                _buildActionButtons(
                                  theme,
                                  chain,
                                  context,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTokenSelector(AppTheme theme, FTokenInfo? token) {
    final appState = Provider.of<AppState>(context);
    final chain = appState.chain!;

    return GestureDetector(
      onTapDown: (_) => handlePressedChanged(true),
      onTapUp: (_) => handlePressedChanged(false),
      onTapCancel: () => handlePressedChanged(false),
      onTap: handleSelectToken,
      child: AnimatedOpacity(
        duration: const Duration(milliseconds: 150),
        opacity: isPressedToken ? 0.6 : 1.0,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 32,
              height: 32,
              decoration: const BoxDecoration(
                shape: BoxShape.circle,
              ),
              child: Center(
                child: AsyncImage(
                  key: _imageKey,
                  url: viewTokenIcon(
                    token!,
                    chain.chainId,
                    theme.value,
                  ),
                  width: 32,
                  height: 32,
                  fit: BoxFit.contain,
                  errorWidget: Blockies(
                    seed: token.addr,
                    color: getWalletColor(0),
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                  loadingWidget: const Center(
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
            Text(
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
              token.name,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 12,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 2),
            Text(
              "(${token.symbol})",
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButtons(
    AppTheme theme,
    NetworkConfigInfo chain,
    BuildContext context,
  ) {
    final appState = Provider.of<AppState>(context);
    final token = appState.wallet!.tokens[selectedToken];

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        TileButton(
          icon: SvgPicture.asset(
            isCopied ? "assets/icons/check.svg" : "assets/icons/copy.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.primaryPurple,
              BlendMode.srcIn,
            ),
          ),
          disabled: false,
          onPressed: () async {
            await handleCopy(appState.account!.addr);
          },
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
        TileButton(
          icon: SvgPicture.asset(
            "assets/icons/hash.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.primaryPurple,
              BlendMode.srcIn,
            ),
          ),
          disabled: false,
          onPressed: _handleAmountDialog,
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
        if (chain.chain == "ZIL") // TODO: only zil method
          TileButton(
            icon: SvgPicture.asset(
              "assets/icons/swap.svg",
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(
                theme.primaryPurple,
                BlendMode.srcIn,
              ),
            ),
            disabled: false,
            onPressed: () {
              //TODO: if zilliqa we need change from bech32 to base16
            },
            backgroundColor: theme.cardBackground,
            textColor: theme.primaryPurple,
          ),
        TileButton(
          icon: SvgPicture.asset(
            "assets/icons/share.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.primaryPurple,
              BlendMode.srcIn,
            ),
          ),
          disabled: false,
          onPressed: () async {
            await handleShare(
              token,
              appState.account?.addr ?? "",
              theme,
              chain,
            );
          },
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
      ],
    );
  }

  Future<void> _handleAmountDialog() async {
    _amountController.text = amount;

    final result = await showDialog<String>(
      context: context,
      builder: (BuildContext context) {
        final theme = Provider.of<AppState>(context).currentTheme;

        return AlertDialog(
          backgroundColor: theme.cardBackground,
          title: Text(
            'Enter Amount',
            style: TextStyle(
              color: theme.textPrimary,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: TextField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9\,\.]')),
              TextInputFormatter.withFunction((oldValue, newValue) {
                return TextEditingValue(
                  text: newValue.text.replaceAll(',', '.'),
                  selection: newValue.selection,
                );
              }),
              TextInputFormatter.withFunction((oldValue, newValue) {
                if (newValue.text.isEmpty) {
                  return newValue;
                }
                if (newValue.text.split('.').length > 2) {
                  return oldValue;
                }
                return newValue;
              }),
            ],
            decoration: InputDecoration(
              hintText: '0.0',
              hintStyle: TextStyle(color: theme.textSecondary),
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: theme.primaryPurple),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: theme.primaryPurple, width: 2),
              ),
            ),
            style: TextStyle(
              color: theme.textPrimary,
              fontSize: 16,
            ),
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(
                'Cancel',
                style: TextStyle(color: theme.textSecondary),
              ),
            ),
            TextButton(
              onPressed: () {
                if (_amountController.text.isEmpty) {
                  _amountController.text = '0';
                }
                Navigator.pop(context, _amountController.text);
              },
              child: Text(
                'Confirm',
                style: TextStyle(
                  color: theme.primaryPurple,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        );
      },
    );

    if (result != null) {
      setState(() {
        amount = result;
      });
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/initial_page.dart`:

```dart
import 'package:flutter/material.dart';

class InitialPage extends StatelessWidget {
  const InitialPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('Initial Page'),
            const SizedBox(height: 20),
            ElevatedButton(
              child: const Text('Go to Main Page'),
              onPressed: () {
                Navigator.of(context).pushNamed('/new_wallet_options');
              },
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/send.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/input_amount.dart';
import 'package:zilpay/components/number_keyboard.dart';
import 'package:zilpay/components/wallet_selector_card.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/modals/transfer.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/state/app_state.dart';

class SendTokenPage extends StatefulWidget {
  const SendTokenPage({super.key});

  @override
  State<SendTokenPage> createState() => _SendTokenPageState();
}

class _SendTokenPageState extends State<SendTokenPage> {
  bool _initialized = false;
  int _tokenIndex = 0;
  String _amount = "0";
  final String _convertAmount = "0";
  bool _hasDecimalPoint = false;
  String? _address;
  String? _walletName;

  late final AppState _appState;

  bool get _isFormValid => _isValidAmount && _isValidAddress;

  bool get _isValidAddress {
    if (_address == null || _address!.isEmpty) {
      return false;
    }

    return true;
  }

  bool get _isValidAmount {
    if (_amount.endsWith('.')) {
      return false;
    }

    try {
      final numAmount = double.parse(_amount);
      final token = _appState.wallet!.tokens[_tokenIndex];
      final bigBalance = BigInt.parse(
          token.balances[_appState.wallet!.selectedAccount] ?? '0');
      final balance = adjustAmountToDouble(bigBalance, token.decimals);

      return numAmount >= 0 && numAmount <= balance;
    } catch (e) {
      debugPrint("amount is not valid $e");
      return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: '',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ScrollConfiguration(
                    behavior: const ScrollBehavior().copyWith(
                      physics: const BouncingScrollPhysics(),
                      overscroll: true,
                    ),
                    child: SingleChildScrollView(
                      physics: const AlwaysScrollableScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          children: [
                            const SizedBox(height: 16),
                            TokenAmountCard(
                              amount: _amount,
                              convertAmount: _convertAmount,
                              tokenIndex: _tokenIndex,
                              onMaxTap: (String value) {
                                setState(() {
                                  _amount = value;
                                });
                              },
                              onTokenSelected: (int value) {
                                setState(() {
                                  _tokenIndex = value;
                                  _amount = '0';
                                });
                              },
                            ),
                            SvgPicture.asset(
                              "assets/icons/down_arrow.svg",
                              width: 20,
                              height: 20,
                              colorFilter: ColorFilter.mode(
                                theme.textSecondary.withValues(alpha: 0.1),
                                BlendMode.srcIn,
                              ),
                            ),
                            WalletSelectionCard(
                              address: _address,
                              walletName: _walletName,
                              onChange: updateAddress,
                            ),
                            NumberKeyboard(
                              onKeyPressed: (value) {
                                handleKeyPress(value.toString());
                              },
                              onBackspace: handleBackspace,
                              onDotPress: () => handleKeyPress("."),
                            ),
                            CustomButton(
                              text: "Submit",
                              onPressed: () => handleSubmit(appState),
                              disabled: !_isFormValid,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (!_initialized) {
      final args =
          ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
      final int? argTokenIndex = args?['token_index'];

      if (argTokenIndex != null) {
        setState(() {
          _tokenIndex = argTokenIndex;
        });
      }
      _initialized = true;
    }
  }

  void handleBackspace() {
    setState(() {
      if (_amount.length > 1) {
        if (_amount[_amount.length - 1] == '.') {
          _hasDecimalPoint = false;
        }
        _amount = _amount.substring(0, _amount.length - 1);
      } else {
        _amount = "0";
        _hasDecimalPoint = false;
      }
    });
  }

  void handleKeyPress(String value) {
    if (value == ".") {
      if (!_hasDecimalPoint) {
        setState(() {
          _hasDecimalPoint = true;
          if (_amount == "0") {
            _amount = "0.";
          } else {
            _amount += value;
          }
        });
      }
      return;
    }

    setState(() {
      if (_hasDecimalPoint) {
        _amount += value;
      } else {
        if (_amount == "0") {
          _amount = value;
        } else {
          _amount += value;
        }
      }
    });
  }

  void handleSubmit(AppState appState) async {
    if (!_isFormValid) {
      return;
    }

    BigInt accountIndex = appState.wallet!.selectedAccount;
    FTokenInfo token = appState.wallet!.tokens[_tokenIndex];
    TokenTransferParamsInfo params = TokenTransferParamsInfo(
      walletIndex: BigInt.from(appState.selectedWallet),
      accountIndex: accountIndex,
      tokenIndex: BigInt.from(_tokenIndex),
      amount: toWei(_amount, token.decimals).toString(),
      recipient: _address ?? "",
    );
    TransactionRequestInfo tx = await createTokenTransfer(params: params);
    if (!mounted) return;
    showConfirmTransactionModal(
      context: context,
      tx: tx,
      to: _address!,
      tokenIndex: _tokenIndex,
      amount: _amount,
      onConfirm: () {
        Navigator.pop(context);
      },
    );
  }

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
  }

  void updateAddress(QRcodeScanResultInfo params, String name) {
    setState(() {
      if (params.recipient.isNotEmpty) {
        _address = params.recipient;
      }

      if (params.amount != null && params.amount!.isNotEmpty) {
        _amount = params.amount!;
      }

      _walletName = name;
    });
  }

  void updateAmount(String value) {
    setState(() {
      if (_amount == "0" && value != ".") {
        _amount = value;
      } else {
        _amount += value;
      }
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/home_page.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/components/linear_refresh_indicator.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/token_card.dart';
import 'package:zilpay/components/wallet_header.dart';

import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/modals/manage_tokens.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:flutter_svg/flutter_svg.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final appState = Provider.of<AppState>(context, listen: false);

      if (appState.wallet == null || appState.account == null) {
        Navigator.of(context).pop();
        return;
      }

      _refreshData(appState);
    });
  }

  Future<void> _refreshData(AppState appState) async {
    try {
      BigInt index = BigInt.from(appState.selectedWallet);
      await syncBalances(walletIndex: index);
      await appState.updateTokensRates();
      await appState.syncData();
      setState(() {});
    } catch (e) {
      debugPrint("error sync balance: $e");
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final adaptivePaddingCard = AdaptiveSize.getAdaptivePadding(context, 12);

    return SafeArea(
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 480),
          child: CustomScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            slivers: [
              CupertinoSliverRefreshControl(
                onRefresh: () async {
                  await _refreshData(appState);
                },
                builder: (
                  BuildContext context,
                  RefreshIndicatorMode refreshState,
                  double pulledExtent,
                  double refreshTriggerPullDistance,
                  double refreshIndicatorExtent,
                ) {
                  return LinearRefreshIndicator(
                    pulledExtent: pulledExtent,
                    refreshTriggerPullDistance: refreshTriggerPullDistance,
                    refreshIndicatorExtent: refreshIndicatorExtent,
                  );
                },
              ),
              SliverToBoxAdapter(
                child: Column(
                  children: [
                    Padding(
                      padding: EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 12,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: WalletHeader(
                              walletName: appState.account?.name ?? "",
                              walletAddress: appState.account?.addr ?? "",
                              primaryPurple: theme.primaryPurple,
                              background: theme.background,
                              textPrimary: theme.textPrimary,
                            ),
                          ),
                          HoverSvgIcon(
                            assetName: 'assets/icons/gear.svg',
                            width: 30,
                            height: 30,
                            padding: EdgeInsets.fromLTRB(16, 0, 0, 0),
                            color: theme.textSecondary,
                            onTap: () {
                              Navigator.pushNamed(context, '/settings');
                            },
                          ),
                        ],
                      ),
                    ),
                    SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Row(
                        children: [
                          TileButton(
                            icon: SvgPicture.asset(
                              "assets/icons/send.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            onPressed: () {
                              Navigator.pushNamed(context, '/send');
                            },
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                          SizedBox(width: adaptivePaddingCard),
                          TileButton(
                            icon: SvgPicture.asset(
                              "assets/icons/receive.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            onPressed: () {
                              Navigator.pushNamed(context, '/receive');
                            },
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                          SizedBox(width: adaptivePaddingCard),
                          TileButton(
                            icon: SvgPicture.asset(
                              "assets/icons/swap.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            disabled: true,
                            onPressed: () {},
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                          SizedBox(width: adaptivePaddingCard),
                          TileButton(
                            icon: SvgPicture.asset(
                              "assets/icons/buy.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            disabled: true,
                            onPressed: () {},
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                          SizedBox(width: adaptivePaddingCard),
                          TileButton(
                            icon: SvgPicture.asset(
                              "assets/icons/sell.svg",
                              width: 24,
                              height: 24,
                              colorFilter: ColorFilter.mode(
                                theme.primaryPurple,
                                BlendMode.srcIn,
                              ),
                            ),
                            onPressed: () {},
                            disabled: true,
                            backgroundColor: theme.cardBackground,
                            textColor: theme.primaryPurple,
                          ),
                        ],
                      ),
                    ),
                    Padding(
                      padding: EdgeInsets.symmetric(
                          horizontal: adaptivePadding, vertical: 4),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          HoverSvgIcon(
                            assetName: 'assets/icons/manage.svg',
                            width: 30,
                            height: 30,
                            padding: EdgeInsets.fromLTRB(30, adaptivePadding,
                                adaptivePadding, adaptivePadding),
                            color: theme.textSecondary,
                            onTap: () {
                              showManageTokensModal(
                                context: context,
                                onAddToken: () {
                                  Navigator.pushNamed(context, '/add_token');
                                },
                                onTokenToggle: (String addr) async {
                                  debugPrint("contract address $addr");
                                },
                              );
                            },
                          ),
                        ],
                      ),
                    ),
                    Padding(
                      padding: EdgeInsets.all(adaptivePadding),
                      child: Column(
                        children: appState.wallet!.tokens
                            .asMap()
                            .entries
                            .map((entry) {
                          final token = entry.value;
                          final isLast =
                              entry.key == appState.wallet!.tokens.length - 1;
                          String tokenAmountValue = token
                                  .balances[appState.wallet!.selectedAccount] ??
                              "0";

                          return TokenCard(
                            currencySymbol:
                                appState.wallet!.settings.currencyConvert ?? "",
                            tokenAmount: tokenAmountValue,
                            tokenAddr: token.addr,
                            tokenDecimals: token.decimals,
                            tokenName: token.name,
                            tokenSymbol: token.symbol,
                            showDivider: !isLast,
                            iconUrl: viewTokenIcon(
                              token,
                              appState.chain!.chainId,
                              theme.value,
                            ),
                            onTap: () => {
                              Navigator.of(context).pushNamed(
                                '/send',
                                arguments: {'token_index': entry.key},
                              )
                            },
                          );
                        }).toList(),
                      ),
                    )
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/security.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/modals/password_change.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/state/app_state.dart';

import '../components/custom_app_bar.dart';

class SecurityPage extends StatefulWidget {
  const SecurityPage({super.key});

  @override
  State<SecurityPage> createState() => _SecurityPageState();
}

class _SecurityPageState extends State<SecurityPage> {
  final TextEditingController _ipfsController = TextEditingController(text: '');

  @override
  void dispose() {
    _ipfsController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final state = Provider.of<AppState>(context, listen: false);

      if (state.wallet != null && state.wallet!.settings.ipfsNode != null) {
        _ipfsController.text = state.wallet!.settings.ipfsNode!;
      } else {
        _ipfsController.text = "dweb.link";
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: 'Security',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: CustomScrollView(
                    physics: const BouncingScrollPhysics(),
                    slivers: [
                      SliverPadding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        sliver: SliverList(
                          delegate: SliverChildListDelegate([
                            _buildNetworkSection(appState),
                            const SizedBox(height: 32),
                            if (!appState.wallet!.walletType
                                .contains(WalletType.ledger.name)) ...[
                              _buildSecuritySection(appState),
                              const SizedBox(height: 32)
                            ],
                            _buildEncryptionSection(appState),
                            const SizedBox(height: 32),
                          ]),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSecuritySection(AppState state) {
    final theme = state.currentTheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground.withValues(alpha: 0.7),
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              _buildPreferenceItem(
                state,
                'Change wallet password',
                'assets/icons/key.svg',
                'Secure your wallet with a strong password',
                false,
                false,
                null,
                onTap: () {
                  showModalBottomSheet<void>(
                    context: context,
                    backgroundColor: theme.cardBackground,
                    isScrollControlled: true,
                    builder: (context) => ChangePasswordModal(theme: theme),
                  );
                },
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildNetworkSection(AppState state) {
    final theme = state.currentTheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            'Network Privacy',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              _buildPreferenceItem(
                state,
                'Show ENS domains in address bar',
                'assets/icons/graph.svg',
                'Keep in mind that using this feature exposes your IP address to IPFS third-party services.',
                true,
                state.wallet!.settings.ensEnabled,
                (value) async {
                  await setWalletEns(
                    walletIndex: BigInt.from(state.selectedWallet),
                    ensEnabled: value,
                  );
                  await state.syncData();
                },
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                'IPFS gateway',
                'assets/icons/ipfs.svg',
                'ZIlPay uses third-party services to show images of your NFTs stored on IPFS, display information related to ENS(ZNS) addresses entered in your browser\'s address bar, and fetch icons for different tokens. Your IP address may be exposed to these services when you\'re using them.',
                true,
                state.wallet!.settings.ipfsNode != null,
                (value) async {
                  await setWalletIpfsNode(
                    walletIndex: BigInt.from(state.selectedWallet),
                    node: value ? _ipfsController.text : null,
                  );
                  await state.syncData();
                },
                showInput: true,
                controller: _ipfsController,
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                'Gas station',
                'assets/icons/gas.svg',
                'Use ZilPay server for optimize your gas usage',
                true,
                state.wallet!.settings.gasControlEnabled,
                (value) async {
                  await setWalletGasControl(
                    walletIndex: BigInt.from(state.selectedWallet),
                    enabled: value,
                  );
                  await state.syncData();
                },
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                'Node ranking',
                'assets/icons/server.svg',
                'Make requests to ZilPay server for fetch best node',
                true,
                state.wallet!.settings.nodeRankingEnabled,
                (value) async {
                  await setWalletNodeRanking(
                    walletIndex: BigInt.from(state.selectedWallet),
                    enabled: value,
                  );
                  await state.syncData();
                },
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPreferenceItem(
    AppState state,
    String title,
    String iconPath,
    String description,
    bool hasSwitch,
    bool value,
    Function(bool)? onChanged, {
    VoidCallback? onTap,
    bool showInput = false,
    TextEditingController? controller,
  }) {
    final theme = state.currentTheme;

    return GestureDetector(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                SvgPicture.asset(
                  iconPath,
                  width: 24,
                  height: 24,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Text(
                    title,
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 16,
                    ),
                  ),
                ),
                if (hasSwitch)
                  Switch(
                    value: value,
                    onChanged: onChanged,
                    activeColor: theme.primaryPurple,
                  )
              ],
            ),
            if (description.isNotEmpty) ...[
              const SizedBox(height: 4),
              Padding(
                padding: const EdgeInsets.only(left: 40),
                child: Text(
                  description,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
              ),
            ],
            if (showInput) ...[
              const SizedBox(height: 12),
              Padding(
                padding: const EdgeInsets.only(left: 40),
                child: TextField(
                  controller: controller,
                  readOnly: !value,
                  style: TextStyle(
                    color: value
                        ? theme.textPrimary
                        : theme.textSecondary.withValues(alpha: 0.5),
                    fontSize: 14,
                  ),
                  decoration: InputDecoration(
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                      borderSide: BorderSide(
                        color: theme.textSecondary.withValues(alpha: 0.2),
                      ),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                      borderSide: BorderSide(
                        color: theme.primaryPurple,
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildEncryptionSection(AppState state) {
    final theme = state.currentTheme;
    final algorithms = generateAlgorithms(state.wallet!.settings.cipherOrders);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            'Encryption Level',
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          physics: const BouncingScrollPhysics(),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: [
                for (int i = 0; i < algorithms.length; i++) ...[
                  if (i > 0)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                      child: SvgPicture.asset(
                        'assets/icons/chevron_right.svg',
                        width: 16,
                        height: 16,
                        colorFilter: ColorFilter.mode(
                          theme.textSecondary,
                          BlendMode.srcIn,
                        ),
                      ),
                    ),
                  SizedBox(
                    width: 250,
                    child: _buildEncryptionCard(
                      state,
                      algorithms[i],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildEncryptionCard(
    AppState state,
    Algorithm algorithm,
  ) {
    final theme = state.currentTheme;
    final cardWidth = MediaQuery.of(context).size.width > 480
        ? 320.0
        : MediaQuery.of(context).size.width * 0.7;

    return Container(
      width: cardWidth,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: theme.background,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: SvgPicture.asset(
                  algorithm.icon,
                  width: 24,
                  height: 24,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Text(
                algorithm.name,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const Spacer(),
            ],
          ),
          const SizedBox(height: 16),
          _buildProgressBar(
            state,
            'Protection',
            algorithm.protection,
            theme.primaryPurple,
          ),
          const SizedBox(height: 12),
          _buildProgressBar(
            state,
            'CPU Load',
            algorithm.cpuLoad,
            theme.warning,
          ),
        ],
      ),
    );
  }

  Widget _buildProgressBar(
    AppState state,
    String label,
    double value,
    Color color,
  ) {
    final theme = state.currentTheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
            ),
            Text(
              '${(value * 100).toInt()}%',
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        Container(
          height: 4,
          decoration: BoxDecoration(
            color: theme.background,
            borderRadius: BorderRadius.circular(2),
          ),
          child: FractionallySizedBox(
            widthFactor: value,
            child: Container(
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
        ),
      ],
    );
  }

  List<Algorithm> generateAlgorithms(List<int> algorithms) {
    final Map<int, Algorithm> algorithmData = {
      0: const Algorithm(
        name: 'AES256',
        protection: 0.60,
        cpuLoad: 0.3,
        icon: 'assets/icons/lock.svg',
      ),
      1: const Algorithm(
        name: 'NTRUPrime',
        protection: 0.92,
        cpuLoad: 0.9,
        icon: 'assets/icons/atom.svg',
      ),
      2: const Algorithm(
        name: 'Cyber',
        protection: 0.70,
        cpuLoad: 0.5,
        icon: 'assets/icons/atom.svg',
      ),
    };

    return algorithms.map((algo) {
      return algorithmData[algo] ??
          Algorithm(
            name: 'Unknown',
            protection: 0.0,
            cpuLoad: 0.0,
            icon: 'assets/icons/lock.svg',
          );
    }).toList();
  }
}

class Algorithm {
  final String name;
  final double protection;
  final double cpuLoad;
  final String icon;

  const Algorithm({
    required this.name,
    required this.protection,
    required this.cpuLoad,
    required this.icon,
  });
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/locale.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';

class Language {
  final String code;
  final String name;
  final String localName;

  Language(this.code, this.name, this.localName);
}

class LanguagePage extends StatefulWidget {
  const LanguagePage({super.key});

  @override
  State<LanguagePage> createState() => _LanguagePageState();
}

class _LanguagePageState extends State<LanguagePage> {
  final List<Language> languages = [
    Language('system', 'System', 'English'),
    Language('ru', 'Russian', 'Русский'),
    Language('en', 'English', 'English'),
    Language('tr', 'Turkish', 'Türkçe'),
    Language('zh', 'Chinese', '简体中文'),
    Language('uz', 'Uzbek', 'O\'zbekcha'),
    Language('id', 'Indonesian', 'Bahasa Indonesia'),
    Language('uk', 'Ukrainian', 'Українська'),
  ];

  String selectedLanguage = 'system';
  bool vibrateEnabled = true;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: CustomAppBar(
                    title: 'Language',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ListView.builder(
                    physics: const BouncingScrollPhysics(),
                    itemCount: languages.length,
                    itemBuilder: (context, index) {
                      final language = languages[index];
                      final isSelected = language.code == selectedLanguage;
                      final isLastItem = index == languages.length - 1;

                      return _buildLanguageItem(
                        theme,
                        language,
                        isSelected,
                        isLastItem,
                        onTap: () {
                          setState(() {
                            selectedLanguage = language.code;
                          });
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLanguageItem(
    AppTheme theme,
    Language language,
    bool isSelected,
    bool isLastItem, {
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: !isLastItem
              ? Border(
                  bottom: BorderSide(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    width: 1,
                  ),
                )
              : null,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              language.name,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    language.localName,
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ),
                SizedBox(
                  width: 24,
                  height: 24,
                  child: isSelected
                      ? SvgPicture.asset(
                          'assets/icons/ok.svg',
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        )
                      : null,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/address_book.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/modals/add_contect.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';

class AddressBookPage extends StatefulWidget {
  const AddressBookPage({super.key});

  @override
  State<AddressBookPage> createState() => _AddressBookPageState();
}

class _AddressBookPageState extends State<AddressBookPage> {
  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: CustomAppBar(
                    title: 'Address Book',
                    onBackPressed: () => Navigator.pop(context),
                    actionWidget: SvgPicture.asset(
                      'assets/icons/plus.svg',
                      width: 24,
                      height: 24,
                      colorFilter: ColorFilter.mode(
                        theme.textPrimary,
                        BlendMode.srcIn,
                      ),
                    ),
                    onActionPressed: () {
                      showModalBottomSheet(
                        context: context,
                        isScrollControlled: true,
                        backgroundColor: theme.cardBackground,
                        shape: const RoundedRectangleBorder(
                          borderRadius:
                              BorderRadius.vertical(top: Radius.circular(16)),
                        ),
                        builder: (context) => AddAddressModal(
                          theme: theme,
                          state: state,
                        ),
                      );
                    },
                  ),
                ),
                Expanded(
                  child: state.book.isEmpty
                      ? _buildEmptyState(theme)
                      : _buildAddressList(state),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(AppTheme theme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SvgPicture.asset(
              'assets/icons/book.svg',
              width: 120,
              height: 120,
              colorFilter: ColorFilter.mode(
                theme.textSecondary.withValues(alpha: 0.4),
                BlendMode.srcIn,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'Your contacts and their wallet address will\nappear here.',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 16,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAddressList(AppState state) {
    final theme = state.currentTheme;

    return ListView.builder(
      itemCount: state.book.length,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      physics: const BouncingScrollPhysics(),
      itemBuilder: (context, index) {
        final address = state.book[index];
        final isLastItem = index == state.book.length - 1;

        return GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: () {
            // Handle address selection
          },
          child: Container(
            height: 72,
            decoration: BoxDecoration(
              border: !isLastItem
                  ? Border(
                      bottom: BorderSide(
                        color: theme.textSecondary.withValues(alpha: 0.1),
                        width: 1,
                      ),
                    )
                  : null,
            ),
            child: Row(
              children: [
                ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: SizedBox(
                    width: 40,
                    height: 40,
                    child: Blockies(
                      seed: address.addr.toLowerCase(),
                      size: 8,
                      color: theme.primaryPurple,
                      spotColor: theme.textSecondary,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        address.name,
                        style: TextStyle(
                          color: theme.textPrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        "Netowrk ${address.net}",
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
                SizedBox(
                  width: 24,
                  height: 24,
                  child: SvgPicture.asset(
                    'assets/icons/chevron_right.svg',
                    colorFilter: ColorFilter.mode(
                      theme.textSecondary,
                      BlendMode.srcIn,
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/gen_bip39.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/components/wor_count_selector.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/backup_confirmation_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/state/app_state.dart';

class SecretPhraseGeneratorPage extends StatefulWidget {
  const SecretPhraseGeneratorPage({
    super.key,
  });

  @override
  State<SecretPhraseGeneratorPage> createState() => _CreateAccountPageState();
}

class _CreateAccountPageState extends State<SecretPhraseGeneratorPage> {
  List<String> _mnemonicWords = [];
  var _count = 12;
  bool _hasBackupWords = false;
  // final String _selectedLanguage = 'English';

  @override
  void initState() {
    super.initState();
    _regenerateMnemonicWords();
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: 'New Wallet',
                  onBackPressed: () => Navigator.pop(context),
                  actionIcon: SvgPicture.asset(
                    'assets/icons/reload.svg',
                    width: 30,
                    height: 30,
                    colorFilter: ColorFilter.mode(
                      theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  ),
                  onActionPressed: _regenerateMnemonicWords,
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        WordCountSelector(
                          wordCounts: const [12, 15, 18, 21, 24],
                          selectedCount: _count,
                          onCountChanged: (newCount) {
                            setState(() {
                              _count = newCount;
                              _regenerateMnemonicWords();
                            });
                          },
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: ListView.builder(
                            physics: const BouncingScrollPhysics(),
                            itemCount: _mnemonicWords.length,
                            itemBuilder: (context, index) {
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 8.0),
                                child: MnemonicWordInput(
                                  index: index + 1,
                                  word: _mnemonicWords[index],
                                  isEditable: false,
                                  opacity: 0.5,
                                ),
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 8),
                        Theme(
                          data: Theme.of(context).copyWith(
                            splashFactory: NoSplash.splashFactory,
                            highlightColor: Colors.transparent,
                          ),
                          child: CheckboxListTile(
                            title: Text(
                              'I have backup words',
                              style: TextStyle(color: theme.textSecondary),
                            ),
                            value: _hasBackupWords,
                            onChanged: (_) {
                              if (!_hasBackupWords) {
                                showBackupConfirmationModal(
                                  context: context,
                                  onConfirmed: (confirmed) {
                                    setState(() {
                                      _hasBackupWords = confirmed;
                                    });
                                  },
                                );
                              }
                            },
                            controlAffinity: ListTileControlAffinity.leading,
                            activeColor: theme.primaryPurple,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16),
                          child: CustomButton(
                            text: 'Next',
                            onPressed: () {
                              Navigator.of(context).pushNamed('/verify_bip39',
                                  arguments: {'bip39': _mnemonicWords});
                            },
                            backgroundColor: theme.primaryPurple,
                            borderRadius: 30.0,
                            height: 56.0,
                            disabled: !_hasBackupWords,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _regenerateMnemonicWords() async {
    String words = await genBip39Words(count: _count);

    setState(() {
      _mnemonicWords = words.split(" ");
      _hasBackupWords = false;
    });
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/new_wallet_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class AddWalletOptionsPage extends StatelessWidget {
  const AddWalletOptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: SvgPicture.asset(
            'assets/icons/back.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.secondaryPurple,
              BlendMode.srcIn,
            ),
          ),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Text('Add Wallet', style: TextStyle(color: theme.textPrimary)),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              WalletListItem(
                title: 'New Wallet',
                subtitle: 'Create new wallet',
                icon: SvgPicture.asset(
                  'assets/icons/add.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_options');
                },
              ),
              WalletListItem(
                title: 'Existing Wallet',
                subtitle: 'Import wallet with a 24 secret recovery words',
                icon: SvgPicture.asset(
                  'assets/icons/import.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/restore_options');
                },
              ),
              WalletListItem(
                title: 'Pair with Ledger',
                subtitle: 'Hardware module, Bluetooth',
                icon: SvgPicture.asset(
                  'assets/icons/ledger.svg',
                  width: 25,
                  height: 25,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/ledger_connect');
                },
              ),
              const SizedBox(height: 24),
              Padding(
                padding: const EdgeInsets.only(left: 16.0),
                child: Text(
                  'Other options',
                  style: TextStyle(color: theme.textSecondary, fontSize: 14),
                ),
              ),
              const SizedBox(height: 16),
              WalletListItem(
                disabled: true,
                title: 'Watch Account',
                subtitle: 'For monitor wallet activity without recovery phrase',
                icon: SvgPicture.asset(
                  'assets/icons/looking.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {/* Handle watch account */},
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/settings_page.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/settings_item.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/colors.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/mixins/icon.dart';
import 'package:zilpay/services/social_media.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final SocialMediaService socialMediaService = SocialMediaService();
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: 'Settings',
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ScrollConfiguration(
                    behavior: const ScrollBehavior().copyWith(
                      physics: const BouncingScrollPhysics(),
                      overscroll: true,
                    ),
                    child: SingleChildScrollView(
                      physics: const AlwaysScrollableScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          children: [
                            _buildWalletSection(theme, appState),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              SettingsItem(
                                title: 'Currency',
                                trailingSvgPath: 'assets/icons/currency.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/currency'),
                              ),
                              SettingsItem(
                                title: 'Appearance',
                                trailingSvgPath: 'assets/icons/appearance.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/appearance'),
                              ),
                              SettingsItem(
                                title: 'Notifications',
                                trailingSvgPath: 'assets/icons/bell.svg',
                                onTap: () => Navigator.pushNamed(
                                    context, '/notifications'),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: true,
                                title: 'Address book',
                                trailingSvgPath: 'assets/icons/book.svg',
                                onTap: () => Navigator.pushNamed(
                                    context, '/address-book'),
                              ),
                            ]),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              SettingsItem(
                                isFirst: true,
                                isLast: false,
                                title: 'Security & privacy',
                                trailingSvgPath: 'assets/icons/shield.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/security'),
                              ),
                              SettingsItem(
                                title: 'Networks',
                                trailingSvgPath: 'assets/icons/globe.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/networks'),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: true,
                                title: 'Language',
                                trailingSvgPath: 'assets/icons/language.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/language'),
                              ),
                            ]),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              SettingsItem(
                                isFirst: true,
                                isLast: false,
                                title: 'Telegram',
                                trailingSvgPath: 'assets/icons/telegram.svg',
                                onTap: () => socialMediaService.openTelegram(
                                    username: 'zilpaychat'),
                              ),
                              SettingsItem(
                                title: 'Twitter',
                                trailingSvgPath: 'assets/icons/x.svg',
                                onTap: () => socialMediaService.openX(
                                    username: 'pay_zil'),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: true,
                                title: 'About',
                                trailingSvgPath: 'assets/icons/info.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/about'),
                              ),
                            ]),
                            SizedBox(height: adaptivePadding),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildWalletSection(AppTheme theme, AppState appState) {
    final chain = appState.chain!;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => Navigator.pushNamed(context, '/wallet'),
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: theme.cardBackground,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: theme.background,
                borderRadius: BorderRadius.circular(20),
              ),
              child: AsyncImage(
                url: chainIcon(chain.chain, null),
                width: 32,
                height: 32,
                fit: BoxFit.contain,
                errorWidget: Blockies(
                  seed: appState.wallet!.walletAddress,
                  color: getWalletColor(0),
                  bgColor: theme.primaryPurple,
                  spotColor: theme.background,
                  size: 8,
                ),
                loadingWidget: const Center(
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 16),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  appState.wallet!.walletName,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
                Text(
                  appState.chain?.name ?? "",
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSettingsGroup(AppTheme theme, List<Widget> items) {
    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        children: List.generate(items.length, (index) {
          final item = items[index];
          final isLast = index == items.length - 1;
          return Column(
            children: [
              item,
              if (!isLast)
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: Divider(
                    height: 1,
                    color: theme.textSecondary.withValues(alpha: 0.1),
                  ),
                ),
            ],
          );
        }),
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/pages/verify_bip39.dart`:

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/state/app_state.dart';

List<int> getRandomNumbers(int min, int max, int count) {
  final random = Random();
  Set<int> numbers = {};
  while (numbers.length < count) {
    int randomNumber = min + random.nextInt(max - min + 1);
    numbers.add(randomNumber);
  }

  return numbers.toList();
}

const maxNumbers = 4;

class SecretPhraseVerifyPage extends StatefulWidget {
  const SecretPhraseVerifyPage({
    super.key,
  });

  @override
  State<SecretPhraseVerifyPage> createState() => _VerifyBip39PageState();
}

class _VerifyBip39PageState extends State<SecretPhraseVerifyPage> {
  List<String>? _bip39List;
  List<int> _indexes = getRandomNumbers(1, 12, maxNumbers);
  final List<String> _verifyWords =
      List<String>.filled(maxNumbers, '', growable: false);

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args = ModalRoute.of(context)?.settings.arguments
        as Map<String, List<String>>?;

    if (args == null || args['bip39'] == null || args['bip39']!.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = args['bip39'];

        if (_bip39List != null) {
          _indexes = getRandomNumbers(1, _bip39List!.length + 1, maxNumbers);
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: 'Verify Secret',
                  onBackPressed: () => Navigator.pop(context),
                  actionWidget: TextButton(
                    onPressed: () {
                      Navigator.of(context).pushNamed('/net_setup',
                          arguments: {'bip39': _bip39List});
                    },
                    child: Text(
                      'Skip',
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ),
                Expanded(
                  child: _bip39List == null
                      ? const Center(child: CircularProgressIndicator())
                      : Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Verify Bip39 Secret',
                                style: TextStyle(
                                  fontSize: 24,
                                  fontWeight: FontWeight.bold,
                                  color: theme.textPrimary,
                                ),
                              ),
                              const SizedBox(height: 16),
                              Expanded(
                                child: ListView.builder(
                                  physics: const BouncingScrollPhysics(),
                                  itemCount: maxNumbers,
                                  itemBuilder: (context, index) {
                                    return Padding(
                                      padding: const EdgeInsets.symmetric(
                                          vertical: 8.0),
                                      child: MnemonicWordInput(
                                        index: _indexes[index],
                                        word: _verifyWords[index],
                                        isEditable: true,
                                        borderColor: _verifyWords[index] == ''
                                            ? theme.textSecondary
                                            : _bip39List![
                                                        _indexes[index] - 1] ==
                                                    _verifyWords[index]
                                                ? Colors.green
                                                : Colors.red,
                                        onChanged: (_, newWord) {
                                          setState(() {
                                            _verifyWords[index] = newWord;
                                          });
                                        },
                                      ),
                                    );
                                  },
                                ),
                              ),
                              Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 16.0),
                                child: CustomButton(
                                  text: 'Next',
                                  onPressed: () {
                                    Navigator.of(context).pushNamed(
                                        '/net_setup',
                                        arguments: {'bip39': _bip39List});
                                  },
                                  backgroundColor: theme.primaryPurple,
                                  borderRadius: 30.0,
                                  height: 56.0,
                                  disabled: !isVerified,
                                ),
                              ),
                            ],
                          ),
                        ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  bool get isVerified {
    if (_bip39List == null ||
        _indexes.length != maxNumbers ||
        _verifyWords.length != maxNumbers) {
      return false;
    }

    for (int i = 0; i < maxNumbers; i++) {
      int bip39Index = _indexes[i] - 1;

      if (bip39Index < 0 || bip39Index >= _bip39List!.length) {
        return false;
      }

      if (_bip39List![bip39Index].trim().toLowerCase() !=
          _verifyWords[i].trim().toLowerCase()) {
        return false;
      }
    }

    return true;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/app.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'router.dart';
import 'services/auth_guard.dart';
import 'state/app_state.dart';

class ZilPayApp extends StatelessWidget {
  final AuthGuard authGuard;
  final AppState appState;

  const ZilPayApp({super.key, required this.authGuard, required this.appState});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: authGuard),
        ChangeNotifierProvider.value(value: appState),
      ],
      child: Builder(
        builder: (context) {
          return Consumer<AppState>(
            builder: (context, appState, _) {
              final currentTheme = appState.currentTheme;

              return MaterialApp(
                title: 'ZilPay Wallet',
                builder: (context, child) {
                  final mediaQuery = MediaQuery.of(context);
                  final screenWidth = mediaQuery.size.width;

                  double textScale = 1.0;

                  if (screenWidth <= 375) {
                    textScale = 0.8;
                  } else if (screenWidth <= 390) {
                    textScale = 0.85;
                  }

                  return MediaQuery(
                    data: mediaQuery.copyWith(
                      textScaler: TextScaler.linear(textScale),
                    ),
                    child: child!,
                  );
                },
                theme: ThemeData(
                  primaryColor: currentTheme.primaryPurple,
                  scaffoldBackgroundColor: currentTheme.background,
                ),
                initialRoute: '/',
                onGenerateRoute: AppRouter(
                  authGuard: Provider.of<AuthGuard>(context, listen: false),
                  appState: Provider.of<AppState>(context, listen: false),
                ).onGenerateRoute,
              );
            },
          );
        },
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/services/biometric_service.dart`:

```dart
import 'package:local_auth/local_auth.dart';
import 'package:flutter/services.dart';

enum AuthMethod { faceId, fingerprint, biometric, pinCode, none }

class AuthService {
  final LocalAuthentication _auth = LocalAuthentication();

  Future<List<AuthMethod>> getAvailableAuthMethods() async {
    try {
      List<AuthMethod> methods = [];

      final isSupported = await _auth.isDeviceSupported();
      final canCheckBiometrics = await _auth.canCheckBiometrics;

      if (isSupported && canCheckBiometrics) {
        final availableBiometrics = await _auth.getAvailableBiometrics();

        if (availableBiometrics.contains(BiometricType.face)) {
          methods.add(AuthMethod.faceId);
        } else if (availableBiometrics.contains(BiometricType.fingerprint)) {
          methods.add(AuthMethod.fingerprint);
        } else if (availableBiometrics.contains(BiometricType.strong) ||
            availableBiometrics.contains(BiometricType.weak)) {
          methods.add(AuthMethod.biometric);
        }
      }

      if (await _checkDevicePinCode()) {
        methods.add(AuthMethod.pinCode);
      }

      return methods.isEmpty ? [AuthMethod.none] : methods;
    } on PlatformException catch (_) {
      return [AuthMethod.none];
    }
  }

  Future<bool> _checkDevicePinCode() async {
    try {
      return await _auth.isDeviceSupported();
    } catch (_) {
      return false;
    }
  }

  Future<bool> authenticate({
    bool allowPinCode = true,
    String reason = 'Please authenticate to continue',
  }) async {
    return await _auth.authenticate(
      localizedReason: reason,
      options: AuthenticationOptions(
        stickyAuth: true,
        biometricOnly: !allowPinCode,
        useErrorDialogs: true,
      ),
    );
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/services/secure_storage.dart`:

```dart
import 'dart:convert';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:zilpay/services/biometric_service.dart';

class SecureStorage {
  static const String _keyPrefix = 'zilpay_';
  static const String _sessionKey = '${_keyPrefix}session';
  static const String _authMethodKey = '${_keyPrefix}auth_method';

  final FlutterSecureStorage _storage;
  final AuthService _authService;

  SecureStorage({AuthService? authService})
      : _storage = const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: true,
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock,
            synchronizable: true,
          ),
        ),
        _authService = authService ?? AuthService();

  Future<void> saveSessionKey(String sessionKey) async {
    try {
      final authMethods = await _authService.getAvailableAuthMethods();

      if (authMethods.contains(AuthMethod.none)) {
        throw SecurityException(
            'Device does not support secure storage. Please enable device lock.');
      }

      final encodedKey = base64.encode(utf8.encode(sessionKey));

      await _storage.write(
        key: _sessionKey,
        value: encodedKey,
      );

      await _storage.write(
        key: _authMethodKey,
        value: authMethods.first.toString(),
      );
    } catch (e) {
      throw StorageException('Failed to save session key: $e');
    }
  }

  Future<String?> getSessionKey({
    bool requireAuth = true,
    String reason = 'Please authenticate to access your wallet',
  }) async {
    try {
      final encodedKey = await _storage.read(key: _sessionKey);
      if (encodedKey == null) return null;

      if (requireAuth) {
        final isAuthenticated = await _authService.authenticate(
          reason: reason,
        );

        if (!isAuthenticated) {
          throw AuthenticationException('Authentication failed');
        }
      }

      return utf8.decode(base64.decode(encodedKey));
    } catch (e) {
      if (e is AuthenticationException) rethrow;
      throw StorageException('Failed to get session key: $e');
    }
  }

  Future<bool> hasSessionKey() async {
    try {
      final key = await _storage.read(key: _sessionKey);
      return key != null;
    } catch (e) {
      return false;
    }
  }

  Future<void> deleteSessionKey() async {
    try {
      await _storage.delete(key: _sessionKey);
      await _storage.delete(key: _authMethodKey);
    } catch (e) {
      throw StorageException('Failed to delete session key: $e');
    }
  }

  Future<void> clearStorage() async {
    try {
      await _storage.deleteAll();
    } catch (e) {
      throw StorageException('Failed to clear storage: $e');
    }
  }

  Future<AuthMethod> getCurrentAuthMethod() async {
    try {
      final method = await _storage.read(key: _authMethodKey);
      if (method == null) return AuthMethod.none;
      return AuthMethod.values.firstWhere(
        (e) => e.toString() == method,
        orElse: () => AuthMethod.none,
      );
    } catch (e) {
      return AuthMethod.none;
    }
  }
}

class SecurityException implements Exception {
  final String message;
  SecurityException(this.message);
  @override
  String toString() => message;
}

class StorageException implements Exception {
  final String message;
  StorageException(this.message);
  @override
  String toString() => message;
}

class AuthenticationException implements Exception {
  final String message;
  AuthenticationException(this.message);
  @override
  String toString() => message;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/services/device.dart`:

```dart
import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:zilpay/services/biometric_service.dart';

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfo = DeviceInfoPlugin();

  Future<List<String>> getDeviceIdentifiers() async {
    final packageInfo = await PackageInfo.fromPlatform();
    final AuthService authService = AuthService();
    final methods =
        (await authService.getAvailableAuthMethods()).map((e) => e.name);

    if (Platform.isAndroid) {
      final info = await _deviceInfo.androidInfo;
      return [
        info.brand,
        info.manufacturer,
        info.hardware,
        info.model,
        info.product,
        info.device,
        info.board,
        info.isPhysicalDevice.toString(),
        packageInfo.packageName,
        packageInfo.buildSignature,
        ...methods
      ];
    }

    if (Platform.isIOS) {
      final info = await _deviceInfo.iosInfo;
      return [
        info.model,
        info.localizedModel,
        info.utsname.machine,
        info.isPhysicalDevice.toString(),
        packageInfo.packageName,
        packageInfo.buildSignature,
        ...methods
      ];
    }

    throw UnsupportedError('Unsupported platform');
  }

  Future<Map<String, String>> getDeviceInfo() async {
    final packageInfo = await PackageInfo.fromPlatform();

    if (Platform.isAndroid) {
      final info = await _deviceInfo.androidInfo;
      return {
        'brand': info.brand,
        'manufacturer': info.manufacturer,
        'hardware': info.hardware,
        'model': info.model,
        'product': info.product,
        'device': info.device,
        'board': info.board,
        'isPhysicalDevice': info.isPhysicalDevice.toString(),
        'appId': packageInfo.packageName,
        'buildSignature': packageInfo.buildSignature,
      };
    }

    if (Platform.isIOS) {
      final info = await _deviceInfo.iosInfo;
      return {
        'model': info.model,
        'localizedModel': info.localizedModel,
        'machine': info.utsname.machine,
        'isPhysicalDevice': info.isPhysicalDevice.toString(),
        'appId': packageInfo.packageName,
        'buildSignature': packageInfo.buildSignature,
      };
    }

    throw UnsupportedError('Unsupported platform');
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/services/social_media.dart`:

```dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:url_launcher/url_launcher.dart';

class SocialMediaService {
  // Telegram URL schemes
  static const String _telegramScheme = 'tg://';
  static const String _telegramWebUrl = 'https://telegram.org';
  static const String _telegramAndroidStore =
      'market://details?id=org.telegram.messenger';
  static const String _telegramIosStore =
      'https://apps.apple.com/app/telegram-messenger/id686449807';

  // X.com (Twitter) URL schemes
  static final String _xScheme =
      Platform.isIOS ? 'twitter://' : 'com.twitter.android';
  static const String _xWebUrl = 'https://x.com';
  static const String _xAndroidStore =
      'market://details?id=com.twitter.android';
  static const String _xIosStore =
      'https://apps.apple.com/app/twitter/id333903271';

  /// Opens Telegram app or store/web if not installed
  Future<void> openTelegram({String? username, String? message}) async {
    String url = _telegramScheme;

    if (username != null) {
      url = 'tg://resolve?domain=$username';
    } else if (message != null) {
      url = 'tg://msg?text=${Uri.encodeComponent(message)}';
    }

    try {
      final Uri uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(
          uri,
          mode: LaunchMode.externalApplication,
        );
      } else {
        await _handleAppNotInstalled(
          webUrl: _telegramWebUrl,
          androidStore: _telegramAndroidStore,
          iosStore: _telegramIosStore,
        );
      }
    } catch (e) {
      debugPrint('Error launching Telegram: $e');
      // Fallback to web version
      await _launchUrl(_telegramWebUrl);
    }
  }

  /// Opens X.com (Twitter) app or store/web if not installed
  Future<void> openX({String? username, String? tweet}) async {
    String url = _xScheme;

    if (username != null) {
      url = Platform.isIOS
          ? 'twitter://user?screen_name=$username'
          : 'com.twitter.android://user?screen_name=$username';
    } else if (tweet != null) {
      url = Platform.isIOS
          ? 'twitter://post?message=${Uri.encodeComponent(tweet)}'
          : 'com.twitter.android://post?message=${Uri.encodeComponent(tweet)}';
    }

    try {
      final Uri uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(
          uri,
          mode: LaunchMode.externalApplication,
        );
      } else {
        await _handleAppNotInstalled(
          webUrl: _xWebUrl,
          androidStore: _xAndroidStore,
          iosStore: _xIosStore,
        );
      }
    } catch (e) {
      debugPrint('Error launching X: $e');
      // Fallback to web version
      await _launchUrl(_xWebUrl);
    }
  }

  Future<void> _handleAppNotInstalled({
    required String webUrl,
    required String androidStore,
    required String iosStore,
  }) async {
    // First try to open store
    final Uri storeUri = Uri.parse(
      Platform.isAndroid ? androidStore : iosStore,
    );

    try {
      if (await canLaunchUrl(storeUri)) {
        await launchUrl(storeUri);
      } else {
        // If store fails, open web version
        await _launchUrl(webUrl);
      }
    } catch (e) {
      debugPrint('Error opening store/web: $e');
      await _launchUrl(webUrl);
    }
  }

  Future<void> _launchUrl(String url) async {
    final Uri uri = Uri.parse(url);
    try {
      await launchUrl(
        uri,
        mode: LaunchMode.externalApplication,
      );
    } catch (e) {
      debugPrint('Error launching URL: $e');
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/services/auth_guard.dart`:

```dart
import 'package:zilpay/services/biometric_service.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:zilpay/state/app_state.dart';

class AuthGuard extends ChangeNotifier {
  final FlutterSecureStorage _storage;
  final AppState _state;

  bool _enabled = false;

  bool get ready => _state.wallets.isNotEmpty;
  bool get enabled => _enabled;

  AuthGuard({required AppState state})
      : _storage = const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: true,
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock,
            synchronizable: true,
          ),
        ),
        _state = state;

  void setEnabled(bool value) {
    _enabled = value;
  }

  Future<void> setSession(String sessionKey, String sessionValue) async {
    final AuthService authService = AuthService();

    try {
      final authMethods = await authService.getAvailableAuthMethods();

      if (authMethods.contains(AuthMethod.none)) {
        throw 'Device does not support secure storage. Please enable device lock.';
      }

      await _storage.write(
        key: sessionKey,
        value: sessionValue,
      );

      _enabled = true;

      notifyListeners();
    } catch (e) {
      throw 'Failed to save session key: $e';
    }
  }

  Future<String> getSession({
    required String sessionKey,
    bool requireAuth = true,
    String reason = 'Please authenticate to access your wallet',
  }) async {
    final value = await _storage.read(key: sessionKey);

    if (value == null) {
      throw 'Session key is empty';
    }

    _enabled = true;

    notifyListeners();

    return value;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/frb_generated.web.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

// Static analysis wrongly picks the IO variant, thus ignore this
// ignore_for_file: argument_type_not_assignable

import 'api/auth.dart';
import 'api/backend.dart';
import 'api/book.dart';
import 'api/cache.dart';
import 'api/connections.dart';
import 'api/ledger.dart';
import 'api/methods.dart';
import 'api/provider.dart';
import 'api/qrcode.dart';
import 'api/settings.dart';
import 'api/token.dart';
import 'api/transaction.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'models/account.dart';
import 'models/background.dart';
import 'models/book.dart';
import 'models/connection.dart';
import 'models/ftoken.dart';
import 'models/gas.dart';
import 'models/keypair.dart';
import 'models/notification.dart';
import 'models/provider.dart';
import 'models/qrcode.dart';
import 'models/settings.dart';
import 'models/transactions/access_list.dart';
import 'models/transactions/base_token.dart';
import 'models/transactions/evm.dart';
import 'models/transactions/history.dart';
import 'models/transactions/request.dart';
import 'models/transactions/scilla.dart';
import 'models/transactions/transaction_metadata.dart';
import 'models/wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_web.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw);

  @protected
  Map<BigInt, String> dco_decode_Map_usize_String(dynamic raw);

  @protected
  Map<BigInt, BackgroundNotificationState>
      dco_decode_Map_usize_background_notification_state(dynamic raw);

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw);

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  BigInt dco_decode_U128(dynamic raw);

  @protected
  AccessListItem dco_decode_access_list_item(dynamic raw);

  @protected
  AccountInfo dco_decode_account_info(dynamic raw);

  @protected
  AddNextBip39AccountParams dco_decode_add_next_bip_39_account_params(
      dynamic raw);

  @protected
  AddSKWalletParams dco_decode_add_sk_wallet_params(dynamic raw);

  @protected
  AddressBookEntryInfo dco_decode_address_book_entry_info(dynamic raw);

  @protected
  BackgroundNotificationState dco_decode_background_notification_state(
      dynamic raw);

  @protected
  BackgroundState dco_decode_background_state(dynamic raw);

  @protected
  BaseTokenInfo dco_decode_base_token_info(dynamic raw);

  @protected
  Bip39AddWalletParams dco_decode_bip_39_add_wallet_params(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  AddNextBip39AccountParams
      dco_decode_box_autoadd_add_next_bip_39_account_params(dynamic raw);

  @protected
  AddSKWalletParams dco_decode_box_autoadd_add_sk_wallet_params(dynamic raw);

  @protected
  BaseTokenInfo dco_decode_box_autoadd_base_token_info(dynamic raw);

  @protected
  Bip39AddWalletParams dco_decode_box_autoadd_bip_39_add_wallet_params(
      dynamic raw);

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw);

  @protected
  ColorsInfo dco_decode_box_autoadd_colors_info(dynamic raw);

  @protected
  ConnectionInfo dco_decode_box_autoadd_connection_info(dynamic raw);

  @protected
  FTokenInfo dco_decode_box_autoadd_f_token_info(dynamic raw);

  @protected
  LedgerParamsInput dco_decode_box_autoadd_ledger_params_input(dynamic raw);

  @protected
  NetworkConfigInfo dco_decode_box_autoadd_network_config_info(dynamic raw);

  @protected
  QrConfigInfo dco_decode_box_autoadd_qr_config_info(dynamic raw);

  @protected
  TokenTransferParamsInfo dco_decode_box_autoadd_token_transfer_params_info(
      dynamic raw);

  @protected
  TransactionRequestEVM dco_decode_box_autoadd_transaction_request_evm(
      dynamic raw);

  @protected
  TransactionRequestInfo dco_decode_box_autoadd_transaction_request_info(
      dynamic raw);

  @protected
  TransactionRequestScilla dco_decode_box_autoadd_transaction_request_scilla(
      dynamic raw);

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw);

  @protected
  WalletSettingsInfo dco_decode_box_autoadd_wallet_settings_info(dynamic raw);

  @protected
  ColorsInfo dco_decode_colors_info(dynamic raw);

  @protected
  ConnectionInfo dco_decode_connection_info(dynamic raw);

  @protected
  ExplorerInfo dco_decode_explorer_info(dynamic raw);

  @protected
  FTokenInfo dco_decode_f_token_info(dynamic raw);

  @protected
  GasFeeHistoryInfo dco_decode_gas_fee_history_info(dynamic raw);

  @protected
  GasInfo dco_decode_gas_info(dynamic raw);

  @protected
  HistoricalTransactionInfo dco_decode_historical_transaction_info(dynamic raw);

  @protected
  int dco_decode_i_32(dynamic raw);

  @protected
  KeyPairInfo dco_decode_key_pair_info(dynamic raw);

  @protected
  LedgerParamsInput dco_decode_ledger_params_input(dynamic raw);

  @protected
  List<String> dco_decode_list_String(dynamic raw);

  @protected
  List<AccessListItem> dco_decode_list_access_list_item(dynamic raw);

  @protected
  List<AccountInfo> dco_decode_list_account_info(dynamic raw);

  @protected
  List<AddressBookEntryInfo> dco_decode_list_address_book_entry_info(
      dynamic raw);

  @protected
  List<ConnectionInfo> dco_decode_list_connection_info(dynamic raw);

  @protected
  List<ExplorerInfo> dco_decode_list_explorer_info(dynamic raw);

  @protected
  List<FTokenInfo> dco_decode_list_f_token_info(dynamic raw);

  @protected
  List<HistoricalTransactionInfo> dco_decode_list_historical_transaction_info(
      dynamic raw);

  @protected
  List<NetworkConfigInfo> dco_decode_list_network_config_info(dynamic raw);

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw);

  @protected
  List<(BigInt, BackgroundNotificationState)>
      dco_decode_list_record_usize_background_notification_state(dynamic raw);

  @protected
  List<(BigInt, String)> dco_decode_list_record_usize_string(dynamic raw);

  @protected
  List<TransactionRequestInfo> dco_decode_list_transaction_request_info(
      dynamic raw);

  @protected
  List<WalletInfo> dco_decode_list_wallet_info(dynamic raw);

  @protected
  NetworkConfigInfo dco_decode_network_config_info(dynamic raw);

  @protected
  String? dco_decode_opt_String(dynamic raw);

  @protected
  BigInt? dco_decode_opt_U128(dynamic raw);

  @protected
  BaseTokenInfo? dco_decode_opt_box_autoadd_base_token_info(dynamic raw);

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw);

  @protected
  ColorsInfo? dco_decode_opt_box_autoadd_colors_info(dynamic raw);

  @protected
  TransactionRequestEVM? dco_decode_opt_box_autoadd_transaction_request_evm(
      dynamic raw);

  @protected
  TransactionRequestScilla?
      dco_decode_opt_box_autoadd_transaction_request_scilla(dynamic raw);

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw);

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw);

  @protected
  List<AccessListItem>? dco_decode_opt_list_access_list_item(dynamic raw);

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw);

  @protected
  QRcodeScanResultInfo dco_decode_q_rcode_scan_result_info(dynamic raw);

  @protected
  QrConfigInfo dco_decode_qr_config_info(dynamic raw);

  @protected
  (Uint8List, String) dco_decode_record_list_prim_u_8_strict_string(
      dynamic raw);

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw);

  @protected
  (BigInt, BackgroundNotificationState)
      dco_decode_record_usize_background_notification_state(dynamic raw);

  @protected
  (BigInt, String) dco_decode_record_usize_string(dynamic raw);

  @protected
  TokenTransferParamsInfo dco_decode_token_transfer_params_info(dynamic raw);

  @protected
  TransactionMetadataInfo dco_decode_transaction_metadata_info(dynamic raw);

  @protected
  TransactionRequestEVM dco_decode_transaction_request_evm(dynamic raw);

  @protected
  TransactionRequestInfo dco_decode_transaction_request_info(dynamic raw);

  @protected
  TransactionRequestScilla dco_decode_transaction_request_scilla(dynamic raw);

  @protected
  TransactionStatusInfo dco_decode_transaction_status_info(dynamic raw);

  @protected
  int dco_decode_u_16(dynamic raw);

  @protected
  int dco_decode_u_32(dynamic raw);

  @protected
  BigInt dco_decode_u_64(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  BigInt dco_decode_usize(dynamic raw);

  @protected
  WalletArgonParamsInfo dco_decode_wallet_argon_params_info(dynamic raw);

  @protected
  WalletInfo dco_decode_wallet_info(dynamic raw);

  @protected
  WalletSettingsInfo dco_decode_wallet_settings_info(dynamic raw);

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer);

  @protected
  Map<BigInt, String> sse_decode_Map_usize_String(SseDeserializer deserializer);

  @protected
  Map<BigInt, BackgroundNotificationState>
      sse_decode_Map_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer);

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_U128(SseDeserializer deserializer);

  @protected
  AccessListItem sse_decode_access_list_item(SseDeserializer deserializer);

  @protected
  AccountInfo sse_decode_account_info(SseDeserializer deserializer);

  @protected
  AddNextBip39AccountParams sse_decode_add_next_bip_39_account_params(
      SseDeserializer deserializer);

  @protected
  AddSKWalletParams sse_decode_add_sk_wallet_params(
      SseDeserializer deserializer);

  @protected
  AddressBookEntryInfo sse_decode_address_book_entry_info(
      SseDeserializer deserializer);

  @protected
  BackgroundNotificationState sse_decode_background_notification_state(
      SseDeserializer deserializer);

  @protected
  BackgroundState sse_decode_background_state(SseDeserializer deserializer);

  @protected
  BaseTokenInfo sse_decode_base_token_info(SseDeserializer deserializer);

  @protected
  Bip39AddWalletParams sse_decode_bip_39_add_wallet_params(
      SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  AddNextBip39AccountParams
      sse_decode_box_autoadd_add_next_bip_39_account_params(
          SseDeserializer deserializer);

  @protected
  AddSKWalletParams sse_decode_box_autoadd_add_sk_wallet_params(
      SseDeserializer deserializer);

  @protected
  BaseTokenInfo sse_decode_box_autoadd_base_token_info(
      SseDeserializer deserializer);

  @protected
  Bip39AddWalletParams sse_decode_box_autoadd_bip_39_add_wallet_params(
      SseDeserializer deserializer);

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer);

  @protected
  ColorsInfo sse_decode_box_autoadd_colors_info(SseDeserializer deserializer);

  @protected
  ConnectionInfo sse_decode_box_autoadd_connection_info(
      SseDeserializer deserializer);

  @protected
  FTokenInfo sse_decode_box_autoadd_f_token_info(SseDeserializer deserializer);

  @protected
  LedgerParamsInput sse_decode_box_autoadd_ledger_params_input(
      SseDeserializer deserializer);

  @protected
  NetworkConfigInfo sse_decode_box_autoadd_network_config_info(
      SseDeserializer deserializer);

  @protected
  QrConfigInfo sse_decode_box_autoadd_qr_config_info(
      SseDeserializer deserializer);

  @protected
  TokenTransferParamsInfo sse_decode_box_autoadd_token_transfer_params_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM sse_decode_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestInfo sse_decode_box_autoadd_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla sse_decode_box_autoadd_transaction_request_scilla(
      SseDeserializer deserializer);

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  WalletSettingsInfo sse_decode_box_autoadd_wallet_settings_info(
      SseDeserializer deserializer);

  @protected
  ColorsInfo sse_decode_colors_info(SseDeserializer deserializer);

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer);

  @protected
  ExplorerInfo sse_decode_explorer_info(SseDeserializer deserializer);

  @protected
  FTokenInfo sse_decode_f_token_info(SseDeserializer deserializer);

  @protected
  GasFeeHistoryInfo sse_decode_gas_fee_history_info(
      SseDeserializer deserializer);

  @protected
  GasInfo sse_decode_gas_info(SseDeserializer deserializer);

  @protected
  HistoricalTransactionInfo sse_decode_historical_transaction_info(
      SseDeserializer deserializer);

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  KeyPairInfo sse_decode_key_pair_info(SseDeserializer deserializer);

  @protected
  LedgerParamsInput sse_decode_ledger_params_input(
      SseDeserializer deserializer);

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer);

  @protected
  List<AccessListItem> sse_decode_list_access_list_item(
      SseDeserializer deserializer);

  @protected
  List<AccountInfo> sse_decode_list_account_info(SseDeserializer deserializer);

  @protected
  List<AddressBookEntryInfo> sse_decode_list_address_book_entry_info(
      SseDeserializer deserializer);

  @protected
  List<ConnectionInfo> sse_decode_list_connection_info(
      SseDeserializer deserializer);

  @protected
  List<ExplorerInfo> sse_decode_list_explorer_info(
      SseDeserializer deserializer);

  @protected
  List<FTokenInfo> sse_decode_list_f_token_info(SseDeserializer deserializer);

  @protected
  List<HistoricalTransactionInfo> sse_decode_list_historical_transaction_info(
      SseDeserializer deserializer);

  @protected
  List<NetworkConfigInfo> sse_decode_list_network_config_info(
      SseDeserializer deserializer);

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer);

  @protected
  List<(BigInt, BackgroundNotificationState)>
      sse_decode_list_record_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  List<(BigInt, String)> sse_decode_list_record_usize_string(
      SseDeserializer deserializer);

  @protected
  List<TransactionRequestInfo> sse_decode_list_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  List<WalletInfo> sse_decode_list_wallet_info(SseDeserializer deserializer);

  @protected
  NetworkConfigInfo sse_decode_network_config_info(
      SseDeserializer deserializer);

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer);

  @protected
  BigInt? sse_decode_opt_U128(SseDeserializer deserializer);

  @protected
  BaseTokenInfo? sse_decode_opt_box_autoadd_base_token_info(
      SseDeserializer deserializer);

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer);

  @protected
  ColorsInfo? sse_decode_opt_box_autoadd_colors_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM? sse_decode_opt_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla?
      sse_decode_opt_box_autoadd_transaction_request_scilla(
          SseDeserializer deserializer);

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer);

  @protected
  List<AccessListItem>? sse_decode_opt_list_access_list_item(
      SseDeserializer deserializer);

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  QRcodeScanResultInfo sse_decode_q_rcode_scan_result_info(
      SseDeserializer deserializer);

  @protected
  QrConfigInfo sse_decode_qr_config_info(SseDeserializer deserializer);

  @protected
  (Uint8List, String) sse_decode_record_list_prim_u_8_strict_string(
      SseDeserializer deserializer);

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer);

  @protected
  (BigInt, BackgroundNotificationState)
      sse_decode_record_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  (BigInt, String) sse_decode_record_usize_string(SseDeserializer deserializer);

  @protected
  TokenTransferParamsInfo sse_decode_token_transfer_params_info(
      SseDeserializer deserializer);

  @protected
  TransactionMetadataInfo sse_decode_transaction_metadata_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM sse_decode_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestInfo sse_decode_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla sse_decode_transaction_request_scilla(
      SseDeserializer deserializer);

  @protected
  TransactionStatusInfo sse_decode_transaction_status_info(
      SseDeserializer deserializer);

  @protected
  int sse_decode_u_16(SseDeserializer deserializer);

  @protected
  int sse_decode_u_32(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer);

  @protected
  WalletArgonParamsInfo sse_decode_wallet_argon_params_info(
      SseDeserializer deserializer);

  @protected
  WalletInfo sse_decode_wallet_info(SseDeserializer deserializer);

  @protected
  WalletSettingsInfo sse_decode_wallet_settings_info(
      SseDeserializer deserializer);

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer);

  @protected
  void sse_encode_Map_usize_String(
      Map<BigInt, String> self, SseSerializer serializer);

  @protected
  void sse_encode_Map_usize_background_notification_state(
      Map<BigInt, BackgroundNotificationState> self, SseSerializer serializer);

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer);

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_U128(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_access_list_item(
      AccessListItem self, SseSerializer serializer);

  @protected
  void sse_encode_account_info(AccountInfo self, SseSerializer serializer);

  @protected
  void sse_encode_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer);

  @protected
  void sse_encode_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_address_book_entry_info(
      AddressBookEntryInfo self, SseSerializer serializer);

  @protected
  void sse_encode_background_notification_state(
      BackgroundNotificationState self, SseSerializer serializer);

  @protected
  void sse_encode_background_state(
      BackgroundState self, SseSerializer serializer);

  @protected
  void sse_encode_base_token_info(BaseTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_base_token_info(
      BaseTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_colors_info(
      ColorsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_connection_info(
      ConnectionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_f_token_info(
      FTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_qr_config_info(
      QrConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_colors_info(ColorsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_connection_info(
      ConnectionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_explorer_info(ExplorerInfo self, SseSerializer serializer);

  @protected
  void sse_encode_f_token_info(FTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_gas_fee_history_info(
      GasFeeHistoryInfo self, SseSerializer serializer);

  @protected
  void sse_encode_gas_info(GasInfo self, SseSerializer serializer);

  @protected
  void sse_encode_historical_transaction_info(
      HistoricalTransactionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_key_pair_info(KeyPairInfo self, SseSerializer serializer);

  @protected
  void sse_encode_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer);

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer);

  @protected
  void sse_encode_list_access_list_item(
      List<AccessListItem> self, SseSerializer serializer);

  @protected
  void sse_encode_list_account_info(
      List<AccountInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_address_book_entry_info(
      List<AddressBookEntryInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_connection_info(
      List<ConnectionInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_explorer_info(
      List<ExplorerInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_f_token_info(
      List<FTokenInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_historical_transaction_info(
      List<HistoricalTransactionInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_network_config_info(
      List<NetworkConfigInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer);

  @protected
  void sse_encode_list_record_usize_background_notification_state(
      List<(BigInt, BackgroundNotificationState)> self,
      SseSerializer serializer);

  @protected
  void sse_encode_list_record_usize_string(
      List<(BigInt, String)> self, SseSerializer serializer);

  @protected
  void sse_encode_list_transaction_request_info(
      List<TransactionRequestInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_wallet_info(
      List<WalletInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_U128(BigInt? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_base_token_info(
      BaseTokenInfo? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_colors_info(
      ColorsInfo? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_evm(
      TransactionRequestEVM? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_access_list_item(
      List<AccessListItem>? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer);

  @protected
  void sse_encode_q_rcode_scan_result_info(
      QRcodeScanResultInfo self, SseSerializer serializer);

  @protected
  void sse_encode_qr_config_info(QrConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_record_list_prim_u_8_strict_string(
      (Uint8List, String) self, SseSerializer serializer);

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer);

  @protected
  void sse_encode_record_usize_background_notification_state(
      (BigInt, BackgroundNotificationState) self, SseSerializer serializer);

  @protected
  void sse_encode_record_usize_string(
      (BigInt, String) self, SseSerializer serializer);

  @protected
  void sse_encode_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_metadata_info(
      TransactionMetadataInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_status_info(
      TransactionStatusInfo self, SseSerializer serializer);

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_argon_params_info(
      WalletArgonParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_info(WalletInfo self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  RustLibWire.fromExternalLibrary(ExternalLibrary lib);
}

@JS('wasm_bindgen')
external RustLibWasmModule get wasmModule;

@JS()
@anonymous
extension type RustLibWasmModule._(JSObject _) implements JSObject {}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/provider.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class ExplorerInfo {
  final String name;
  final String url;
  final String? icon;
  final int standard;

  const ExplorerInfo({
    required this.name,
    required this.url,
    this.icon,
    required this.standard,
  });

  @override
  int get hashCode =>
      name.hashCode ^ url.hashCode ^ icon.hashCode ^ standard.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExplorerInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          url == other.url &&
          icon == other.icon &&
          standard == other.standard;
}

class NetworkConfigInfo {
  final String name;
  final String chain;
  final String shortName;
  final List<String> rpc;
  final Uint16List features;
  final BigInt chainId;
  final int slip44;
  final BigInt chainHash;
  final String? ens;
  final List<ExplorerInfo> explorers;
  final bool fallbackEnabled;
  final bool? testnet;

  const NetworkConfigInfo({
    required this.name,
    required this.chain,
    required this.shortName,
    required this.rpc,
    required this.features,
    required this.chainId,
    required this.slip44,
    required this.chainHash,
    this.ens,
    required this.explorers,
    required this.fallbackEnabled,
    this.testnet,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      chain.hashCode ^
      shortName.hashCode ^
      rpc.hashCode ^
      features.hashCode ^
      chainId.hashCode ^
      slip44.hashCode ^
      chainHash.hashCode ^
      ens.hashCode ^
      explorers.hashCode ^
      fallbackEnabled.hashCode ^
      testnet.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetworkConfigInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          chain == other.chain &&
          shortName == other.shortName &&
          rpc == other.rpc &&
          features == other.features &&
          chainId == other.chainId &&
          slip44 == other.slip44 &&
          chainHash == other.chainHash &&
          ens == other.ens &&
          explorers == other.explorers &&
          fallbackEnabled == other.fallbackEnabled &&
          testnet == other.testnet;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/qrcode.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class QRcodeScanResultInfo {
  final String recipient;
  final String? provider;
  final String? tokenAddress;
  final String? amount;

  const QRcodeScanResultInfo({
    required this.recipient,
    this.provider,
    this.tokenAddress,
    this.amount,
  });

  @override
  int get hashCode =>
      recipient.hashCode ^
      provider.hashCode ^
      tokenAddress.hashCode ^
      amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QRcodeScanResultInfo &&
          runtimeType == other.runtimeType &&
          recipient == other.recipient &&
          provider == other.provider &&
          tokenAddress == other.tokenAddress &&
          amount == other.amount;
}

class QrConfigInfo {
  final int size;
  final bool gapless;
  final int color;
  final int eyeShape;
  final int dataModuleShape;

  const QrConfigInfo({
    required this.size,
    required this.gapless,
    required this.color,
    required this.eyeShape,
    required this.dataModuleShape,
  });

  @override
  int get hashCode =>
      size.hashCode ^
      gapless.hashCode ^
      color.hashCode ^
      eyeShape.hashCode ^
      dataModuleShape.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QrConfigInfo &&
          runtimeType == other.runtimeType &&
          size == other.size &&
          gapless == other.gapless &&
          color == other.color &&
          eyeShape == other.eyeShape &&
          dataModuleShape == other.dataModuleShape;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/account.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class AccountInfo {
  final String addr;
  final String name;
  final BigInt chainHash;
  final BigInt index;

  const AccountInfo({
    required this.addr,
    required this.name,
    required this.chainHash,
    required this.index,
  });

  @override
  int get hashCode =>
      addr.hashCode ^ name.hashCode ^ chainHash.hashCode ^ index.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountInfo &&
          runtimeType == other.runtimeType &&
          addr == other.addr &&
          name == other.name &&
          chainHash == other.chainHash &&
          index == other.index;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/notification.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class BackgroundNotificationState {
  final bool transactions;
  final bool price;
  final bool security;
  final bool balance;

  const BackgroundNotificationState({
    required this.transactions,
    required this.price,
    required this.security,
    required this.balance,
  });

  @override
  int get hashCode =>
      transactions.hashCode ^
      price.hashCode ^
      security.hashCode ^
      balance.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundNotificationState &&
          runtimeType == other.runtimeType &&
          transactions == other.transactions &&
          price == other.price &&
          security == other.security &&
          balance == other.balance;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/ftoken.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class FTokenInfo {
  final String name;
  final String symbol;
  final int decimals;
  final String addr;
  final String? logo;
  final Map<BigInt, String> balances;
  final bool default_;
  final bool native;
  final BigInt chainHash;

  const FTokenInfo({
    required this.name,
    required this.symbol,
    required this.decimals,
    required this.addr,
    this.logo,
    required this.balances,
    required this.default_,
    required this.native,
    required this.chainHash,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      symbol.hashCode ^
      decimals.hashCode ^
      addr.hashCode ^
      logo.hashCode ^
      balances.hashCode ^
      default_.hashCode ^
      native.hashCode ^
      chainHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FTokenInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          symbol == other.symbol &&
          decimals == other.decimals &&
          addr == other.addr &&
          logo == other.logo &&
          balances == other.balances &&
          default_ == other.default_ &&
          native == other.native &&
          chainHash == other.chainHash;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/wallet.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'account.dart';
import 'ftoken.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'settings.dart';

class WalletInfo {
  final String walletType;
  final String walletName;
  final String authType;
  final String walletAddress;
  final List<AccountInfo> accounts;
  final BigInt selectedAccount;
  final List<FTokenInfo> tokens;
  final WalletSettingsInfo settings;
  final BigInt defaultChainHash;

  const WalletInfo({
    required this.walletType,
    required this.walletName,
    required this.authType,
    required this.walletAddress,
    required this.accounts,
    required this.selectedAccount,
    required this.tokens,
    required this.settings,
    required this.defaultChainHash,
  });

  @override
  int get hashCode =>
      walletType.hashCode ^
      walletName.hashCode ^
      authType.hashCode ^
      walletAddress.hashCode ^
      accounts.hashCode ^
      selectedAccount.hashCode ^
      tokens.hashCode ^
      settings.hashCode ^
      defaultChainHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletInfo &&
          runtimeType == other.runtimeType &&
          walletType == other.walletType &&
          walletName == other.walletName &&
          authType == other.authType &&
          walletAddress == other.walletAddress &&
          accounts == other.accounts &&
          selectedAccount == other.selectedAccount &&
          tokens == other.tokens &&
          settings == other.settings &&
          defaultChainHash == other.defaultChainHash;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/book.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class AddressBookEntryInfo {
  final String name;
  final String addr;
  final BigInt net;

  const AddressBookEntryInfo({
    required this.name,
    required this.addr,
    required this.net,
  });

  @override
  int get hashCode => name.hashCode ^ addr.hashCode ^ net.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressBookEntryInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          addr == other.addr &&
          net == other.net;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/evm.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'access_list.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class TransactionRequestEVM {
  final BigInt? nonce;
  final String? from;
  final String? to;
  final String? value;
  final BigInt? gasLimit;
  final Uint8List? data;
  final BigInt? maxFeePerGas;
  final BigInt? maxPriorityFeePerGas;
  final BigInt? gasPrice;
  final BigInt? chainId;
  final List<AccessListItem>? accessList;
  final List<String>? blobVersionedHashes;
  final BigInt? maxFeePerBlobGas;

  const TransactionRequestEVM({
    this.nonce,
    this.from,
    this.to,
    this.value,
    this.gasLimit,
    this.data,
    this.maxFeePerGas,
    this.maxPriorityFeePerGas,
    this.gasPrice,
    this.chainId,
    this.accessList,
    this.blobVersionedHashes,
    this.maxFeePerBlobGas,
  });

  @override
  int get hashCode =>
      nonce.hashCode ^
      from.hashCode ^
      to.hashCode ^
      value.hashCode ^
      gasLimit.hashCode ^
      data.hashCode ^
      maxFeePerGas.hashCode ^
      maxPriorityFeePerGas.hashCode ^
      gasPrice.hashCode ^
      chainId.hashCode ^
      accessList.hashCode ^
      blobVersionedHashes.hashCode ^
      maxFeePerBlobGas.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionRequestEVM &&
          runtimeType == other.runtimeType &&
          nonce == other.nonce &&
          from == other.from &&
          to == other.to &&
          value == other.value &&
          gasLimit == other.gasLimit &&
          data == other.data &&
          maxFeePerGas == other.maxFeePerGas &&
          maxPriorityFeePerGas == other.maxPriorityFeePerGas &&
          gasPrice == other.gasPrice &&
          chainId == other.chainId &&
          accessList == other.accessList &&
          blobVersionedHashes == other.blobVersionedHashes &&
          maxFeePerBlobGas == other.maxFeePerBlobGas;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/base_token.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class BaseTokenInfo {
  final String value;
  final String symbol;
  final int decimals;

  const BaseTokenInfo({
    required this.value,
    required this.symbol,
    required this.decimals,
  });

  @override
  int get hashCode => value.hashCode ^ symbol.hashCode ^ decimals.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BaseTokenInfo &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          symbol == other.symbol &&
          decimals == other.decimals;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/transaction_metadata.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'base_token.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class TransactionMetadataInfo {
  final BigInt chainHash;
  final String? hash;
  final String? info;
  final String? icon;
  final String? title;
  final String? signer;
  final BaseTokenInfo? tokenInfo;

  const TransactionMetadataInfo({
    required this.chainHash,
    this.hash,
    this.info,
    this.icon,
    this.title,
    this.signer,
    this.tokenInfo,
  });

  @override
  int get hashCode =>
      chainHash.hashCode ^
      hash.hashCode ^
      info.hashCode ^
      icon.hashCode ^
      title.hashCode ^
      signer.hashCode ^
      tokenInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionMetadataInfo &&
          runtimeType == other.runtimeType &&
          chainHash == other.chainHash &&
          hash == other.hash &&
          info == other.info &&
          icon == other.icon &&
          title == other.title &&
          signer == other.signer &&
          tokenInfo == other.tokenInfo;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/history.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'base_token.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class HistoricalTransactionInfo {
  final String id;
  final String amount;
  final String sender;
  final String recipient;
  final String? teg;
  final TransactionStatusInfo status;
  final BigInt? confirmed;
  final BigInt timestamp;
  final BigInt fee;
  final String? icon;
  final String? title;
  final BigInt nonce;
  final BaseTokenInfo? tokenInfo;

  const HistoricalTransactionInfo({
    required this.id,
    required this.amount,
    required this.sender,
    required this.recipient,
    this.teg,
    required this.status,
    this.confirmed,
    required this.timestamp,
    required this.fee,
    this.icon,
    this.title,
    required this.nonce,
    this.tokenInfo,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      amount.hashCode ^
      sender.hashCode ^
      recipient.hashCode ^
      teg.hashCode ^
      status.hashCode ^
      confirmed.hashCode ^
      timestamp.hashCode ^
      fee.hashCode ^
      icon.hashCode ^
      title.hashCode ^
      nonce.hashCode ^
      tokenInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HistoricalTransactionInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          amount == other.amount &&
          sender == other.sender &&
          recipient == other.recipient &&
          teg == other.teg &&
          status == other.status &&
          confirmed == other.confirmed &&
          timestamp == other.timestamp &&
          fee == other.fee &&
          icon == other.icon &&
          title == other.title &&
          nonce == other.nonce &&
          tokenInfo == other.tokenInfo;
}

enum TransactionStatusInfo {
  pending,
  confirmed,
  rejected,
  ;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/request.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'access_list.dart';
import 'base_token.dart';
import 'evm.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'scilla.dart';
import 'transaction_metadata.dart';

class TransactionRequestInfo {
  final TransactionMetadataInfo metadata;
  final TransactionRequestScilla? scilla;
  final TransactionRequestEVM? evm;

  const TransactionRequestInfo({
    required this.metadata,
    this.scilla,
    this.evm,
  });

  @override
  int get hashCode => metadata.hashCode ^ scilla.hashCode ^ evm.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionRequestInfo &&
          runtimeType == other.runtimeType &&
          metadata == other.metadata &&
          scilla == other.scilla &&
          evm == other.evm;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/access_list.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class AccessListItem {
  final String address;
  final List<String> storageKeys;

  const AccessListItem({
    required this.address,
    required this.storageKeys,
  });

  @override
  int get hashCode => address.hashCode ^ storageKeys.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccessListItem &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          storageKeys == other.storageKeys;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/transactions/scilla.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class TransactionRequestScilla {
  final int chainId;
  final BigInt nonce;
  final BigInt gasPrice;
  final BigInt gasLimit;
  final String toAddr;
  final BigInt amount;
  final String code;
  final String data;

  const TransactionRequestScilla({
    required this.chainId,
    required this.nonce,
    required this.gasPrice,
    required this.gasLimit,
    required this.toAddr,
    required this.amount,
    required this.code,
    required this.data,
  });

  @override
  int get hashCode =>
      chainId.hashCode ^
      nonce.hashCode ^
      gasPrice.hashCode ^
      gasLimit.hashCode ^
      toAddr.hashCode ^
      amount.hashCode ^
      code.hashCode ^
      data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionRequestScilla &&
          runtimeType == other.runtimeType &&
          chainId == other.chainId &&
          nonce == other.nonce &&
          gasPrice == other.gasPrice &&
          gasLimit == other.gasLimit &&
          toAddr == other.toAddr &&
          amount == other.amount &&
          code == other.code &&
          data == other.data;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/keypair.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class KeyPairInfo {
  final String sk;
  final String pk;

  const KeyPairInfo({
    required this.sk,
    required this.pk,
  });

  @override
  int get hashCode => sk.hashCode ^ pk.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPairInfo &&
          runtimeType == other.runtimeType &&
          sk == other.sk &&
          pk == other.pk;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/gas.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class GasFeeHistoryInfo {
  final BigInt maxFee;
  final BigInt priorityFee;
  final BigInt baseFee;

  const GasFeeHistoryInfo({
    required this.maxFee,
    required this.priorityFee,
    required this.baseFee,
  });

  @override
  int get hashCode => maxFee.hashCode ^ priorityFee.hashCode ^ baseFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GasFeeHistoryInfo &&
          runtimeType == other.runtimeType &&
          maxFee == other.maxFee &&
          priorityFee == other.priorityFee &&
          baseFee == other.baseFee;
}

class GasInfo {
  final BigInt gasPrice;
  final BigInt maxPriorityFee;
  final GasFeeHistoryInfo feeHistory;
  final BigInt txEstimateGas;
  final BigInt blobBaseFee;

  const GasInfo({
    required this.gasPrice,
    required this.maxPriorityFee,
    required this.feeHistory,
    required this.txEstimateGas,
    required this.blobBaseFee,
  });

  @override
  int get hashCode =>
      gasPrice.hashCode ^
      maxPriorityFee.hashCode ^
      feeHistory.hashCode ^
      txEstimateGas.hashCode ^
      blobBaseFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GasInfo &&
          runtimeType == other.runtimeType &&
          gasPrice == other.gasPrice &&
          maxPriorityFee == other.maxPriorityFee &&
          feeHistory == other.feeHistory &&
          txEstimateGas == other.txEstimateGas &&
          blobBaseFee == other.blobBaseFee;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/connection.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class ColorsInfo {
  final String primary;
  final String? secondary;
  final String? background;
  final String? text;

  const ColorsInfo({
    required this.primary,
    this.secondary,
    this.background,
    this.text,
  });

  @override
  int get hashCode =>
      primary.hashCode ^
      secondary.hashCode ^
      background.hashCode ^
      text.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ColorsInfo &&
          runtimeType == other.runtimeType &&
          primary == other.primary &&
          secondary == other.secondary &&
          background == other.background &&
          text == other.text;
}

class ConnectionInfo {
  final String domain;
  final Uint64List walletIndexes;
  final String? favicon;
  final String title;
  final String? description;
  final ColorsInfo? colors;
  final BigInt lastConnected;
  final bool canReadAccounts;
  final bool canRequestSignatures;
  final bool canSuggestTokens;
  final bool canSuggestTransactions;

  const ConnectionInfo({
    required this.domain,
    required this.walletIndexes,
    this.favicon,
    required this.title,
    this.description,
    this.colors,
    required this.lastConnected,
    required this.canReadAccounts,
    required this.canRequestSignatures,
    required this.canSuggestTokens,
    required this.canSuggestTransactions,
  });

  @override
  int get hashCode =>
      domain.hashCode ^
      walletIndexes.hashCode ^
      favicon.hashCode ^
      title.hashCode ^
      description.hashCode ^
      colors.hashCode ^
      lastConnected.hashCode ^
      canReadAccounts.hashCode ^
      canRequestSignatures.hashCode ^
      canSuggestTokens.hashCode ^
      canSuggestTransactions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectionInfo &&
          runtimeType == other.runtimeType &&
          domain == other.domain &&
          walletIndexes == other.walletIndexes &&
          favicon == other.favicon &&
          title == other.title &&
          description == other.description &&
          colors == other.colors &&
          lastConnected == other.lastConnected &&
          canReadAccounts == other.canReadAccounts &&
          canRequestSignatures == other.canRequestSignatures &&
          canSuggestTokens == other.canSuggestTokens &&
          canSuggestTransactions == other.canSuggestTransactions;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/background.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'account.dart';
import 'ftoken.dart';
import 'notification.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'provider.dart';
import 'settings.dart';
import 'wallet.dart';

class BackgroundState {
  final List<WalletInfo> wallets;
  final Map<BigInt, BackgroundNotificationState> notificationsWalletStates;
  final bool notificationsGlobalEnabled;
  final String locale;
  final int appearances;
  final List<NetworkConfigInfo> providers;

  const BackgroundState({
    required this.wallets,
    required this.notificationsWalletStates,
    required this.notificationsGlobalEnabled,
    required this.locale,
    required this.appearances,
    required this.providers,
  });

  @override
  int get hashCode =>
      wallets.hashCode ^
      notificationsWalletStates.hashCode ^
      notificationsGlobalEnabled.hashCode ^
      locale.hashCode ^
      appearances.hashCode ^
      providers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundState &&
          runtimeType == other.runtimeType &&
          wallets == other.wallets &&
          notificationsWalletStates == other.notificationsWalletStates &&
          notificationsGlobalEnabled == other.notificationsGlobalEnabled &&
          locale == other.locale &&
          appearances == other.appearances &&
          providers == other.providers;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/models/settings.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class WalletArgonParamsInfo {
  final int memory;
  final int iterations;
  final int threads;
  final String secret;

  const WalletArgonParamsInfo({
    required this.memory,
    required this.iterations,
    required this.threads,
    required this.secret,
  });

  @override
  int get hashCode =>
      memory.hashCode ^
      iterations.hashCode ^
      threads.hashCode ^
      secret.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletArgonParamsInfo &&
          runtimeType == other.runtimeType &&
          memory == other.memory &&
          iterations == other.iterations &&
          threads == other.threads &&
          secret == other.secret;
}

class WalletSettingsInfo {
  final Uint8List cipherOrders;
  final WalletArgonParamsInfo argonParams;
  final String? currencyConvert;
  final String? ipfsNode;
  final bool ensEnabled;
  final bool gasControlEnabled;
  final bool nodeRankingEnabled;
  final int maxConnections;
  final int requestTimeoutSecs;

  const WalletSettingsInfo({
    required this.cipherOrders,
    required this.argonParams,
    this.currencyConvert,
    this.ipfsNode,
    required this.ensEnabled,
    required this.gasControlEnabled,
    required this.nodeRankingEnabled,
    required this.maxConnections,
    required this.requestTimeoutSecs,
  });

  @override
  int get hashCode =>
      cipherOrders.hashCode ^
      argonParams.hashCode ^
      currencyConvert.hashCode ^
      ipfsNode.hashCode ^
      ensEnabled.hashCode ^
      gasControlEnabled.hashCode ^
      nodeRankingEnabled.hashCode ^
      maxConnections.hashCode ^
      requestTimeoutSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletSettingsInfo &&
          runtimeType == other.runtimeType &&
          cipherOrders == other.cipherOrders &&
          argonParams == other.argonParams &&
          currencyConvert == other.currencyConvert &&
          ipfsNode == other.ipfsNode &&
          ensEnabled == other.ensEnabled &&
          gasControlEnabled == other.gasControlEnabled &&
          nodeRankingEnabled == other.nodeRankingEnabled &&
          maxConnections == other.maxConnections &&
          requestTimeoutSecs == other.requestTimeoutSecs;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/auth.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<bool> tryUnlockWithSession(
        {required String sessionCipher,
        required BigInt walletIndex,
        required List<String> identifiers}) =>
    RustLib.instance.api.crateApiAuthTryUnlockWithSession(
        sessionCipher: sessionCipher,
        walletIndex: walletIndex,
        identifiers: identifiers);

Future<bool> tryUnlockWithPassword(
        {required String password,
        required BigInt walletIndex,
        required List<String> identifiers}) =>
    RustLib.instance.api.crateApiAuthTryUnlockWithPassword(
        password: password, walletIndex: walletIndex, identifiers: identifiers);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/provider.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/provider.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<List<NetworkConfigInfo>> getProviders() =>
    RustLib.instance.api.crateApiProviderGetProviders();

Future<NetworkConfigInfo> getProvider({required BigInt chainHash}) =>
    RustLib.instance.api.crateApiProviderGetProvider(chainHash: chainHash);

Future<BigInt> addProvider({required NetworkConfigInfo providerConfig}) =>
    RustLib.instance.api
        .crateApiProviderAddProvider(providerConfig: providerConfig);

Future<void> addProvidersList(
        {required List<NetworkConfigInfo> providerConfig}) =>
    RustLib.instance.api
        .crateApiProviderAddProvidersList(providerConfig: providerConfig);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/backend.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/account.dart';
import '../models/background.dart';
import '../models/ftoken.dart';
import '../models/notification.dart';
import '../models/provider.dart';
import '../models/settings.dart';
import '../models/wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<BackgroundState> startService({required String path}) =>
    RustLib.instance.api.crateApiBackendStartService(path: path);

Future<void> stopService() => RustLib.instance.api.crateApiBackendStopService();

Future<bool> isServiceRunning() =>
    RustLib.instance.api.crateApiBackendIsServiceRunning();

Stream<String> startWorker() =>
    RustLib.instance.api.crateApiBackendStartWorker();

Future<BackgroundState> getData() =>
    RustLib.instance.api.crateApiBackendGetData();

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/ledger.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/ftoken.dart';
import '../models/settings.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<(String, String)> addLedgerWallet(
        {required LedgerParamsInput params,
        required WalletSettingsInfo walletSettings,
        required List<FTokenInfo> ftokens}) =>
    RustLib.instance.api.crateApiLedgerAddLedgerWallet(
        params: params, walletSettings: walletSettings, ftokens: ftokens);

Future<void> addLedgerAccount(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        required String name,
        required String pubKey,
        required List<String> identifiers,
        String? sessionCipher}) =>
    RustLib.instance.api.crateApiLedgerAddLedgerAccount(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        name: name,
        pubKey: pubKey,
        identifiers: identifiers,
        sessionCipher: sessionCipher);

class LedgerParamsInput {
  final String pubKey;
  final BigInt walletIndex;
  final String walletName;
  final String ledgerId;
  final String accountName;
  final String biometricType;
  final List<String> identifiers;
  final BigInt chainHash;

  const LedgerParamsInput({
    required this.pubKey,
    required this.walletIndex,
    required this.walletName,
    required this.ledgerId,
    required this.accountName,
    required this.biometricType,
    required this.identifiers,
    required this.chainHash,
  });

  @override
  int get hashCode =>
      pubKey.hashCode ^
      walletIndex.hashCode ^
      walletName.hashCode ^
      ledgerId.hashCode ^
      accountName.hashCode ^
      biometricType.hashCode ^
      identifiers.hashCode ^
      chainHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LedgerParamsInput &&
          runtimeType == other.runtimeType &&
          pubKey == other.pubKey &&
          walletIndex == other.walletIndex &&
          walletName == other.walletName &&
          ledgerId == other.ledgerId &&
          accountName == other.accountName &&
          biometricType == other.biometricType &&
          identifiers == other.identifiers &&
          chainHash == other.chainHash;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/qrcode.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/qrcode.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<String> genSvgQrcode(
        {required String data, required QrConfigInfo config}) =>
    RustLib.instance.api.crateApiQrcodeGenSvgQrcode(data: data, config: config);

Future<Uint8List> genPngQrcode(
        {required String data, required QrConfigInfo config}) =>
    RustLib.instance.api.crateApiQrcodeGenPngQrcode(data: data, config: config);

Future<QRcodeScanResultInfo> parseQrcodeStr({required String data}) =>
    RustLib.instance.api.crateApiQrcodeParseQrcodeStr(data: data);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/methods.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/keypair.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<String> genBip39Words({required int count}) =>
    RustLib.instance.api.crateApiMethodsGenBip39Words(count: count);

Future<Uint64List> checkNotExistsBip39Words(
        {required List<String> words, required String lang}) =>
    RustLib.instance.api
        .crateApiMethodsCheckNotExistsBip39Words(words: words, lang: lang);

Future<KeyPairInfo> genKeypair() =>
    RustLib.instance.api.crateApiMethodsGenKeypair();

Future<KeyPairInfo> keypairFromSk({required String sk}) =>
    RustLib.instance.api.crateApiMethodsKeypairFromSk(sk: sk);

Future<bool> isCryptoAddress({required String addr}) =>
    RustLib.instance.api.crateApiMethodsIsCryptoAddress(addr: addr);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/cache.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<String> getImageName({required String dir, required String url}) =>
    RustLib.instance.api.crateApiCacheGetImageName(dir: dir, url: url);

Future<(Uint8List, String)> getImageBytes(
        {required String dir, required String url}) =>
    RustLib.instance.api.crateApiCacheGetImageBytes(dir: dir, url: url);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/wallet.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/account.dart';
import '../models/ftoken.dart';
import '../models/keypair.dart';
import '../models/settings.dart';
import '../models/wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<List<WalletInfo>> getWallets() =>
    RustLib.instance.api.crateApiWalletGetWallets();

Future<(String, String)> addBip39Wallet(
        {required Bip39AddWalletParams params,
        required WalletSettingsInfo walletSettings,
        required List<FTokenInfo> ftokens}) =>
    RustLib.instance.api.crateApiWalletAddBip39Wallet(
        params: params, walletSettings: walletSettings, ftokens: ftokens);

Future<(String, String)> addSkWallet(
        {required AddSKWalletParams params,
        required WalletSettingsInfo walletSettings,
        required List<FTokenInfo> ftokens}) =>
    RustLib.instance.api.crateApiWalletAddSkWallet(
        params: params, walletSettings: walletSettings, ftokens: ftokens);

Future<void> addNextBip39Account({required AddNextBip39AccountParams params}) =>
    RustLib.instance.api.crateApiWalletAddNextBip39Account(params: params);

Future<void> selectAccount(
        {required BigInt walletIndex, required BigInt accountIndex}) =>
    RustLib.instance.api.crateApiWalletSelectAccount(
        walletIndex: walletIndex, accountIndex: accountIndex);

Future<void> changeAccountName(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        required String newName}) =>
    RustLib.instance.api.crateApiWalletChangeAccountName(
        walletIndex: walletIndex, accountIndex: accountIndex, newName: newName);

Future<void> changeWalletName(
        {required BigInt walletIndex, required String newName}) =>
    RustLib.instance.api.crateApiWalletChangeWalletName(
        walletIndex: walletIndex, newName: newName);

Future<void> deleteWallet(
        {required BigInt walletIndex,
        required List<String> identifiers,
        String? password,
        String? sessionCipher}) =>
    RustLib.instance.api.crateApiWalletDeleteWallet(
        walletIndex: walletIndex,
        identifiers: identifiers,
        password: password,
        sessionCipher: sessionCipher);

Future<void> deleteAccount(
        {required BigInt walletIndex, required BigInt accountIndex}) =>
    RustLib.instance.api.crateApiWalletDeleteAccount(
        walletIndex: walletIndex, accountIndex: accountIndex);

Future<KeyPairInfo> revealKeypair(
        {required BigInt walletIndex,
        required BigInt accountIndex,
        required List<String> identifiers,
        required String password,
        String? passphrase}) =>
    RustLib.instance.api.crateApiWalletRevealKeypair(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        identifiers: identifiers,
        password: password,
        passphrase: passphrase);

Future<String> revealBip39Phrase(
        {required BigInt walletIndex,
        required List<String> identifiers,
        required String password,
        String? passphrase}) =>
    RustLib.instance.api.crateApiWalletRevealBip39Phrase(
        walletIndex: walletIndex,
        identifiers: identifiers,
        password: password,
        passphrase: passphrase);

class AddNextBip39AccountParams {
  final BigInt walletIndex;
  final BigInt accountIndex;
  final String name;
  final String passphrase;
  final List<String> identifiers;
  final String? password;
  final String? sessionCipher;
  final BigInt chainHash;

  const AddNextBip39AccountParams({
    required this.walletIndex,
    required this.accountIndex,
    required this.name,
    required this.passphrase,
    required this.identifiers,
    this.password,
    this.sessionCipher,
    required this.chainHash,
  });

  @override
  int get hashCode =>
      walletIndex.hashCode ^
      accountIndex.hashCode ^
      name.hashCode ^
      passphrase.hashCode ^
      identifiers.hashCode ^
      password.hashCode ^
      sessionCipher.hashCode ^
      chainHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddNextBip39AccountParams &&
          runtimeType == other.runtimeType &&
          walletIndex == other.walletIndex &&
          accountIndex == other.accountIndex &&
          name == other.name &&
          passphrase == other.passphrase &&
          identifiers == other.identifiers &&
          password == other.password &&
          sessionCipher == other.sessionCipher &&
          chainHash == other.chainHash;
}

class AddSKWalletParams {
  final String sk;
  final String password;
  final String walletName;
  final String biometricType;
  final List<String> identifiers;
  final BigInt chainHash;

  const AddSKWalletParams({
    required this.sk,
    required this.password,
    required this.walletName,
    required this.biometricType,
    required this.identifiers,
    required this.chainHash,
  });

  @override
  int get hashCode =>
      sk.hashCode ^
      password.hashCode ^
      walletName.hashCode ^
      biometricType.hashCode ^
      identifiers.hashCode ^
      chainHash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddSKWalletParams &&
          runtimeType == other.runtimeType &&
          sk == other.sk &&
          password == other.password &&
          walletName == other.walletName &&
          biometricType == other.biometricType &&
          identifiers == other.identifiers &&
          chainHash == other.chainHash;
}

class Bip39AddWalletParams {
  final String password;
  final String mnemonicStr;
  final List<(BigInt, String)> accounts;
  final String passphrase;
  final String walletName;
  final String biometricType;
  final BigInt chainHash;
  final List<String> identifiers;

  const Bip39AddWalletParams({
    required this.password,
    required this.mnemonicStr,
    required this.accounts,
    required this.passphrase,
    required this.walletName,
    required this.biometricType,
    required this.chainHash,
    required this.identifiers,
  });

  @override
  int get hashCode =>
      password.hashCode ^
      mnemonicStr.hashCode ^
      accounts.hashCode ^
      passphrase.hashCode ^
      walletName.hashCode ^
      biometricType.hashCode ^
      chainHash.hashCode ^
      identifiers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bip39AddWalletParams &&
          runtimeType == other.runtimeType &&
          password == other.password &&
          mnemonicStr == other.mnemonicStr &&
          accounts == other.accounts &&
          passphrase == other.passphrase &&
          walletName == other.walletName &&
          biometricType == other.biometricType &&
          chainHash == other.chainHash &&
          identifiers == other.identifiers;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/book.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/book.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<void> addNewBookAddress(
        {required String name, required String addr, required BigInt net}) =>
    RustLib.instance.api
        .crateApiBookAddNewBookAddress(name: name, addr: addr, net: net);

Future<List<AddressBookEntryInfo>> getAddressBookList() =>
    RustLib.instance.api.crateApiBookGetAddressBookList();

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/transaction.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/gas.dart';
import '../models/transactions/access_list.dart';
import '../models/transactions/base_token.dart';
import '../models/transactions/evm.dart';
import '../models/transactions/history.dart';
import '../models/transactions/request.dart';
import '../models/transactions/scilla.dart';
import '../models/transactions/transaction_metadata.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<List<TransactionRequestInfo>> getRequestedTransactions(
        {required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTransactionGetRequestedTransactions(walletIndex: walletIndex);

Future<void> clearRequestedTransactions({required BigInt walletIndex}) =>
    RustLib.instance.api.crateApiTransactionClearRequestedTransactions(
        walletIndex: walletIndex);

Future<void> addRequestedTransactions(
        {required BigInt walletIndex, required TransactionRequestInfo tx}) =>
    RustLib.instance.api.crateApiTransactionAddRequestedTransactions(
        walletIndex: walletIndex, tx: tx);

Future<List<HistoricalTransactionInfo>> getHistory(
        {required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTransactionGetHistory(walletIndex: walletIndex);

Future<TransactionRequestInfo> createTokenTransfer(
        {required TokenTransferParamsInfo params}) =>
    RustLib.instance.api.crateApiTransactionCreateTokenTransfer(params: params);

Future<GasInfo> caclGasFee({required TransactionRequestInfo params}) =>
    RustLib.instance.api.crateApiTransactionCaclGasFee(params: params);

class TokenTransferParamsInfo {
  final BigInt walletIndex;
  final BigInt accountIndex;
  final BigInt tokenIndex;
  final String amount;
  final String recipient;

  const TokenTransferParamsInfo({
    required this.walletIndex,
    required this.accountIndex,
    required this.tokenIndex,
    required this.amount,
    required this.recipient,
  });

  @override
  int get hashCode =>
      walletIndex.hashCode ^
      accountIndex.hashCode ^
      tokenIndex.hashCode ^
      amount.hashCode ^
      recipient.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenTransferParamsInfo &&
          runtimeType == other.runtimeType &&
          walletIndex == other.walletIndex &&
          accountIndex == other.accountIndex &&
          tokenIndex == other.tokenIndex &&
          amount == other.amount &&
          recipient == other.recipient;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/connections.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/connection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<void> createNewConnection({required ConnectionInfo conn}) =>
    RustLib.instance.api.crateApiConnectionsCreateNewConnection(conn: conn);

Future<void> addWalletToConnection(
        {required String domain, required BigInt walletIndex}) =>
    RustLib.instance.api.crateApiConnectionsAddWalletToConnection(
        domain: domain, walletIndex: walletIndex);

Future<List<ConnectionInfo>> getConnectionsList() =>
    RustLib.instance.api.crateApiConnectionsGetConnectionsList();

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/token.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../models/ftoken.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<void> syncBalances({required BigInt walletIndex}) =>
    RustLib.instance.api.crateApiTokenSyncBalances(walletIndex: walletIndex);

Future<void> updateRates() => RustLib.instance.api.crateApiTokenUpdateRates();

Future<String> getRates() => RustLib.instance.api.crateApiTokenGetRates();

Future<FTokenInfo> fetchTokenMeta(
        {required String addr, required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTokenFetchTokenMeta(addr: addr, walletIndex: walletIndex);

Future<List<FTokenInfo>> addFtoken(
        {required FTokenInfo meta, required BigInt walletIndex}) =>
    RustLib.instance.api
        .crateApiTokenAddFtoken(meta: meta, walletIndex: walletIndex);

Future<void> rmFtoken(
        {required BigInt walletIndex, required BigInt tokenIndex}) =>
    RustLib.instance.api.crateApiTokenRmFtoken(
        walletIndex: walletIndex, tokenIndex: tokenIndex);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/api/settings.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<void> setTheme({required int appearancesCode}) => RustLib.instance.api
    .crateApiSettingsSetTheme(appearancesCode: appearancesCode);

Future<void> setWalletNotifications(
        {required BigInt walletIndex,
        required bool transactions,
        required bool price,
        required bool security,
        required bool balance}) =>
    RustLib.instance.api.crateApiSettingsSetWalletNotifications(
        walletIndex: walletIndex,
        transactions: transactions,
        price: price,
        security: security,
        balance: balance);

Future<void> setGlobalNotifications({required bool globalEnabled}) =>
    RustLib.instance.api
        .crateApiSettingsSetGlobalNotifications(globalEnabled: globalEnabled);

Future<void> setRateFetcher({required BigInt walletIndex, String? currency}) =>
    RustLib.instance.api.crateApiSettingsSetRateFetcher(
        walletIndex: walletIndex, currency: currency);

Future<void> setWalletEns(
        {required BigInt walletIndex, required bool ensEnabled}) =>
    RustLib.instance.api.crateApiSettingsSetWalletEns(
        walletIndex: walletIndex, ensEnabled: ensEnabled);

Future<void> setWalletIpfsNode({required BigInt walletIndex, String? node}) =>
    RustLib.instance.api.crateApiSettingsSetWalletIpfsNode(
        walletIndex: walletIndex, node: node);

Future<void> setWalletGasControl(
        {required BigInt walletIndex, required bool enabled}) =>
    RustLib.instance.api.crateApiSettingsSetWalletGasControl(
        walletIndex: walletIndex, enabled: enabled);

Future<void> setWalletNodeRanking(
        {required BigInt walletIndex, required bool enabled}) =>
    RustLib.instance.api.crateApiSettingsSetWalletNodeRanking(
        walletIndex: walletIndex, enabled: enabled);

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/frb_generated.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/auth.dart';
import 'api/backend.dart';
import 'api/book.dart';
import 'api/cache.dart';
import 'api/connections.dart';
import 'api/ledger.dart';
import 'api/methods.dart';
import 'api/provider.dart';
import 'api/qrcode.dart';
import 'api/settings.dart';
import 'api/token.dart';
import 'api/transaction.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'models/account.dart';
import 'models/background.dart';
import 'models/book.dart';
import 'models/connection.dart';
import 'models/ftoken.dart';
import 'models/gas.dart';
import 'models/keypair.dart';
import 'models/notification.dart';
import 'models/provider.dart';
import 'models/qrcode.dart';
import 'models/settings.dart';
import 'models/transactions/access_list.dart';
import 'models/transactions/base_token.dart';
import 'models/transactions/evm.dart';
import 'models/transactions/history.dart';
import 'models/transactions/request.dart';
import 'models/transactions/scilla.dart';
import 'models/transactions/transaction_metadata.dart';
import 'models/wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiMethodsInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.6.0';

  @override
  int get rustContentHash => 1429302511;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_zilpay',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<(String, String)> crateApiWalletAddBip39Wallet(
      {required Bip39AddWalletParams params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens});

  Future<List<FTokenInfo>> crateApiTokenAddFtoken(
      {required FTokenInfo meta, required BigInt walletIndex});

  Future<void> crateApiLedgerAddLedgerAccount(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required String name,
      required String pubKey,
      required List<String> identifiers,
      String? sessionCipher});

  Future<(String, String)> crateApiLedgerAddLedgerWallet(
      {required LedgerParamsInput params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens});

  Future<void> crateApiBookAddNewBookAddress(
      {required String name, required String addr, required BigInt net});

  Future<void> crateApiWalletAddNextBip39Account(
      {required AddNextBip39AccountParams params});

  Future<BigInt> crateApiProviderAddProvider(
      {required NetworkConfigInfo providerConfig});

  Future<void> crateApiProviderAddProvidersList(
      {required List<NetworkConfigInfo> providerConfig});

  Future<void> crateApiTransactionAddRequestedTransactions(
      {required BigInt walletIndex, required TransactionRequestInfo tx});

  Future<(String, String)> crateApiWalletAddSkWallet(
      {required AddSKWalletParams params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens});

  Future<void> crateApiConnectionsAddWalletToConnection(
      {required String domain, required BigInt walletIndex});

  Future<GasInfo> crateApiTransactionCaclGasFee(
      {required TransactionRequestInfo params});

  Future<void> crateApiWalletChangeAccountName(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required String newName});

  Future<void> crateApiWalletChangeWalletName(
      {required BigInt walletIndex, required String newName});

  Future<Uint64List> crateApiMethodsCheckNotExistsBip39Words(
      {required List<String> words, required String lang});

  Future<void> crateApiTransactionClearRequestedTransactions(
      {required BigInt walletIndex});

  Future<void> crateApiConnectionsCreateNewConnection(
      {required ConnectionInfo conn});

  Future<TransactionRequestInfo> crateApiTransactionCreateTokenTransfer(
      {required TokenTransferParamsInfo params});

  Future<void> crateApiWalletDeleteAccount(
      {required BigInt walletIndex, required BigInt accountIndex});

  Future<void> crateApiWalletDeleteWallet(
      {required BigInt walletIndex,
      required List<String> identifiers,
      String? password,
      String? sessionCipher});

  Future<FTokenInfo> crateApiTokenFetchTokenMeta(
      {required String addr, required BigInt walletIndex});

  Future<String> crateApiMethodsGenBip39Words({required int count});

  Future<KeyPairInfo> crateApiMethodsGenKeypair();

  Future<Uint8List> crateApiQrcodeGenPngQrcode(
      {required String data, required QrConfigInfo config});

  Future<String> crateApiQrcodeGenSvgQrcode(
      {required String data, required QrConfigInfo config});

  Future<List<AddressBookEntryInfo>> crateApiBookGetAddressBookList();

  Future<List<ConnectionInfo>> crateApiConnectionsGetConnectionsList();

  Future<BackgroundState> crateApiBackendGetData();

  Future<List<HistoricalTransactionInfo>> crateApiTransactionGetHistory(
      {required BigInt walletIndex});

  Future<(Uint8List, String)> crateApiCacheGetImageBytes(
      {required String dir, required String url});

  Future<String> crateApiCacheGetImageName(
      {required String dir, required String url});

  Future<NetworkConfigInfo> crateApiProviderGetProvider(
      {required BigInt chainHash});

  Future<List<NetworkConfigInfo>> crateApiProviderGetProviders();

  Future<String> crateApiTokenGetRates();

  Future<List<TransactionRequestInfo>>
      crateApiTransactionGetRequestedTransactions(
          {required BigInt walletIndex});

  Future<List<WalletInfo>> crateApiWalletGetWallets();

  Future<void> crateApiMethodsInitApp();

  Future<bool> crateApiMethodsIsCryptoAddress({required String addr});

  Future<bool> crateApiBackendIsServiceRunning();

  Future<KeyPairInfo> crateApiMethodsKeypairFromSk({required String sk});

  Future<QRcodeScanResultInfo> crateApiQrcodeParseQrcodeStr(
      {required String data});

  Future<String> crateApiWalletRevealBip39Phrase(
      {required BigInt walletIndex,
      required List<String> identifiers,
      required String password,
      String? passphrase});

  Future<KeyPairInfo> crateApiWalletRevealKeypair(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required List<String> identifiers,
      required String password,
      String? passphrase});

  Future<void> crateApiTokenRmFtoken(
      {required BigInt walletIndex, required BigInt tokenIndex});

  Future<void> crateApiWalletSelectAccount(
      {required BigInt walletIndex, required BigInt accountIndex});

  Future<void> crateApiSettingsSetGlobalNotifications(
      {required bool globalEnabled});

  Future<void> crateApiSettingsSetRateFetcher(
      {required BigInt walletIndex, String? currency});

  Future<void> crateApiSettingsSetTheme({required int appearancesCode});

  Future<void> crateApiSettingsSetWalletEns(
      {required BigInt walletIndex, required bool ensEnabled});

  Future<void> crateApiSettingsSetWalletGasControl(
      {required BigInt walletIndex, required bool enabled});

  Future<void> crateApiSettingsSetWalletIpfsNode(
      {required BigInt walletIndex, String? node});

  Future<void> crateApiSettingsSetWalletNodeRanking(
      {required BigInt walletIndex, required bool enabled});

  Future<void> crateApiSettingsSetWalletNotifications(
      {required BigInt walletIndex,
      required bool transactions,
      required bool price,
      required bool security,
      required bool balance});

  Future<BackgroundState> crateApiBackendStartService({required String path});

  Stream<String> crateApiBackendStartWorker();

  Future<void> crateApiBackendStopService();

  Future<void> crateApiTokenSyncBalances({required BigInt walletIndex});

  Future<bool> crateApiAuthTryUnlockWithPassword(
      {required String password,
      required BigInt walletIndex,
      required List<String> identifiers});

  Future<bool> crateApiAuthTryUnlockWithSession(
      {required String sessionCipher,
      required BigInt walletIndex,
      required List<String> identifiers});

  Future<void> crateApiTokenUpdateRates();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<(String, String)> crateApiWalletAddBip39Wallet(
      {required Bip39AddWalletParams params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_bip_39_add_wallet_params(params, serializer);
        sse_encode_box_autoadd_wallet_settings_info(walletSettings, serializer);
        sse_encode_list_f_token_info(ftokens, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_string,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletAddBip39WalletConstMeta,
      argValues: [params, walletSettings, ftokens],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletAddBip39WalletConstMeta =>
      const TaskConstMeta(
        debugName: "add_bip39_wallet",
        argNames: ["params", "walletSettings", "ftokens"],
      );

  @override
  Future<List<FTokenInfo>> crateApiTokenAddFtoken(
      {required FTokenInfo meta, required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_f_token_info(meta, serializer);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_f_token_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenAddFtokenConstMeta,
      argValues: [meta, walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenAddFtokenConstMeta => const TaskConstMeta(
        debugName: "add_ftoken",
        argNames: ["meta", "walletIndex"],
      );

  @override
  Future<void> crateApiLedgerAddLedgerAccount(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required String name,
      required String pubKey,
      required List<String> identifiers,
      String? sessionCipher}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(accountIndex, serializer);
        sse_encode_String(name, serializer);
        sse_encode_String(pubKey, serializer);
        sse_encode_list_String(identifiers, serializer);
        sse_encode_opt_String(sessionCipher, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLedgerAddLedgerAccountConstMeta,
      argValues: [
        walletIndex,
        accountIndex,
        name,
        pubKey,
        identifiers,
        sessionCipher
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLedgerAddLedgerAccountConstMeta =>
      const TaskConstMeta(
        debugName: "add_ledger_account",
        argNames: [
          "walletIndex",
          "accountIndex",
          "name",
          "pubKey",
          "identifiers",
          "sessionCipher"
        ],
      );

  @override
  Future<(String, String)> crateApiLedgerAddLedgerWallet(
      {required LedgerParamsInput params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ledger_params_input(params, serializer);
        sse_encode_box_autoadd_wallet_settings_info(walletSettings, serializer);
        sse_encode_list_f_token_info(ftokens, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_string,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiLedgerAddLedgerWalletConstMeta,
      argValues: [params, walletSettings, ftokens],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLedgerAddLedgerWalletConstMeta =>
      const TaskConstMeta(
        debugName: "add_ledger_wallet",
        argNames: ["params", "walletSettings", "ftokens"],
      );

  @override
  Future<void> crateApiBookAddNewBookAddress(
      {required String name, required String addr, required BigInt net}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_String(addr, serializer);
        sse_encode_usize(net, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBookAddNewBookAddressConstMeta,
      argValues: [name, addr, net],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBookAddNewBookAddressConstMeta =>
      const TaskConstMeta(
        debugName: "add_new_book_address",
        argNames: ["name", "addr", "net"],
      );

  @override
  Future<void> crateApiWalletAddNextBip39Account(
      {required AddNextBip39AccountParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_add_next_bip_39_account_params(
            params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletAddNextBip39AccountConstMeta,
      argValues: [params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletAddNextBip39AccountConstMeta =>
      const TaskConstMeta(
        debugName: "add_next_bip39_account",
        argNames: ["params"],
      );

  @override
  Future<BigInt> crateApiProviderAddProvider(
      {required NetworkConfigInfo providerConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_network_config_info(providerConfig, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiProviderAddProviderConstMeta,
      argValues: [providerConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiProviderAddProviderConstMeta =>
      const TaskConstMeta(
        debugName: "add_provider",
        argNames: ["providerConfig"],
      );

  @override
  Future<void> crateApiProviderAddProvidersList(
      {required List<NetworkConfigInfo> providerConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_network_config_info(providerConfig, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiProviderAddProvidersListConstMeta,
      argValues: [providerConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiProviderAddProvidersListConstMeta =>
      const TaskConstMeta(
        debugName: "add_providers_list",
        argNames: ["providerConfig"],
      );

  @override
  Future<void> crateApiTransactionAddRequestedTransactions(
      {required BigInt walletIndex, required TransactionRequestInfo tx}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_box_autoadd_transaction_request_info(tx, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionAddRequestedTransactionsConstMeta,
      argValues: [walletIndex, tx],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionAddRequestedTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "add_requested_transactions",
        argNames: ["walletIndex", "tx"],
      );

  @override
  Future<(String, String)> crateApiWalletAddSkWallet(
      {required AddSKWalletParams params,
      required WalletSettingsInfo walletSettings,
      required List<FTokenInfo> ftokens}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_add_sk_wallet_params(params, serializer);
        sse_encode_box_autoadd_wallet_settings_info(walletSettings, serializer);
        sse_encode_list_f_token_info(ftokens, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_string_string,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletAddSkWalletConstMeta,
      argValues: [params, walletSettings, ftokens],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletAddSkWalletConstMeta => const TaskConstMeta(
        debugName: "add_sk_wallet",
        argNames: ["params", "walletSettings", "ftokens"],
      );

  @override
  Future<void> crateApiConnectionsAddWalletToConnection(
      {required String domain, required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(domain, serializer);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiConnectionsAddWalletToConnectionConstMeta,
      argValues: [domain, walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConnectionsAddWalletToConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "add_wallet_to_connection",
        argNames: ["domain", "walletIndex"],
      );

  @override
  Future<GasInfo> crateApiTransactionCaclGasFee(
      {required TransactionRequestInfo params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_transaction_request_info(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gas_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionCaclGasFeeConstMeta,
      argValues: [params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionCaclGasFeeConstMeta =>
      const TaskConstMeta(
        debugName: "cacl_gas_fee",
        argNames: ["params"],
      );

  @override
  Future<void> crateApiWalletChangeAccountName(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required String newName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(accountIndex, serializer);
        sse_encode_String(newName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletChangeAccountNameConstMeta,
      argValues: [walletIndex, accountIndex, newName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletChangeAccountNameConstMeta =>
      const TaskConstMeta(
        debugName: "change_account_name",
        argNames: ["walletIndex", "accountIndex", "newName"],
      );

  @override
  Future<void> crateApiWalletChangeWalletName(
      {required BigInt walletIndex, required String newName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_String(newName, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletChangeWalletNameConstMeta,
      argValues: [walletIndex, newName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletChangeWalletNameConstMeta =>
      const TaskConstMeta(
        debugName: "change_wallet_name",
        argNames: ["walletIndex", "newName"],
      );

  @override
  Future<Uint64List> crateApiMethodsCheckNotExistsBip39Words(
      {required List<String> words, required String lang}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_String(words, serializer);
        sse_encode_String(lang, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_usize_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMethodsCheckNotExistsBip39WordsConstMeta,
      argValues: [words, lang],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsCheckNotExistsBip39WordsConstMeta =>
      const TaskConstMeta(
        debugName: "check_not_exists_bip39_words",
        argNames: ["words", "lang"],
      );

  @override
  Future<void> crateApiTransactionClearRequestedTransactions(
      {required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionClearRequestedTransactionsConstMeta,
      argValues: [walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionClearRequestedTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "clear_requested_transactions",
        argNames: ["walletIndex"],
      );

  @override
  Future<void> crateApiConnectionsCreateNewConnection(
      {required ConnectionInfo conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_connection_info(conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiConnectionsCreateNewConnectionConstMeta,
      argValues: [conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConnectionsCreateNewConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "create_new_connection",
        argNames: ["conn"],
      );

  @override
  Future<TransactionRequestInfo> crateApiTransactionCreateTokenTransfer(
      {required TokenTransferParamsInfo params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_token_transfer_params_info(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_transaction_request_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionCreateTokenTransferConstMeta,
      argValues: [params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionCreateTokenTransferConstMeta =>
      const TaskConstMeta(
        debugName: "create_token_transfer",
        argNames: ["params"],
      );

  @override
  Future<void> crateApiWalletDeleteAccount(
      {required BigInt walletIndex, required BigInt accountIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(accountIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletDeleteAccountConstMeta,
      argValues: [walletIndex, accountIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletDeleteAccountConstMeta =>
      const TaskConstMeta(
        debugName: "delete_account",
        argNames: ["walletIndex", "accountIndex"],
      );

  @override
  Future<void> crateApiWalletDeleteWallet(
      {required BigInt walletIndex,
      required List<String> identifiers,
      String? password,
      String? sessionCipher}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_list_String(identifiers, serializer);
        sse_encode_opt_String(password, serializer);
        sse_encode_opt_String(sessionCipher, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletDeleteWalletConstMeta,
      argValues: [walletIndex, identifiers, password, sessionCipher],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletDeleteWalletConstMeta => const TaskConstMeta(
        debugName: "delete_wallet",
        argNames: ["walletIndex", "identifiers", "password", "sessionCipher"],
      );

  @override
  Future<FTokenInfo> crateApiTokenFetchTokenMeta(
      {required String addr, required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(addr, serializer);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_token_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenFetchTokenMetaConstMeta,
      argValues: [addr, walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenFetchTokenMetaConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_token_meta",
        argNames: ["addr", "walletIndex"],
      );

  @override
  Future<String> crateApiMethodsGenBip39Words({required int count}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(count, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiMethodsGenBip39WordsConstMeta,
      argValues: [count],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsGenBip39WordsConstMeta =>
      const TaskConstMeta(
        debugName: "gen_bip39_words",
        argNames: ["count"],
      );

  @override
  Future<KeyPairInfo> crateApiMethodsGenKeypair() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_pair_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiMethodsGenKeypairConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsGenKeypairConstMeta => const TaskConstMeta(
        debugName: "gen_keypair",
        argNames: [],
      );

  @override
  Future<Uint8List> crateApiQrcodeGenPngQrcode(
      {required String data, required QrConfigInfo config}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(data, serializer);
        sse_encode_box_autoadd_qr_config_info(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiQrcodeGenPngQrcodeConstMeta,
      argValues: [data, config],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiQrcodeGenPngQrcodeConstMeta => const TaskConstMeta(
        debugName: "gen_png_qrcode",
        argNames: ["data", "config"],
      );

  @override
  Future<String> crateApiQrcodeGenSvgQrcode(
      {required String data, required QrConfigInfo config}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(data, serializer);
        sse_encode_box_autoadd_qr_config_info(config, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiQrcodeGenSvgQrcodeConstMeta,
      argValues: [data, config],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiQrcodeGenSvgQrcodeConstMeta => const TaskConstMeta(
        debugName: "gen_svg_qrcode",
        argNames: ["data", "config"],
      );

  @override
  Future<List<AddressBookEntryInfo>> crateApiBookGetAddressBookList() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_address_book_entry_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBookGetAddressBookListConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBookGetAddressBookListConstMeta =>
      const TaskConstMeta(
        debugName: "get_address_book_list",
        argNames: [],
      );

  @override
  Future<List<ConnectionInfo>> crateApiConnectionsGetConnectionsList() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_connection_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiConnectionsGetConnectionsListConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConnectionsGetConnectionsListConstMeta =>
      const TaskConstMeta(
        debugName: "get_connections_list",
        argNames: [],
      );

  @override
  Future<BackgroundState> crateApiBackendGetData() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_background_state,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBackendGetDataConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBackendGetDataConstMeta => const TaskConstMeta(
        debugName: "get_data",
        argNames: [],
      );

  @override
  Future<List<HistoricalTransactionInfo>> crateApiTransactionGetHistory(
      {required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_historical_transaction_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionGetHistoryConstMeta,
      argValues: [walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionGetHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "get_history",
        argNames: ["walletIndex"],
      );

  @override
  Future<(Uint8List, String)> crateApiCacheGetImageBytes(
      {required String dir, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dir, serializer);
        sse_encode_String(url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_list_prim_u_8_strict_string,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiCacheGetImageBytesConstMeta,
      argValues: [dir, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCacheGetImageBytesConstMeta => const TaskConstMeta(
        debugName: "get_image_bytes",
        argNames: ["dir", "url"],
      );

  @override
  Future<String> crateApiCacheGetImageName(
      {required String dir, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dir, serializer);
        sse_encode_String(url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiCacheGetImageNameConstMeta,
      argValues: [dir, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCacheGetImageNameConstMeta => const TaskConstMeta(
        debugName: "get_image_name",
        argNames: ["dir", "url"],
      );

  @override
  Future<NetworkConfigInfo> crateApiProviderGetProvider(
      {required BigInt chainHash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_64(chainHash, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_network_config_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiProviderGetProviderConstMeta,
      argValues: [chainHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiProviderGetProviderConstMeta =>
      const TaskConstMeta(
        debugName: "get_provider",
        argNames: ["chainHash"],
      );

  @override
  Future<List<NetworkConfigInfo>> crateApiProviderGetProviders() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_network_config_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiProviderGetProvidersConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiProviderGetProvidersConstMeta =>
      const TaskConstMeta(
        debugName: "get_providers",
        argNames: [],
      );

  @override
  Future<String> crateApiTokenGetRates() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenGetRatesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenGetRatesConstMeta => const TaskConstMeta(
        debugName: "get_rates",
        argNames: [],
      );

  @override
  Future<List<TransactionRequestInfo>>
      crateApiTransactionGetRequestedTransactions(
          {required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_transaction_request_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTransactionGetRequestedTransactionsConstMeta,
      argValues: [walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTransactionGetRequestedTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "get_requested_transactions",
        argNames: ["walletIndex"],
      );

  @override
  Future<List<WalletInfo>> crateApiWalletGetWallets() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_wallet_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletGetWalletsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletGetWalletsConstMeta => const TaskConstMeta(
        debugName: "get_wallets",
        argNames: [],
      );

  @override
  Future<void> crateApiMethodsInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMethodsInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<bool> crateApiMethodsIsCryptoAddress({required String addr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(addr, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMethodsIsCryptoAddressConstMeta,
      argValues: [addr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsIsCryptoAddressConstMeta =>
      const TaskConstMeta(
        debugName: "is_crypto_address",
        argNames: ["addr"],
      );

  @override
  Future<bool> crateApiBackendIsServiceRunning() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBackendIsServiceRunningConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBackendIsServiceRunningConstMeta =>
      const TaskConstMeta(
        debugName: "is_service_running",
        argNames: [],
      );

  @override
  Future<KeyPairInfo> crateApiMethodsKeypairFromSk({required String sk}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(sk, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_pair_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiMethodsKeypairFromSkConstMeta,
      argValues: [sk],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMethodsKeypairFromSkConstMeta =>
      const TaskConstMeta(
        debugName: "keypair_from_sk",
        argNames: ["sk"],
      );

  @override
  Future<QRcodeScanResultInfo> crateApiQrcodeParseQrcodeStr(
      {required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_q_rcode_scan_result_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiQrcodeParseQrcodeStrConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiQrcodeParseQrcodeStrConstMeta =>
      const TaskConstMeta(
        debugName: "parse_qrcode_str",
        argNames: ["data"],
      );

  @override
  Future<String> crateApiWalletRevealBip39Phrase(
      {required BigInt walletIndex,
      required List<String> identifiers,
      required String password,
      String? passphrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_list_String(identifiers, serializer);
        sse_encode_String(password, serializer);
        sse_encode_opt_String(passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletRevealBip39PhraseConstMeta,
      argValues: [walletIndex, identifiers, password, passphrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletRevealBip39PhraseConstMeta =>
      const TaskConstMeta(
        debugName: "reveal_bip39_phrase",
        argNames: ["walletIndex", "identifiers", "password", "passphrase"],
      );

  @override
  Future<KeyPairInfo> crateApiWalletRevealKeypair(
      {required BigInt walletIndex,
      required BigInt accountIndex,
      required List<String> identifiers,
      required String password,
      String? passphrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(accountIndex, serializer);
        sse_encode_list_String(identifiers, serializer);
        sse_encode_String(password, serializer);
        sse_encode_opt_String(passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_key_pair_info,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletRevealKeypairConstMeta,
      argValues: [walletIndex, accountIndex, identifiers, password, passphrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletRevealKeypairConstMeta =>
      const TaskConstMeta(
        debugName: "reveal_keypair",
        argNames: [
          "walletIndex",
          "accountIndex",
          "identifiers",
          "password",
          "passphrase"
        ],
      );

  @override
  Future<void> crateApiTokenRmFtoken(
      {required BigInt walletIndex, required BigInt tokenIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(tokenIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenRmFtokenConstMeta,
      argValues: [walletIndex, tokenIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenRmFtokenConstMeta => const TaskConstMeta(
        debugName: "rm_ftoken",
        argNames: ["walletIndex", "tokenIndex"],
      );

  @override
  Future<void> crateApiWalletSelectAccount(
      {required BigInt walletIndex, required BigInt accountIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_usize(accountIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiWalletSelectAccountConstMeta,
      argValues: [walletIndex, accountIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWalletSelectAccountConstMeta =>
      const TaskConstMeta(
        debugName: "select_account",
        argNames: ["walletIndex", "accountIndex"],
      );

  @override
  Future<void> crateApiSettingsSetGlobalNotifications(
      {required bool globalEnabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(globalEnabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetGlobalNotificationsConstMeta,
      argValues: [globalEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetGlobalNotificationsConstMeta =>
      const TaskConstMeta(
        debugName: "set_global_notifications",
        argNames: ["globalEnabled"],
      );

  @override
  Future<void> crateApiSettingsSetRateFetcher(
      {required BigInt walletIndex, String? currency}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_opt_String(currency, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetRateFetcherConstMeta,
      argValues: [walletIndex, currency],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetRateFetcherConstMeta =>
      const TaskConstMeta(
        debugName: "set_rate_fetcher",
        argNames: ["walletIndex", "currency"],
      );

  @override
  Future<void> crateApiSettingsSetTheme({required int appearancesCode}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(appearancesCode, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetThemeConstMeta,
      argValues: [appearancesCode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetThemeConstMeta => const TaskConstMeta(
        debugName: "set_theme",
        argNames: ["appearancesCode"],
      );

  @override
  Future<void> crateApiSettingsSetWalletEns(
      {required BigInt walletIndex, required bool ensEnabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_bool(ensEnabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetWalletEnsConstMeta,
      argValues: [walletIndex, ensEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetWalletEnsConstMeta =>
      const TaskConstMeta(
        debugName: "set_wallet_ens",
        argNames: ["walletIndex", "ensEnabled"],
      );

  @override
  Future<void> crateApiSettingsSetWalletGasControl(
      {required BigInt walletIndex, required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetWalletGasControlConstMeta,
      argValues: [walletIndex, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetWalletGasControlConstMeta =>
      const TaskConstMeta(
        debugName: "set_wallet_gas_control",
        argNames: ["walletIndex", "enabled"],
      );

  @override
  Future<void> crateApiSettingsSetWalletIpfsNode(
      {required BigInt walletIndex, String? node}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_opt_String(node, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetWalletIpfsNodeConstMeta,
      argValues: [walletIndex, node],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetWalletIpfsNodeConstMeta =>
      const TaskConstMeta(
        debugName: "set_wallet_ipfs_node",
        argNames: ["walletIndex", "node"],
      );

  @override
  Future<void> crateApiSettingsSetWalletNodeRanking(
      {required BigInt walletIndex, required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetWalletNodeRankingConstMeta,
      argValues: [walletIndex, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetWalletNodeRankingConstMeta =>
      const TaskConstMeta(
        debugName: "set_wallet_node_ranking",
        argNames: ["walletIndex", "enabled"],
      );

  @override
  Future<void> crateApiSettingsSetWalletNotifications(
      {required BigInt walletIndex,
      required bool transactions,
      required bool price,
      required bool security,
      required bool balance}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_bool(transactions, serializer);
        sse_encode_bool(price, serializer);
        sse_encode_bool(security, serializer);
        sse_encode_bool(balance, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiSettingsSetWalletNotificationsConstMeta,
      argValues: [walletIndex, transactions, price, security, balance],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSettingsSetWalletNotificationsConstMeta =>
      const TaskConstMeta(
        debugName: "set_wallet_notifications",
        argNames: [
          "walletIndex",
          "transactions",
          "price",
          "security",
          "balance"
        ],
      );

  @override
  Future<BackgroundState> crateApiBackendStartService({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_background_state,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBackendStartServiceConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBackendStartServiceConstMeta =>
      const TaskConstMeta(
        debugName: "start_service",
        argNames: ["path"],
      );

  @override
  Stream<String> crateApiBackendStartWorker() {
    final sink = RustStreamSink<String>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_String_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBackendStartWorkerConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiBackendStartWorkerConstMeta => const TaskConstMeta(
        debugName: "start_worker",
        argNames: ["sink"],
      );

  @override
  Future<void> crateApiBackendStopService() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiBackendStopServiceConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBackendStopServiceConstMeta => const TaskConstMeta(
        debugName: "stop_service",
        argNames: [],
      );

  @override
  Future<void> crateApiTokenSyncBalances({required BigInt walletIndex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(walletIndex, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenSyncBalancesConstMeta,
      argValues: [walletIndex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenSyncBalancesConstMeta => const TaskConstMeta(
        debugName: "sync_balances",
        argNames: ["walletIndex"],
      );

  @override
  Future<bool> crateApiAuthTryUnlockWithPassword(
      {required String password,
      required BigInt walletIndex,
      required List<String> identifiers}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(password, serializer);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_list_String(identifiers, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiAuthTryUnlockWithPasswordConstMeta,
      argValues: [password, walletIndex, identifiers],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAuthTryUnlockWithPasswordConstMeta =>
      const TaskConstMeta(
        debugName: "try_unlock_with_password",
        argNames: ["password", "walletIndex", "identifiers"],
      );

  @override
  Future<bool> crateApiAuthTryUnlockWithSession(
      {required String sessionCipher,
      required BigInt walletIndex,
      required List<String> identifiers}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(sessionCipher, serializer);
        sse_encode_usize(walletIndex, serializer);
        sse_encode_list_String(identifiers, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiAuthTryUnlockWithSessionConstMeta,
      argValues: [sessionCipher, walletIndex, identifiers],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAuthTryUnlockWithSessionConstMeta =>
      const TaskConstMeta(
        debugName: "try_unlock_with_session",
        argNames: ["sessionCipher", "walletIndex", "identifiers"],
      );

  @override
  Future<void> crateApiTokenUpdateRates() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateApiTokenUpdateRatesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTokenUpdateRatesConstMeta => const TaskConstMeta(
        debugName: "update_rates",
        argNames: [],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<BigInt, String> dco_decode_Map_usize_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_usize_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<BigInt, BackgroundNotificationState>
      dco_decode_Map_usize_background_notification_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_usize_background_notification_state(raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  BigInt dco_decode_U128(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BigInt.parse(raw);
  }

  @protected
  AccessListItem dco_decode_access_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AccessListItem(
      address: dco_decode_String(arr[0]),
      storageKeys: dco_decode_list_String(arr[1]),
    );
  }

  @protected
  AccountInfo dco_decode_account_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AccountInfo(
      addr: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      chainHash: dco_decode_u_64(arr[2]),
      index: dco_decode_usize(arr[3]),
    );
  }

  @protected
  AddNextBip39AccountParams dco_decode_add_next_bip_39_account_params(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return AddNextBip39AccountParams(
      walletIndex: dco_decode_usize(arr[0]),
      accountIndex: dco_decode_usize(arr[1]),
      name: dco_decode_String(arr[2]),
      passphrase: dco_decode_String(arr[3]),
      identifiers: dco_decode_list_String(arr[4]),
      password: dco_decode_opt_String(arr[5]),
      sessionCipher: dco_decode_opt_String(arr[6]),
      chainHash: dco_decode_u_64(arr[7]),
    );
  }

  @protected
  AddSKWalletParams dco_decode_add_sk_wallet_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return AddSKWalletParams(
      sk: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
      walletName: dco_decode_String(arr[2]),
      biometricType: dco_decode_String(arr[3]),
      identifiers: dco_decode_list_String(arr[4]),
      chainHash: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  AddressBookEntryInfo dco_decode_address_book_entry_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AddressBookEntryInfo(
      name: dco_decode_String(arr[0]),
      addr: dco_decode_String(arr[1]),
      net: dco_decode_usize(arr[2]),
    );
  }

  @protected
  BackgroundNotificationState dco_decode_background_notification_state(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return BackgroundNotificationState(
      transactions: dco_decode_bool(arr[0]),
      price: dco_decode_bool(arr[1]),
      security: dco_decode_bool(arr[2]),
      balance: dco_decode_bool(arr[3]),
    );
  }

  @protected
  BackgroundState dco_decode_background_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return BackgroundState(
      wallets: dco_decode_list_wallet_info(arr[0]),
      notificationsWalletStates:
          dco_decode_Map_usize_background_notification_state(arr[1]),
      notificationsGlobalEnabled: dco_decode_bool(arr[2]),
      locale: dco_decode_String(arr[3]),
      appearances: dco_decode_u_8(arr[4]),
      providers: dco_decode_list_network_config_info(arr[5]),
    );
  }

  @protected
  BaseTokenInfo dco_decode_base_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return BaseTokenInfo(
      value: dco_decode_String(arr[0]),
      symbol: dco_decode_String(arr[1]),
      decimals: dco_decode_u_8(arr[2]),
    );
  }

  @protected
  Bip39AddWalletParams dco_decode_bip_39_add_wallet_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Bip39AddWalletParams(
      password: dco_decode_String(arr[0]),
      mnemonicStr: dco_decode_String(arr[1]),
      accounts: dco_decode_list_record_usize_string(arr[2]),
      passphrase: dco_decode_String(arr[3]),
      walletName: dco_decode_String(arr[4]),
      biometricType: dco_decode_String(arr[5]),
      chainHash: dco_decode_u_64(arr[6]),
      identifiers: dco_decode_list_String(arr[7]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AddNextBip39AccountParams
      dco_decode_box_autoadd_add_next_bip_39_account_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_add_next_bip_39_account_params(raw);
  }

  @protected
  AddSKWalletParams dco_decode_box_autoadd_add_sk_wallet_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_add_sk_wallet_params(raw);
  }

  @protected
  BaseTokenInfo dco_decode_box_autoadd_base_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_base_token_info(raw);
  }

  @protected
  Bip39AddWalletParams dco_decode_box_autoadd_bip_39_add_wallet_params(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bip_39_add_wallet_params(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ColorsInfo dco_decode_box_autoadd_colors_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_colors_info(raw);
  }

  @protected
  ConnectionInfo dco_decode_box_autoadd_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_connection_info(raw);
  }

  @protected
  FTokenInfo dco_decode_box_autoadd_f_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_f_token_info(raw);
  }

  @protected
  LedgerParamsInput dco_decode_box_autoadd_ledger_params_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ledger_params_input(raw);
  }

  @protected
  NetworkConfigInfo dco_decode_box_autoadd_network_config_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_network_config_info(raw);
  }

  @protected
  QrConfigInfo dco_decode_box_autoadd_qr_config_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_qr_config_info(raw);
  }

  @protected
  TokenTransferParamsInfo dco_decode_box_autoadd_token_transfer_params_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_token_transfer_params_info(raw);
  }

  @protected
  TransactionRequestEVM dco_decode_box_autoadd_transaction_request_evm(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_transaction_request_evm(raw);
  }

  @protected
  TransactionRequestInfo dco_decode_box_autoadd_transaction_request_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_transaction_request_info(raw);
  }

  @protected
  TransactionRequestScilla dco_decode_box_autoadd_transaction_request_scilla(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_transaction_request_scilla(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WalletSettingsInfo dco_decode_box_autoadd_wallet_settings_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wallet_settings_info(raw);
  }

  @protected
  ColorsInfo dco_decode_colors_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ColorsInfo(
      primary: dco_decode_String(arr[0]),
      secondary: dco_decode_opt_String(arr[1]),
      background: dco_decode_opt_String(arr[2]),
      text: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  ConnectionInfo dco_decode_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return ConnectionInfo(
      domain: dco_decode_String(arr[0]),
      walletIndexes: dco_decode_list_prim_usize_strict(arr[1]),
      favicon: dco_decode_opt_String(arr[2]),
      title: dco_decode_String(arr[3]),
      description: dco_decode_opt_String(arr[4]),
      colors: dco_decode_opt_box_autoadd_colors_info(arr[5]),
      lastConnected: dco_decode_u_64(arr[6]),
      canReadAccounts: dco_decode_bool(arr[7]),
      canRequestSignatures: dco_decode_bool(arr[8]),
      canSuggestTokens: dco_decode_bool(arr[9]),
      canSuggestTransactions: dco_decode_bool(arr[10]),
    );
  }

  @protected
  ExplorerInfo dco_decode_explorer_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ExplorerInfo(
      name: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
      icon: dco_decode_opt_String(arr[2]),
      standard: dco_decode_u_16(arr[3]),
    );
  }

  @protected
  FTokenInfo dco_decode_f_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return FTokenInfo(
      name: dco_decode_String(arr[0]),
      symbol: dco_decode_String(arr[1]),
      decimals: dco_decode_u_8(arr[2]),
      addr: dco_decode_String(arr[3]),
      logo: dco_decode_opt_String(arr[4]),
      balances: dco_decode_Map_usize_String(arr[5]),
      default_: dco_decode_bool(arr[6]),
      native: dco_decode_bool(arr[7]),
      chainHash: dco_decode_u_64(arr[8]),
    );
  }

  @protected
  GasFeeHistoryInfo dco_decode_gas_fee_history_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GasFeeHistoryInfo(
      maxFee: dco_decode_U128(arr[0]),
      priorityFee: dco_decode_U128(arr[1]),
      baseFee: dco_decode_U128(arr[2]),
    );
  }

  @protected
  GasInfo dco_decode_gas_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GasInfo(
      gasPrice: dco_decode_U128(arr[0]),
      maxPriorityFee: dco_decode_U128(arr[1]),
      feeHistory: dco_decode_gas_fee_history_info(arr[2]),
      txEstimateGas: dco_decode_u_64(arr[3]),
      blobBaseFee: dco_decode_U128(arr[4]),
    );
  }

  @protected
  HistoricalTransactionInfo dco_decode_historical_transaction_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return HistoricalTransactionInfo(
      id: dco_decode_String(arr[0]),
      amount: dco_decode_String(arr[1]),
      sender: dco_decode_String(arr[2]),
      recipient: dco_decode_String(arr[3]),
      teg: dco_decode_opt_String(arr[4]),
      status: dco_decode_transaction_status_info(arr[5]),
      confirmed: dco_decode_opt_U128(arr[6]),
      timestamp: dco_decode_u_64(arr[7]),
      fee: dco_decode_U128(arr[8]),
      icon: dco_decode_opt_String(arr[9]),
      title: dco_decode_opt_String(arr[10]),
      nonce: dco_decode_u_64(arr[11]),
      tokenInfo: dco_decode_opt_box_autoadd_base_token_info(arr[12]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeyPairInfo dco_decode_key_pair_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyPairInfo(
      sk: dco_decode_String(arr[0]),
      pk: dco_decode_String(arr[1]),
    );
  }

  @protected
  LedgerParamsInput dco_decode_ledger_params_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return LedgerParamsInput(
      pubKey: dco_decode_String(arr[0]),
      walletIndex: dco_decode_usize(arr[1]),
      walletName: dco_decode_String(arr[2]),
      ledgerId: dco_decode_String(arr[3]),
      accountName: dco_decode_String(arr[4]),
      biometricType: dco_decode_String(arr[5]),
      identifiers: dco_decode_list_String(arr[6]),
      chainHash: dco_decode_u_64(arr[7]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AccessListItem> dco_decode_list_access_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_access_list_item).toList();
  }

  @protected
  List<AccountInfo> dco_decode_list_account_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_account_info).toList();
  }

  @protected
  List<AddressBookEntryInfo> dco_decode_list_address_book_entry_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_address_book_entry_info)
        .toList();
  }

  @protected
  List<ConnectionInfo> dco_decode_list_connection_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_connection_info).toList();
  }

  @protected
  List<ExplorerInfo> dco_decode_list_explorer_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_explorer_info).toList();
  }

  @protected
  List<FTokenInfo> dco_decode_list_f_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_f_token_info).toList();
  }

  @protected
  List<HistoricalTransactionInfo> dco_decode_list_historical_transaction_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_historical_transaction_info)
        .toList();
  }

  @protected
  List<NetworkConfigInfo> dco_decode_list_network_config_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_network_config_info).toList();
  }

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint16List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(BigInt, BackgroundNotificationState)>
      dco_decode_list_record_usize_background_notification_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_usize_background_notification_state)
        .toList();
  }

  @protected
  List<(BigInt, String)> dco_decode_list_record_usize_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_usize_string).toList();
  }

  @protected
  List<TransactionRequestInfo> dco_decode_list_transaction_request_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_transaction_request_info)
        .toList();
  }

  @protected
  List<WalletInfo> dco_decode_list_wallet_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_wallet_info).toList();
  }

  @protected
  NetworkConfigInfo dco_decode_network_config_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return NetworkConfigInfo(
      name: dco_decode_String(arr[0]),
      chain: dco_decode_String(arr[1]),
      shortName: dco_decode_String(arr[2]),
      rpc: dco_decode_list_String(arr[3]),
      features: dco_decode_list_prim_u_16_strict(arr[4]),
      chainId: dco_decode_u_64(arr[5]),
      slip44: dco_decode_u_32(arr[6]),
      chainHash: dco_decode_u_64(arr[7]),
      ens: dco_decode_opt_String(arr[8]),
      explorers: dco_decode_list_explorer_info(arr[9]),
      fallbackEnabled: dco_decode_bool(arr[10]),
      testnet: dco_decode_opt_box_autoadd_bool(arr[11]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  BigInt? dco_decode_opt_U128(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_U128(raw);
  }

  @protected
  BaseTokenInfo? dco_decode_opt_box_autoadd_base_token_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_base_token_info(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  ColorsInfo? dco_decode_opt_box_autoadd_colors_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_colors_info(raw);
  }

  @protected
  TransactionRequestEVM? dco_decode_opt_box_autoadd_transaction_request_evm(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_transaction_request_evm(raw);
  }

  @protected
  TransactionRequestScilla?
      dco_decode_opt_box_autoadd_transaction_request_scilla(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_transaction_request_scilla(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<AccessListItem>? dco_decode_opt_list_access_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_access_list_item(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  QRcodeScanResultInfo dco_decode_q_rcode_scan_result_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return QRcodeScanResultInfo(
      recipient: dco_decode_String(arr[0]),
      provider: dco_decode_opt_String(arr[1]),
      tokenAddress: dco_decode_opt_String(arr[2]),
      amount: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  QrConfigInfo dco_decode_qr_config_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return QrConfigInfo(
      size: dco_decode_u_32(arr[0]),
      gapless: dco_decode_bool(arr[1]),
      color: dco_decode_u_32(arr[2]),
      eyeShape: dco_decode_u_8(arr[3]),
      dataModuleShape: dco_decode_u_8(arr[4]),
    );
  }

  @protected
  (Uint8List, String) dco_decode_record_list_prim_u_8_strict_string(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_list_prim_u_8_strict(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (BigInt, BackgroundNotificationState)
      dco_decode_record_usize_background_notification_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_usize(arr[0]),
      dco_decode_background_notification_state(arr[1]),
    );
  }

  @protected
  (BigInt, String) dco_decode_record_usize_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_usize(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  TokenTransferParamsInfo dco_decode_token_transfer_params_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return TokenTransferParamsInfo(
      walletIndex: dco_decode_usize(arr[0]),
      accountIndex: dco_decode_usize(arr[1]),
      tokenIndex: dco_decode_usize(arr[2]),
      amount: dco_decode_String(arr[3]),
      recipient: dco_decode_String(arr[4]),
    );
  }

  @protected
  TransactionMetadataInfo dco_decode_transaction_metadata_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return TransactionMetadataInfo(
      chainHash: dco_decode_u_64(arr[0]),
      hash: dco_decode_opt_String(arr[1]),
      info: dco_decode_opt_String(arr[2]),
      icon: dco_decode_opt_String(arr[3]),
      title: dco_decode_opt_String(arr[4]),
      signer: dco_decode_opt_String(arr[5]),
      tokenInfo: dco_decode_opt_box_autoadd_base_token_info(arr[6]),
    );
  }

  @protected
  TransactionRequestEVM dco_decode_transaction_request_evm(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return TransactionRequestEVM(
      nonce: dco_decode_opt_box_autoadd_u_64(arr[0]),
      from: dco_decode_opt_String(arr[1]),
      to: dco_decode_opt_String(arr[2]),
      value: dco_decode_opt_String(arr[3]),
      gasLimit: dco_decode_opt_box_autoadd_u_64(arr[4]),
      data: dco_decode_opt_list_prim_u_8_strict(arr[5]),
      maxFeePerGas: dco_decode_opt_U128(arr[6]),
      maxPriorityFeePerGas: dco_decode_opt_U128(arr[7]),
      gasPrice: dco_decode_opt_U128(arr[8]),
      chainId: dco_decode_opt_box_autoadd_u_64(arr[9]),
      accessList: dco_decode_opt_list_access_list_item(arr[10]),
      blobVersionedHashes: dco_decode_opt_list_String(arr[11]),
      maxFeePerBlobGas: dco_decode_opt_U128(arr[12]),
    );
  }

  @protected
  TransactionRequestInfo dco_decode_transaction_request_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return TransactionRequestInfo(
      metadata: dco_decode_transaction_metadata_info(arr[0]),
      scilla: dco_decode_opt_box_autoadd_transaction_request_scilla(arr[1]),
      evm: dco_decode_opt_box_autoadd_transaction_request_evm(arr[2]),
    );
  }

  @protected
  TransactionRequestScilla dco_decode_transaction_request_scilla(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return TransactionRequestScilla(
      chainId: dco_decode_u_16(arr[0]),
      nonce: dco_decode_u_64(arr[1]),
      gasPrice: dco_decode_U128(arr[2]),
      gasLimit: dco_decode_u_64(arr[3]),
      toAddr: dco_decode_String(arr[4]),
      amount: dco_decode_U128(arr[5]),
      code: dco_decode_String(arr[6]),
      data: dco_decode_String(arr[7]),
    );
  }

  @protected
  TransactionStatusInfo dco_decode_transaction_status_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TransactionStatusInfo.values[raw as int];
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WalletArgonParamsInfo dco_decode_wallet_argon_params_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return WalletArgonParamsInfo(
      memory: dco_decode_u_32(arr[0]),
      iterations: dco_decode_u_32(arr[1]),
      threads: dco_decode_u_32(arr[2]),
      secret: dco_decode_String(arr[3]),
    );
  }

  @protected
  WalletInfo dco_decode_wallet_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return WalletInfo(
      walletType: dco_decode_String(arr[0]),
      walletName: dco_decode_String(arr[1]),
      authType: dco_decode_String(arr[2]),
      walletAddress: dco_decode_String(arr[3]),
      accounts: dco_decode_list_account_info(arr[4]),
      selectedAccount: dco_decode_usize(arr[5]),
      tokens: dco_decode_list_f_token_info(arr[6]),
      settings: dco_decode_wallet_settings_info(arr[7]),
      defaultChainHash: dco_decode_u_64(arr[8]),
    );
  }

  @protected
  WalletSettingsInfo dco_decode_wallet_settings_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return WalletSettingsInfo(
      cipherOrders: dco_decode_list_prim_u_8_strict(arr[0]),
      argonParams: dco_decode_wallet_argon_params_info(arr[1]),
      currencyConvert: dco_decode_opt_String(arr[2]),
      ipfsNode: dco_decode_opt_String(arr[3]),
      ensEnabled: dco_decode_bool(arr[4]),
      gasControlEnabled: dco_decode_bool(arr[5]),
      nodeRankingEnabled: dco_decode_bool(arr[6]),
      maxConnections: dco_decode_u_8(arr[7]),
      requestTimeoutSecs: dco_decode_u_32(arr[8]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<BigInt, String> sse_decode_Map_usize_String(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_usize_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<BigInt, BackgroundNotificationState>
      sse_decode_Map_usize_background_notification_state(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_usize_background_notification_state(
        deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  BigInt sse_decode_U128(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return BigInt.parse(inner);
  }

  @protected
  AccessListItem sse_decode_access_list_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_storageKeys = sse_decode_list_String(deserializer);
    return AccessListItem(address: var_address, storageKeys: var_storageKeys);
  }

  @protected
  AccountInfo sse_decode_account_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_addr = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    var var_index = sse_decode_usize(deserializer);
    return AccountInfo(
        addr: var_addr,
        name: var_name,
        chainHash: var_chainHash,
        index: var_index);
  }

  @protected
  AddNextBip39AccountParams sse_decode_add_next_bip_39_account_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletIndex = sse_decode_usize(deserializer);
    var var_accountIndex = sse_decode_usize(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_passphrase = sse_decode_String(deserializer);
    var var_identifiers = sse_decode_list_String(deserializer);
    var var_password = sse_decode_opt_String(deserializer);
    var var_sessionCipher = sse_decode_opt_String(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    return AddNextBip39AccountParams(
        walletIndex: var_walletIndex,
        accountIndex: var_accountIndex,
        name: var_name,
        passphrase: var_passphrase,
        identifiers: var_identifiers,
        password: var_password,
        sessionCipher: var_sessionCipher,
        chainHash: var_chainHash);
  }

  @protected
  AddSKWalletParams sse_decode_add_sk_wallet_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sk = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_biometricType = sse_decode_String(deserializer);
    var var_identifiers = sse_decode_list_String(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    return AddSKWalletParams(
        sk: var_sk,
        password: var_password,
        walletName: var_walletName,
        biometricType: var_biometricType,
        identifiers: var_identifiers,
        chainHash: var_chainHash);
  }

  @protected
  AddressBookEntryInfo sse_decode_address_book_entry_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_addr = sse_decode_String(deserializer);
    var var_net = sse_decode_usize(deserializer);
    return AddressBookEntryInfo(name: var_name, addr: var_addr, net: var_net);
  }

  @protected
  BackgroundNotificationState sse_decode_background_notification_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transactions = sse_decode_bool(deserializer);
    var var_price = sse_decode_bool(deserializer);
    var var_security = sse_decode_bool(deserializer);
    var var_balance = sse_decode_bool(deserializer);
    return BackgroundNotificationState(
        transactions: var_transactions,
        price: var_price,
        security: var_security,
        balance: var_balance);
  }

  @protected
  BackgroundState sse_decode_background_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_wallets = sse_decode_list_wallet_info(deserializer);
    var var_notificationsWalletStates =
        sse_decode_Map_usize_background_notification_state(deserializer);
    var var_notificationsGlobalEnabled = sse_decode_bool(deserializer);
    var var_locale = sse_decode_String(deserializer);
    var var_appearances = sse_decode_u_8(deserializer);
    var var_providers = sse_decode_list_network_config_info(deserializer);
    return BackgroundState(
        wallets: var_wallets,
        notificationsWalletStates: var_notificationsWalletStates,
        notificationsGlobalEnabled: var_notificationsGlobalEnabled,
        locale: var_locale,
        appearances: var_appearances,
        providers: var_providers);
  }

  @protected
  BaseTokenInfo sse_decode_base_token_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_symbol = sse_decode_String(deserializer);
    var var_decimals = sse_decode_u_8(deserializer);
    return BaseTokenInfo(
        value: var_value, symbol: var_symbol, decimals: var_decimals);
  }

  @protected
  Bip39AddWalletParams sse_decode_bip_39_add_wallet_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_password = sse_decode_String(deserializer);
    var var_mnemonicStr = sse_decode_String(deserializer);
    var var_accounts = sse_decode_list_record_usize_string(deserializer);
    var var_passphrase = sse_decode_String(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_biometricType = sse_decode_String(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    var var_identifiers = sse_decode_list_String(deserializer);
    return Bip39AddWalletParams(
        password: var_password,
        mnemonicStr: var_mnemonicStr,
        accounts: var_accounts,
        passphrase: var_passphrase,
        walletName: var_walletName,
        biometricType: var_biometricType,
        chainHash: var_chainHash,
        identifiers: var_identifiers);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AddNextBip39AccountParams
      sse_decode_box_autoadd_add_next_bip_39_account_params(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_add_next_bip_39_account_params(deserializer));
  }

  @protected
  AddSKWalletParams sse_decode_box_autoadd_add_sk_wallet_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_add_sk_wallet_params(deserializer));
  }

  @protected
  BaseTokenInfo sse_decode_box_autoadd_base_token_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_base_token_info(deserializer));
  }

  @protected
  Bip39AddWalletParams sse_decode_box_autoadd_bip_39_add_wallet_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bip_39_add_wallet_params(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  ColorsInfo sse_decode_box_autoadd_colors_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_colors_info(deserializer));
  }

  @protected
  ConnectionInfo sse_decode_box_autoadd_connection_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_connection_info(deserializer));
  }

  @protected
  FTokenInfo sse_decode_box_autoadd_f_token_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_token_info(deserializer));
  }

  @protected
  LedgerParamsInput sse_decode_box_autoadd_ledger_params_input(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ledger_params_input(deserializer));
  }

  @protected
  NetworkConfigInfo sse_decode_box_autoadd_network_config_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_network_config_info(deserializer));
  }

  @protected
  QrConfigInfo sse_decode_box_autoadd_qr_config_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_qr_config_info(deserializer));
  }

  @protected
  TokenTransferParamsInfo sse_decode_box_autoadd_token_transfer_params_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_token_transfer_params_info(deserializer));
  }

  @protected
  TransactionRequestEVM sse_decode_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_transaction_request_evm(deserializer));
  }

  @protected
  TransactionRequestInfo sse_decode_box_autoadd_transaction_request_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_transaction_request_info(deserializer));
  }

  @protected
  TransactionRequestScilla sse_decode_box_autoadd_transaction_request_scilla(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_transaction_request_scilla(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  WalletSettingsInfo sse_decode_box_autoadd_wallet_settings_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wallet_settings_info(deserializer));
  }

  @protected
  ColorsInfo sse_decode_colors_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_primary = sse_decode_String(deserializer);
    var var_secondary = sse_decode_opt_String(deserializer);
    var var_background = sse_decode_opt_String(deserializer);
    var var_text = sse_decode_opt_String(deserializer);
    return ColorsInfo(
        primary: var_primary,
        secondary: var_secondary,
        background: var_background,
        text: var_text);
  }

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_domain = sse_decode_String(deserializer);
    var var_walletIndexes = sse_decode_list_prim_usize_strict(deserializer);
    var var_favicon = sse_decode_opt_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_colors = sse_decode_opt_box_autoadd_colors_info(deserializer);
    var var_lastConnected = sse_decode_u_64(deserializer);
    var var_canReadAccounts = sse_decode_bool(deserializer);
    var var_canRequestSignatures = sse_decode_bool(deserializer);
    var var_canSuggestTokens = sse_decode_bool(deserializer);
    var var_canSuggestTransactions = sse_decode_bool(deserializer);
    return ConnectionInfo(
        domain: var_domain,
        walletIndexes: var_walletIndexes,
        favicon: var_favicon,
        title: var_title,
        description: var_description,
        colors: var_colors,
        lastConnected: var_lastConnected,
        canReadAccounts: var_canReadAccounts,
        canRequestSignatures: var_canRequestSignatures,
        canSuggestTokens: var_canSuggestTokens,
        canSuggestTransactions: var_canSuggestTransactions);
  }

  @protected
  ExplorerInfo sse_decode_explorer_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    var var_standard = sse_decode_u_16(deserializer);
    return ExplorerInfo(
        name: var_name, url: var_url, icon: var_icon, standard: var_standard);
  }

  @protected
  FTokenInfo sse_decode_f_token_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_symbol = sse_decode_String(deserializer);
    var var_decimals = sse_decode_u_8(deserializer);
    var var_addr = sse_decode_String(deserializer);
    var var_logo = sse_decode_opt_String(deserializer);
    var var_balances = sse_decode_Map_usize_String(deserializer);
    var var_default_ = sse_decode_bool(deserializer);
    var var_native = sse_decode_bool(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    return FTokenInfo(
        name: var_name,
        symbol: var_symbol,
        decimals: var_decimals,
        addr: var_addr,
        logo: var_logo,
        balances: var_balances,
        default_: var_default_,
        native: var_native,
        chainHash: var_chainHash);
  }

  @protected
  GasFeeHistoryInfo sse_decode_gas_fee_history_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxFee = sse_decode_U128(deserializer);
    var var_priorityFee = sse_decode_U128(deserializer);
    var var_baseFee = sse_decode_U128(deserializer);
    return GasFeeHistoryInfo(
        maxFee: var_maxFee, priorityFee: var_priorityFee, baseFee: var_baseFee);
  }

  @protected
  GasInfo sse_decode_gas_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gasPrice = sse_decode_U128(deserializer);
    var var_maxPriorityFee = sse_decode_U128(deserializer);
    var var_feeHistory = sse_decode_gas_fee_history_info(deserializer);
    var var_txEstimateGas = sse_decode_u_64(deserializer);
    var var_blobBaseFee = sse_decode_U128(deserializer);
    return GasInfo(
        gasPrice: var_gasPrice,
        maxPriorityFee: var_maxPriorityFee,
        feeHistory: var_feeHistory,
        txEstimateGas: var_txEstimateGas,
        blobBaseFee: var_blobBaseFee);
  }

  @protected
  HistoricalTransactionInfo sse_decode_historical_transaction_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_amount = sse_decode_String(deserializer);
    var var_sender = sse_decode_String(deserializer);
    var var_recipient = sse_decode_String(deserializer);
    var var_teg = sse_decode_opt_String(deserializer);
    var var_status = sse_decode_transaction_status_info(deserializer);
    var var_confirmed = sse_decode_opt_U128(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_fee = sse_decode_U128(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    var var_title = sse_decode_opt_String(deserializer);
    var var_nonce = sse_decode_u_64(deserializer);
    var var_tokenInfo =
        sse_decode_opt_box_autoadd_base_token_info(deserializer);
    return HistoricalTransactionInfo(
        id: var_id,
        amount: var_amount,
        sender: var_sender,
        recipient: var_recipient,
        teg: var_teg,
        status: var_status,
        confirmed: var_confirmed,
        timestamp: var_timestamp,
        fee: var_fee,
        icon: var_icon,
        title: var_title,
        nonce: var_nonce,
        tokenInfo: var_tokenInfo);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeyPairInfo sse_decode_key_pair_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sk = sse_decode_String(deserializer);
    var var_pk = sse_decode_String(deserializer);
    return KeyPairInfo(sk: var_sk, pk: var_pk);
  }

  @protected
  LedgerParamsInput sse_decode_ledger_params_input(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pubKey = sse_decode_String(deserializer);
    var var_walletIndex = sse_decode_usize(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_ledgerId = sse_decode_String(deserializer);
    var var_accountName = sse_decode_String(deserializer);
    var var_biometricType = sse_decode_String(deserializer);
    var var_identifiers = sse_decode_list_String(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    return LedgerParamsInput(
        pubKey: var_pubKey,
        walletIndex: var_walletIndex,
        walletName: var_walletName,
        ledgerId: var_ledgerId,
        accountName: var_accountName,
        biometricType: var_biometricType,
        identifiers: var_identifiers,
        chainHash: var_chainHash);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AccessListItem> sse_decode_list_access_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AccessListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_access_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<AccountInfo> sse_decode_list_account_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AccountInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_account_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<AddressBookEntryInfo> sse_decode_list_address_book_entry_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AddressBookEntryInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_address_book_entry_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<ConnectionInfo> sse_decode_list_connection_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ConnectionInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_connection_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExplorerInfo> sse_decode_list_explorer_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExplorerInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_explorer_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<FTokenInfo> sse_decode_list_f_token_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FTokenInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_f_token_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<HistoricalTransactionInfo> sse_decode_list_historical_transaction_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <HistoricalTransactionInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_historical_transaction_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<NetworkConfigInfo> sse_decode_list_network_config_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NetworkConfigInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_network_config_info(deserializer));
    }
    return ans_;
  }

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint16List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(BigInt, BackgroundNotificationState)>
      sse_decode_list_record_usize_background_notification_state(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(BigInt, BackgroundNotificationState)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_record_usize_background_notification_state(deserializer));
    }
    return ans_;
  }

  @protected
  List<(BigInt, String)> sse_decode_list_record_usize_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(BigInt, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_usize_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<TransactionRequestInfo> sse_decode_list_transaction_request_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TransactionRequestInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_transaction_request_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<WalletInfo> sse_decode_list_wallet_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WalletInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_wallet_info(deserializer));
    }
    return ans_;
  }

  @protected
  NetworkConfigInfo sse_decode_network_config_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_chain = sse_decode_String(deserializer);
    var var_shortName = sse_decode_String(deserializer);
    var var_rpc = sse_decode_list_String(deserializer);
    var var_features = sse_decode_list_prim_u_16_strict(deserializer);
    var var_chainId = sse_decode_u_64(deserializer);
    var var_slip44 = sse_decode_u_32(deserializer);
    var var_chainHash = sse_decode_u_64(deserializer);
    var var_ens = sse_decode_opt_String(deserializer);
    var var_explorers = sse_decode_list_explorer_info(deserializer);
    var var_fallbackEnabled = sse_decode_bool(deserializer);
    var var_testnet = sse_decode_opt_box_autoadd_bool(deserializer);
    return NetworkConfigInfo(
        name: var_name,
        chain: var_chain,
        shortName: var_shortName,
        rpc: var_rpc,
        features: var_features,
        chainId: var_chainId,
        slip44: var_slip44,
        chainHash: var_chainHash,
        ens: var_ens,
        explorers: var_explorers,
        fallbackEnabled: var_fallbackEnabled,
        testnet: var_testnet);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_U128(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_U128(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BaseTokenInfo? sse_decode_opt_box_autoadd_base_token_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_base_token_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ColorsInfo? sse_decode_opt_box_autoadd_colors_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_colors_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TransactionRequestEVM? sse_decode_opt_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_transaction_request_evm(deserializer));
    } else {
      return null;
    }
  }

  @protected
  TransactionRequestScilla?
      sse_decode_opt_box_autoadd_transaction_request_scilla(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_transaction_request_scilla(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<AccessListItem>? sse_decode_opt_list_access_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_access_list_item(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  QRcodeScanResultInfo sse_decode_q_rcode_scan_result_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_recipient = sse_decode_String(deserializer);
    var var_provider = sse_decode_opt_String(deserializer);
    var var_tokenAddress = sse_decode_opt_String(deserializer);
    var var_amount = sse_decode_opt_String(deserializer);
    return QRcodeScanResultInfo(
        recipient: var_recipient,
        provider: var_provider,
        tokenAddress: var_tokenAddress,
        amount: var_amount);
  }

  @protected
  QrConfigInfo sse_decode_qr_config_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_size = sse_decode_u_32(deserializer);
    var var_gapless = sse_decode_bool(deserializer);
    var var_color = sse_decode_u_32(deserializer);
    var var_eyeShape = sse_decode_u_8(deserializer);
    var var_dataModuleShape = sse_decode_u_8(deserializer);
    return QrConfigInfo(
        size: var_size,
        gapless: var_gapless,
        color: var_color,
        eyeShape: var_eyeShape,
        dataModuleShape: var_dataModuleShape);
  }

  @protected
  (Uint8List, String) sse_decode_record_list_prim_u_8_strict_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_list_prim_u_8_strict(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (BigInt, BackgroundNotificationState)
      sse_decode_record_usize_background_notification_state(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_usize(deserializer);
    var var_field1 = sse_decode_background_notification_state(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (BigInt, String) sse_decode_record_usize_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_usize(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  TokenTransferParamsInfo sse_decode_token_transfer_params_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletIndex = sse_decode_usize(deserializer);
    var var_accountIndex = sse_decode_usize(deserializer);
    var var_tokenIndex = sse_decode_usize(deserializer);
    var var_amount = sse_decode_String(deserializer);
    var var_recipient = sse_decode_String(deserializer);
    return TokenTransferParamsInfo(
        walletIndex: var_walletIndex,
        accountIndex: var_accountIndex,
        tokenIndex: var_tokenIndex,
        amount: var_amount,
        recipient: var_recipient);
  }

  @protected
  TransactionMetadataInfo sse_decode_transaction_metadata_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chainHash = sse_decode_u_64(deserializer);
    var var_hash = sse_decode_opt_String(deserializer);
    var var_info = sse_decode_opt_String(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    var var_title = sse_decode_opt_String(deserializer);
    var var_signer = sse_decode_opt_String(deserializer);
    var var_tokenInfo =
        sse_decode_opt_box_autoadd_base_token_info(deserializer);
    return TransactionMetadataInfo(
        chainHash: var_chainHash,
        hash: var_hash,
        info: var_info,
        icon: var_icon,
        title: var_title,
        signer: var_signer,
        tokenInfo: var_tokenInfo);
  }

  @protected
  TransactionRequestEVM sse_decode_transaction_request_evm(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nonce = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_from = sse_decode_opt_String(deserializer);
    var var_to = sse_decode_opt_String(deserializer);
    var var_value = sse_decode_opt_String(deserializer);
    var var_gasLimit = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_data = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_maxFeePerGas = sse_decode_opt_U128(deserializer);
    var var_maxPriorityFeePerGas = sse_decode_opt_U128(deserializer);
    var var_gasPrice = sse_decode_opt_U128(deserializer);
    var var_chainId = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_accessList = sse_decode_opt_list_access_list_item(deserializer);
    var var_blobVersionedHashes = sse_decode_opt_list_String(deserializer);
    var var_maxFeePerBlobGas = sse_decode_opt_U128(deserializer);
    return TransactionRequestEVM(
        nonce: var_nonce,
        from: var_from,
        to: var_to,
        value: var_value,
        gasLimit: var_gasLimit,
        data: var_data,
        maxFeePerGas: var_maxFeePerGas,
        maxPriorityFeePerGas: var_maxPriorityFeePerGas,
        gasPrice: var_gasPrice,
        chainId: var_chainId,
        accessList: var_accessList,
        blobVersionedHashes: var_blobVersionedHashes,
        maxFeePerBlobGas: var_maxFeePerBlobGas);
  }

  @protected
  TransactionRequestInfo sse_decode_transaction_request_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_metadata = sse_decode_transaction_metadata_info(deserializer);
    var var_scilla =
        sse_decode_opt_box_autoadd_transaction_request_scilla(deserializer);
    var var_evm =
        sse_decode_opt_box_autoadd_transaction_request_evm(deserializer);
    return TransactionRequestInfo(
        metadata: var_metadata, scilla: var_scilla, evm: var_evm);
  }

  @protected
  TransactionRequestScilla sse_decode_transaction_request_scilla(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_chainId = sse_decode_u_16(deserializer);
    var var_nonce = sse_decode_u_64(deserializer);
    var var_gasPrice = sse_decode_U128(deserializer);
    var var_gasLimit = sse_decode_u_64(deserializer);
    var var_toAddr = sse_decode_String(deserializer);
    var var_amount = sse_decode_U128(deserializer);
    var var_code = sse_decode_String(deserializer);
    var var_data = sse_decode_String(deserializer);
    return TransactionRequestScilla(
        chainId: var_chainId,
        nonce: var_nonce,
        gasPrice: var_gasPrice,
        gasLimit: var_gasLimit,
        toAddr: var_toAddr,
        amount: var_amount,
        code: var_code,
        data: var_data);
  }

  @protected
  TransactionStatusInfo sse_decode_transaction_status_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TransactionStatusInfo.values[inner];
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WalletArgonParamsInfo sse_decode_wallet_argon_params_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_memory = sse_decode_u_32(deserializer);
    var var_iterations = sse_decode_u_32(deserializer);
    var var_threads = sse_decode_u_32(deserializer);
    var var_secret = sse_decode_String(deserializer);
    return WalletArgonParamsInfo(
        memory: var_memory,
        iterations: var_iterations,
        threads: var_threads,
        secret: var_secret);
  }

  @protected
  WalletInfo sse_decode_wallet_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_walletType = sse_decode_String(deserializer);
    var var_walletName = sse_decode_String(deserializer);
    var var_authType = sse_decode_String(deserializer);
    var var_walletAddress = sse_decode_String(deserializer);
    var var_accounts = sse_decode_list_account_info(deserializer);
    var var_selectedAccount = sse_decode_usize(deserializer);
    var var_tokens = sse_decode_list_f_token_info(deserializer);
    var var_settings = sse_decode_wallet_settings_info(deserializer);
    var var_defaultChainHash = sse_decode_u_64(deserializer);
    return WalletInfo(
        walletType: var_walletType,
        walletName: var_walletName,
        authType: var_authType,
        walletAddress: var_walletAddress,
        accounts: var_accounts,
        selectedAccount: var_selectedAccount,
        tokens: var_tokens,
        settings: var_settings,
        defaultChainHash: var_defaultChainHash);
  }

  @protected
  WalletSettingsInfo sse_decode_wallet_settings_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cipherOrders = sse_decode_list_prim_u_8_strict(deserializer);
    var var_argonParams = sse_decode_wallet_argon_params_info(deserializer);
    var var_currencyConvert = sse_decode_opt_String(deserializer);
    var var_ipfsNode = sse_decode_opt_String(deserializer);
    var var_ensEnabled = sse_decode_bool(deserializer);
    var var_gasControlEnabled = sse_decode_bool(deserializer);
    var var_nodeRankingEnabled = sse_decode_bool(deserializer);
    var var_maxConnections = sse_decode_u_8(deserializer);
    var var_requestTimeoutSecs = sse_decode_u_32(deserializer);
    return WalletSettingsInfo(
        cipherOrders: var_cipherOrders,
        argonParams: var_argonParams,
        currencyConvert: var_currencyConvert,
        ipfsNode: var_ipfsNode,
        ensEnabled: var_ensEnabled,
        gasControlEnabled: var_gasControlEnabled,
        nodeRankingEnabled: var_nodeRankingEnabled,
        maxConnections: var_maxConnections,
        requestTimeoutSecs: var_requestTimeoutSecs);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_usize_String(
      Map<BigInt, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_usize_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_usize_background_notification_state(
      Map<BigInt, BackgroundNotificationState> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_usize_background_notification_state(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_U128(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.toString(), serializer);
  }

  @protected
  void sse_encode_access_list_item(
      AccessListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_list_String(self.storageKeys, serializer);
  }

  @protected
  void sse_encode_account_info(AccountInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.addr, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_u_64(self.chainHash, serializer);
    sse_encode_usize(self.index, serializer);
  }

  @protected
  void sse_encode_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.walletIndex, serializer);
    sse_encode_usize(self.accountIndex, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.passphrase, serializer);
    sse_encode_list_String(self.identifiers, serializer);
    sse_encode_opt_String(self.password, serializer);
    sse_encode_opt_String(self.sessionCipher, serializer);
    sse_encode_u_64(self.chainHash, serializer);
  }

  @protected
  void sse_encode_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sk, serializer);
    sse_encode_String(self.password, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_String(self.biometricType, serializer);
    sse_encode_list_String(self.identifiers, serializer);
    sse_encode_u_64(self.chainHash, serializer);
  }

  @protected
  void sse_encode_address_book_entry_info(
      AddressBookEntryInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.addr, serializer);
    sse_encode_usize(self.net, serializer);
  }

  @protected
  void sse_encode_background_notification_state(
      BackgroundNotificationState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.transactions, serializer);
    sse_encode_bool(self.price, serializer);
    sse_encode_bool(self.security, serializer);
    sse_encode_bool(self.balance, serializer);
  }

  @protected
  void sse_encode_background_state(
      BackgroundState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_wallet_info(self.wallets, serializer);
    sse_encode_Map_usize_background_notification_state(
        self.notificationsWalletStates, serializer);
    sse_encode_bool(self.notificationsGlobalEnabled, serializer);
    sse_encode_String(self.locale, serializer);
    sse_encode_u_8(self.appearances, serializer);
    sse_encode_list_network_config_info(self.providers, serializer);
  }

  @protected
  void sse_encode_base_token_info(
      BaseTokenInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.symbol, serializer);
    sse_encode_u_8(self.decimals, serializer);
  }

  @protected
  void sse_encode_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.password, serializer);
    sse_encode_String(self.mnemonicStr, serializer);
    sse_encode_list_record_usize_string(self.accounts, serializer);
    sse_encode_String(self.passphrase, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_String(self.biometricType, serializer);
    sse_encode_u_64(self.chainHash, serializer);
    sse_encode_list_String(self.identifiers, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_add_next_bip_39_account_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_add_sk_wallet_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_base_token_info(
      BaseTokenInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_base_token_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bip_39_add_wallet_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_colors_info(
      ColorsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_colors_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_connection_info(
      ConnectionInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connection_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_token_info(
      FTokenInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_token_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ledger_params_input(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_network_config_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_qr_config_info(
      QrConfigInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_qr_config_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_token_transfer_params_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transaction_request_evm(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transaction_request_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transaction_request_scilla(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wallet_settings_info(self, serializer);
  }

  @protected
  void sse_encode_colors_info(ColorsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.primary, serializer);
    sse_encode_opt_String(self.secondary, serializer);
    sse_encode_opt_String(self.background, serializer);
    sse_encode_opt_String(self.text, serializer);
  }

  @protected
  void sse_encode_connection_info(
      ConnectionInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.domain, serializer);
    sse_encode_list_prim_usize_strict(self.walletIndexes, serializer);
    sse_encode_opt_String(self.favicon, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_box_autoadd_colors_info(self.colors, serializer);
    sse_encode_u_64(self.lastConnected, serializer);
    sse_encode_bool(self.canReadAccounts, serializer);
    sse_encode_bool(self.canRequestSignatures, serializer);
    sse_encode_bool(self.canSuggestTokens, serializer);
    sse_encode_bool(self.canSuggestTransactions, serializer);
  }

  @protected
  void sse_encode_explorer_info(ExplorerInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_String(self.icon, serializer);
    sse_encode_u_16(self.standard, serializer);
  }

  @protected
  void sse_encode_f_token_info(FTokenInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.symbol, serializer);
    sse_encode_u_8(self.decimals, serializer);
    sse_encode_String(self.addr, serializer);
    sse_encode_opt_String(self.logo, serializer);
    sse_encode_Map_usize_String(self.balances, serializer);
    sse_encode_bool(self.default_, serializer);
    sse_encode_bool(self.native, serializer);
    sse_encode_u_64(self.chainHash, serializer);
  }

  @protected
  void sse_encode_gas_fee_history_info(
      GasFeeHistoryInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_U128(self.maxFee, serializer);
    sse_encode_U128(self.priorityFee, serializer);
    sse_encode_U128(self.baseFee, serializer);
  }

  @protected
  void sse_encode_gas_info(GasInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_U128(self.gasPrice, serializer);
    sse_encode_U128(self.maxPriorityFee, serializer);
    sse_encode_gas_fee_history_info(self.feeHistory, serializer);
    sse_encode_u_64(self.txEstimateGas, serializer);
    sse_encode_U128(self.blobBaseFee, serializer);
  }

  @protected
  void sse_encode_historical_transaction_info(
      HistoricalTransactionInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.amount, serializer);
    sse_encode_String(self.sender, serializer);
    sse_encode_String(self.recipient, serializer);
    sse_encode_opt_String(self.teg, serializer);
    sse_encode_transaction_status_info(self.status, serializer);
    sse_encode_opt_U128(self.confirmed, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_U128(self.fee, serializer);
    sse_encode_opt_String(self.icon, serializer);
    sse_encode_opt_String(self.title, serializer);
    sse_encode_u_64(self.nonce, serializer);
    sse_encode_opt_box_autoadd_base_token_info(self.tokenInfo, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_key_pair_info(KeyPairInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sk, serializer);
    sse_encode_String(self.pk, serializer);
  }

  @protected
  void sse_encode_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.pubKey, serializer);
    sse_encode_usize(self.walletIndex, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_String(self.ledgerId, serializer);
    sse_encode_String(self.accountName, serializer);
    sse_encode_String(self.biometricType, serializer);
    sse_encode_list_String(self.identifiers, serializer);
    sse_encode_u_64(self.chainHash, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_access_list_item(
      List<AccessListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_access_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_account_info(
      List<AccountInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_account_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_address_book_entry_info(
      List<AddressBookEntryInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_address_book_entry_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_connection_info(
      List<ConnectionInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_connection_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_explorer_info(
      List<ExplorerInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_explorer_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_f_token_info(
      List<FTokenInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_f_token_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_historical_transaction_info(
      List<HistoricalTransactionInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_historical_transaction_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_network_config_info(
      List<NetworkConfigInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_network_config_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint16List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_usize_background_notification_state(
      List<(BigInt, BackgroundNotificationState)> self,
      SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_usize_background_notification_state(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_usize_string(
      List<(BigInt, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_usize_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_transaction_request_info(
      List<TransactionRequestInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_transaction_request_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_wallet_info(
      List<WalletInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_wallet_info(item, serializer);
    }
  }

  @protected
  void sse_encode_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.chain, serializer);
    sse_encode_String(self.shortName, serializer);
    sse_encode_list_String(self.rpc, serializer);
    sse_encode_list_prim_u_16_strict(self.features, serializer);
    sse_encode_u_64(self.chainId, serializer);
    sse_encode_u_32(self.slip44, serializer);
    sse_encode_u_64(self.chainHash, serializer);
    sse_encode_opt_String(self.ens, serializer);
    sse_encode_list_explorer_info(self.explorers, serializer);
    sse_encode_bool(self.fallbackEnabled, serializer);
    sse_encode_opt_box_autoadd_bool(self.testnet, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_U128(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_U128(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_base_token_info(
      BaseTokenInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_base_token_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_colors_info(
      ColorsInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_colors_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_evm(
      TransactionRequestEVM? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_transaction_request_evm(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_transaction_request_scilla(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_access_list_item(
      List<AccessListItem>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_access_list_item(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_q_rcode_scan_result_info(
      QRcodeScanResultInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.recipient, serializer);
    sse_encode_opt_String(self.provider, serializer);
    sse_encode_opt_String(self.tokenAddress, serializer);
    sse_encode_opt_String(self.amount, serializer);
  }

  @protected
  void sse_encode_qr_config_info(QrConfigInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.size, serializer);
    sse_encode_bool(self.gapless, serializer);
    sse_encode_u_32(self.color, serializer);
    sse_encode_u_8(self.eyeShape, serializer);
    sse_encode_u_8(self.dataModuleShape, serializer);
  }

  @protected
  void sse_encode_record_list_prim_u_8_strict_string(
      (Uint8List, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_usize_background_notification_state(
      (BigInt, BackgroundNotificationState) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.$1, serializer);
    sse_encode_background_notification_state(self.$2, serializer);
  }

  @protected
  void sse_encode_record_usize_string(
      (BigInt, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.walletIndex, serializer);
    sse_encode_usize(self.accountIndex, serializer);
    sse_encode_usize(self.tokenIndex, serializer);
    sse_encode_String(self.amount, serializer);
    sse_encode_String(self.recipient, serializer);
  }

  @protected
  void sse_encode_transaction_metadata_info(
      TransactionMetadataInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.chainHash, serializer);
    sse_encode_opt_String(self.hash, serializer);
    sse_encode_opt_String(self.info, serializer);
    sse_encode_opt_String(self.icon, serializer);
    sse_encode_opt_String(self.title, serializer);
    sse_encode_opt_String(self.signer, serializer);
    sse_encode_opt_box_autoadd_base_token_info(self.tokenInfo, serializer);
  }

  @protected
  void sse_encode_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.nonce, serializer);
    sse_encode_opt_String(self.from, serializer);
    sse_encode_opt_String(self.to, serializer);
    sse_encode_opt_String(self.value, serializer);
    sse_encode_opt_box_autoadd_u_64(self.gasLimit, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.data, serializer);
    sse_encode_opt_U128(self.maxFeePerGas, serializer);
    sse_encode_opt_U128(self.maxPriorityFeePerGas, serializer);
    sse_encode_opt_U128(self.gasPrice, serializer);
    sse_encode_opt_box_autoadd_u_64(self.chainId, serializer);
    sse_encode_opt_list_access_list_item(self.accessList, serializer);
    sse_encode_opt_list_String(self.blobVersionedHashes, serializer);
    sse_encode_opt_U128(self.maxFeePerBlobGas, serializer);
  }

  @protected
  void sse_encode_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_transaction_metadata_info(self.metadata, serializer);
    sse_encode_opt_box_autoadd_transaction_request_scilla(
        self.scilla, serializer);
    sse_encode_opt_box_autoadd_transaction_request_evm(self.evm, serializer);
  }

  @protected
  void sse_encode_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.chainId, serializer);
    sse_encode_u_64(self.nonce, serializer);
    sse_encode_U128(self.gasPrice, serializer);
    sse_encode_u_64(self.gasLimit, serializer);
    sse_encode_String(self.toAddr, serializer);
    sse_encode_U128(self.amount, serializer);
    sse_encode_String(self.code, serializer);
    sse_encode_String(self.data, serializer);
  }

  @protected
  void sse_encode_transaction_status_info(
      TransactionStatusInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wallet_argon_params_info(
      WalletArgonParamsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.memory, serializer);
    sse_encode_u_32(self.iterations, serializer);
    sse_encode_u_32(self.threads, serializer);
    sse_encode_String(self.secret, serializer);
  }

  @protected
  void sse_encode_wallet_info(WalletInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.walletType, serializer);
    sse_encode_String(self.walletName, serializer);
    sse_encode_String(self.authType, serializer);
    sse_encode_String(self.walletAddress, serializer);
    sse_encode_list_account_info(self.accounts, serializer);
    sse_encode_usize(self.selectedAccount, serializer);
    sse_encode_list_f_token_info(self.tokens, serializer);
    sse_encode_wallet_settings_info(self.settings, serializer);
    sse_encode_u_64(self.defaultChainHash, serializer);
  }

  @protected
  void sse_encode_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.cipherOrders, serializer);
    sse_encode_wallet_argon_params_info(self.argonParams, serializer);
    sse_encode_opt_String(self.currencyConvert, serializer);
    sse_encode_opt_String(self.ipfsNode, serializer);
    sse_encode_bool(self.ensEnabled, serializer);
    sse_encode_bool(self.gasControlEnabled, serializer);
    sse_encode_bool(self.nodeRankingEnabled, serializer);
    sse_encode_u_8(self.maxConnections, serializer);
    sse_encode_u_32(self.requestTimeoutSecs, serializer);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/lib/src/rust/frb_generated.io.dart`:

```dart
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/auth.dart';
import 'api/backend.dart';
import 'api/book.dart';
import 'api/cache.dart';
import 'api/connections.dart';
import 'api/ledger.dart';
import 'api/methods.dart';
import 'api/provider.dart';
import 'api/qrcode.dart';
import 'api/settings.dart';
import 'api/token.dart';
import 'api/transaction.dart';
import 'api/wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'frb_generated.dart';
import 'models/account.dart';
import 'models/background.dart';
import 'models/book.dart';
import 'models/connection.dart';
import 'models/ftoken.dart';
import 'models/gas.dart';
import 'models/keypair.dart';
import 'models/notification.dart';
import 'models/provider.dart';
import 'models/qrcode.dart';
import 'models/settings.dart';
import 'models/transactions/access_list.dart';
import 'models/transactions/base_token.dart';
import 'models/transactions/evm.dart';
import 'models/transactions/history.dart';
import 'models/transactions/request.dart';
import 'models/transactions/scilla.dart';
import 'models/transactions/transaction_metadata.dart';
import 'models/wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw);

  @protected
  Map<BigInt, String> dco_decode_Map_usize_String(dynamic raw);

  @protected
  Map<BigInt, BackgroundNotificationState>
      dco_decode_Map_usize_background_notification_state(dynamic raw);

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw);

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  BigInt dco_decode_U128(dynamic raw);

  @protected
  AccessListItem dco_decode_access_list_item(dynamic raw);

  @protected
  AccountInfo dco_decode_account_info(dynamic raw);

  @protected
  AddNextBip39AccountParams dco_decode_add_next_bip_39_account_params(
      dynamic raw);

  @protected
  AddSKWalletParams dco_decode_add_sk_wallet_params(dynamic raw);

  @protected
  AddressBookEntryInfo dco_decode_address_book_entry_info(dynamic raw);

  @protected
  BackgroundNotificationState dco_decode_background_notification_state(
      dynamic raw);

  @protected
  BackgroundState dco_decode_background_state(dynamic raw);

  @protected
  BaseTokenInfo dco_decode_base_token_info(dynamic raw);

  @protected
  Bip39AddWalletParams dco_decode_bip_39_add_wallet_params(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  AddNextBip39AccountParams
      dco_decode_box_autoadd_add_next_bip_39_account_params(dynamic raw);

  @protected
  AddSKWalletParams dco_decode_box_autoadd_add_sk_wallet_params(dynamic raw);

  @protected
  BaseTokenInfo dco_decode_box_autoadd_base_token_info(dynamic raw);

  @protected
  Bip39AddWalletParams dco_decode_box_autoadd_bip_39_add_wallet_params(
      dynamic raw);

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw);

  @protected
  ColorsInfo dco_decode_box_autoadd_colors_info(dynamic raw);

  @protected
  ConnectionInfo dco_decode_box_autoadd_connection_info(dynamic raw);

  @protected
  FTokenInfo dco_decode_box_autoadd_f_token_info(dynamic raw);

  @protected
  LedgerParamsInput dco_decode_box_autoadd_ledger_params_input(dynamic raw);

  @protected
  NetworkConfigInfo dco_decode_box_autoadd_network_config_info(dynamic raw);

  @protected
  QrConfigInfo dco_decode_box_autoadd_qr_config_info(dynamic raw);

  @protected
  TokenTransferParamsInfo dco_decode_box_autoadd_token_transfer_params_info(
      dynamic raw);

  @protected
  TransactionRequestEVM dco_decode_box_autoadd_transaction_request_evm(
      dynamic raw);

  @protected
  TransactionRequestInfo dco_decode_box_autoadd_transaction_request_info(
      dynamic raw);

  @protected
  TransactionRequestScilla dco_decode_box_autoadd_transaction_request_scilla(
      dynamic raw);

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw);

  @protected
  WalletSettingsInfo dco_decode_box_autoadd_wallet_settings_info(dynamic raw);

  @protected
  ColorsInfo dco_decode_colors_info(dynamic raw);

  @protected
  ConnectionInfo dco_decode_connection_info(dynamic raw);

  @protected
  ExplorerInfo dco_decode_explorer_info(dynamic raw);

  @protected
  FTokenInfo dco_decode_f_token_info(dynamic raw);

  @protected
  GasFeeHistoryInfo dco_decode_gas_fee_history_info(dynamic raw);

  @protected
  GasInfo dco_decode_gas_info(dynamic raw);

  @protected
  HistoricalTransactionInfo dco_decode_historical_transaction_info(dynamic raw);

  @protected
  int dco_decode_i_32(dynamic raw);

  @protected
  KeyPairInfo dco_decode_key_pair_info(dynamic raw);

  @protected
  LedgerParamsInput dco_decode_ledger_params_input(dynamic raw);

  @protected
  List<String> dco_decode_list_String(dynamic raw);

  @protected
  List<AccessListItem> dco_decode_list_access_list_item(dynamic raw);

  @protected
  List<AccountInfo> dco_decode_list_account_info(dynamic raw);

  @protected
  List<AddressBookEntryInfo> dco_decode_list_address_book_entry_info(
      dynamic raw);

  @protected
  List<ConnectionInfo> dco_decode_list_connection_info(dynamic raw);

  @protected
  List<ExplorerInfo> dco_decode_list_explorer_info(dynamic raw);

  @protected
  List<FTokenInfo> dco_decode_list_f_token_info(dynamic raw);

  @protected
  List<HistoricalTransactionInfo> dco_decode_list_historical_transaction_info(
      dynamic raw);

  @protected
  List<NetworkConfigInfo> dco_decode_list_network_config_info(dynamic raw);

  @protected
  Uint16List dco_decode_list_prim_u_16_strict(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw);

  @protected
  List<(BigInt, BackgroundNotificationState)>
      dco_decode_list_record_usize_background_notification_state(dynamic raw);

  @protected
  List<(BigInt, String)> dco_decode_list_record_usize_string(dynamic raw);

  @protected
  List<TransactionRequestInfo> dco_decode_list_transaction_request_info(
      dynamic raw);

  @protected
  List<WalletInfo> dco_decode_list_wallet_info(dynamic raw);

  @protected
  NetworkConfigInfo dco_decode_network_config_info(dynamic raw);

  @protected
  String? dco_decode_opt_String(dynamic raw);

  @protected
  BigInt? dco_decode_opt_U128(dynamic raw);

  @protected
  BaseTokenInfo? dco_decode_opt_box_autoadd_base_token_info(dynamic raw);

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw);

  @protected
  ColorsInfo? dco_decode_opt_box_autoadd_colors_info(dynamic raw);

  @protected
  TransactionRequestEVM? dco_decode_opt_box_autoadd_transaction_request_evm(
      dynamic raw);

  @protected
  TransactionRequestScilla?
      dco_decode_opt_box_autoadd_transaction_request_scilla(dynamic raw);

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw);

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw);

  @protected
  List<AccessListItem>? dco_decode_opt_list_access_list_item(dynamic raw);

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw);

  @protected
  QRcodeScanResultInfo dco_decode_q_rcode_scan_result_info(dynamic raw);

  @protected
  QrConfigInfo dco_decode_qr_config_info(dynamic raw);

  @protected
  (Uint8List, String) dco_decode_record_list_prim_u_8_strict_string(
      dynamic raw);

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw);

  @protected
  (BigInt, BackgroundNotificationState)
      dco_decode_record_usize_background_notification_state(dynamic raw);

  @protected
  (BigInt, String) dco_decode_record_usize_string(dynamic raw);

  @protected
  TokenTransferParamsInfo dco_decode_token_transfer_params_info(dynamic raw);

  @protected
  TransactionMetadataInfo dco_decode_transaction_metadata_info(dynamic raw);

  @protected
  TransactionRequestEVM dco_decode_transaction_request_evm(dynamic raw);

  @protected
  TransactionRequestInfo dco_decode_transaction_request_info(dynamic raw);

  @protected
  TransactionRequestScilla dco_decode_transaction_request_scilla(dynamic raw);

  @protected
  TransactionStatusInfo dco_decode_transaction_status_info(dynamic raw);

  @protected
  int dco_decode_u_16(dynamic raw);

  @protected
  int dco_decode_u_32(dynamic raw);

  @protected
  BigInt dco_decode_u_64(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  BigInt dco_decode_usize(dynamic raw);

  @protected
  WalletArgonParamsInfo dco_decode_wallet_argon_params_info(dynamic raw);

  @protected
  WalletInfo dco_decode_wallet_info(dynamic raw);

  @protected
  WalletSettingsInfo dco_decode_wallet_settings_info(dynamic raw);

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer);

  @protected
  Map<BigInt, String> sse_decode_Map_usize_String(SseDeserializer deserializer);

  @protected
  Map<BigInt, BackgroundNotificationState>
      sse_decode_Map_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
      SseDeserializer deserializer);

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_U128(SseDeserializer deserializer);

  @protected
  AccessListItem sse_decode_access_list_item(SseDeserializer deserializer);

  @protected
  AccountInfo sse_decode_account_info(SseDeserializer deserializer);

  @protected
  AddNextBip39AccountParams sse_decode_add_next_bip_39_account_params(
      SseDeserializer deserializer);

  @protected
  AddSKWalletParams sse_decode_add_sk_wallet_params(
      SseDeserializer deserializer);

  @protected
  AddressBookEntryInfo sse_decode_address_book_entry_info(
      SseDeserializer deserializer);

  @protected
  BackgroundNotificationState sse_decode_background_notification_state(
      SseDeserializer deserializer);

  @protected
  BackgroundState sse_decode_background_state(SseDeserializer deserializer);

  @protected
  BaseTokenInfo sse_decode_base_token_info(SseDeserializer deserializer);

  @protected
  Bip39AddWalletParams sse_decode_bip_39_add_wallet_params(
      SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  AddNextBip39AccountParams
      sse_decode_box_autoadd_add_next_bip_39_account_params(
          SseDeserializer deserializer);

  @protected
  AddSKWalletParams sse_decode_box_autoadd_add_sk_wallet_params(
      SseDeserializer deserializer);

  @protected
  BaseTokenInfo sse_decode_box_autoadd_base_token_info(
      SseDeserializer deserializer);

  @protected
  Bip39AddWalletParams sse_decode_box_autoadd_bip_39_add_wallet_params(
      SseDeserializer deserializer);

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer);

  @protected
  ColorsInfo sse_decode_box_autoadd_colors_info(SseDeserializer deserializer);

  @protected
  ConnectionInfo sse_decode_box_autoadd_connection_info(
      SseDeserializer deserializer);

  @protected
  FTokenInfo sse_decode_box_autoadd_f_token_info(SseDeserializer deserializer);

  @protected
  LedgerParamsInput sse_decode_box_autoadd_ledger_params_input(
      SseDeserializer deserializer);

  @protected
  NetworkConfigInfo sse_decode_box_autoadd_network_config_info(
      SseDeserializer deserializer);

  @protected
  QrConfigInfo sse_decode_box_autoadd_qr_config_info(
      SseDeserializer deserializer);

  @protected
  TokenTransferParamsInfo sse_decode_box_autoadd_token_transfer_params_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM sse_decode_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestInfo sse_decode_box_autoadd_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla sse_decode_box_autoadd_transaction_request_scilla(
      SseDeserializer deserializer);

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  WalletSettingsInfo sse_decode_box_autoadd_wallet_settings_info(
      SseDeserializer deserializer);

  @protected
  ColorsInfo sse_decode_colors_info(SseDeserializer deserializer);

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer);

  @protected
  ExplorerInfo sse_decode_explorer_info(SseDeserializer deserializer);

  @protected
  FTokenInfo sse_decode_f_token_info(SseDeserializer deserializer);

  @protected
  GasFeeHistoryInfo sse_decode_gas_fee_history_info(
      SseDeserializer deserializer);

  @protected
  GasInfo sse_decode_gas_info(SseDeserializer deserializer);

  @protected
  HistoricalTransactionInfo sse_decode_historical_transaction_info(
      SseDeserializer deserializer);

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  KeyPairInfo sse_decode_key_pair_info(SseDeserializer deserializer);

  @protected
  LedgerParamsInput sse_decode_ledger_params_input(
      SseDeserializer deserializer);

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer);

  @protected
  List<AccessListItem> sse_decode_list_access_list_item(
      SseDeserializer deserializer);

  @protected
  List<AccountInfo> sse_decode_list_account_info(SseDeserializer deserializer);

  @protected
  List<AddressBookEntryInfo> sse_decode_list_address_book_entry_info(
      SseDeserializer deserializer);

  @protected
  List<ConnectionInfo> sse_decode_list_connection_info(
      SseDeserializer deserializer);

  @protected
  List<ExplorerInfo> sse_decode_list_explorer_info(
      SseDeserializer deserializer);

  @protected
  List<FTokenInfo> sse_decode_list_f_token_info(SseDeserializer deserializer);

  @protected
  List<HistoricalTransactionInfo> sse_decode_list_historical_transaction_info(
      SseDeserializer deserializer);

  @protected
  List<NetworkConfigInfo> sse_decode_list_network_config_info(
      SseDeserializer deserializer);

  @protected
  Uint16List sse_decode_list_prim_u_16_strict(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer);

  @protected
  List<(BigInt, BackgroundNotificationState)>
      sse_decode_list_record_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  List<(BigInt, String)> sse_decode_list_record_usize_string(
      SseDeserializer deserializer);

  @protected
  List<TransactionRequestInfo> sse_decode_list_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  List<WalletInfo> sse_decode_list_wallet_info(SseDeserializer deserializer);

  @protected
  NetworkConfigInfo sse_decode_network_config_info(
      SseDeserializer deserializer);

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer);

  @protected
  BigInt? sse_decode_opt_U128(SseDeserializer deserializer);

  @protected
  BaseTokenInfo? sse_decode_opt_box_autoadd_base_token_info(
      SseDeserializer deserializer);

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer);

  @protected
  ColorsInfo? sse_decode_opt_box_autoadd_colors_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM? sse_decode_opt_box_autoadd_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla?
      sse_decode_opt_box_autoadd_transaction_request_scilla(
          SseDeserializer deserializer);

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer);

  @protected
  List<AccessListItem>? sse_decode_opt_list_access_list_item(
      SseDeserializer deserializer);

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  QRcodeScanResultInfo sse_decode_q_rcode_scan_result_info(
      SseDeserializer deserializer);

  @protected
  QrConfigInfo sse_decode_qr_config_info(SseDeserializer deserializer);

  @protected
  (Uint8List, String) sse_decode_record_list_prim_u_8_strict_string(
      SseDeserializer deserializer);

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer);

  @protected
  (BigInt, BackgroundNotificationState)
      sse_decode_record_usize_background_notification_state(
          SseDeserializer deserializer);

  @protected
  (BigInt, String) sse_decode_record_usize_string(SseDeserializer deserializer);

  @protected
  TokenTransferParamsInfo sse_decode_token_transfer_params_info(
      SseDeserializer deserializer);

  @protected
  TransactionMetadataInfo sse_decode_transaction_metadata_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestEVM sse_decode_transaction_request_evm(
      SseDeserializer deserializer);

  @protected
  TransactionRequestInfo sse_decode_transaction_request_info(
      SseDeserializer deserializer);

  @protected
  TransactionRequestScilla sse_decode_transaction_request_scilla(
      SseDeserializer deserializer);

  @protected
  TransactionStatusInfo sse_decode_transaction_status_info(
      SseDeserializer deserializer);

  @protected
  int sse_decode_u_16(SseDeserializer deserializer);

  @protected
  int sse_decode_u_32(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer);

  @protected
  WalletArgonParamsInfo sse_decode_wallet_argon_params_info(
      SseDeserializer deserializer);

  @protected
  WalletInfo sse_decode_wallet_info(SseDeserializer deserializer);

  @protected
  WalletSettingsInfo sse_decode_wallet_settings_info(
      SseDeserializer deserializer);

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer);

  @protected
  void sse_encode_Map_usize_String(
      Map<BigInt, String> self, SseSerializer serializer);

  @protected
  void sse_encode_Map_usize_background_notification_state(
      Map<BigInt, BackgroundNotificationState> self, SseSerializer serializer);

  @protected
  void sse_encode_StreamSink_String_Sse(
      RustStreamSink<String> self, SseSerializer serializer);

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_U128(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_access_list_item(
      AccessListItem self, SseSerializer serializer);

  @protected
  void sse_encode_account_info(AccountInfo self, SseSerializer serializer);

  @protected
  void sse_encode_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer);

  @protected
  void sse_encode_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_address_book_entry_info(
      AddressBookEntryInfo self, SseSerializer serializer);

  @protected
  void sse_encode_background_notification_state(
      BackgroundNotificationState self, SseSerializer serializer);

  @protected
  void sse_encode_background_state(
      BackgroundState self, SseSerializer serializer);

  @protected
  void sse_encode_base_token_info(BaseTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_add_next_bip_39_account_params(
      AddNextBip39AccountParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_add_sk_wallet_params(
      AddSKWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_base_token_info(
      BaseTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_bip_39_add_wallet_params(
      Bip39AddWalletParams self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_colors_info(
      ColorsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_connection_info(
      ConnectionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_f_token_info(
      FTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_qr_config_info(
      QrConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_colors_info(ColorsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_connection_info(
      ConnectionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_explorer_info(ExplorerInfo self, SseSerializer serializer);

  @protected
  void sse_encode_f_token_info(FTokenInfo self, SseSerializer serializer);

  @protected
  void sse_encode_gas_fee_history_info(
      GasFeeHistoryInfo self, SseSerializer serializer);

  @protected
  void sse_encode_gas_info(GasInfo self, SseSerializer serializer);

  @protected
  void sse_encode_historical_transaction_info(
      HistoricalTransactionInfo self, SseSerializer serializer);

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_key_pair_info(KeyPairInfo self, SseSerializer serializer);

  @protected
  void sse_encode_ledger_params_input(
      LedgerParamsInput self, SseSerializer serializer);

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer);

  @protected
  void sse_encode_list_access_list_item(
      List<AccessListItem> self, SseSerializer serializer);

  @protected
  void sse_encode_list_account_info(
      List<AccountInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_address_book_entry_info(
      List<AddressBookEntryInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_connection_info(
      List<ConnectionInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_explorer_info(
      List<ExplorerInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_f_token_info(
      List<FTokenInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_historical_transaction_info(
      List<HistoricalTransactionInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_network_config_info(
      List<NetworkConfigInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_16_strict(
      Uint16List self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer);

  @protected
  void sse_encode_list_record_usize_background_notification_state(
      List<(BigInt, BackgroundNotificationState)> self,
      SseSerializer serializer);

  @protected
  void sse_encode_list_record_usize_string(
      List<(BigInt, String)> self, SseSerializer serializer);

  @protected
  void sse_encode_list_transaction_request_info(
      List<TransactionRequestInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_list_wallet_info(
      List<WalletInfo> self, SseSerializer serializer);

  @protected
  void sse_encode_network_config_info(
      NetworkConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_U128(BigInt? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_base_token_info(
      BaseTokenInfo? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_colors_info(
      ColorsInfo? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_evm(
      TransactionRequestEVM? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_transaction_request_scilla(
      TransactionRequestScilla? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_String(List<String>? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_access_list_item(
      List<AccessListItem>? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer);

  @protected
  void sse_encode_q_rcode_scan_result_info(
      QRcodeScanResultInfo self, SseSerializer serializer);

  @protected
  void sse_encode_qr_config_info(QrConfigInfo self, SseSerializer serializer);

  @protected
  void sse_encode_record_list_prim_u_8_strict_string(
      (Uint8List, String) self, SseSerializer serializer);

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer);

  @protected
  void sse_encode_record_usize_background_notification_state(
      (BigInt, BackgroundNotificationState) self, SseSerializer serializer);

  @protected
  void sse_encode_record_usize_string(
      (BigInt, String) self, SseSerializer serializer);

  @protected
  void sse_encode_token_transfer_params_info(
      TokenTransferParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_metadata_info(
      TransactionMetadataInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_evm(
      TransactionRequestEVM self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_info(
      TransactionRequestInfo self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_request_scilla(
      TransactionRequestScilla self, SseSerializer serializer);

  @protected
  void sse_encode_transaction_status_info(
      TransactionStatusInfo self, SseSerializer serializer);

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_argon_params_info(
      WalletArgonParamsInfo self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_info(WalletInfo self, SseSerializer serializer);

  @protected
  void sse_encode_wallet_settings_info(
      WalletSettingsInfo self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  factory RustLibWire.fromExternalLibrary(ExternalLibrary lib) =>
      RustLibWire(lib.ffiDynamicLibrary);

  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustLibWire(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/build_tool.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'src/build_tool.dart' as build_tool;

Future<void> runMain(List<String> args) async {
  return build_tool.runMain(args);
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/util.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:convert';
import 'dart:io';

import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

import 'logging.dart';
import 'rustup.dart';

final log = Logger("process");

class CommandFailedException implements Exception {
  final String executable;
  final List<String> arguments;
  final ProcessResult result;

  CommandFailedException({
    required this.executable,
    required this.arguments,
    required this.result,
  });

  @override
  String toString() {
    final stdout = result.stdout.toString().trim();
    final stderr = result.stderr.toString().trim();
    return [
      "External Command: $executable ${arguments.map((e) => '"$e"').join(' ')}",
      "Returned Exit Code: ${result.exitCode}",
      kSeparator,
      "STDOUT:",
      if (stdout.isNotEmpty) stdout,
      kSeparator,
      "STDERR:",
      if (stderr.isNotEmpty) stderr,
    ].join('\n');
  }
}

class TestRunCommandArgs {
  final String executable;
  final List<String> arguments;
  final String? workingDirectory;
  final Map<String, String>? environment;
  final bool includeParentEnvironment;
  final bool runInShell;
  final Encoding? stdoutEncoding;
  final Encoding? stderrEncoding;

  TestRunCommandArgs({
    required this.executable,
    required this.arguments,
    this.workingDirectory,
    this.environment,
    this.includeParentEnvironment = true,
    this.runInShell = false,
    this.stdoutEncoding,
    this.stderrEncoding,
  });
}

class TestRunCommandResult {
  TestRunCommandResult({
    this.pid = 1,
    this.exitCode = 0,
    this.stdout = '',
    this.stderr = '',
  });

  final int pid;
  final int exitCode;
  final String stdout;
  final String stderr;
}

TestRunCommandResult Function(TestRunCommandArgs args)? testRunCommandOverride;

ProcessResult runCommand(
  String executable,
  List<String> arguments, {
  String? workingDirectory,
  Map<String, String>? environment,
  bool includeParentEnvironment = true,
  bool runInShell = false,
  Encoding? stdoutEncoding = systemEncoding,
  Encoding? stderrEncoding = systemEncoding,
}) {
  if (testRunCommandOverride != null) {
    final result = testRunCommandOverride!(TestRunCommandArgs(
      executable: executable,
      arguments: arguments,
      workingDirectory: workingDirectory,
      environment: environment,
      includeParentEnvironment: includeParentEnvironment,
      runInShell: runInShell,
      stdoutEncoding: stdoutEncoding,
      stderrEncoding: stderrEncoding,
    ));
    return ProcessResult(
      result.pid,
      result.exitCode,
      result.stdout,
      result.stderr,
    );
  }
  log.finer('Running command $executable ${arguments.join(' ')}');
  final res = Process.runSync(
    _resolveExecutable(executable),
    arguments,
    workingDirectory: workingDirectory,
    environment: environment,
    includeParentEnvironment: includeParentEnvironment,
    runInShell: runInShell,
    stderrEncoding: stderrEncoding,
    stdoutEncoding: stdoutEncoding,
  );
  if (res.exitCode != 0) {
    throw CommandFailedException(
      executable: executable,
      arguments: arguments,
      result: res,
    );
  } else {
    return res;
  }
}

class RustupNotFoundException implements Exception {
  @override
  String toString() {
    return [
      ' ',
      'rustup not found in PATH.',
      ' ',
      'Maybe you need to install Rust? It only takes a minute:',
      ' ',
      if (Platform.isWindows) 'https://www.rust-lang.org/tools/install',
      if (hasHomebrewRustInPath()) ...[
        '\$ brew unlink rust # Unlink homebrew Rust from PATH',
      ],
      if (!Platform.isWindows)
        "\$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh",
      ' ',
    ].join('\n');
  }

  static bool hasHomebrewRustInPath() {
    if (!Platform.isMacOS) {
      return false;
    }
    final envPath = Platform.environment['PATH'] ?? '';
    final paths = envPath.split(':');
    return paths.any((p) {
      return p.contains('homebrew') && File(path.join(p, 'rustc')).existsSync();
    });
  }
}

String _resolveExecutable(String executable) {
  if (executable == 'rustup') {
    final resolved = Rustup.executablePath();
    if (resolved != null) {
      return resolved;
    }
    throw RustupNotFoundException();
  } else {
    return executable;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/rustup.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:collection/collection.dart';
import 'package:path/path.dart' as path;

import 'util.dart';

class _Toolchain {
  _Toolchain(
    this.name,
    this.targets,
  );

  final String name;
  final List<String> targets;
}

class Rustup {
  List<String>? installedTargets(String toolchain) {
    final targets = _installedTargets(toolchain);
    return targets != null ? List.unmodifiable(targets) : null;
  }

  void installToolchain(String toolchain) {
    log.info("Installing Rust toolchain: $toolchain");
    runCommand("rustup", ['toolchain', 'install', toolchain]);
    _installedToolchains
        .add(_Toolchain(toolchain, _getInstalledTargets(toolchain)));
  }

  void installTarget(
    String target, {
    required String toolchain,
  }) {
    log.info("Installing Rust target: $target");
    runCommand("rustup", [
      'target',
      'add',
      '--toolchain',
      toolchain,
      target,
    ]);
    _installedTargets(toolchain)?.add(target);
  }

  final List<_Toolchain> _installedToolchains;

  Rustup() : _installedToolchains = _getInstalledToolchains();

  List<String>? _installedTargets(String toolchain) => _installedToolchains
      .firstWhereOrNull(
          (e) => e.name == toolchain || e.name.startsWith('$toolchain-'))
      ?.targets;

  static List<_Toolchain> _getInstalledToolchains() {
    String extractToolchainName(String line) {
      // ignore (default) after toolchain name
      final parts = line.split(' ');
      return parts[0];
    }

    final res = runCommand("rustup", ['toolchain', 'list']);

    // To list all non-custom toolchains, we need to filter out lines that
    // don't start with "stable", "beta", or "nightly".
    Pattern nonCustom = RegExp(r"^(stable|beta|nightly)");
    final lines = res.stdout
        .toString()
        .split('\n')
        .where((e) => e.isNotEmpty && e.startsWith(nonCustom))
        .map(extractToolchainName)
        .toList(growable: true);

    return lines
        .map(
          (name) => _Toolchain(
            name,
            _getInstalledTargets(name),
          ),
        )
        .toList(growable: true);
  }

  static List<String> _getInstalledTargets(String toolchain) {
    final res = runCommand("rustup", [
      'target',
      'list',
      '--toolchain',
      toolchain,
      '--installed',
    ]);
    final lines = res.stdout
        .toString()
        .split('\n')
        .where((e) => e.isNotEmpty)
        .toList(growable: true);
    return lines;
  }

  bool _didInstallRustSrcForNightly = false;

  void installRustSrcForNightly() {
    if (_didInstallRustSrcForNightly) {
      return;
    }
    // Useful for -Z build-std
    runCommand(
      "rustup",
      ['component', 'add', 'rust-src', '--toolchain', 'nightly'],
    );
    _didInstallRustSrcForNightly = true;
  }

  static String? executablePath() {
    final envPath = Platform.environment['PATH'];
    final envPathSeparator = Platform.isWindows ? ';' : ':';
    final home = Platform.isWindows
        ? Platform.environment['USERPROFILE']
        : Platform.environment['HOME'];
    final paths = [
      if (home != null) path.join(home, '.cargo', 'bin'),
      if (envPath != null) ...envPath.split(envPathSeparator),
    ];
    for (final p in paths) {
      final rustup = Platform.isWindows ? 'rustup.exe' : 'rustup';
      final rustupPath = path.join(p, rustup);
      if (File(rustupPath).existsSync()) {
        return rustupPath;
      }
    }
    return null;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/builder.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'package:collection/collection.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

import 'android_environment.dart';
import 'cargo.dart';
import 'environment.dart';
import 'options.dart';
import 'rustup.dart';
import 'target.dart';
import 'util.dart';

final _log = Logger('builder');

enum BuildConfiguration {
  debug,
  release,
  profile,
}

extension on BuildConfiguration {
  bool get isDebug => this == BuildConfiguration.debug;
  String get rustName => switch (this) {
        BuildConfiguration.debug => 'debug',
        BuildConfiguration.release => 'release',
        BuildConfiguration.profile => 'release',
      };
}

class BuildException implements Exception {
  final String message;

  BuildException(this.message);

  @override
  String toString() {
    return 'BuildException: $message';
  }
}

class BuildEnvironment {
  final BuildConfiguration configuration;
  final CargokitCrateOptions crateOptions;
  final String targetTempDir;
  final String manifestDir;
  final CrateInfo crateInfo;

  final bool isAndroid;
  final String? androidSdkPath;
  final String? androidNdkVersion;
  final int? androidMinSdkVersion;
  final String? javaHome;

  BuildEnvironment({
    required this.configuration,
    required this.crateOptions,
    required this.targetTempDir,
    required this.manifestDir,
    required this.crateInfo,
    required this.isAndroid,
    this.androidSdkPath,
    this.androidNdkVersion,
    this.androidMinSdkVersion,
    this.javaHome,
  });

  static BuildConfiguration parseBuildConfiguration(String value) {
    // XCode configuration adds the flavor to configuration name.
    final firstSegment = value.split('-').first;
    final buildConfiguration = BuildConfiguration.values.firstWhereOrNull(
      (e) => e.name == firstSegment,
    );
    if (buildConfiguration == null) {
      _log.warning('Unknown build configuraiton $value, will assume release');
      return BuildConfiguration.release;
    }
    return buildConfiguration;
  }

  static BuildEnvironment fromEnvironment({
    required bool isAndroid,
  }) {
    final buildConfiguration =
        parseBuildConfiguration(Environment.configuration);
    final manifestDir = Environment.manifestDir;
    final crateOptions = CargokitCrateOptions.load(
      manifestDir: manifestDir,
    );
    final crateInfo = CrateInfo.load(manifestDir);
    return BuildEnvironment(
      configuration: buildConfiguration,
      crateOptions: crateOptions,
      targetTempDir: Environment.targetTempDir,
      manifestDir: manifestDir,
      crateInfo: crateInfo,
      isAndroid: isAndroid,
      androidSdkPath: isAndroid ? Environment.sdkPath : null,
      androidNdkVersion: isAndroid ? Environment.ndkVersion : null,
      androidMinSdkVersion:
          isAndroid ? int.parse(Environment.minSdkVersion) : null,
      javaHome: isAndroid ? Environment.javaHome : null,
    );
  }
}

class RustBuilder {
  final Target target;
  final BuildEnvironment environment;

  RustBuilder({
    required this.target,
    required this.environment,
  });

  void prepare(
    Rustup rustup,
  ) {
    final toolchain = _toolchain;
    if (rustup.installedTargets(toolchain) == null) {
      rustup.installToolchain(toolchain);
    }
    if (toolchain == 'nightly') {
      rustup.installRustSrcForNightly();
    }
    if (!rustup.installedTargets(toolchain)!.contains(target.rust)) {
      rustup.installTarget(target.rust, toolchain: toolchain);
    }
  }

  CargoBuildOptions? get _buildOptions =>
      environment.crateOptions.cargo[environment.configuration];

  String get _toolchain => _buildOptions?.toolchain.name ?? 'stable';

  /// Returns the path of directory containing build artifacts.
  Future<String> build() async {
    final extraArgs = _buildOptions?.flags ?? [];
    final manifestPath = path.join(environment.manifestDir, 'Cargo.toml');
    runCommand(
      'rustup',
      [
        'run',
        _toolchain,
        'cargo',
        'build',
        ...extraArgs,
        '--manifest-path',
        manifestPath,
        '-p',
        environment.crateInfo.packageName,
        if (!environment.configuration.isDebug) '--release',
        '--target',
        target.rust,
        '--target-dir',
        environment.targetTempDir,
      ],
      environment: await _buildEnvironment(),
    );
    return path.join(
      environment.targetTempDir,
      target.rust,
      environment.configuration.rustName,
    );
  }

  Future<Map<String, String>> _buildEnvironment() async {
    if (target.android == null) {
      return {};
    } else {
      final sdkPath = environment.androidSdkPath;
      final ndkVersion = environment.androidNdkVersion;
      final minSdkVersion = environment.androidMinSdkVersion;
      if (sdkPath == null) {
        throw BuildException('androidSdkPath is not set');
      }
      if (ndkVersion == null) {
        throw BuildException('androidNdkVersion is not set');
      }
      if (minSdkVersion == null) {
        throw BuildException('androidMinSdkVersion is not set');
      }
      final env = AndroidEnvironment(
        sdkPath: sdkPath,
        ndkVersion: ndkVersion,
        minSdkVersion: minSdkVersion,
        targetTempDir: environment.targetTempDir,
        target: target,
      );
      if (!env.ndkIsInstalled() && environment.javaHome != null) {
        env.installNdk(javaHome: environment.javaHome!);
      }
      return env.buildEnvironment();
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/build_tool.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:ed25519_edwards/ed25519_edwards.dart';
import 'package:github/github.dart';
import 'package:hex/hex.dart';
import 'package:logging/logging.dart';

import 'android_environment.dart';
import 'build_cmake.dart';
import 'build_gradle.dart';
import 'build_pod.dart';
import 'logging.dart';
import 'options.dart';
import 'precompile_binaries.dart';
import 'target.dart';
import 'util.dart';
import 'verify_binaries.dart';

final log = Logger('build_tool');

abstract class BuildCommand extends Command {
  Future<void> runBuildCommand(CargokitUserOptions options);

  @override
  Future<void> run() async {
    final options = CargokitUserOptions.load();

    if (options.verboseLogging ||
        Platform.environment['CARGOKIT_VERBOSE'] == '1') {
      enableVerboseLogging();
    }

    await runBuildCommand(options);
  }
}

class BuildPodCommand extends BuildCommand {
  @override
  final name = 'build-pod';

  @override
  final description = 'Build cocoa pod library';

  @override
  Future<void> runBuildCommand(CargokitUserOptions options) async {
    final build = BuildPod(userOptions: options);
    await build.build();
  }
}

class BuildGradleCommand extends BuildCommand {
  @override
  final name = 'build-gradle';

  @override
  final description = 'Build android library';

  @override
  Future<void> runBuildCommand(CargokitUserOptions options) async {
    final build = BuildGradle(userOptions: options);
    await build.build();
  }
}

class BuildCMakeCommand extends BuildCommand {
  @override
  final name = 'build-cmake';

  @override
  final description = 'Build CMake library';

  @override
  Future<void> runBuildCommand(CargokitUserOptions options) async {
    final build = BuildCMake(userOptions: options);
    await build.build();
  }
}

class GenKeyCommand extends Command {
  @override
  final name = 'gen-key';

  @override
  final description = 'Generate key pair for signing precompiled binaries';

  @override
  void run() {
    final kp = generateKey();
    final private = HEX.encode(kp.privateKey.bytes);
    final public = HEX.encode(kp.publicKey.bytes);
    print("Private Key: $private");
    print("Public Key: $public");
  }
}

class PrecompileBinariesCommand extends Command {
  PrecompileBinariesCommand() {
    argParser
      ..addOption(
        'repository',
        mandatory: true,
        help: 'Github repository slug in format owner/name',
      )
      ..addOption(
        'manifest-dir',
        mandatory: true,
        help: 'Directory containing Cargo.toml',
      )
      ..addMultiOption('target',
          help: 'Rust target triple of artifact to build.\n'
              'Can be specified multiple times or omitted in which case\n'
              'all targets for current platform will be built.')
      ..addOption(
        'android-sdk-location',
        help: 'Location of Android SDK (if available)',
      )
      ..addOption(
        'android-ndk-version',
        help: 'Android NDK version (if available)',
      )
      ..addOption(
        'android-min-sdk-version',
        help: 'Android minimum rquired version (if available)',
      )
      ..addOption(
        'temp-dir',
        help: 'Directory to store temporary build artifacts',
      )
      ..addFlag(
        "verbose",
        abbr: "v",
        defaultsTo: false,
        help: "Enable verbose logging",
      );
  }

  @override
  final name = 'precompile-binaries';

  @override
  final description = 'Prebuild and upload binaries\n'
      'Private key must be passed through PRIVATE_KEY environment variable. '
      'Use gen_key through generate priave key.\n'
      'Github token must be passed as GITHUB_TOKEN environment variable.\n';

  @override
  Future<void> run() async {
    final verbose = argResults!['verbose'] as bool;
    if (verbose) {
      enableVerboseLogging();
    }

    final privateKeyString = Platform.environment['PRIVATE_KEY'];
    if (privateKeyString == null) {
      throw ArgumentError('Missing PRIVATE_KEY environment variable');
    }
    final githubToken = Platform.environment['GITHUB_TOKEN'];
    if (githubToken == null) {
      throw ArgumentError('Missing GITHUB_TOKEN environment variable');
    }
    final privateKey = HEX.decode(privateKeyString);
    if (privateKey.length != 64) {
      throw ArgumentError('Private key must be 64 bytes long');
    }
    final manifestDir = argResults!['manifest-dir'] as String;
    if (!Directory(manifestDir).existsSync()) {
      throw ArgumentError('Manifest directory does not exist: $manifestDir');
    }
    String? androidMinSdkVersionString =
        argResults!['android-min-sdk-version'] as String?;
    int? androidMinSdkVersion;
    if (androidMinSdkVersionString != null) {
      androidMinSdkVersion = int.tryParse(androidMinSdkVersionString);
      if (androidMinSdkVersion == null) {
        throw ArgumentError(
            'Invalid android-min-sdk-version: $androidMinSdkVersionString');
      }
    }
    final targetStrigns = argResults!['target'] as List<String>;
    final targets = targetStrigns.map((target) {
      final res = Target.forRustTriple(target);
      if (res == null) {
        throw ArgumentError('Invalid target: $target');
      }
      return res;
    }).toList(growable: false);
    final precompileBinaries = PrecompileBinaries(
      privateKey: PrivateKey(privateKey),
      githubToken: githubToken,
      manifestDir: manifestDir,
      repositorySlug: RepositorySlug.full(argResults!['repository'] as String),
      targets: targets,
      androidSdkLocation: argResults!['android-sdk-location'] as String?,
      androidNdkVersion: argResults!['android-ndk-version'] as String?,
      androidMinSdkVersion: androidMinSdkVersion,
      tempDir: argResults!['temp-dir'] as String?,
    );

    await precompileBinaries.run();
  }
}

class VerifyBinariesCommand extends Command {
  VerifyBinariesCommand() {
    argParser.addOption(
      'manifest-dir',
      mandatory: true,
      help: 'Directory containing Cargo.toml',
    );
  }

  @override
  final name = "verify-binaries";

  @override
  final description = 'Verifies published binaries\n'
      'Checks whether there is a binary published for each targets\n'
      'and checks the signature.';

  @override
  Future<void> run() async {
    final manifestDir = argResults!['manifest-dir'] as String;
    final verifyBinaries = VerifyBinaries(
      manifestDir: manifestDir,
    );
    await verifyBinaries.run();
  }
}

Future<void> runMain(List<String> args) async {
  try {
    // Init logging before options are loaded
    initLogging();

    if (Platform.environment['_CARGOKIT_NDK_LINK_TARGET'] != null) {
      return AndroidEnvironment.clangLinkerWrapper(args);
    }

    final runner = CommandRunner('build_tool', 'Cargokit built_tool')
      ..addCommand(BuildPodCommand())
      ..addCommand(BuildGradleCommand())
      ..addCommand(BuildCMakeCommand())
      ..addCommand(GenKeyCommand())
      ..addCommand(PrecompileBinariesCommand())
      ..addCommand(VerifyBinariesCommand());

    await runner.run(args);
  } on ArgumentError catch (e) {
    stderr.writeln(e.toString());
    exit(1);
  } catch (e, s) {
    log.severe(kDoubleSeparator);
    log.severe('Cargokit BuildTool failed with error:');
    log.severe(kSeparator);
    log.severe(e);
    // This tells user to install Rust, there's no need to pollute the log with
    // stack trace.
    if (e is! RustupNotFoundException) {
      log.severe(kSeparator);
      log.severe(s);
      log.severe(kSeparator);
      log.severe('BuildTool arguments: $args');
    }
    log.severe(kDoubleSeparator);
    exit(1);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/build_pod.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:path/path.dart' as path;

import 'artifacts_provider.dart';
import 'builder.dart';
import 'environment.dart';
import 'options.dart';
import 'target.dart';
import 'util.dart';

class BuildPod {
  BuildPod({required this.userOptions});

  final CargokitUserOptions userOptions;

  Future<void> build() async {
    final targets = Environment.darwinArchs.map((arch) {
      final target = Target.forDarwin(
          platformName: Environment.darwinPlatformName, darwinAarch: arch);
      if (target == null) {
        throw Exception(
            "Unknown darwin target or platform: $arch, ${Environment.darwinPlatformName}");
      }
      return target;
    }).toList();

    final environment = BuildEnvironment.fromEnvironment(isAndroid: false);
    final provider =
        ArtifactProvider(environment: environment, userOptions: userOptions);
    final artifacts = await provider.getArtifacts(targets);

    void performLipo(String targetFile, Iterable<String> sourceFiles) {
      runCommand("lipo", [
        '-create',
        ...sourceFiles,
        '-output',
        targetFile,
      ]);
    }

    final outputDir = Environment.outputDir;

    Directory(outputDir).createSync(recursive: true);

    final staticLibs = artifacts.values
        .expand((element) => element)
        .where((element) => element.type == AritifactType.staticlib)
        .toList();
    final dynamicLibs = artifacts.values
        .expand((element) => element)
        .where((element) => element.type == AritifactType.dylib)
        .toList();

    final libName = environment.crateInfo.packageName;

    // If there is static lib, use it and link it with pod
    if (staticLibs.isNotEmpty) {
      final finalTargetFile = path.join(outputDir, "lib$libName.a");
      performLipo(finalTargetFile, staticLibs.map((e) => e.path));
    } else {
      // Otherwise try to replace bundle dylib with our dylib
      final bundlePaths = [
        '$libName.framework/Versions/A/$libName',
        '$libName.framework/$libName',
      ];

      for (final bundlePath in bundlePaths) {
        final targetFile = path.join(outputDir, bundlePath);
        if (File(targetFile).existsSync()) {
          performLipo(targetFile, dynamicLibs.map((e) => e.path));

          // Replace absolute id with @rpath one so that it works properly
          // when moved to Frameworks.
          runCommand("install_name_tool", [
            '-id',
            '@rpath/$bundlePath',
            targetFile,
          ]);
          return;
        }
      }
      throw Exception('Unable to find bundle for dynamic library');
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/crate_hash.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:collection/collection.dart';
import 'package:convert/convert.dart';
import 'package:crypto/crypto.dart';
import 'package:path/path.dart' as path;

class CrateHash {
  /// Computes a hash uniquely identifying crate content. This takes into account
  /// content all all .rs files inside the src directory, as well as Cargo.toml,
  /// Cargo.lock, build.rs and cargokit.yaml.
  ///
  /// If [tempStorage] is provided, computed hash is stored in a file in that directory
  /// and reused on subsequent calls if the crate content hasn't changed.
  static String compute(String manifestDir, {String? tempStorage}) {
    return CrateHash._(
      manifestDir: manifestDir,
      tempStorage: tempStorage,
    )._compute();
  }

  CrateHash._({
    required this.manifestDir,
    required this.tempStorage,
  });

  String _compute() {
    final files = getFiles();
    final tempStorage = this.tempStorage;
    if (tempStorage != null) {
      final quickHash = _computeQuickHash(files);
      final quickHashFolder = Directory(path.join(tempStorage, 'crate_hash'));
      quickHashFolder.createSync(recursive: true);
      final quickHashFile = File(path.join(quickHashFolder.path, quickHash));
      if (quickHashFile.existsSync()) {
        return quickHashFile.readAsStringSync();
      }
      final hash = _computeHash(files);
      quickHashFile.writeAsStringSync(hash);
      return hash;
    } else {
      return _computeHash(files);
    }
  }

  /// Computes a quick hash based on files stat (without reading contents). This
  /// is used to cache the real hash, which is slower to compute since it involves
  /// reading every single file.
  String _computeQuickHash(List<File> files) {
    final output = AccumulatorSink<Digest>();
    final input = sha256.startChunkedConversion(output);

    final data = ByteData(8);
    for (final file in files) {
      input.add(utf8.encode(file.path));
      final stat = file.statSync();
      data.setUint64(0, stat.size);
      input.add(data.buffer.asUint8List());
      data.setUint64(0, stat.modified.millisecondsSinceEpoch);
      input.add(data.buffer.asUint8List());
    }

    input.close();
    return base64Url.encode(output.events.single.bytes);
  }

  String _computeHash(List<File> files) {
    final output = AccumulatorSink<Digest>();
    final input = sha256.startChunkedConversion(output);

    void addTextFile(File file) {
      // text Files are hashed by lines in case we're dealing with github checkout
      // that auto-converts line endings.
      final splitter = LineSplitter();
      if (file.existsSync()) {
        final data = file.readAsStringSync();
        final lines = splitter.convert(data);
        for (final line in lines) {
          input.add(utf8.encode(line));
        }
      }
    }

    for (final file in files) {
      addTextFile(file);
    }

    input.close();
    final res = output.events.single;

    // Truncate to 128bits.
    final hash = res.bytes.sublist(0, 16);
    return hex.encode(hash);
  }

  List<File> getFiles() {
    final src = Directory(path.join(manifestDir, 'src'));
    final files = src
        .listSync(recursive: true, followLinks: false)
        .whereType<File>()
        .toList();
    files.sortBy((element) => element.path);
    void addFile(String relative) {
      final file = File(path.join(manifestDir, relative));
      if (file.existsSync()) {
        files.add(file);
      }
    }

    addFile('Cargo.toml');
    addFile('Cargo.lock');
    addFile('build.rs');
    addFile('cargokit.yaml');
    return files;
  }

  final String manifestDir;
  final String? tempStorage;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/environment.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

extension on String {
  String resolveSymlink() => File(this).resolveSymbolicLinksSync();
}

class Environment {
  /// Current build configuration (debug or release).
  static String get configuration =>
      _getEnv("CARGOKIT_CONFIGURATION").toLowerCase();

  static bool get isDebug => configuration == 'debug';
  static bool get isRelease => configuration == 'release';

  /// Temporary directory where Rust build artifacts are placed.
  static String get targetTempDir => _getEnv("CARGOKIT_TARGET_TEMP_DIR");

  /// Final output directory where the build artifacts are placed.
  static String get outputDir => _getEnvPath('CARGOKIT_OUTPUT_DIR');

  /// Path to the crate manifest (containing Cargo.toml).
  static String get manifestDir => _getEnvPath('CARGOKIT_MANIFEST_DIR');

  /// Directory inside root project. Not necessarily root folder. Symlinks are
  /// not resolved on purpose.
  static String get rootProjectDir => _getEnv('CARGOKIT_ROOT_PROJECT_DIR');

  // Pod

  /// Platform name (macosx, iphoneos, iphonesimulator).
  static String get darwinPlatformName =>
      _getEnv("CARGOKIT_DARWIN_PLATFORM_NAME");

  /// List of architectures to build for (arm64, armv7, x86_64).
  static List<String> get darwinArchs =>
      _getEnv("CARGOKIT_DARWIN_ARCHS").split(' ');

  // Gradle
  static String get minSdkVersion => _getEnv("CARGOKIT_MIN_SDK_VERSION");
  static String get ndkVersion => _getEnv("CARGOKIT_NDK_VERSION");
  static String get sdkPath => _getEnvPath("CARGOKIT_SDK_DIR");
  static String get javaHome => _getEnvPath("CARGOKIT_JAVA_HOME");
  static List<String> get targetPlatforms =>
      _getEnv("CARGOKIT_TARGET_PLATFORMS").split(',');

  // CMAKE
  static String get targetPlatform => _getEnv("CARGOKIT_TARGET_PLATFORM");

  static String _getEnv(String key) {
    final res = Platform.environment[key];
    if (res == null) {
      throw Exception("Missing environment variable $key");
    }
    return res;
  }

  static String _getEnvPath(String key) {
    final res = _getEnv(key);
    if (Directory(res).existsSync()) {
      return res.resolveSymlink();
    } else {
      return res;
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/cargo.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:toml/toml.dart';

class ManifestException {
  ManifestException(this.message, {required this.fileName});

  final String? fileName;
  final String message;

  @override
  String toString() {
    if (fileName != null) {
      return 'Failed to parse package manifest at $fileName: $message';
    } else {
      return 'Failed to parse package manifest: $message';
    }
  }
}

class CrateInfo {
  CrateInfo({required this.packageName});

  final String packageName;

  static CrateInfo parseManifest(String manifest, {final String? fileName}) {
    final toml = TomlDocument.parse(manifest);
    final package = toml.toMap()['package'];
    if (package == null) {
      throw ManifestException('Missing package section', fileName: fileName);
    }
    final name = package['name'];
    if (name == null) {
      throw ManifestException('Missing package name', fileName: fileName);
    }
    return CrateInfo(packageName: name);
  }

  static CrateInfo load(String manifestDir) {
    final manifestFile = File(path.join(manifestDir, 'Cargo.toml'));
    final manifest = manifestFile.readAsStringSync();
    return parseManifest(manifest, fileName: manifestFile.path);
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/android_environment.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';
import 'dart:isolate';
import 'dart:math' as math;

import 'package:collection/collection.dart';
import 'package:path/path.dart' as path;
import 'package:version/version.dart';

import 'target.dart';
import 'util.dart';

class AndroidEnvironment {
  AndroidEnvironment({
    required this.sdkPath,
    required this.ndkVersion,
    required this.minSdkVersion,
    required this.targetTempDir,
    required this.target,
  });

  static void clangLinkerWrapper(List<String> args) {
    final clang = Platform.environment['_CARGOKIT_NDK_LINK_CLANG'];
    if (clang == null) {
      throw Exception(
          "cargo-ndk rustc linker: didn't find _CARGOKIT_NDK_LINK_CLANG env var");
    }
    final target = Platform.environment['_CARGOKIT_NDK_LINK_TARGET'];
    if (target == null) {
      throw Exception(
          "cargo-ndk rustc linker: didn't find _CARGOKIT_NDK_LINK_TARGET env var");
    }

    runCommand(clang, [
      target,
      ...args,
    ]);
  }

  /// Full path to Android SDK.
  final String sdkPath;

  /// Full version of Android NDK.
  final String ndkVersion;

  /// Minimum supported SDK version.
  final int minSdkVersion;

  /// Target directory for build artifacts.
  final String targetTempDir;

  /// Target being built.
  final Target target;

  bool ndkIsInstalled() {
    final ndkPath = path.join(sdkPath, 'ndk', ndkVersion);
    final ndkPackageXml = File(path.join(ndkPath, 'package.xml'));
    return ndkPackageXml.existsSync();
  }

  void installNdk({
    required String javaHome,
  }) {
    final sdkManagerExtension = Platform.isWindows ? '.bat' : '';
    final sdkManager = path.join(
      sdkPath,
      'cmdline-tools',
      'latest',
      'bin',
      'sdkmanager$sdkManagerExtension',
    );

    log.info('Installing NDK $ndkVersion');
    runCommand(sdkManager, [
      '--install',
      'ndk;$ndkVersion',
    ], environment: {
      'JAVA_HOME': javaHome,
    });
  }

  Future<Map<String, String>> buildEnvironment() async {
    final hostArch = Platform.isMacOS
        ? "darwin-x86_64"
        : (Platform.isLinux ? "linux-x86_64" : "windows-x86_64");

    final ndkPath = path.join(sdkPath, 'ndk', ndkVersion);
    final toolchainPath = path.join(
      ndkPath,
      'toolchains',
      'llvm',
      'prebuilt',
      hostArch,
      'bin',
    );

    final minSdkVersion =
        math.max(target.androidMinSdkVersion!, this.minSdkVersion);

    final exe = Platform.isWindows ? '.exe' : '';

    final arKey = 'AR_${target.rust}';
    final arValue = ['${target.rust}-ar', 'llvm-ar', 'llvm-ar.exe']
        .map((e) => path.join(toolchainPath, e))
        .firstWhereOrNull((element) => File(element).existsSync());
    if (arValue == null) {
      throw Exception('Failed to find ar for $target in $toolchainPath');
    }

    final targetArg = '--target=${target.rust}$minSdkVersion';

    final ccKey = 'CC_${target.rust}';
    final ccValue = path.join(toolchainPath, 'clang$exe');
    final cfFlagsKey = 'CFLAGS_${target.rust}';
    final cFlagsValue = targetArg;

    final cxxKey = 'CXX_${target.rust}';
    final cxxValue = path.join(toolchainPath, 'clang++$exe');
    final cxxFlagsKey = 'CXXFLAGS_${target.rust}';
    final cxxFlagsValue = targetArg;

    final linkerKey =
        'cargo_target_${target.rust.replaceAll('-', '_')}_linker'.toUpperCase();

    final ranlibKey = 'RANLIB_${target.rust}';
    final ranlibValue = path.join(toolchainPath, 'llvm-ranlib$exe');

    final ndkVersionParsed = Version.parse(ndkVersion);
    final rustFlagsKey = 'CARGO_ENCODED_RUSTFLAGS';
    final rustFlagsValue = _libGccWorkaround(targetTempDir, ndkVersionParsed);

    final runRustTool =
        Platform.isWindows ? 'run_build_tool.cmd' : 'run_build_tool.sh';

    final packagePath = (await Isolate.resolvePackageUri(
            Uri.parse('package:build_tool/buildtool.dart')))!
        .toFilePath();
    final selfPath = path.canonicalize(path.join(
      packagePath,
      '..',
      '..',
      '..',
      runRustTool,
    ));

    // Make sure that run_build_tool is working properly even initially launched directly
    // through dart run.
    final toolTempDir =
        Platform.environment['CARGOKIT_TOOL_TEMP_DIR'] ?? targetTempDir;

    return {
      arKey: arValue,
      ccKey: ccValue,
      cfFlagsKey: cFlagsValue,
      cxxKey: cxxValue,
      cxxFlagsKey: cxxFlagsValue,
      ranlibKey: ranlibValue,
      rustFlagsKey: rustFlagsValue,
      linkerKey: selfPath,
      // Recognized by main() so we know when we're acting as a wrapper
      '_CARGOKIT_NDK_LINK_TARGET': targetArg,
      '_CARGOKIT_NDK_LINK_CLANG': ccValue,
      'CARGOKIT_TOOL_TEMP_DIR': toolTempDir,
    };
  }

  // Workaround for libgcc missing in NDK23, inspired by cargo-ndk
  String _libGccWorkaround(String buildDir, Version ndkVersion) {
    final workaroundDir = path.join(
      buildDir,
      'cargokit',
      'libgcc_workaround',
      '${ndkVersion.major}',
    );
    Directory(workaroundDir).createSync(recursive: true);
    if (ndkVersion.major >= 23) {
      File(path.join(workaroundDir, 'libgcc.a'))
          .writeAsStringSync('INPUT(-lunwind)');
    } else {
      // Other way around, untested, forward libgcc.a from libunwind once Rust
      // gets updated for NDK23+.
      File(path.join(workaroundDir, 'libunwind.a'))
          .writeAsStringSync('INPUT(-lgcc)');
    }

    var rustFlags = Platform.environment['CARGO_ENCODED_RUSTFLAGS'] ?? '';
    if (rustFlags.isNotEmpty) {
      rustFlags = '$rustFlags\x1f';
    }
    rustFlags = '$rustFlags-L\x1f$workaroundDir';
    return rustFlags;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/precompile_binaries.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:ed25519_edwards/ed25519_edwards.dart';
import 'package:github/github.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

import 'artifacts_provider.dart';
import 'builder.dart';
import 'cargo.dart';
import 'crate_hash.dart';
import 'options.dart';
import 'rustup.dart';
import 'target.dart';

final _log = Logger('precompile_binaries');

class PrecompileBinaries {
  PrecompileBinaries({
    required this.privateKey,
    required this.githubToken,
    required this.repositorySlug,
    required this.manifestDir,
    required this.targets,
    this.androidSdkLocation,
    this.androidNdkVersion,
    this.androidMinSdkVersion,
    this.tempDir,
  });

  final PrivateKey privateKey;
  final String githubToken;
  final RepositorySlug repositorySlug;
  final String manifestDir;
  final List<Target> targets;
  final String? androidSdkLocation;
  final String? androidNdkVersion;
  final int? androidMinSdkVersion;
  final String? tempDir;

  static String fileName(Target target, String name) {
    return '${target.rust}_$name';
  }

  static String signatureFileName(Target target, String name) {
    return '${target.rust}_$name.sig';
  }

  Future<void> run() async {
    final crateInfo = CrateInfo.load(manifestDir);

    final targets = List.of(this.targets);
    if (targets.isEmpty) {
      targets.addAll([
        ...Target.buildableTargets(),
        if (androidSdkLocation != null) ...Target.androidTargets(),
      ]);
    }

    _log.info('Precompiling binaries for $targets');

    final hash = CrateHash.compute(manifestDir);
    _log.info('Computed crate hash: $hash');

    final String tagName = 'precompiled_$hash';

    final github = GitHub(auth: Authentication.withToken(githubToken));
    final repo = github.repositories;
    final release = await _getOrCreateRelease(
      repo: repo,
      tagName: tagName,
      packageName: crateInfo.packageName,
      hash: hash,
    );

    final tempDir = this.tempDir != null
        ? Directory(this.tempDir!)
        : Directory.systemTemp.createTempSync('precompiled_');

    tempDir.createSync(recursive: true);

    final crateOptions = CargokitCrateOptions.load(
      manifestDir: manifestDir,
    );

    final buildEnvironment = BuildEnvironment(
      configuration: BuildConfiguration.release,
      crateOptions: crateOptions,
      targetTempDir: tempDir.path,
      manifestDir: manifestDir,
      crateInfo: crateInfo,
      isAndroid: androidSdkLocation != null,
      androidSdkPath: androidSdkLocation,
      androidNdkVersion: androidNdkVersion,
      androidMinSdkVersion: androidMinSdkVersion,
    );

    final rustup = Rustup();

    for (final target in targets) {
      final artifactNames = getArtifactNames(
        target: target,
        libraryName: crateInfo.packageName,
        remote: true,
      );

      if (artifactNames.every((name) {
        final fileName = PrecompileBinaries.fileName(target, name);
        return (release.assets ?? []).any((e) => e.name == fileName);
      })) {
        _log.info("All artifacts for $target already exist - skipping");
        continue;
      }

      _log.info('Building for $target');

      final builder =
          RustBuilder(target: target, environment: buildEnvironment);
      builder.prepare(rustup);
      final res = await builder.build();

      final assets = <CreateReleaseAsset>[];
      for (final name in artifactNames) {
        final file = File(path.join(res, name));
        if (!file.existsSync()) {
          throw Exception('Missing artifact: ${file.path}');
        }

        final data = file.readAsBytesSync();
        final create = CreateReleaseAsset(
          name: PrecompileBinaries.fileName(target, name),
          contentType: "application/octet-stream",
          assetData: data,
        );
        final signature = sign(privateKey, data);
        final signatureCreate = CreateReleaseAsset(
          name: signatureFileName(target, name),
          contentType: "application/octet-stream",
          assetData: signature,
        );
        bool verified = verify(public(privateKey), data, signature);
        if (!verified) {
          throw Exception('Signature verification failed');
        }
        assets.add(create);
        assets.add(signatureCreate);
      }
      _log.info('Uploading assets: ${assets.map((e) => e.name)}');
      for (final asset in assets) {
        // This seems to be failing on CI so do it one by one
        int retryCount = 0;
        while (true) {
          try {
            await repo.uploadReleaseAssets(release, [asset]);
            break;
          } on Exception catch (e) {
            if (retryCount == 10) {
              rethrow;
            }
            ++retryCount;
            _log.shout(
                'Upload failed (attempt $retryCount, will retry): ${e.toString()}');
            await Future.delayed(Duration(seconds: 2));
          }
        }
      }
    }

    _log.info('Cleaning up');
    tempDir.deleteSync(recursive: true);
  }

  Future<Release> _getOrCreateRelease({
    required RepositoriesService repo,
    required String tagName,
    required String packageName,
    required String hash,
  }) async {
    Release release;
    try {
      _log.info('Fetching release $tagName');
      release = await repo.getReleaseByTagName(repositorySlug, tagName);
    } on ReleaseNotFound {
      _log.info('Release not found - creating release $tagName');
      release = await repo.createRelease(
          repositorySlug,
          CreateRelease.from(
            tagName: tagName,
            name: 'Precompiled binaries ${hash.substring(0, 8)}',
            targetCommitish: null,
            isDraft: false,
            isPrerelease: false,
            body: 'Precompiled binaries for crate $packageName, '
                'crate hash $hash.',
          ));
    }
    return release;
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/build_cmake.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:path/path.dart' as path;

import 'artifacts_provider.dart';
import 'builder.dart';
import 'environment.dart';
import 'options.dart';
import 'target.dart';

class BuildCMake {
  final CargokitUserOptions userOptions;

  BuildCMake({required this.userOptions});

  Future<void> build() async {
    final targetPlatform = Environment.targetPlatform;
    final target = Target.forFlutterName(Environment.targetPlatform);
    if (target == null) {
      throw Exception("Unknown target platform: $targetPlatform");
    }

    final environment = BuildEnvironment.fromEnvironment(isAndroid: false);
    final provider =
        ArtifactProvider(environment: environment, userOptions: userOptions);
    final artifacts = await provider.getArtifacts([target]);

    final libs = artifacts[target]!;

    for (final lib in libs) {
      if (lib.type == AritifactType.dylib) {
        File(lib.path)
            .copySync(path.join(Environment.outputDir, lib.finalFileName));
      }
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/build_gradle.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

import 'artifacts_provider.dart';
import 'builder.dart';
import 'environment.dart';
import 'options.dart';
import 'target.dart';

final log = Logger('build_gradle');

class BuildGradle {
  BuildGradle({required this.userOptions});

  final CargokitUserOptions userOptions;

  Future<void> build() async {
    final targets = Environment.targetPlatforms.map((arch) {
      final target = Target.forFlutterName(arch);
      if (target == null) {
        throw Exception(
            "Unknown darwin target or platform: $arch, ${Environment.darwinPlatformName}");
      }
      return target;
    }).toList();

    final environment = BuildEnvironment.fromEnvironment(isAndroid: true);
    final provider =
        ArtifactProvider(environment: environment, userOptions: userOptions);
    final artifacts = await provider.getArtifacts(targets);

    for (final target in targets) {
      final libs = artifacts[target]!;
      final outputDir = path.join(Environment.outputDir, target.android!);
      Directory(outputDir).createSync(recursive: true);

      for (final lib in libs) {
        if (lib.type == AritifactType.dylib) {
          File(lib.path).copySync(path.join(outputDir, lib.finalFileName));
        }
      }
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/verify_binaries.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:ed25519_edwards/ed25519_edwards.dart';
import 'package:http/http.dart';

import 'artifacts_provider.dart';
import 'cargo.dart';
import 'crate_hash.dart';
import 'options.dart';
import 'precompile_binaries.dart';
import 'target.dart';

class VerifyBinaries {
  VerifyBinaries({
    required this.manifestDir,
  });

  final String manifestDir;

  Future<void> run() async {
    final crateInfo = CrateInfo.load(manifestDir);

    final config = CargokitCrateOptions.load(manifestDir: manifestDir);
    final precompiledBinaries = config.precompiledBinaries;
    if (precompiledBinaries == null) {
      stdout.writeln('Crate does not support precompiled binaries.');
    } else {
      final crateHash = CrateHash.compute(manifestDir);
      stdout.writeln('Crate hash: $crateHash');

      for (final target in Target.all) {
        final message = 'Checking ${target.rust}...';
        stdout.write(message.padRight(40));
        stdout.flush();

        final artifacts = getArtifactNames(
          target: target,
          libraryName: crateInfo.packageName,
          remote: true,
        );

        final prefix = precompiledBinaries.uriPrefix;

        bool ok = true;

        for (final artifact in artifacts) {
          final fileName = PrecompileBinaries.fileName(target, artifact);
          final signatureFileName =
              PrecompileBinaries.signatureFileName(target, artifact);

          final url = Uri.parse('$prefix$crateHash/$fileName');
          final signatureUrl =
              Uri.parse('$prefix$crateHash/$signatureFileName');

          final signature = await get(signatureUrl);
          if (signature.statusCode != 200) {
            stdout.writeln('MISSING');
            ok = false;
            break;
          }
          final asset = await get(url);
          if (asset.statusCode != 200) {
            stdout.writeln('MISSING');
            ok = false;
            break;
          }

          if (!verify(precompiledBinaries.publicKey, asset.bodyBytes,
              signature.bodyBytes)) {
            stdout.writeln('INVALID SIGNATURE');
            ok = false;
          }
        }

        if (ok) {
          stdout.writeln('OK');
        }
      }
    }
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/artifacts_provider.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:ed25519_edwards/ed25519_edwards.dart';
import 'package:http/http.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

import 'builder.dart';
import 'crate_hash.dart';
import 'options.dart';
import 'precompile_binaries.dart';
import 'rustup.dart';
import 'target.dart';

class Artifact {
  /// File system location of the artifact.
  final String path;

  /// Actual file name that the artifact should have in destination folder.
  final String finalFileName;

  AritifactType get type {
    if (finalFileName.endsWith('.dll') ||
        finalFileName.endsWith('.dll.lib') ||
        finalFileName.endsWith('.pdb') ||
        finalFileName.endsWith('.so') ||
        finalFileName.endsWith('.dylib')) {
      return AritifactType.dylib;
    } else if (finalFileName.endsWith('.lib') || finalFileName.endsWith('.a')) {
      return AritifactType.staticlib;
    } else {
      throw Exception('Unknown artifact type for $finalFileName');
    }
  }

  Artifact({
    required this.path,
    required this.finalFileName,
  });
}

final _log = Logger('artifacts_provider');

class ArtifactProvider {
  ArtifactProvider({
    required this.environment,
    required this.userOptions,
  });

  final BuildEnvironment environment;
  final CargokitUserOptions userOptions;

  Future<Map<Target, List<Artifact>>> getArtifacts(List<Target> targets) async {
    final result = await _getPrecompiledArtifacts(targets);

    final pendingTargets = List.of(targets);
    pendingTargets.removeWhere((element) => result.containsKey(element));

    if (pendingTargets.isEmpty) {
      return result;
    }

    final rustup = Rustup();
    for (final target in targets) {
      final builder = RustBuilder(target: target, environment: environment);
      builder.prepare(rustup);
      _log.info('Building ${environment.crateInfo.packageName} for $target');
      final targetDir = await builder.build();
      // For local build accept both static and dynamic libraries.
      final artifactNames = <String>{
        ...getArtifactNames(
          target: target,
          libraryName: environment.crateInfo.packageName,
          aritifactType: AritifactType.dylib,
          remote: false,
        ),
        ...getArtifactNames(
          target: target,
          libraryName: environment.crateInfo.packageName,
          aritifactType: AritifactType.staticlib,
          remote: false,
        )
      };
      final artifacts = artifactNames
          .map((artifactName) => Artifact(
                path: path.join(targetDir, artifactName),
                finalFileName: artifactName,
              ))
          .where((element) => File(element.path).existsSync())
          .toList();
      result[target] = artifacts;
    }
    return result;
  }

  Future<Map<Target, List<Artifact>>> _getPrecompiledArtifacts(
      List<Target> targets) async {
    if (userOptions.usePrecompiledBinaries == false) {
      _log.info('Precompiled binaries are disabled');
      return {};
    }
    if (environment.crateOptions.precompiledBinaries == null) {
      _log.fine('Precompiled binaries not enabled for this crate');
      return {};
    }

    final start = Stopwatch()..start();
    final crateHash = CrateHash.compute(environment.manifestDir,
        tempStorage: environment.targetTempDir);
    _log.fine(
        'Computed crate hash $crateHash in ${start.elapsedMilliseconds}ms');

    final downloadedArtifactsDir =
        path.join(environment.targetTempDir, 'precompiled', crateHash);
    Directory(downloadedArtifactsDir).createSync(recursive: true);

    final res = <Target, List<Artifact>>{};

    for (final target in targets) {
      final requiredArtifacts = getArtifactNames(
        target: target,
        libraryName: environment.crateInfo.packageName,
        remote: true,
      );
      final artifactsForTarget = <Artifact>[];

      for (final artifact in requiredArtifacts) {
        final fileName = PrecompileBinaries.fileName(target, artifact);
        final downloadedPath = path.join(downloadedArtifactsDir, fileName);
        if (!File(downloadedPath).existsSync()) {
          final signatureFileName =
              PrecompileBinaries.signatureFileName(target, artifact);
          await _tryDownloadArtifacts(
            crateHash: crateHash,
            fileName: fileName,
            signatureFileName: signatureFileName,
            finalPath: downloadedPath,
          );
        }
        if (File(downloadedPath).existsSync()) {
          artifactsForTarget.add(Artifact(
            path: downloadedPath,
            finalFileName: artifact,
          ));
        } else {
          break;
        }
      }

      // Only provide complete set of artifacts.
      if (artifactsForTarget.length == requiredArtifacts.length) {
        _log.fine('Found precompiled artifacts for $target');
        res[target] = artifactsForTarget;
      }
    }

    return res;
  }

  static Future<Response> _get(Uri url, {Map<String, String>? headers}) async {
    int attempt = 0;
    const maxAttempts = 10;
    while (true) {
      try {
        return await get(url, headers: headers);
      } on SocketException catch (e) {
        // Try to detect reset by peer error and retry.
        if (attempt++ < maxAttempts &&
            (e.osError?.errorCode == 54 || e.osError?.errorCode == 10054)) {
          _log.severe(
              'Failed to download $url: $e, attempt $attempt of $maxAttempts, will retry...');
          await Future.delayed(Duration(seconds: 1));
          continue;
        } else {
          rethrow;
        }
      }
    }
  }

  Future<void> _tryDownloadArtifacts({
    required String crateHash,
    required String fileName,
    required String signatureFileName,
    required String finalPath,
  }) async {
    final precompiledBinaries = environment.crateOptions.precompiledBinaries!;
    final prefix = precompiledBinaries.uriPrefix;
    final url = Uri.parse('$prefix$crateHash/$fileName');
    final signatureUrl = Uri.parse('$prefix$crateHash/$signatureFileName');
    _log.fine('Downloading signature from $signatureUrl');
    final signature = await _get(signatureUrl);
    if (signature.statusCode == 404) {
      _log.warning(
          'Precompiled binaries not available for crate hash $crateHash ($fileName)');
      return;
    }
    if (signature.statusCode != 200) {
      _log.severe(
          'Failed to download signature $signatureUrl: status ${signature.statusCode}');
      return;
    }
    _log.fine('Downloading binary from $url');
    final res = await _get(url);
    if (res.statusCode != 200) {
      _log.severe('Failed to download binary $url: status ${res.statusCode}');
      return;
    }
    if (verify(
        precompiledBinaries.publicKey, res.bodyBytes, signature.bodyBytes)) {
      File(finalPath).writeAsBytesSync(res.bodyBytes);
    } else {
      _log.shout('Signature verification failed! Ignoring binary.');
    }
  }
}

enum AritifactType {
  staticlib,
  dylib,
}

AritifactType artifactTypeForTarget(Target target) {
  if (target.darwinPlatform != null) {
    return AritifactType.staticlib;
  } else {
    return AritifactType.dylib;
  }
}

List<String> getArtifactNames({
  required Target target,
  required String libraryName,
  required bool remote,
  AritifactType? aritifactType,
}) {
  aritifactType ??= artifactTypeForTarget(target);
  if (target.darwinArch != null) {
    if (aritifactType == AritifactType.staticlib) {
      return ['lib$libraryName.a'];
    } else {
      return ['lib$libraryName.dylib'];
    }
  } else if (target.rust.contains('-windows-')) {
    if (aritifactType == AritifactType.staticlib) {
      return ['$libraryName.lib'];
    } else {
      return [
        '$libraryName.dll',
        '$libraryName.dll.lib',
        if (!remote) '$libraryName.pdb'
      ];
    }
  } else if (target.rust.contains('-linux-')) {
    if (aritifactType == AritifactType.staticlib) {
      return ['lib$libraryName.a'];
    } else {
      return ['lib$libraryName.so'];
    }
  } else {
    throw Exception("Unsupported target: ${target.rust}");
  }
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/logging.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:logging/logging.dart';

const String kSeparator = "--";
const String kDoubleSeparator = "==";

bool _lastMessageWasSeparator = false;

void _log(LogRecord rec) {
  final prefix = '${rec.level.name}: ';
  final out = rec.level == Level.SEVERE ? stderr : stdout;
  if (rec.message == kSeparator) {
    if (!_lastMessageWasSeparator) {
      out.write(prefix);
      out.writeln('-' * 80);
      _lastMessageWasSeparator = true;
    }
    return;
  } else if (rec.message == kDoubleSeparator) {
    out.write(prefix);
    out.writeln('=' * 80);
    _lastMessageWasSeparator = true;
    return;
  }
  out.write(prefix);
  out.writeln(rec.message);
  _lastMessageWasSeparator = false;
}

void initLogging() {
  Logger.root.level = Level.INFO;
  Logger.root.onRecord.listen((LogRecord rec) {
    final lines = rec.message.split('\n');
    for (final line in lines) {
      if (line.isNotEmpty || lines.length == 1 || line != lines.last) {
        _log(LogRecord(
          rec.level,
          line,
          rec.loggerName,
        ));
      }
    }
  });
}

void enableVerboseLogging() {
  Logger.root.level = Level.ALL;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/options.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:collection/collection.dart';
import 'package:ed25519_edwards/ed25519_edwards.dart';
import 'package:hex/hex.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;
import 'package:source_span/source_span.dart';
import 'package:yaml/yaml.dart';

import 'builder.dart';
import 'environment.dart';
import 'rustup.dart';

final _log = Logger('options');

/// A class for exceptions that have source span information attached.
class SourceSpanException implements Exception {
  // This is a getter so that subclasses can override it.
  /// A message describing the exception.
  String get message => _message;
  final String _message;

  // This is a getter so that subclasses can override it.
  /// The span associated with this exception.
  ///
  /// This may be `null` if the source location can't be determined.
  SourceSpan? get span => _span;
  final SourceSpan? _span;

  SourceSpanException(this._message, this._span);

  /// Returns a string representation of `this`.
  ///
  /// [color] may either be a [String], a [bool], or `null`. If it's a string,
  /// it indicates an ANSI terminal color escape that should be used to
  /// highlight the span's text. If it's `true`, it indicates that the text
  /// should be highlighted using the default color. If it's `false` or `null`,
  /// it indicates that the text shouldn't be highlighted.
  @override
  String toString({Object? color}) {
    if (span == null) return message;
    return 'Error on ${span!.message(message, color: color)}';
  }
}

enum Toolchain {
  stable,
  beta,
  nightly,
}

class CargoBuildOptions {
  final Toolchain toolchain;
  final List<String> flags;

  CargoBuildOptions({
    required this.toolchain,
    required this.flags,
  });

  static Toolchain _toolchainFromNode(YamlNode node) {
    if (node case YamlScalar(value: String name)) {
      final toolchain =
          Toolchain.values.firstWhereOrNull((element) => element.name == name);
      if (toolchain != null) {
        return toolchain;
      }
    }
    throw SourceSpanException(
        'Unknown toolchain. Must be one of ${Toolchain.values.map((e) => e.name)}.',
        node.span);
  }

  static CargoBuildOptions parse(YamlNode node) {
    if (node is! YamlMap) {
      throw SourceSpanException('Cargo options must be a map', node.span);
    }
    Toolchain toolchain = Toolchain.stable;
    List<String> flags = [];
    for (final MapEntry(:key, :value) in node.nodes.entries) {
      if (key case YamlScalar(value: 'toolchain')) {
        toolchain = _toolchainFromNode(value);
      } else if (key case YamlScalar(value: 'extra_flags')) {
        if (value case YamlList(nodes: List<YamlNode> list)) {
          if (list.every((element) {
            if (element case YamlScalar(value: String _)) {
              return true;
            }
            return false;
          })) {
            flags = list.map((e) => e.value as String).toList();
            continue;
          }
        }
        throw SourceSpanException(
            'Extra flags must be a list of strings', value.span);
      } else {
        throw SourceSpanException(
            'Unknown cargo option type. Must be "toolchain" or "extra_flags".',
            key.span);
      }
    }
    return CargoBuildOptions(toolchain: toolchain, flags: flags);
  }
}

extension on YamlMap {
  /// Map that extracts keys so that we can do map case check on them.
  Map<dynamic, YamlNode> get valueMap =>
      nodes.map((key, value) => MapEntry(key.value, value));
}

class PrecompiledBinaries {
  final String uriPrefix;
  final PublicKey publicKey;

  PrecompiledBinaries({
    required this.uriPrefix,
    required this.publicKey,
  });

  static PublicKey _publicKeyFromHex(String key, SourceSpan? span) {
    final bytes = HEX.decode(key);
    if (bytes.length != 32) {
      throw SourceSpanException(
          'Invalid public key. Must be 32 bytes long.', span);
    }
    return PublicKey(bytes);
  }

  static PrecompiledBinaries parse(YamlNode node) {
    if (node case YamlMap(valueMap: Map<dynamic, YamlNode> map)) {
      if (map
          case {
            'url_prefix': YamlNode urlPrefixNode,
            'public_key': YamlNode publicKeyNode,
          }) {
        final urlPrefix = switch (urlPrefixNode) {
          YamlScalar(value: String urlPrefix) => urlPrefix,
          _ => throw SourceSpanException(
              'Invalid URL prefix value.', urlPrefixNode.span),
        };
        final publicKey = switch (publicKeyNode) {
          YamlScalar(value: String publicKey) =>
            _publicKeyFromHex(publicKey, publicKeyNode.span),
          _ => throw SourceSpanException(
              'Invalid public key value.', publicKeyNode.span),
        };
        return PrecompiledBinaries(
          uriPrefix: urlPrefix,
          publicKey: publicKey,
        );
      }
    }
    throw SourceSpanException(
        'Invalid precompiled binaries value. '
        'Expected Map with "url_prefix" and "public_key".',
        node.span);
  }
}

/// Cargokit options specified for Rust crate.
class CargokitCrateOptions {
  CargokitCrateOptions({
    this.cargo = const {},
    this.precompiledBinaries,
  });

  final Map<BuildConfiguration, CargoBuildOptions> cargo;
  final PrecompiledBinaries? precompiledBinaries;

  static CargokitCrateOptions parse(YamlNode node) {
    if (node is! YamlMap) {
      throw SourceSpanException('Cargokit options must be a map', node.span);
    }
    final options = <BuildConfiguration, CargoBuildOptions>{};
    PrecompiledBinaries? precompiledBinaries;

    for (final entry in node.nodes.entries) {
      if (entry
          case MapEntry(
            key: YamlScalar(value: 'cargo'),
            value: YamlNode node,
          )) {
        if (node is! YamlMap) {
          throw SourceSpanException('Cargo options must be a map', node.span);
        }
        for (final MapEntry(:YamlNode key, :value) in node.nodes.entries) {
          if (key case YamlScalar(value: String name)) {
            final configuration = BuildConfiguration.values
                .firstWhereOrNull((element) => element.name == name);
            if (configuration != null) {
              options[configuration] = CargoBuildOptions.parse(value);
              continue;
            }
          }
          throw SourceSpanException(
              'Unknown build configuration. Must be one of ${BuildConfiguration.values.map((e) => e.name)}.',
              key.span);
        }
      } else if (entry.key case YamlScalar(value: 'precompiled_binaries')) {
        precompiledBinaries = PrecompiledBinaries.parse(entry.value);
      } else {
        throw SourceSpanException(
            'Unknown cargokit option type. Must be "cargo" or "precompiled_binaries".',
            entry.key.span);
      }
    }
    return CargokitCrateOptions(
      cargo: options,
      precompiledBinaries: precompiledBinaries,
    );
  }

  static CargokitCrateOptions load({
    required String manifestDir,
  }) {
    final uri = Uri.file(path.join(manifestDir, "cargokit.yaml"));
    final file = File.fromUri(uri);
    if (file.existsSync()) {
      final contents = loadYamlNode(file.readAsStringSync(), sourceUrl: uri);
      return parse(contents);
    } else {
      return CargokitCrateOptions();
    }
  }
}

class CargokitUserOptions {
  // When Rustup is installed always build locally unless user opts into
  // using precompiled binaries.
  static bool defaultUsePrecompiledBinaries() {
    return Rustup.executablePath() == null;
  }

  CargokitUserOptions({
    required this.usePrecompiledBinaries,
    required this.verboseLogging,
  });

  CargokitUserOptions._()
      : usePrecompiledBinaries = defaultUsePrecompiledBinaries(),
        verboseLogging = false;

  static CargokitUserOptions parse(YamlNode node) {
    if (node is! YamlMap) {
      throw SourceSpanException('Cargokit options must be a map', node.span);
    }
    bool usePrecompiledBinaries = defaultUsePrecompiledBinaries();
    bool verboseLogging = false;

    for (final entry in node.nodes.entries) {
      if (entry.key case YamlScalar(value: 'use_precompiled_binaries')) {
        if (entry.value case YamlScalar(value: bool value)) {
          usePrecompiledBinaries = value;
          continue;
        }
        throw SourceSpanException(
            'Invalid value for "use_precompiled_binaries". Must be a boolean.',
            entry.value.span);
      } else if (entry.key case YamlScalar(value: 'verbose_logging')) {
        if (entry.value case YamlScalar(value: bool value)) {
          verboseLogging = value;
          continue;
        }
        throw SourceSpanException(
            'Invalid value for "verbose_logging". Must be a boolean.',
            entry.value.span);
      } else {
        throw SourceSpanException(
            'Unknown cargokit option type. Must be "use_precompiled_binaries" or "verbose_logging".',
            entry.key.span);
      }
    }
    return CargokitUserOptions(
      usePrecompiledBinaries: usePrecompiledBinaries,
      verboseLogging: verboseLogging,
    );
  }

  static CargokitUserOptions load() {
    String fileName = "cargokit_options.yaml";
    var userProjectDir = Directory(Environment.rootProjectDir);

    while (userProjectDir.parent.path != userProjectDir.path) {
      final configFile = File(path.join(userProjectDir.path, fileName));
      if (configFile.existsSync()) {
        final contents = loadYamlNode(
          configFile.readAsStringSync(),
          sourceUrl: configFile.uri,
        );
        final res = parse(contents);
        if (res.verboseLogging) {
          _log.info('Found user options file at ${configFile.path}');
        }
        return res;
      }
      userProjectDir = userProjectDir.parent;
    }
    return CargokitUserOptions._();
  }

  final bool usePrecompiledBinaries;
  final bool verboseLogging;
}

```

`/Users/rinat/projects/zilpay/zilpay-mobile/rust_builder/cargokit/build_tool/lib/src/target.dart`:

```dart
/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import 'dart:io';

import 'package:collection/collection.dart';

import 'util.dart';

class Target {
  Target({
    required this.rust,
    this.flutter,
    this.android,
    this.androidMinSdkVersion,
    this.darwinPlatform,
    this.darwinArch,
  });

  static final all = [
    Target(
      rust: 'armv7-linux-androideabi',
      flutter: 'android-arm',
      android: 'armeabi-v7a',
      androidMinSdkVersion: 16,
    ),
    Target(
      rust: 'aarch64-linux-android',
      flutter: 'android-arm64',
      android: 'arm64-v8a',
      androidMinSdkVersion: 21,
    ),
    Target(
      rust: 'i686-linux-android',
      flutter: 'android-x86',
      android: 'x86',
      androidMinSdkVersion: 16,
    ),
    Target(
      rust: 'x86_64-linux-android',
      flutter: 'android-x64',
      android: 'x86_64',
      androidMinSdkVersion: 21,
    ),
    Target(
      rust: 'x86_64-pc-windows-msvc',
      flutter: 'windows-x64',
    ),
    Target(
      rust: 'x86_64-unknown-linux-gnu',
      flutter: 'linux-x64',
    ),
    Target(
      rust: 'aarch64-unknown-linux-gnu',
      flutter: 'linux-arm64',
    ),
    Target(
      rust: 'x86_64-apple-darwin',
      darwinPlatform: 'macosx',
      darwinArch: 'x86_64',
    ),
    Target(
      rust: 'aarch64-apple-darwin',
      darwinPlatform: 'macosx',
      darwinArch: 'arm64',
    ),
    Target(
      rust: 'aarch64-apple-ios',
      darwinPlatform: 'iphoneos',
      darwinArch: 'arm64',
    ),
    Target(
      rust: 'aarch64-apple-ios-sim',
      darwinPlatform: 'iphonesimulator',
      darwinArch: 'arm64',
    ),
    Target(
      rust: 'x86_64-apple-ios',
      darwinPlatform: 'iphonesimulator',
      darwinArch: 'x86_64',
    ),
  ];

  static Target? forFlutterName(String flutterName) {
    return all.firstWhereOrNull((element) => element.flutter == flutterName);
  }

  static Target? forDarwin({
    required String platformName,
    required String darwinAarch,
  }) {
    return all.firstWhereOrNull((element) => //
        element.darwinPlatform == platformName &&
        element.darwinArch == darwinAarch);
  }

  static Target? forRustTriple(String triple) {
    return all.firstWhereOrNull((element) => element.rust == triple);
  }

  static List<Target> androidTargets() {
    return all
        .where((element) => element.android != null)
        .toList(growable: false);
  }

  /// Returns buildable targets on current host platform ignoring Android targets.
  static List<Target> buildableTargets() {
    if (Platform.isLinux) {
      // Right now we don't support cross-compiling on Linux. So we just return
      // the host target.
      final arch = runCommand('arch', []).stdout as String;
      if (arch.trim() == 'aarch64') {
        return [Target.forRustTriple('aarch64-unknown-linux-gnu')!];
      } else {
        return [Target.forRustTriple('x86_64-unknown-linux-gnu')!];
      }
    }
    return all.where((target) {
      if (Platform.isWindows) {
        return target.rust.contains('-windows-');
      } else if (Platform.isMacOS) {
        return target.darwinPlatform != null;
      }
      return false;
    }).toList(growable: false);
  }

  @override
  String toString() {
    return rust;
  }

  final String? flutter;
  final String rust;
  final String? android;
  final int? androidMinSdkVersion;
  final String? darwinPlatform;
  final String? darwinArch;
}

```