Project Path: lib

Source Tree:

```txt
lib
├── app.dart
├── components
│   ├── action_button.dart
│   ├── address_avatar.dart
│   ├── async_qrcode.dart
│   ├── biometric_switch.dart
│   ├── bottom_nav_bar.dart
│   ├── browser_action_menu.dart
│   ├── button.dart
│   ├── button_item.dart
│   ├── copy_content.dart
│   ├── counter.dart
│   ├── crypto_list.dart
│   ├── custom_app_bar.dart
│   ├── custom_dropdown.dart
│   ├── detail_group_card.dart
│   ├── detail_item_group_card.dart
│   ├── enable_card.dart
│   ├── gas_eip1559.dart
│   ├── hex_key.dart
│   ├── hoverd_svg.dart
│   ├── image_cache.dart
│   ├── input_amount.dart
│   ├── ledger_device_card.dart
│   ├── linear_refresh_indicator.dart
│   ├── load_button.dart
│   ├── mnemonic_word_input.dart
│   ├── net_btn.dart
│   ├── network_card.dart
│   ├── network_tile.dart
│   ├── number_keyboard.dart
│   ├── option_list.dart
│   ├── settings_item.dart
│   ├── smart_input.dart
│   ├── stakeing_card.dart
│   ├── swipe_button.dart
│   ├── switch_setting_item.dart
│   ├── tile_button.dart
│   ├── token_card.dart
│   ├── token_select_item.dart
│   ├── token_transfer_amount.dart
│   ├── transaction_amount_display.dart
│   ├── transaction_item.dart
│   ├── view_item.dart
│   ├── wallet_card.dart
│   ├── wallet_header.dart
│   ├── wallet_option.dart
│   ├── wallet_selector_card.dart
│   └── wor_count_selector.dart
├── config
│   ├── argon.dart
│   ├── eip1193.dart
│   ├── evm_messages.dart
│   ├── ftokens.dart
│   ├── search_engines.dart
│   ├── settings.dart
│   └── zilliqa_legacy_messages.dart
├── l10n
│   ├── app_localizations.dart
│   ├── app_localizations_en.dart
│   ├── app_localizations_ja.dart
│   ├── app_localizations_ru.dart
│   └── app_localizations_zh.dart
├── ledger
│   ├── common.dart
│   ├── ethereum
│   │   ├── ethereum_eip712_hashed_message_operation.dart
│   │   ├── ethereum_ledger_application.dart
│   │   ├── ethereum_personal_message_operation.dart
│   │   ├── ethereum_public_key_operation.dart
│   │   ├── ethereum_transaction_operation.dart
│   │   ├── models.dart
│   │   └── utils.dart
│   └── zilliqa
│       ├── zilliqa_ledger_application.dart
│       ├── zilliqa_public_key_operation.dart
│       ├── zilliqa_sign_hash_operation.dart
│       └── zilliqa_sign_tx_operation.dart
├── main.dart
├── mixins
│   ├── adaptive_size.dart
│   ├── addr.dart
│   ├── amount.dart
│   ├── colors.dart
│   ├── eip712.dart
│   ├── gas_eip1559.dart
│   ├── jazzicon.dart
│   ├── preprocess_url.dart
│   ├── qrcode.dart
│   └── wallet_type.dart
├── pages
│   ├── about.dart
│   ├── add_account.dart
│   ├── add_ledger_account.dart
│   ├── address_book.dart
│   ├── appearance.dart
│   ├── browser_page.dart
│   ├── browser_settings.dart
│   ├── currency_conversion.dart
│   ├── gen_bip39.dart
│   ├── gen_wallet_options.dart
│   ├── history_page.dart
│   ├── home_page.dart
│   ├── initial_page.dart
│   ├── keystore_backup.dart
│   ├── keystore_file_restore.dart
│   ├── ledger_connect.dart
│   ├── locale.dart
│   ├── login_page.dart
│   ├── main_page.dart
│   ├── manage_tokens.dart
│   ├── network.dart
│   ├── new_wallet_options.dart
│   ├── notification.dart
│   ├── password_setup.dart
│   ├── receive.dart
│   ├── restore_bip39.dart
│   ├── restore_rkstorage.dart
│   ├── restore_sk.dart
│   ├── reveal_bip39.dart
│   ├── reveal_sk.dart
│   ├── security.dart
│   ├── send.dart
│   ├── settings_page.dart
│   ├── setup_cipher.dart
│   ├── setup_net.dart
│   ├── sk_gen.dart
│   ├── verify_bip39.dart
│   ├── wallet.dart
│   ├── wallet_restore_options.dart
│   ├── web_view.dart
│   └── zil_stake.dart
├── router.dart
├── services
│   ├── auth_guard.dart
│   ├── biometric_service.dart
│   ├── device.dart
│   ├── secure_storage.dart
│   └── social_media.dart
├── state
│   └── app_state.dart
├── theme
│   └── app_theme.dart
├── utils
│   └── utils.dart
└── web3
    ├── eip_1193.dart
    ├── message.dart
    ├── web3_utils.dart
    └── zilpay_legacy.dart

```

`lib/app.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'router.dart';
import 'services/auth_guard.dart';
import 'state/app_state.dart';

class ZilPayApp extends StatelessWidget {
  final AuthGuard authGuard;
  final AppState appState;

  const ZilPayApp({super.key, required this.authGuard, required this.appState});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider.value(value: authGuard),
        ChangeNotifierProvider.value(value: appState),
      ],
      child: Builder(
        builder: (context) {
          return Consumer<AppState>(
            builder: (context, appState, _) {
              final currentTheme = appState.currentTheme;

              return MaterialApp(
                // debugShowCheckedModeBanner: false,
                title:
                    AppLocalizations.of(context)?.appTitle ?? 'ZilPay Wallet',
                localizationsDelegates: const [
                  AppLocalizations.delegate,
                  GlobalMaterialLocalizations.delegate,
                  GlobalWidgetsLocalizations.delegate,
                  GlobalCupertinoLocalizations.delegate,
                ],
                supportedLocales: const [
                  Locale('en'),
                  Locale('ru'),
                  Locale('ja'),
                  Locale('zh'),
                ],
                locale: appState.locale,
                builder: (context, child) {
                  final mediaQuery = MediaQuery.of(context);
                  final screenWidth = mediaQuery.size.width;

                  double textScale = 1.0;

                  if (screenWidth <= 375) {
                    textScale = 0.8;
                  } else if (screenWidth <= 390) {
                    textScale = 0.85;
                  } else {
                    textScale = 1.1;
                  }

                  return MediaQuery(
                    data: mediaQuery.copyWith(
                      textScaler: TextScaler.linear(textScale),
                    ),
                    child: child!,
                  );
                },
                theme: ThemeData(
                  brightness: currentTheme.brightness,
                  primaryColor: currentTheme.primaryPurple,
                  cardColor: currentTheme.cardBackground,
                  scaffoldBackgroundColor: currentTheme.background,
                  canvasColor: Colors.transparent,
                  textTheme: TextTheme(
                    bodyLarge: TextStyle(color: currentTheme.textPrimary),
                    bodyMedium: TextStyle(color: currentTheme.textSecondary),
                    displayLarge: TextStyle(
                        color: currentTheme.textPrimary,
                        fontSize: 34.0,
                        fontWeight: FontWeight.bold),
                    displayMedium: TextStyle(
                        color: currentTheme.textPrimary,
                        fontSize: 28.0,
                        fontWeight: FontWeight.bold),
                    headlineMedium: TextStyle(
                        color: currentTheme.textPrimary,
                        fontSize: 24.0,
                        fontWeight: FontWeight.w600),
                    titleMedium: TextStyle(
                        color: currentTheme.textPrimary,
                        fontSize: 18.0,
                        fontWeight: FontWeight.w500),
                    labelLarge: TextStyle(
                        color: currentTheme.buttonText,
                        fontSize: 16.0,
                        fontWeight: FontWeight.w500),
                  ),
                  pageTransitionsTheme: const PageTransitionsTheme(
                    builders: {
                      TargetPlatform.android:
                          FadeUpwardsPageTransitionsBuilder(),
                      TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),
                    },
                  ),
                  checkboxTheme: CheckboxThemeData(
                    side: BorderSide(
                      color: currentTheme.primaryPurple,
                      width: 1.5,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(3.0),
                    ),
                  ),
                  colorScheme: currentTheme.brightness == Brightness.light
                      ? ColorScheme.light(
                          primary: currentTheme.primaryPurple,
                          secondary: currentTheme.secondaryPurple,
                          error: currentTheme.danger,
                          surface: currentTheme.buttonText,
                        )
                      : ColorScheme.dark(
                          primary: currentTheme.primaryPurple,
                          secondary: currentTheme.secondaryPurple,
                          error: currentTheme.danger,
                          surface: currentTheme.buttonText,
                        ),
                  switchTheme: SwitchThemeData(
                    overlayColor: WidgetStateProperty.resolveWith((states) {
                      if (states.contains(WidgetState.selected)) {
                        return currentTheme.primaryPurple
                            .withValues(alpha: 0.1);
                      }
                      return null;
                    }),
                    trackColor: WidgetStateProperty.resolveWith((states) {
                      if (!states.contains(WidgetState.selected)) {
                        return currentTheme.textSecondary
                            .withValues(alpha: 0.3);
                      }

                      return currentTheme.primaryPurple.withValues(alpha: 0.2);
                    }),
                    trackOutlineColor:
                        WidgetStateProperty.resolveWith((states) {
                      if (!states.contains(WidgetState.selected)) {
                        return currentTheme.cardBackground;
                      }
                      return currentTheme.cardBackground;
                    }),
                  ),
                ),
                initialRoute: '/',
                onGenerateRoute: AppRouter(
                  authGuard: Provider.of<AuthGuard>(context, listen: false),
                  appState: Provider.of<AppState>(context, listen: false),
                ).onGenerateRoute,
              );
            },
          );
        },
      ),
    );
  }
}

```

`lib/components/action_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomActionButton extends StatefulWidget {
  final String label;
  final String iconPath;
  final VoidCallback onPressed;

  const CustomActionButton({
    super.key,
    required this.label,
    required this.iconPath,
    required this.onPressed,
  });

  @override
  State<CustomActionButton> createState() => CustomActionButtonState();
}

class CustomActionButtonState extends State<CustomActionButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) => setState(() => _isPressed = false),
      onTapCancel: () => setState(() => _isPressed = false),
      onTap: widget.onPressed,
      child: AnimatedOpacity(
        duration: const Duration(milliseconds: 150),
        opacity: _isPressed ? 0.5 : 1.0,
        child: Container(
          width: 70,
          height: 70,
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.2),
                spreadRadius: 1,
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              SvgPicture.asset(
                widget.iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.primaryPurple,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(height: 6),
              Text(
                widget.label,
                style: theme.caption.copyWith(
                  color: theme.buttonText,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`lib/components/address_avatar.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/jazzicon.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/state/app_state.dart';

class AvatarAddress extends StatelessWidget {
  final double avatarSize;
  final AccountInfo account;

  const AvatarAddress({
    super.key,
    required this.avatarSize,
    required this.account,
  });

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return Container(
      width: avatarSize,
      height: avatarSize,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: theme.primaryPurple.withAlpha(0x1A),
          width: 1,
        ),
      ),
      child: ClipOval(
        child: account.addrType == 1
            ? Jazzicon(
                diameter: avatarSize,
                seed: account.addr,
                theme: theme,
                shapeCount: 4,
              )
            : Blockies(
                color: theme.secondaryPurple,
                bgColor: theme.primaryPurple,
                size: 8,
                spotColor: theme.background,
                seed: account.addr,
              ),
      ),
    );
  }
}

```

`lib/components/async_qrcode.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/qrcode.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';

enum EyeShape {
  square(0),
  circle(1);

  final int value;
  const EyeShape(this.value);
}

enum DataModuleShape {
  square(0),
  circle(1);

  final int value;
  const DataModuleShape(this.value);
}

class AsyncQRcode extends StatefulWidget {
  final int size;
  final String data;
  final EyeShape eyeShape;
  final bool gapless;
  final Color color;
  final DataModuleShape dataModuleShape;
  final BoxFit? fit;
  final Widget? loadingWidget;
  final Widget? errorWidget;

  const AsyncQRcode({
    super.key,
    required this.data,
    required this.color,
    this.size = 200,
    this.gapless = false,
    this.eyeShape = EyeShape.circle,
    this.dataModuleShape = DataModuleShape.circle,
    this.fit = BoxFit.cover,
    this.loadingWidget,
    this.errorWidget,
  });

  @override
  State<AsyncQRcode> createState() => _AsyncQRcodeState();
}

class _AsyncQRcodeState extends State<AsyncQRcode> {
  late final AppState _appState;
  String? _svgString;
  bool _hasError = false;

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
    _loadImage();
  }

  @override
  void didUpdateWidget(AsyncQRcode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.data != widget.data ||
        oldWidget.size != widget.size ||
        oldWidget.gapless != widget.gapless ||
        oldWidget.color != widget.color ||
        oldWidget.eyeShape != widget.eyeShape ||
        oldWidget.dataModuleShape != widget.dataModuleShape) {
      _loadImage();
    }
  }

  Future<void> _loadImage() async {
    try {
      QrConfigInfo config = QrConfigInfo(
        size: widget.size,
        gapless: widget.gapless,
        color: widget.color.toARGB32(),
        eyeShape: widget.eyeShape.value,
        dataModuleShape: widget.dataModuleShape.value,
      );
      final svg = await genSvgQrcode(data: widget.data, config: config);

      if (mounted) {
        setState(() {
          _svgString = svg;
          _hasError = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _svgString = null;
          _hasError = true;
        });
      }
    }
  }

  Widget _buildImage() {
    if (_hasError) {
      return SizedBox(
        width: widget.size.toDouble(),
        height: widget.size.toDouble(),
        child: widget.errorWidget ??
            Center(
              child: Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: _appState.currentTheme.danger,
                  shape: BoxShape.circle,
                ),
              ),
            ),
      );
    }

    return SvgPicture.string(
      _svgString!,
      width: widget.size.toDouble(),
      height: widget.size.toDouble(),
      fit: widget.fit ?? BoxFit.cover,
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_svgString == null && !_hasError) {
      return SizedBox(
        width: widget.size.toDouble(),
        height: widget.size.toDouble(),
        child: widget.loadingWidget ??
            const Center(
              child: CircularProgressIndicator(),
            ),
      );
    }

    return _buildImage();
  }
}

```

`lib/components/biometric_switch.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/state/app_state.dart';

class BiometricSwitch extends StatelessWidget {
  final AuthMethod biometricType;
  final bool value;
  final bool disabled;
  final bool isLoading;
  final ValueChanged<bool>? onChanged;

  const BiometricSwitch({
    super.key,
    required this.biometricType,
    required this.value,
    this.disabled = false,
    this.isLoading = false,
    this.onChanged,
  });

  String _authMethodText(BuildContext context) {
    switch (biometricType) {
      case AuthMethod.faceId:
        return AppLocalizations.of(context)!.biometricSwitchFaceId;
      case AuthMethod.fingerprint:
        return AppLocalizations.of(context)!.biometricSwitchFingerprint;
      case AuthMethod.biometric:
        return AppLocalizations.of(context)!.biometricSwitchBiometric;
      case AuthMethod.pinCode:
        return AppLocalizations.of(context)!.biometricSwitchPinCode;
      case AuthMethod.none:
        return '';
    }
  }

  String get _iconPath {
    switch (biometricType) {
      case AuthMethod.faceId:
        return 'assets/icons/face_id.svg';
      case AuthMethod.fingerprint:
        return 'assets/icons/fingerprint.svg';
      case AuthMethod.biometric:
        return 'assets/icons/biometric.svg';
      case AuthMethod.pinCode:
        return 'assets/icons/pin.svg';
      case AuthMethod.none:
        return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    if (biometricType == AuthMethod.none) {
      return const SizedBox.shrink();
    }

    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              SvgPicture.asset(
                _iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                _authMethodText(context),
                style: theme.bodyText1.copyWith(
                  color: theme.textPrimary,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 2,
                softWrap: true,
              ),
            ],
          ),
          isLoading
              ? SizedBox(
                  width: 36,
                  height: 36,
                  child: CupertinoActivityIndicator(
                    color: theme.primaryPurple,
                  ),
                )
              : Switch(
                  value: value,
                  onChanged: disabled ? null : onChanged,
                  activeThumbColor: theme.primaryPurple,
                  activeTrackColor: theme.primaryPurple.withValues(alpha: 0.4),
                ),
        ],
      ),
    );
  }
}

```

`lib/components/bottom_nav_bar.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'dart:ui';
import 'package:zilpay/state/app_state.dart';

class CustomBottomNavigationBar extends StatelessWidget {
  final List<CustomBottomNavigationBarItem> items;
  final int currentIndex;
  final Function(int) onTap;

  const CustomBottomNavigationBar({
    super.key,
    required this.items,
    required this.currentIndex,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return ClipRect(
      child: BackdropFilter(
        filter: ImageFilter.blur(
          sigmaX: 10.0,
          sigmaY: 10.0,
        ),
        child: SizedBox(
          height: 80,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: items.asMap().entries.map((entry) {
              int index = entry.key;
              CustomBottomNavigationBarItem item = entry.value;
              return Expanded(
                child: GestureDetector(
                  behavior: HitTestBehavior.opaque,
                  onTap: () => onTap(index),
                  child: Container(
                    color: Colors.transparent,
                    child: SvgPicture.asset(
                      item.iconPath,
                      colorFilter: ColorFilter.mode(
                        index == currentIndex
                            ? theme.primaryPurple
                            : theme.textSecondary,
                        BlendMode.srcIn,
                      ),
                      width: 40,
                      height: 40,
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ),
      ),
    );
  }
}

class CustomBottomNavigationBarItem {
  final String iconPath;

  CustomBottomNavigationBarItem({required this.iconPath});
}

```

`lib/components/browser_action_menu.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class BrowserActionMenu extends StatelessWidget {
  final VoidCallback onShare;
  final VoidCallback onCopyLink;
  final VoidCallback onClose;
  final VoidCallback? onBack;
  final VoidCallback? onForward;
  final BuildContext parentContext;

  const BrowserActionMenu({
    Key? key,
    required this.onShare,
    required this.onCopyLink,
    required this.onClose,
    this.onBack,
    this.onForward,
    required this.parentContext,
  }) : super(key: key);

  void _showMenu() {
    final appState = Provider.of<AppState>(parentContext, listen: false);
    final theme = appState.currentTheme;

    showDialog<void>(
      context: parentContext,
      barrierDismissible: true,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        child: Dialog(
          insetPadding: const EdgeInsets.all(0),
          backgroundColor: Colors.transparent,
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            child: Align(
              alignment: Alignment.topRight,
              child: Container(
                width: 200,
                margin: const EdgeInsets.only(top: 5, right: 5),
                decoration: BoxDecoration(
                  color: theme.cardBackground,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: IconButton(
                            onPressed: () {
                              Navigator.pop(context);
                              onBack!();
                            },
                            icon: SvgPicture.asset(
                              "assets/icons/back.svg",
                              width: 20,
                              height: 20,
                              colorFilter: ColorFilter.mode(
                                theme.textSecondary,
                                BlendMode.srcIn,
                              ),
                            ),
                          ),
                        ),
                        Expanded(
                          child: IconButton(
                            onPressed: () {
                              Navigator.pop(context);
                              onForward!();
                            },
                            icon: SvgPicture.asset(
                              "assets/icons/forward.svg",
                              width: 20,
                              height: 20,
                              colorFilter: ColorFilter.mode(
                                theme.textSecondary,
                                BlendMode.srcIn,
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                    _buildDivider(theme),
                    _buildMenuItem(
                      context,
                      AppLocalizations.of(context)!.browserActionMenuShare,
                      'assets/icons/share.svg',
                      onShare,
                      theme,
                    ),
                    _buildDivider(theme),
                    _buildMenuItem(
                      context,
                      AppLocalizations.of(context)!.browserActionMenuCopyLink,
                      'assets/icons/copy.svg',
                      onCopyLink,
                      theme,
                    ),
                    _buildDivider(theme),
                    _buildMenuItem(
                      context,
                      AppLocalizations.of(context)!.browserActionMenuClose,
                      'assets/icons/close.svg',
                      onClose,
                      theme,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildMenuItem(
    BuildContext context,
    String title,
    String icon,
    VoidCallback onTap,
    AppTheme theme,
  ) {
    return InkWell(
      onTap: () {
        Navigator.pop(context);
        onTap();
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 4),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            HoverSvgIcon(
              assetName: icon,
              width: 20,
              height: 20,
              color: theme.textPrimary,
              onTap: () {},
            ),
            const SizedBox(width: 12),
            Text(
              title,
              style: theme.bodyText2.copyWith(
                color: theme.textPrimary,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDivider(AppTheme theme) {
    return Divider(
      height: 1,
      thickness: 1,
      color: theme.textSecondary.withValues(alpha: 0.1),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme =
        Provider.of<AppState>(parentContext, listen: false).currentTheme;

    return Container(
      height: 40,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(20),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          HoverSvgIcon(
            assetName: 'assets/icons/dots.svg',
            width: 24,
            height: 24,
            onTap: _showMenu,
            color: theme.textPrimary,
          ),
          const SizedBox(width: 8),
          Container(
            width: 1,
            height: 40,
            color: theme.textSecondary.withValues(alpha: 0.1),
          ),
          const SizedBox(width: 8),
          HoverSvgIcon(
            assetName: 'assets/icons/close.svg',
            width: 20,
            height: 20,
            onTap: onClose,
            color: theme.textPrimary,
          ),
        ],
      ),
    );
  }
}

```

`lib/components/button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomButton extends StatefulWidget {
  final String text;
  final VoidCallback? onPressed;
  final double borderRadius;
  final Color textColor;
  final Color backgroundColor;
  final double width;
  final double height;
  final EdgeInsetsGeometry padding;
  final bool disabled;

  const CustomButton({
    super.key,
    required this.text,
    this.onPressed,
    this.borderRadius = 30.0,
    required this.textColor,
    required this.backgroundColor,
    this.width = double.infinity,
    this.height = 56.0,
    this.padding = const EdgeInsets.symmetric(horizontal: 16.0),
    this.disabled = false,
  });

  @override
  State<CustomButton> createState() => _CustomButtonState();
}

class _CustomButtonState extends State<CustomButton> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return GestureDetector(
      onTap: widget.disabled ? null : widget.onPressed,
      onTapDown:
          widget.disabled ? null : (_) => setState(() => _isHovered = true),
      onTapUp:
          widget.disabled ? null : (_) => setState(() => _isHovered = false),
      onTapCancel:
          widget.disabled ? null : () => setState(() => _isHovered = false),
      child: Focus(
        canRequestFocus: !widget.disabled,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          width: widget.width,
          height: widget.height,
          padding: widget.padding,
          decoration: BoxDecoration(
            color: widget.disabled
                ? widget.backgroundColor.withValues(alpha: 0.5)
                : widget.backgroundColor,
            borderRadius: BorderRadius.circular(widget.borderRadius),
          ),
          transform: _isHovered
              ? Matrix4.diagonal3Values(0.9, 0.9, 1)
              : Matrix4.identity(),
          transformAlignment: Alignment.center,
          child: Center(
            child: FittedBox(
              fit: BoxFit.scaleDown,
              child: Text(
                widget.text,
                style: theme.subtitle1.copyWith(
                  color: widget.disabled
                      ? widget.textColor.withAlpha(128)
                      : widget.textColor,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/components/button_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/theme/app_theme.dart';

extension BrowserSettingsInfoExtension on BrowserSettingsInfo {
  BrowserSettingsInfo copyWith({
    int? searchEngineIndex,
    bool? cacheEnabled,
    bool? cookiesEnabled,
    int? contentBlocking,
    bool? doNotTrack,
    bool? incognitoMode,
    double? textScalingFactor,
    bool? allowGeolocation,
    bool? allowCamera,
    bool? allowMicrophone,
    bool? allowAutoPlay,
  }) {
    return BrowserSettingsInfo(
      searchEngineIndex: searchEngineIndex ?? this.searchEngineIndex,
      cacheEnabled: cacheEnabled ?? this.cacheEnabled,
      cookiesEnabled: cookiesEnabled ?? this.cookiesEnabled,
      contentBlocking: contentBlocking ?? this.contentBlocking,
      doNotTrack: doNotTrack ?? this.doNotTrack,
      incognitoMode: incognitoMode ?? this.incognitoMode,
      textScalingFactor: textScalingFactor ?? this.textScalingFactor,
      allowGeolocation: allowGeolocation ?? this.allowGeolocation,
      allowCamera: allowCamera ?? this.allowCamera,
      allowMicrophone: allowMicrophone ?? this.allowMicrophone,
      allowAutoPlay: allowAutoPlay ?? this.allowAutoPlay,
    );
  }
}

class ButtonItem extends StatelessWidget {
  final AppTheme theme;
  final String title;
  final String iconPath;
  final String description;
  final VoidCallback onTap;
  final String? subtitleText;

  const ButtonItem({
    super.key,
    required this.theme,
    required this.title,
    required this.iconPath,
    required this.description,
    required this.onTap,
    this.subtitleText,
  });

  @override
  Widget build(BuildContext context) {
    return _ButtonItemContent(
      theme: theme,
      title: title,
      iconPath: iconPath,
      description: description,
      onTap: onTap,
      subtitleText: subtitleText,
    );
  }
}

class _ButtonItemContent extends StatefulWidget {
  final AppTheme theme;
  final String title;
  final String iconPath;
  final String description;
  final VoidCallback onTap;
  final String? subtitleText;

  const _ButtonItemContent({
    required this.theme,
    required this.title,
    required this.iconPath,
    required this.description,
    required this.onTap,
    this.subtitleText,
  });

  @override
  State<_ButtonItemContent> createState() => _ButtonItemContentState();
}

class _ButtonItemContentState extends State<_ButtonItemContent>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController;
  late final Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 100),
    );

    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.98).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: Curves.easeInOut,
      ),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onTap,
      onTapDown: (_) => _animationController.forward(),
      onTapUp: (_) => _animationController.reverse(),
      onTapCancel: () => _animationController.reverse(),
      behavior: HitTestBehavior.opaque,
      child: AnimatedBuilder(
        animation: _scaleAnimation,
        builder: (context, child) => Transform.scale(
          scale: _scaleAnimation.value,
          child: child,
        ),
        child: SizedBox(
          width: double.infinity,
          child: _buildContent(),
        ),
      ),
    );
  }

  Widget _buildContent() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              SvgPicture.asset(
                widget.iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  widget.theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.title,
                      style: widget.theme.bodyText1.copyWith(
                        color: widget.theme.textPrimary,
                      ),
                    ),
                    if (widget.subtitleText != null) ...[
                      const SizedBox(height: 4),
                      Text(
                        widget.subtitleText!,
                        style: widget.theme.bodyText2.copyWith(
                          color: widget.theme.primaryPurple,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              SvgPicture.asset(
                'assets/icons/chevron_right.svg',
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  widget.theme.textSecondary,
                  BlendMode.srcIn,
                ),
              ),
            ],
          ),
          if (widget.description.isNotEmpty) ...[
            const SizedBox(height: 4),
            Padding(
              padding: const EdgeInsets.only(left: 40),
              child: Text(
                widget.description,
                style: widget.theme.bodyText2.copyWith(
                  color: widget.theme.textSecondary,
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }
}

```

`lib/components/copy_content.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/state/app_state.dart';

class CopyContent extends StatefulWidget {
  final String address;
  final bool isShort;

  const CopyContent({
    super.key,
    required this.address,
    this.isShort = true,
  });

  @override
  State<CopyContent> createState() => _CopyContentState();
}

class _CopyContentState extends State<CopyContent>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  bool _isCopied = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );

    _opacityAnimation = Tween<double>(begin: 1.0, end: 0.7).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _copyToClipboard() async {
    await Clipboard.setData(ClipboardData(text: widget.address));
    if (mounted) {
      setState(() {
        _isCopied = true;
      });
      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          setState(() {
            _isCopied = false;
          });
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) => _controller.forward(),
        onTapUp: (_) {
          _controller.reverse();
          _copyToClipboard();
        },
        onTapCancel: () => _controller.reverse(),
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: Opacity(
                opacity: _opacityAnimation.value,
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  child: Wrap(
                    alignment: WrapAlignment.center,
                    crossAxisAlignment: WrapCrossAlignment.center,
                    spacing: 4,
                    runSpacing: 4,
                    children: [
                      Text(
                        widget.isShort
                            ? shortenAddress(widget.address)
                            : widget.address,
                        style: theme.bodyText2.copyWith(
                          color: theme.textSecondary,
                        ),
                      ),
                      SvgPicture.asset(
                        _isCopied
                            ? 'assets/icons/check.svg'
                            : 'assets/icons/copy.svg',
                        width: 14,
                        height: 14,
                        colorFilter: ColorFilter.mode(
                          _isCopied ? theme.success : theme.textSecondary,
                          BlendMode.srcIn,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

```

`lib/components/counter.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/state/app_state.dart';

class CounterIcons {
  static const String minus = '''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle cx="16" cy="16" r="15" fill="none" stroke="currentColor" stroke-width="2"/>
  <line x1="8" y1="16" x2="24" y2="16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
''';

  static const String plus = '''
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <circle cx="16" cy="16" r="15" fill="none" stroke="currentColor" stroke-width="2"/>
  <line x1="8" y1="16" x2="24" y2="16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  <line x1="16" y1="8" x2="16" y2="24" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>
''';
}

class Counter extends StatefulWidget {
  final double iconSize;
  final Color? iconColor;
  final TextStyle? numberStyle;
  final Duration animationDuration;
  final int initialValue;
  final ValueChanged<int>? onChanged;
  final bool disabled;
  final int minValue;
  final int maxValue;
  final String? errorText;

  const Counter({
    super.key,
    this.iconSize = 32,
    this.iconColor,
    this.numberStyle,
    this.animationDuration = const Duration(milliseconds: 300),
    this.initialValue = 0,
    this.onChanged,
    this.disabled = false,
    this.minValue = 0,
    this.maxValue = 999999,
    this.errorText,
  }) : assert(initialValue >= minValue && initialValue <= maxValue,
            'Initial value must be between min and max values');

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> with SingleTickerProviderStateMixin {
  late int _count;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _count = widget.initialValue;
    _controller = AnimationController(
      duration: widget.animationDuration,
      vsync: this,
    );

    _scaleAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.0, end: 1.2),
        weight: 50,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.2, end: 1.0),
        weight: 50,
      ),
    ]).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _animate() {
    if (!widget.disabled) {
      _controller.forward(from: 0);
    }
  }

  void _increment() {
    if (!widget.disabled && _count < widget.maxValue) {
      setState(() {
        _count++;
        _animate();
        _errorMessage = null;
        widget.onChanged?.call(_count);
      });
    } else if (!widget.disabled && _count >= widget.maxValue) {
      setState(() {
        _errorMessage = AppLocalizations.of(context)!.counterMaxValueError;
      });
    }
  }

  void _decrement() {
    if (!widget.disabled && _count > widget.minValue) {
      setState(() {
        _count--;
        _animate();
        _errorMessage = null;
        widget.onChanged?.call(_count);
      });
    } else if (!widget.disabled && _count <= widget.minValue) {
      setState(() {
        _errorMessage = AppLocalizations.of(context)!.counterMinValueError;
      });
    }
  }

  @override
  void didUpdateWidget(Counter oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialValue != oldWidget.initialValue) {
      setState(() {
        _count = widget.initialValue;
        _errorMessage = null;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Opacity(
      opacity: widget.disabled ? 0.6 : 1.0,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          SizedBox(
            width: double.infinity,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                IconButton(
                  icon: SvgPicture.string(
                    CounterIcons.minus,
                    width: widget.iconSize,
                    height: widget.iconSize,
                    colorFilter: ColorFilter.mode(
                      _count > widget.minValue && !widget.disabled
                          ? widget.iconColor ?? theme.secondaryPurple
                          : (widget.iconColor ?? theme.secondaryPurple)
                              .withValues(alpha: 0.3),
                      BlendMode.srcIn,
                    ),
                  ),
                  onPressed: widget.disabled
                      ? null
                      : (_count > widget.minValue ? _decrement : null),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: AnimatedBuilder(
                    animation: _scaleAnimation,
                    builder: (context, child) => Transform.scale(
                      scale: _scaleAnimation.value,
                      child: child,
                    ),
                    child: Text(
                      '$_count',
                      style: widget.numberStyle ??
                          theme.bodyText2.copyWith(
                            color: theme.textSecondary,
                            fontWeight: FontWeight.w500,
                          ),
                    ),
                  ),
                ),
                IconButton(
                  icon: SvgPicture.string(
                    CounterIcons.plus,
                    width: widget.iconSize,
                    height: widget.iconSize,
                    colorFilter: ColorFilter.mode(
                      _count < widget.maxValue && !widget.disabled
                          ? widget.iconColor ?? theme.secondaryPurple
                          : (widget.iconColor ?? theme.secondaryPurple)
                              .withValues(alpha: 0.3),
                      BlendMode.srcIn,
                    ),
                  ),
                  onPressed: widget.disabled
                      ? null
                      : (_count < widget.maxValue ? _increment : null),
                ),
              ],
            ),
          ),
          if (_errorMessage != null || widget.errorText != null)
            Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Text(
                _errorMessage ?? widget.errorText ?? '',
                style: theme.caption.copyWith(
                  color: theme.danger,
                ),
                textAlign: TextAlign.center,
              ),
            ),
        ],
      ),
    );
  }
}

```

`lib/components/crypto_list.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CryptoList extends StatelessWidget {
  final List<CryptoListItem> items;

  const CryptoList({super.key, required this.items});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: ListView.separated(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: items.length,
        separatorBuilder: (context, index) => Divider(
          color: theme.textSecondary.withValues(alpha: 0.2),
          height: 1,
        ),
        itemBuilder: (context, index) {
          return items[index];
        },
      ),
    );
  }
}

class CryptoListItem extends StatelessWidget {
  final String name;
  final String balance;
  final String balanceInUsd;
  final List<Widget> icons;

  const CryptoListItem({
    super.key,
    required this.name,
    required this.balance,
    required this.balanceInUsd,
    required this.icons,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: theme.bodyText1.copyWith(
                    color: theme.textPrimary,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  balanceInUsd,
                  style: theme.bodyText2.copyWith(
                    color: theme.textSecondary,
                  ),
                ),
              ],
            ),
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                balance,
                style: theme.bodyText1.copyWith(
                  color: theme.textPrimary,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const SizedBox(height: 4),
              Row(
                children: icons,
              ),
            ],
          ),
        ],
      ),
    );
  }
}

```

`lib/components/custom_app_bar.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String? title;
  final VoidCallback onBackPressed;
  final VoidCallback? onActionPressed;
  final Widget? actionIcon;
  final Widget? actionWidget;

  const CustomAppBar({
    super.key,
    required this.onBackPressed,
    this.title,
    this.onActionPressed,
    this.actionIcon,
    this.actionWidget,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 5.0, vertical: 5.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              icon: SvgPicture.asset(
                'assets/icons/back.svg',
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              onPressed: onBackPressed,
            ),
            if (title != null)
              Expanded(
                child: Text(
                  title!,
                  style: theme.headline2.copyWith(
                    color: theme.textPrimary,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            if (actionWidget != null)
              Padding(
                padding: const EdgeInsets.only(right: 8.0),
                child: actionWidget!,
              )
            else if (actionIcon != null && onActionPressed != null)
              IconButton(
                icon: actionIcon!,
                onPressed: onActionPressed,
              )
            else
              const SizedBox(width: 48),
          ],
        ),
      ),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

```

`lib/components/custom_dropdown.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class CustomDropdown extends StatefulWidget {
  final List<dynamic> items;
  final int selectedItem;
  final Function(int) onChanged;

  const CustomDropdown({
    super.key,
    required this.items,
    required this.selectedItem,
    required this.onChanged,
  });

  @override
  State<CustomDropdown> createState() => _CustomDropdownState();
}

class _CustomDropdownState extends State<CustomDropdown>
    with SingleTickerProviderStateMixin {
  bool _isExpanded = false;
  late OverlayEntry _overlayEntry;
  late AnimationController _animationController;
  late Animation<double> _expandAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 300));
    _expandAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return GestureDetector(
      onTap: _toggleDropdown,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: theme.primaryPurple,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              widget.selectedItem.toString(),
              style: theme.bodyText1.copyWith(color: theme.textPrimary),
            ),
            const SizedBox(width: 8),
            Icon(
              _isExpanded ? Icons.arrow_drop_up : Icons.arrow_drop_down,
              color: Colors.white,
            ),
          ],
        ),
      ),
    );
  }

  void _toggleDropdown() {
    if (_isExpanded) {
      _animationController.reverse().then((_) {
        if (_overlayEntry.mounted) {
          _overlayEntry.remove();
        }
      });
    } else {
      _overlayEntry = _createOverlayEntry();
      Overlay.of(context).insert(_overlayEntry);
      _animationController.forward();
    }
    setState(() {
      _isExpanded = !_isExpanded;
    });
  }

  OverlayEntry _createOverlayEntry() {
    RenderBox renderBox = context.findRenderObject() as RenderBox;
    var size = renderBox.size;
    var offset = renderBox.localToGlobal(Offset.zero);

    return OverlayEntry(
      builder: (context) {
        final theme = Provider.of<AppState>(context).currentTheme;

        return GestureDetector(
          onTap: () => _toggleDropdown(),
          behavior: HitTestBehavior.translucent,
          child: Stack(
            children: [
              Positioned.fill(
                child: Container(
                  color: Colors.transparent,
                ),
              ),
              Positioned(
                left: offset.dx,
                top: offset.dy + size.height,
                width: size.width,
                child: SizeTransition(
                  sizeFactor: _expandAnimation,
                  axisAlignment: 1,
                  child: Material(
                    elevation: 4,
                    child: Container(
                      padding: const EdgeInsets.symmetric(vertical: 4),
                      decoration: BoxDecoration(
                        color: theme.primaryPurple,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Column(
                        children: widget.items.map((item) {
                          return InkWell(
                            onTap: () {
                              widget.onChanged(item);
                              _toggleDropdown();
                            },
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                  vertical: 12, horizontal: 16),
                              child: Text(
                                item.toString(),
                                style: theme.bodyText1.copyWith(color: Colors.white),
                              ),
                            ),
                          );
                        }).toList(),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

```

`lib/components/detail_group_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:zilpay/theme/app_theme.dart';

class DetailGroupCard extends StatelessWidget {
  final String title;
  final List<Widget> children;
  final AppTheme theme;
  final Widget? headerTrailing;
  final EdgeInsetsGeometry? padding;
  final EdgeInsetsGeometry? contentPadding;
  final BorderRadius? borderRadius;

  const DetailGroupCard({
    super.key,
    required this.title,
    required this.children,
    required this.theme,
    this.headerTrailing,
    this.padding,
    this.contentPadding,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: theme.background.withValues(alpha: 0.5),
        borderRadius: borderRadius ?? BorderRadius.circular(12),
        border: Border.all(color: theme.modalBorder.withValues(alpha: 0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: padding ??
                const EdgeInsets.only(top: 12, left: 12, right: 12, bottom: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  title,
                  style: theme.bodyText1.copyWith(
                    color: theme.textPrimary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                if (headerTrailing != null) headerTrailing!,
              ],
            ),
          ),
          Divider(height: 1, color: theme.modalBorder.withValues(alpha: 0.3)),
          if (contentPadding != null)
            Padding(
              padding: contentPadding!,
              child: Column(children: children),
            )
          else
            Column(children: children),
        ],
      ),
    );
  }
}

```

`lib/components/detail_item_group_card.dart`:

```dart
import 'package:flutter/widgets.dart';
import 'package:zilpay/components/copy_content.dart';
import 'package:zilpay/theme/app_theme.dart';

class DetailItem extends StatelessWidget {
  final String label;
  final dynamic value;
  final AppTheme theme;
  final bool isCopyable;
  final Widget? valueWidget;

  const DetailItem({
    super.key,
    required this.label,
    this.value,
    required this.theme,
    this.isCopyable = false,
    this.valueWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            flex: 2,
            child: Text(
              label,
              style: theme.bodyText2.copyWith(
                color: theme.textSecondary.withValues(alpha: 0.7),
              ),
            ),
          ),
          Expanded(
            flex: 3,
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                if (valueWidget != null)
                  Expanded(
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: valueWidget!,
                    ),
                  )
                else if (isCopyable)
                  CopyContent(
                    address: value.toString(),
                    isShort: true,
                  )
                else
                  Expanded(
                    child: value is Widget
                        ? value
                        : Text(
                            value?.toString() ?? '',
                            style: theme.bodyText2.copyWith(
                              color: theme.textPrimary,
                            ),
                            textAlign: TextAlign.right,
                            overflow: TextOverflow.ellipsis,
                          ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

```

`lib/components/enable_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class EnableCard extends StatelessWidget {
  final String title;
  final String name;
  final Widget? iconWidget;
  final bool isDefault;
  final bool isEnabled;
  final void Function(bool)? onToggle;

  const EnableCard({
    super.key,
    required this.title,
    required this.name,
    this.iconWidget,
    required this.isDefault,
    required this.isEnabled,
    this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    const double iconSize = 32.0;

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          if (iconWidget != null)
            Container(
              width: iconSize,
              height: iconSize,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(16),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(16),
                child: iconWidget,
              ),
            ),
          if (iconWidget != null) const SizedBox(width: 12),
          Expanded(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        title,
                        style: theme.bodyText1.copyWith(
                          color: theme.textPrimary,
                          fontWeight: FontWeight.w500,
                          height: 1.2,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  name,
                  style: theme.bodyText2.copyWith(
                    color: theme.textSecondary,
                    height: 1.2,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
          Switch(
            value: isDefault ? true : isEnabled,
            onChanged: isDefault ? null : onToggle,
            activeThumbColor:
                isDefault ? theme.textSecondary : theme.primaryPurple,
          ),
        ],
      ),
    );
  }
}

```

`lib/components/gas_eip1559.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/gas_eip1559.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/gas.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

extension GasFeeOptionX on GasFeeOption {
  String title(BuildContext context) {
    switch (this) {
      case GasFeeOption.low:
        return AppLocalizations.of(context)!.gasFeeOptionLow;
      case GasFeeOption.market:
        return AppLocalizations.of(context)!.gasFeeOptionMarket;
      case GasFeeOption.aggressive:
        return AppLocalizations.of(context)!.gasFeeOptionAggressive;
    }
  }

  int get blocksForConfirmation {
    switch (this) {
      case GasFeeOption.low:
        return 10;
      case GasFeeOption.market:
        return 5;
      case GasFeeOption.aggressive:
        return 2;
    }
  }

  String confirmationTime(int timeDiffBlock) {
    int seconds = blocksForConfirmation * timeDiffBlock;
    if (seconds < 60) {
      seconds = seconds == 0 ? 1 : seconds;
      return '~$seconds sec';
    } else {
      int minutes = (seconds / 60).round();
      return '~$minutes min';
    }
  }

  String get icon {
    switch (this) {
      case GasFeeOption.low:
        return '🐥';
      case GasFeeOption.market:
        return '🐼';
      case GasFeeOption.aggressive:
        return '👹';
    }
  }
}

class GasDetails extends StatelessWidget {
  final RequiredTxParamsInfo txParamsInfo;
  final GasFeeOption selectedOption;
  final FTokenInfo token;
  final AppTheme theme;
  final bool disabled;
  final Color? textColor;
  final Color? secondaryColor;

  const GasDetails({
    super.key,
    required this.txParamsInfo,
    required this.selectedOption,
    required this.token,
    required this.theme,
    required this.disabled,
    this.textColor,
    this.secondaryColor,
  });

  @override
  Widget build(BuildContext context) {
    final effectiveTextColor = textColor ?? theme.textPrimary;
    final effectiveSecondaryColor = secondaryColor ?? theme.textSecondary;

    return Column(
      children: [
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: theme.background,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            children: [
              if (txParamsInfo.txEstimateGas != BigInt.zero)
                _buildDetailRow(
                  AppLocalizations.of(context)!.gasDetailsEstimatedGas,
                  '${txParamsInfo.txEstimateGas}',
                  effectiveTextColor,
                  effectiveSecondaryColor,
                ),
              _buildDetailRow(
                AppLocalizations.of(context)!.gasDetailsGasPrice,
                formatGasPriceDetail(
                  calculateGasPrice(selectedOption, txParamsInfo.gasPrice),
                  token,
                ),
                effectiveTextColor,
                effectiveSecondaryColor,
              ),
              if (txParamsInfo.feeHistory.baseFee != BigInt.zero)
                _buildDetailRow(
                  AppLocalizations.of(context)!.gasDetailsBaseFee,
                  formatGasPriceDetail(
                    txParamsInfo.feeHistory.baseFee,
                    token,
                  ),
                  effectiveTextColor,
                  effectiveSecondaryColor,
                ),
              if (txParamsInfo.feeHistory.priorityFee != BigInt.zero)
                _buildDetailRow(
                  AppLocalizations.of(context)!.gasDetailsPriorityFee,
                  formatGasPriceDetail(
                    calculateMaxPriorityFee(
                      selectedOption,
                      txParamsInfo.feeHistory.priorityFee,
                    ),
                    token,
                  ),
                  effectiveTextColor,
                  effectiveSecondaryColor,
                ),
              if (txParamsInfo.feeHistory.baseFee != BigInt.zero &&
                  txParamsInfo.feeHistory.priorityFee != BigInt.zero)
                _buildDetailRow(
                  AppLocalizations.of(context)!.gasDetailsMaxFee,
                  formatGasPriceDetail(
                    calculateFeeForOption(
                      selectedOption,
                      txParamsInfo.feeHistory.baseFee,
                      txParamsInfo.feeHistory.priorityFee,
                    ),
                    token,
                  ),
                  effectiveTextColor,
                  effectiveSecondaryColor,
                ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildDetailRow(
    String label,
    String value,
    Color textColor,
    Color secondaryColor,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: theme.caption.copyWith(
              color: secondaryColor.withValues(alpha: disabled ? 0.5 : 1.0),
            ),
          ),
          Text(
            value,
            style: theme.caption.copyWith(
              color: textColor.withValues(alpha: disabled ? 0.5 : 1.0),
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

class GasEIP1559 extends StatefulWidget {
  final RequiredTxParamsInfo txParamsInfo;
  final Function(BigInt maxPriorityFee) onChangeMaxPriorityFee;
  final Function(BigInt gasPrice) onChangeGasPrice;
  final Function(BigInt totalFee) onTotalFeeChange;
  final bool disabled;
  final int timeDiffBlock;
  final Color? primaryColor;
  final Color? textColor;
  final Color? secondaryColor;

  const GasEIP1559({
    super.key,
    required this.txParamsInfo,
    required this.onChangeMaxPriorityFee,
    required this.onChangeGasPrice,
    required this.onTotalFeeChange,
    required this.timeDiffBlock,
    this.disabled = false,
    this.primaryColor,
    this.textColor,
    this.secondaryColor,
  });

  @override
  State<GasEIP1559> createState() => _GasEIP1559State();
}

class _GasEIP1559State extends State<GasEIP1559> with TickerProviderStateMixin {
  late final AnimationController _expandController;
  late final Animation<double> _expandAnimation;
  bool _isExpanded = false;
  GasFeeOption _selected = GasFeeOption.market;
  BigInt _currentTotalFee = BigInt.zero;

  @override
  void initState() {
    super.initState();
    _expandController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _expandAnimation = CurvedAnimation(
      parent: _expandController,
      curve: Curves.easeInOut,
    );

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeSelectedOption();
    });
  }

  @override
  void dispose() {
    _expandController.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(GasEIP1559 oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.txParamsInfo != widget.txParamsInfo) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _updateGasFees();
      });
    }
  }

  void _initializeSelectedOption() {
    final appState = Provider.of<AppState>(context, listen: false);
    _selected = appState.selectedGasOption;
    _updateGasFees();
  }

  void _updateGasFees() {
    BigInt maxPriorityFee = calculateMaxPriorityFee(
      _selected,
      widget.txParamsInfo.feeHistory.priorityFee,
    );
    BigInt gasPrice = calculateGasPrice(
      _selected,
      widget.txParamsInfo.gasPrice,
    );

    widget.onChangeMaxPriorityFee(maxPriorityFee);
    widget.onChangeGasPrice(gasPrice);
    _updateTotalFee();
  }

  void _updateTotalFee() {
    final totalGasFee = calculateTotalGasCost(
      _selected,
      widget.txParamsInfo.feeHistory.baseFee,
      widget.txParamsInfo.feeHistory.priorityFee,
      widget.txParamsInfo.txEstimateGas,
      widget.txParamsInfo.gasPrice,
    );

    if (_currentTotalFee != totalGasFee) {
      _currentTotalFee = totalGasFee;
      widget.onTotalFeeChange(totalGasFee);
    }
  }

  void _handleOptionTap(GasFeeOption option) {
    if (widget.disabled) return;

    if (_selected == option) {
      setState(() {
        _isExpanded = !_isExpanded;
        _isExpanded ? _expandController.forward() : _expandController.reverse();
      });
      return;
    }

    setState(() {
      _selected = option;
      _isExpanded = false;
      _expandController.reverse();
    });

    final appState = Provider.of<AppState>(context, listen: false);
    appState.setSelectedGasOption(option);

    final maxPriorityFee = calculateMaxPriorityFee(
      option,
      widget.txParamsInfo.feeHistory.priorityFee,
    );
    widget.onChangeMaxPriorityFee(maxPriorityFee);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateTotalFee();
    });
  }

  Widget _buildGasOption({
    required GasFeeOption option,
    required Color optionTextColor,
    required AppState appState,
    required NetworkConfigInfo chain,
    required FTokenInfo token,
  }) {
    final theme = appState.currentTheme;
    final effectivePrimaryColor = widget.primaryColor ?? theme.primaryPurple;
    final effectiveTextColor = widget.textColor ?? theme.textPrimary;
    final effectiveSecondaryColor =
        widget.secondaryColor ?? theme.textSecondary;

    final isSelected = _selected == option;
    final confirmationTime = option.confirmationTime(widget.timeDiffBlock);

    final totalGasFee = calculateTotalGasCost(
      option,
      widget.txParamsInfo.feeHistory.baseFee,
      widget.txParamsInfo.feeHistory.priorityFee,
      widget.txParamsInfo.txEstimateGas,
      widget.txParamsInfo.gasPrice,
    );
    final (normalizedGasFee, convertedGasFee) = formatingAmount(
      amount: totalGasFee,
      symbol: token.symbol,
      decimals: token.decimals,
      rate: token.rate,
      appState: appState,
    );

    return TweenAnimationBuilder<double>(
      tween: Tween<double>(
        begin: 0.95,
        end: isSelected ? 1.0 : 0.95,
      ),
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeOutQuart,
      builder: (context, value, child) => Transform.scale(
        scale: value,
        child: Opacity(
          opacity: widget.disabled ? 0.5 : 1.0,
          child: Semantics(
            button: true,
            label: '${option.title(context)} gas fee option',
            child: GestureDetector(
              onTap: widget.disabled ? null : () => _handleOptionTap(option),
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? effectivePrimaryColor.withValues(alpha: 0.1)
                      : Colors.transparent,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Column(
                  children: [
                    Row(
                      children: [
                        Text(
                          option.icon,
                          style: theme.bodyText1,
                        ),
                        const SizedBox(width: 8),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              option.title(context),
                              style: theme.bodyText1.copyWith(
                                color: effectiveTextColor,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              confirmationTime,
                              style: theme.caption.copyWith(
                                color: effectiveSecondaryColor,
                              ),
                            ),
                          ],
                        ),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Text(
                                '≈ $normalizedGasFee',
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                                style: theme.bodyText1.copyWith(
                                  color: optionTextColor,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                convertedGasFee,
                                style: theme.caption.copyWith(
                                  color: effectiveSecondaryColor,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    if (isSelected)
                      SizeTransition(
                        sizeFactor: _expandAnimation,
                        child: GasDetails(
                          txParamsInfo: widget.txParamsInfo,
                          selectedOption: option,
                          token: token,
                          theme: theme,
                          disabled: widget.disabled,
                          textColor: effectiveTextColor,
                          secondaryColor: effectiveSecondaryColor,
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final chain = appState.chain!;
    final token = appState.wallet!.tokens
        .firstWhere((t) => t.addrType == appState.account?.addrType);

    final warningColor = theme.warning;
    final textColor = widget.textColor ?? theme.textPrimary;
    final dangerColor = theme.danger;

    return Column(
      children: [
        if (_isExpanded || _selected == GasFeeOption.low)
          _buildGasOption(
            option: GasFeeOption.low,
            optionTextColor: warningColor,
            appState: appState,
            chain: chain,
            token: token,
          ),
        if (_isExpanded || _selected == GasFeeOption.market)
          _buildGasOption(
            option: GasFeeOption.market,
            optionTextColor: textColor,
            appState: appState,
            chain: chain,
            token: token,
          ),
        if (_isExpanded || _selected == GasFeeOption.aggressive)
          _buildGasOption(
            option: GasFeeOption.aggressive,
            optionTextColor: dangerColor,
            appState: appState,
            chain: chain,
            token: token,
          ),
      ],
    );
  }
}

BigInt calculateTotalGasCost(
  GasFeeOption option,
  BigInt baseFee,
  BigInt priorityFee,
  BigInt gasLimit,
  BigInt gasPrice,
) {
  if (baseFee != BigInt.zero && priorityFee != BigInt.zero) {
    final maxFeePerGas = calculateFeeForOption(option, baseFee, priorityFee);
    return gasLimit * maxFeePerGas;
  } else if (gasPrice != BigInt.zero) {
    final adjustedGasPrice = calculateGasPrice(option, gasPrice);
    return gasLimit * adjustedGasPrice;
  }

  return BigInt.zero;
}

```

`lib/components/hex_key.dart`:

```dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';

class HexKeyDisplay extends StatefulWidget {
  final String hexKey;
  final String title;

  const HexKeyDisplay({
    super.key,
    required this.hexKey,
    required this.title,
  });

  @override
  State<HexKeyDisplay> createState() => _HexKeyDisplayState();
}

class _HexKeyDisplayState extends State<HexKeyDisplay> {
  List<bool> animationStates = [];
  List<String> currentPairs = [];
  List<String> targetPairs = [];

  @override
  void initState() {
    super.initState();
    _initializePairs();
  }

  void _initializePairs() {
    currentPairs = _getPairs(widget.hexKey);
    targetPairs = List.from(currentPairs);
    animationStates = List.generate(currentPairs.length, (_) => false);
  }

  @override
  void didUpdateWidget(HexKeyDisplay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.hexKey != widget.hexKey) {
      targetPairs = _getPairs(widget.hexKey);
      if (targetPairs.length != currentPairs.length) {
        currentPairs = List.from(targetPairs);
        animationStates = List.generate(currentPairs.length, (_) => false);
      }
      _startAnimation();
    }
  }

  List<String> _getPairs(String key) {
    if (key.isEmpty) return [];

    final cleanKey = key.replaceAll(RegExp(r'[^0-9A-Fa-f]'), '').toUpperCase();
    final pairs = <String>[];
    for (var i = 0; i < cleanKey.length; i += 2) {
      if (i + 2 <= cleanKey.length) {
        pairs.add(cleanKey.substring(i, i + 2));
      }
    }
    return pairs;
  }

  void _startAnimation() {
    if (currentPairs.isEmpty) return;

    double delayMs = 30;
    double acceleration = 1.0; // Factor of animation

    for (var i = 0; i < currentPairs.length; i++) {
      final totalDelay =
          List.generate(i + 1, (index) => delayMs * pow(acceleration, index))
              .reduce((sum, delay) => sum + delay);

      Future.delayed(Duration(milliseconds: totalDelay.round()), () {
        if (mounted) {
          setState(() {
            animationStates[i] = true;
            currentPairs[i] = targetPairs[i];
          });

          Future.delayed(const Duration(milliseconds: 80), () {
            if (mounted) {
              setState(() {
                animationStates[i] = false;
              });
            }
          });
        }
      });
    }
  }

  int _getChunkSize(BuildContext context) {
    final width = MediaQuery.of(context).size.width;

    if (width < 600) return 6;
    if (width < 905) return 8;
    if (width < 1240) return 10;

    return 12;
  }

  List<List<String>> _formatHexKey(BuildContext context) {
    if (currentPairs.isEmpty) return [];

    final chunkSize = _getChunkSize(context);
    final chunks = <List<String>>[];

    for (var i = 0; i < currentPairs.length; i += chunkSize) {
      chunks.add(currentPairs.sublist(
          i,
          i + chunkSize > currentPairs.length
              ? currentPairs.length
              : i + chunkSize));
    }

    return chunks;
  }

  @override
  Widget build(BuildContext context) {
    if (currentPairs.isEmpty) {
      _initializePairs();
    }

    final chunks = _formatHexKey(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    final chunkSize = _getChunkSize(context);
    final containerWidth = (45.0 * chunkSize) + adaptivePadding * 2;

    return Container(
      padding: EdgeInsets.all(adaptivePadding),
      constraints: BoxConstraints(maxWidth: containerWidth),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: EdgeInsets.only(bottom: adaptivePadding),
            child: Text(
              widget.title,
              style: theme.subtitle1.copyWith(
                color: theme.textSecondary,
                fontSize: 18, // subtitle1 is 20, adjusting to 18
              ),
            ),
          ),
          ...chunks.asMap().entries.map((chunkEntry) {
            return Padding(
              padding: const EdgeInsets.only(bottom: 6),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: chunkEntry.value.asMap().entries.map((pairEntry) {
                  final globalIndex =
                      chunkEntry.key * _getChunkSize(context) + pairEntry.key;
                  final isAnimating = globalIndex < animationStates.length
                      ? animationStates[globalIndex]
                      : false;

                  return AnimatedContainer(
                    duration: const Duration(milliseconds: 100),
                    width: 45,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      pairEntry.value,
                      style: theme.bodyText1.copyWith(
                        color: isAnimating
                            ? theme.secondaryPurple
                            : theme.textPrimary,
                        fontFamily: 'Courier',
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  );
                }).toList(),
              ),
            );
          }),
        ],
      ),
    );
  }
}

```

`lib/components/hoverd_svg.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class HoverSvgIcon extends StatefulWidget {
  final String assetName;
  final double width;
  final double height;
  final VoidCallback onTap;
  final Color? color;
  final EdgeInsets? padding;

  const HoverSvgIcon({
    super.key,
    required this.assetName,
    required this.width,
    required this.height,
    required this.onTap,
    this.color,
    this.padding = const EdgeInsets.all(8.0),
  });

  @override
  State<HoverSvgIcon> createState() => HoverSvgIconState();
}

class HoverSvgIconState extends State<HoverSvgIcon> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final iconColor = widget.color ?? theme.textPrimary;

    return Container(
      constraints: BoxConstraints(
        minWidth: widget.width + 16,
        minHeight: widget.height + 16,
      ),
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) => setState(() => _isPressed = true),
        onTapUp: (_) => setState(() => _isPressed = false),
        onTapCancel: () => setState(() => _isPressed = false),
        onTap: widget.onTap,
        child: Padding(
          padding: widget.padding!,
          child: Opacity(
            opacity: _isPressed ? 0.5 : 1.0,
            child: SvgPicture.asset(
              widget.assetName,
              width: widget.width,
              height: widget.height,
              colorFilter: ColorFilter.mode(
                iconColor,
                BlendMode.srcIn,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/components/image_cache.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/cache.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class AsyncImage extends StatefulWidget {
  final String? url;
  final double? width;
  final double? height;
  final BoxFit? fit;
  final Widget? loadingWidget;
  final Widget? errorWidget;

  const AsyncImage({
    super.key,
    this.url,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.loadingWidget,
    this.errorWidget,
  });

  @override
  State<AsyncImage> createState() => _AsyncImageState();
}

class _AsyncImageState extends State<AsyncImage> {
  late final AppState _appState;
  Uint8List? _cachedImageBytes;
  String? _cachedImageExt;
  bool _isLoading = false;
  bool _hasError = false;

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
    if (widget.url != null && widget.url!.isNotEmpty) {
      _loadImage();
    } else {
      setState(() {
        _hasError = true;
      });
    }
  }

  @override
  void didUpdateWidget(AsyncImage oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.url != oldWidget.url) {
      if (widget.url != null && widget.url!.isNotEmpty) {
        _cachedImageBytes = null;
        _cachedImageExt = null;
        _loadImage();
      } else {
        setState(() {
          _cachedImageBytes = null;
          _cachedImageExt = null;
          _isLoading = false;
          _hasError = true;
        });
      }
    }
  }

  Future<void> _loadImage() async {
    if (_cachedImageBytes != null && _cachedImageExt != null) return;

    setState(() {
      _isLoading = true;
      _hasError = false;
    });

    try {
      final (bytes, ext) = await getImageBytes(
        dir: _appState.cahceDir,
        url: widget.url!,
      );

      if (!mounted) return;

      setState(() {
        _cachedImageBytes = bytes;
        _cachedImageExt = ext;
        _isLoading = false;
        _hasError = false;
      });
    } catch (e) {
      if (!mounted) return;

      setState(() {
        _cachedImageBytes = null;
        _cachedImageExt = null;
        _isLoading = false;
        _hasError = true;
      });

      debugPrint('Error loading image from ${widget.url}: $e');
    }
  }

  Widget _buildImage(AppTheme theme) {
    if (_hasError || _cachedImageBytes == null) {
      return SizedBox(
        width: widget.width,
        height: widget.height,
        child: widget.errorWidget ??
            Center(
              child: Container(
                width: widget.width ?? 24,
                height: widget.height ?? 24,
                decoration: BoxDecoration(
                  color: theme.danger.withValues(alpha: 0.2),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  Icons.broken_image,
                  size: (widget.width ?? 24) * 0.6,
                  color: theme.danger,
                ),
              ),
            ),
      );
    }

    if (_cachedImageExt == 'svg') {
      return SvgPicture.memory(
        _cachedImageBytes!,
        width: widget.width,
        height: widget.height,
        fit: widget.fit ?? BoxFit.cover,
      );
    }

    return Image.memory(
      _cachedImageBytes!,
      width: widget.width,
      height: widget.height,
      fit: widget.fit,
      errorBuilder: (context, error, stackTrace) {
        return widget.errorWidget ??
            Center(
              child: Container(
                width: widget.width ?? 24,
                height: widget.height ?? 24,
                decoration: BoxDecoration(
                  color: theme.danger.withValues(alpha: 0.2),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  Icons.broken_image,
                  size: (widget.width ?? 24) * 0.6,
                  color: theme.danger,
                ),
              ),
            );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    if (_isLoading) {
      return SizedBox(
        width: widget.width,
        height: widget.height,
        child: widget.loadingWidget ??
            Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: theme.primaryPurple,
              ),
            ),
      );
    }

    return _buildImage(theme);
  }
}

```

`lib/components/input_amount.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/modals/select_token.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class TokenAmountCard extends StatefulWidget {
  final String amount;
  final int tokenIndex;
  final bool showMax;
  final Function(String) onMaxTap;
  final Function(int) onTokenSelected;

  const TokenAmountCard({
    super.key,
    this.amount = "0",
    this.tokenIndex = 0,
    this.showMax = true,
    required this.onMaxTap,
    required this.onTokenSelected,
  });

  @override
  State<TokenAmountCard> createState() => _TokenAmountCardState();
}

class _TokenAmountCardState extends State<TokenAmountCard> {
  Key _imageKey = UniqueKey();

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final token = appState.wallet!.tokens[widget.tokenIndex];
    final bigAmount = toDecimalsWei(widget.amount.toString(), token.decimals);
    final bigBalance =
        BigInt.parse(token.balances[appState.wallet!.selectedAccount] ?? '0');

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.transparent,
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.2),
          width: 1.5,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        children: [
          _buildAmountRow(context, theme, token, bigAmount, appState),
          const SizedBox(height: 8),
          _buildBalanceRow(theme, bigBalance, token),
        ],
      ),
    );
  }

  Widget _buildAmountRow(
    BuildContext context,
    AppTheme theme,
    FTokenInfo token,
    BigInt bigAmount,
    AppState appState,
  ) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Expanded(
          child: _buildAmountInfo(context, theme, token, bigAmount, appState),
        ),
        _buildTokenSelector(context, appState, token),
      ],
    );
  }

  Widget _buildAmountInfo(
    BuildContext context,
    AppTheme theme,
    FTokenInfo token,
    BigInt bigAmount,
    AppState appState,
  ) {
    const double amountHeight = 40.0;
    const double convertHeight = 20.0;

    final (_, converted) = formatingAmount(
      amount: bigAmount,
      symbol: token.symbol,
      decimals: token.decimals,
      rate: token.rate,
      appState: appState,
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(
          height: amountHeight,
          child: Align(
            alignment: Alignment.centerLeft,
            child: Text(
              widget.amount,
              style: theme.subtitle1.copyWith(
                color: theme.textPrimary,
                fontSize: _calculateFontSize(context, widget.amount),
                // fontWeight is already w500 in subtitle1, but explicitly set if different
              ),
            ),
          ),
        ),
        if (appState.wallet?.settings.currencyConvert != null)
          SizedBox(
            height: convertHeight,
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(
                converted,
                style: theme.bodyText1.copyWith(
                  color: theme.textPrimary.withValues(alpha: 0.7),
                ),
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildTokenSelector(
    BuildContext context,
    AppState appState,
    FTokenInfo token,
  ) {
    final theme = appState.currentTheme;

    return GestureDetector(
      onTap: () {
        showTokenSelectModal(
          context: context,
          onTokenSelected: (int index) {
            widget.onTokenSelected(index);
            setState(() {
              _imageKey = UniqueKey();
            });
          },
        );
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          border: Border.all(
            color: theme.textPrimary.withValues(alpha: 0.2),
            width: 1.5,
          ),
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildTokenIcon(appState, token),
            const SizedBox(width: 8),
            Text(
              token.symbol,
              style: theme.bodyText1.copyWith(
                color: theme.textPrimary,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTokenIcon(AppState appState, FTokenInfo token) {
    final theme = appState.currentTheme;

    return Container(
        width: 24,
        height: 24,
        decoration: BoxDecoration(
          border: Border.all(
            color: theme.textPrimary.withValues(alpha: 0.2),
            width: 1.5,
          ),
          shape: BoxShape.circle,
        ),
        child: ClipOval(
          child: AsyncImage(
            key: _imageKey,
            url: processTokenLogo(
              token: token,
              shortName: appState.chain?.shortName ?? "",
              theme: theme.value,
            ),
            width: 24,
            height: 24,
            fit: BoxFit.cover,
            errorWidget: Blockies(
              seed: token.addr,
              color: theme.secondaryPurple,
              bgColor: theme.primaryPurple,
              spotColor: theme.background,
              size: 8,
            ),
            loadingWidget: const Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
              ),
            ),
          ),
        ));
  }

  Widget _buildBalanceRow(AppTheme theme, BigInt balance, FTokenInfo token) {
    final currentAmount = toDecimalsWei(widget.amount, token.decimals);
    final bool isExceeded = currentAmount > balance;
    final bool isMax = currentAmount == balance;

    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        if (isExceeded)
          SvgPicture.asset(
            "assets/icons/warning.svg",
            width: 15,
            height: 15,
            colorFilter: ColorFilter.mode(
              theme.warning.withValues(alpha: 0.7),
              BlendMode.srcIn,
            ),
          ),
        if (isExceeded) const SizedBox(width: 4),
        Text(
          fromWei(value: balance.toString(), decimals: token.decimals),
          style: theme.bodyText2.copyWith(
            color: theme.textPrimary.withValues(alpha: 0.7),
          ),
        ),
        if (widget.showMax)
          Padding(
            padding: const EdgeInsets.only(left: 8),
            child: GestureDetector(
              onTap: () => widget.onMaxTap(
                  fromWei(value: balance.toString(), decimals: token.decimals)),
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 8,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: isMax
                      ? theme.warning.withValues(alpha: 0.2)
                      : theme.textPrimary.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Text(
                  'Max',
                  style: theme.caption.copyWith(
                    color: isMax
                        ? theme.warning
                        : theme.textPrimary.withValues(alpha: 0.7),
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }

  double _calculateFontSize(BuildContext context, String text) {
    final screenWidth = MediaQuery.of(context).size.width;
    const baseSize = 30.0;
    const minSize = 13.0;

    if (text.length <= 8) return baseSize;

    final fontSize = (screenWidth * 0.12) / ((text.length - 8) * 0.5);
    return fontSize.clamp(minSize, baseSize);
  }
}

```

`lib/components/ledger_device_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class LedgerCard extends StatefulWidget {
  final LedgerDevice device;
  final bool isConnected;
  final bool isConnecting;
  final VoidCallback onTap;

  const LedgerCard({
    super.key,
    required this.device,
    required this.isConnected,
    required this.isConnecting,
    required this.onTap,
  });

  @override
  State<LedgerCard> createState() => _LedgerCardState();
}

class _LedgerCardState extends State<LedgerCard> {
  bool _isPressed = false;

  void _setPressed(bool pressed) {
    if (widget.isConnected || widget.isConnecting) return;
    setState(() {
      _isPressed = pressed;
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final scale =
        !(widget.isConnected || widget.isConnecting) && _isPressed ? 0.96 : 1.0;

    return GestureDetector(
      onTapDown: (_) => _setPressed(true),
      onTapUp: (_) {
        _setPressed(false);
        if (!(widget.isConnected || widget.isConnecting)) {
          Future.delayed(const Duration(milliseconds: 50), () {
            if (mounted) {
              widget.onTap();
            }
          });
        }
      },
      onTapCancel: () => _setPressed(false),
      child: AnimatedScale(
        scale: scale,
        duration: const Duration(milliseconds: 100),
        curve: Curves.easeOut,
        child: Card(
          elevation: 0,
          margin: EdgeInsets.zero,
          clipBehavior: Clip.antiAlias,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
          color: theme.cardBackground,
          child: ListTile(
            contentPadding:
                const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
            leading: SvgPicture.asset(
              widget.device.connectionType == ConnectionType.ble
                  ? 'assets/icons/ble.svg'
                  : 'assets/icons/usb.svg',
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(
                widget.isConnected ? theme.success : theme.primaryPurple,
                BlendMode.srcIn,
              ),
            ),
            title: Text(
              widget.device.name.isEmpty
                  ? '(Unknown Device)'
                  : widget.device.name,
              style: theme.bodyText1.copyWith(
                fontWeight:
                    widget.isConnected ? FontWeight.bold : FontWeight.normal,
                color: (widget.isConnected || widget.isConnecting)
                    ? theme.textSecondary.withAlpha(180)
                    : theme.textPrimary,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            subtitle: Text(
              'ID: ${widget.device.id.length > 12 ? '${widget.device.id.substring(0, 6)}...${widget.device.id.substring(widget.device.id.length - 6)}' : widget.device.id}\nType: ${widget.device.connectionType.name.toUpperCase()}',
              style: theme.caption.copyWith(color: theme.textSecondary),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            trailing: widget.isConnecting
                ? SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryPurple),
                    ),
                  )
                : widget.isConnected
                    ? SvgPicture.asset(
                        'assets/icons/check.svg',
                        width: 26,
                        height: 26,
                        colorFilter:
                            ColorFilter.mode(theme.success, BlendMode.srcIn),
                      )
                    : SvgPicture.asset(
                        'assets/icons/chevron_right.svg',
                        width: 24,
                        height: 24,
                        colorFilter: ColorFilter.mode(
                            theme.textSecondary, BlendMode.srcIn),
                      ),
          ),
        ),
      ),
    );
  }
}

```

`lib/components/linear_refresh_indicator.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class LinearRefreshIndicator extends StatefulWidget {
  final double pulledExtent;
  final double refreshTriggerPullDistance;
  final double refreshIndicatorExtent;

  const LinearRefreshIndicator({
    super.key,
    required this.pulledExtent,
    required this.refreshTriggerPullDistance,
    required this.refreshIndicatorExtent,
  });

  @override
  State<LinearRefreshIndicator> createState() => _LinearRefreshIndicatorState();
}

class _LinearRefreshIndicatorState extends State<LinearRefreshIndicator>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  bool _hasStartedLoading = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 1.0,
      end: 0.1,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));
  }

  @override
  void didUpdateWidget(LinearRefreshIndicator oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.pulledExtent >= widget.refreshTriggerPullDistance &&
        !_hasStartedLoading) {
      _hasStartedLoading = true;
      _controller.forward();
    }

    if (widget.pulledExtent < widget.refreshTriggerPullDistance) {
      _hasStartedLoading = false;
      _controller.reset();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final double progress =
        (widget.pulledExtent / widget.refreshTriggerPullDistance)
            .clamp(0.0, 1.0);

    return SizedBox(
      height: widget.refreshIndicatorExtent,
      child: Center(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.6,
          height: 2.0,
          child: AnimatedBuilder(
            animation: _animation,
            builder: (context, child) {
              return Center(
                child: Container(
                  height: 2.0,
                  width: (MediaQuery.of(context).size.width * 0.6) *
                      progress *
                      _animation.value,
                  decoration: BoxDecoration(
                    color: theme.primaryPurple,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}

```

`lib/components/load_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

enum ButtonState { idle, loading, success, error }

class RoundedLoadingButton extends StatefulWidget {
  final RoundedLoadingButtonController controller;
  final VoidCallback? onPressed;
  final Widget child;
  final Color? color;
  final double height;
  final double width;
  final double loaderSize;
  final Color valueColor;
  final double borderRadius;
  final String? successIcon;
  final String? failedSvgAsset;
  final Color errorColor;

  const RoundedLoadingButton({
    super.key,
    required this.controller,
    required this.onPressed,
    required this.child,
    this.color,
    this.height = 56.0,
    this.width = double.infinity,
    this.loaderSize = 24.0,
    this.valueColor = Colors.white,
    this.borderRadius = 30.0,
    this.successIcon = 'assets/icons/ok.svg',
    this.failedSvgAsset = 'assets/icons/close.svg',
    this.errorColor = Colors.red,
  });

  @override
  State<RoundedLoadingButton> createState() => _RoundedLoadingButtonState();
}

class _RoundedLoadingButtonState extends State<RoundedLoadingButton>
    with TickerProviderStateMixin {
  late AnimationController _buttonController;
  late AnimationController _resultIconController;
  late Animation<double> _bounceAnimation;
  late Animation<double> _squeezeAnimation;
  late double _buttonWidth;

  @override
  void initState() {
    super.initState();

    _buttonController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _resultIconController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _bounceAnimation = Tween<double>(begin: 0, end: widget.height).animate(
      CurvedAnimation(
        parent: _resultIconController,
        curve: Curves.elasticOut,
      ),
    )..addListener(() {
        setState(() {});
      });

    _buttonWidth = 0;

    widget.controller._addListeners(_start, _stop, _success, _error, _reset);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return LayoutBuilder(
      builder: (context, constraints) {
        _buttonWidth = widget.width == double.infinity
            ? constraints.maxWidth
            : widget.width;

        _squeezeAnimation = Tween<double>(
          begin: _buttonWidth,
          end: widget.height,
        ).animate(
          CurvedAnimation(
            parent: _buttonController,
            curve: Curves.easeInOutCirc,
          ),
        )..addListener(() {
            setState(() {});
          });

        Widget successIcon = Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: theme.success,
            borderRadius: BorderRadius.circular(_bounceAnimation.value / 2),
          ),
          width: _bounceAnimation.value,
          height: _bounceAnimation.value,
          child: _bounceAnimation.value > 20
              ? SvgPicture.asset(
                  widget.successIcon!,
                  width: widget.loaderSize,
                  height: widget.loaderSize,
                  colorFilter: ColorFilter.mode(
                    widget.valueColor,
                    BlendMode.srcIn,
                  ),
                )
              : null,
        );

        Widget errorIcon = Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: widget.errorColor,
            borderRadius: BorderRadius.circular(_bounceAnimation.value / 2),
          ),
          width: _bounceAnimation.value,
          height: _bounceAnimation.value,
          child: _bounceAnimation.value > 20
              ? SvgPicture.asset(
                  widget.failedSvgAsset!,
                  width: widget.loaderSize,
                  height: widget.loaderSize,
                  colorFilter: ColorFilter.mode(
                    widget.valueColor,
                    BlendMode.srcIn,
                  ),
                )
              : null,
        );

        Widget loader = SizedBox(
          height: widget.loaderSize,
          width: widget.loaderSize,
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation<Color>(widget.valueColor),
            strokeWidth: 2.0,
          ),
        );

        Widget buttonContent = ValueListenableBuilder<ButtonState>(
          valueListenable: widget.controller._stateNotifier,
          builder: (context, state, _) {
            return AnimatedSwitcher(
              duration: const Duration(milliseconds: 200),
              child: state == ButtonState.loading ? loader : widget.child,
            );
          },
        );

        final button = ElevatedButton(
          style: ElevatedButton.styleFrom(
            minimumSize: Size(_squeezeAnimation.value, widget.height),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(widget.borderRadius),
            ),
            backgroundColor: widget.color ?? theme.buttonBackground,
            foregroundColor: theme.buttonText,
            elevation: 0,
            padding: EdgeInsets.zero,
          ),
          onPressed: widget.onPressed,
          child: buttonContent,
        );

        return SizedBox(
          height: widget.height,
          child: ValueListenableBuilder<ButtonState>(
            valueListenable: widget.controller._stateNotifier,
            builder: (context, state, _) {
              return Center(
                child: state == ButtonState.error
                    ? errorIcon
                    : state == ButtonState.success
                        ? successIcon
                        : SizedBox(
                            width: _squeezeAnimation.value,
                            child: button,
                          ),
              );
            },
          ),
        );
      },
    );
  }

  void _start() {
    if (!mounted) return;
    _buttonController.forward();
  }

  void _stop() {
    if (!mounted) return;
    _buttonController.reverse();
  }

  void _success() {
    if (!mounted) return;
    _resultIconController.forward();
  }

  void _error() {
    if (!mounted) return;
    _resultIconController.forward();
  }

  void _reset() {
    if (!mounted) return;
    _buttonController.reverse();
    _resultIconController.reset();
  }

  @override
  void dispose() {
    _buttonController.dispose();
    _resultIconController.dispose();
    super.dispose();
  }
}

class RoundedLoadingButtonController {
  VoidCallback? _startListener;
  VoidCallback? _stopListener;
  VoidCallback? _successListener;
  VoidCallback? _errorListener;
  VoidCallback? _resetListener;

  final ValueNotifier<ButtonState> _stateNotifier =
      ValueNotifier(ButtonState.idle);

  ButtonState get currentState => _stateNotifier.value;

  void _addListeners(
    VoidCallback startListener,
    VoidCallback stopListener,
    VoidCallback successListener,
    VoidCallback errorListener,
    VoidCallback resetListener,
  ) {
    _startListener = startListener;
    _stopListener = stopListener;
    _successListener = successListener;
    _errorListener = errorListener;
    _resetListener = resetListener;
  }

  void start() {
    _stateNotifier.value = ButtonState.loading;
    if (_startListener != null) _startListener!();
  }

  void stop() {
    _stateNotifier.value = ButtonState.idle;
    if (_stopListener != null) _stopListener!();
  }

  void success() {
    _stateNotifier.value = ButtonState.success;
    if (_successListener != null) _successListener!();
  }

  void error() {
    _stateNotifier.value = ButtonState.error;
    if (_errorListener != null) _errorListener!();
  }

  void reset() {
    _stateNotifier.value = ButtonState.idle;
    if (_resetListener != null) _resetListener!();
  }

  void dispose() {
    _stateNotifier.dispose();
  }
}

```

`lib/components/mnemonic_word_input.dart`:

```dart
import 'package:provider/provider.dart';
import 'package:flutter/material.dart';
import 'package:zilpay/state/app_state.dart';

class MnemonicWordInput extends StatefulWidget {
  final int index;
  final String word;
  final bool isEditable;
  final Color? borderColor;
  final Color? errorBorderColor;
  final bool hasError;
  final double opacity;
  final Function(int, String)? onChanged;

  const MnemonicWordInput({
    super.key,
    required this.index,
    required this.word,
    this.onChanged,
    this.opacity = 1,
    this.isEditable = false,
    this.borderColor,
    this.errorBorderColor,
    this.hasError = false,
  });

  @override
  State<MnemonicWordInput> createState() => _MnemonicWordInputState();
}

class _MnemonicWordInputState extends State<MnemonicWordInput> {
  late TextEditingController _controller;
  bool _shouldUpdateText = true;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.word);
  }

  @override
  void didUpdateWidget(MnemonicWordInput oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (_shouldUpdateText && widget.word != _controller.text) {
      _controller.text = widget.word;
    }
    _shouldUpdateText = true;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: theme.cardBackground.withValues(alpha: widget.opacity),
        borderRadius: BorderRadius.circular(16),
        border: widget.hasError
            ? Border.all(
                color: widget.errorBorderColor ?? theme.danger,
                width: 1,
              )
            : widget.borderColor != null
                ? Border.all(color: widget.borderColor!, width: 1)
                : null,
      ),
      child: Row(
        children: [
          Text(
            '${widget.index}',
            style: theme.bodyText2.copyWith(
              color: widget.hasError
                  ? (widget.errorBorderColor ?? theme.danger)
                  : theme.textSecondary,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: TextField(
              controller: _controller,
              style: theme.bodyText1.copyWith(
                color: widget.hasError
                    ? (widget.errorBorderColor ?? theme.danger)
                    : theme.textPrimary,
              ),
              enabled: widget.isEditable,
              decoration: const InputDecoration(
                border: InputBorder.none,
                isDense: true,
                contentPadding: EdgeInsets.zero,
              ),
              onChanged: (value) {
                _shouldUpdateText = false;
                if (widget.onChanged != null) {
                  widget.onChanged!(widget.index, value);
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

`lib/components/net_btn.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';

class NetworkDownButton extends StatefulWidget {
  final VoidCallback onPressed;
  final NetworkConfigInfo chain;

  const NetworkDownButton({
    super.key,
    required this.onPressed,
    required this.chain,
  });

  @override
  _NetworkDownButtonState createState() => _NetworkDownButtonState();
}

class _NetworkDownButtonState extends State<NetworkDownButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 100),
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(_controller);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onTapDown(TapDownDetails details) {
    _controller.forward();
  }

  void _onTapUp(TapUpDetails details) {
    _controller.reverse();
    widget.onPressed();
  }

  void _onTapCancel() {
    _controller.reverse();
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTapDown: _onTapDown,
      onTapUp: _onTapUp,
      onTapCancel: _onTapCancel,
      child: ScaleTransition(
        scale: _scaleAnimation,
        child: Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(20.0),
            border:
                Border.all(color: theme.textSecondary.withValues(alpha: 0.4)),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              AsyncImage(
                url: viewChain(network: widget.chain, theme: theme.value),
                width: 24,
                height: 24,
                fit: BoxFit.contain,
                loadingWidget: const Center(
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                ),
              ),
              if (widget.chain.testnet == true) ...[
                const SizedBox(width: 8),
                Text(
                  'testnet',
                  style: TextStyle(color: theme.warning),
                ),
              ],
              const SizedBox(width: 8),
              SvgPicture.asset(
                "assets/icons/tiny_down_arrow.svg",
                width: 8,
                height: 8,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary.withValues(alpha: 0.6),
                  BlendMode.srcIn,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`lib/components/network_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:zilpay/components/network_tile.dart';
import 'package:zilpay/src/rust/models/provider.dart';

class NetworkCard extends StatefulWidget {
  final NetworkConfigInfo configInfo;
  final bool isAdded;
  final bool isDefault;
  final bool isSelected;
  final bool disabled;
  final bool isTestnet;
  final String iconUrl;
  final Function(NetworkConfigInfo) onNetworkSelect;
  final Function(NetworkConfigInfo) onNetworkEdit;
  final Function(NetworkConfigInfo) onNetworkAdd;

  const NetworkCard({
    Key? key,
    required this.configInfo,
    required this.isAdded,
    required this.isDefault,
    required this.isSelected,
    this.disabled = false,
    required this.isTestnet,
    required this.iconUrl,
    required this.onNetworkSelect,
    required this.onNetworkEdit,
    required this.onNetworkAdd,
  }) : super(key: key);

  @override
  State<NetworkCard> createState() => _NetworkCardState();
}

class _NetworkCardState extends State<NetworkCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 100),
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.97).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _handlePress(bool isDown) {
    if (isDown) {
      _animationController.forward();
    } else {
      _animationController.reverse();
    }
  }

  void _handleNetworkTap() {
    if (widget.disabled) return;

    if (!widget.isAdded) {
      widget.onNetworkAdd(widget.configInfo);
      widget.onNetworkSelect(widget.configInfo);
    } else {
      widget.onNetworkSelect(widget.configInfo);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: GestureDetector(
        onTapDown: (_) {
          if (!widget.disabled) {
            _handlePress(true);
          }
        },
        onTapUp: (_) {
          _handlePress(false);
        },
        onTapCancel: () {
          _handlePress(false);
        },
        onTap: _handleNetworkTap,
        child: AnimatedBuilder(
          animation: _scaleAnimation,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: child,
            );
          },
          child: NetworkTile(
            iconUrl: widget.iconUrl,
            title: widget.configInfo.name,
            isTestnet: widget.isTestnet,
            isAdded: widget.isAdded,
            isDefault: widget.isDefault,
            isSelected: widget.isSelected,
            disabled: widget.disabled,
            onTap: null,
            onAdd: widget.isAdded
                ? null
                : () => widget.onNetworkAdd(widget.configInfo),
            onEdit: widget.isAdded
                ? () => widget.onNetworkEdit(widget.configInfo)
                : null,
          ),
        ),
      ),
    );
  }
}

```

`lib/components/network_tile.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class NetworkTile extends StatelessWidget {
  final String? iconUrl;
  final String title;
  final bool isAdded;
  final bool isSelected;
  final bool disabled;
  final bool? isTestnet;
  final bool? isDefault;
  final VoidCallback? onTap;
  final VoidCallback? onEdit;
  final VoidCallback? onAdd;

  const NetworkTile({
    super.key,
    required this.title,
    this.iconUrl,
    this.isAdded = false,
    this.isSelected = false,
    this.disabled = false,
    this.isTestnet = false,
    this.isDefault = false,
    this.onTap,
    this.onEdit,
    this.onAdd,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final isActive = !disabled;

    final textColor =
        disabled ? theme.textPrimary.withValues(alpha: 0.5) : theme.textPrimary;
    final backgroundColor = disabled
        ? theme.textSecondary.withValues(alpha: 0.05)
        : isSelected
            ? theme.primaryPurple.withValues(alpha: 0.1)
            : theme.textSecondary.withValues(alpha: 0.02);
    final borderColor = isSelected ? theme.primaryPurple : Colors.transparent;

    return Opacity(
      opacity: disabled ? 0.2 : 1.0,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: isActive ? onTap : null,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: borderColor,
              width: 1,
            ),
            color: backgroundColor,
          ),
          margin: const EdgeInsets.all(0),
          child: ListTile(
            enabled: isActive,
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            leading: _buildLeadingIcon(),
            title: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                _buildLabels(theme),
                const SizedBox(height: 4),
                Text(
                  title,
                  style: theme.bodyText1.copyWith(
                    fontWeight: FontWeight.w500,
                    color: textColor,
                  ),
                ),
              ],
            ),
            trailing: _buildTrailingIcon(isActive, textColor),
          ),
        ),
      ),
    );
  }

  Widget _buildLeadingIcon() {
    if (iconUrl == null) {
      return const SizedBox(
        width: 32,
        height: 32,
        child: Placeholder(color: Colors.grey),
      );
    }

    return SizedBox(
      width: 32,
      height: 32,
      child: AsyncImage(
        url: iconUrl!,
        width: 24,
        height: 24,
        fit: BoxFit.contain,
        loadingWidget: const Center(
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
    );
  }

  Widget _buildLabels(AppTheme theme) {
    if (isTestnet == null && isDefault != true) {
      return const SizedBox.shrink();
    }

    return Wrap(
      spacing: 8,
      children: [
        if (isTestnet != null)
          _buildNetworkLabel(
            isTestnet! ? "Testnet" : "Mainnet",
            isTestnet! ? theme.warning : theme.success,
            theme,
          ),
        if (isDefault == true)
          _buildNetworkLabel(
            "Default",
            theme.primaryPurple,
            theme,
          ),
      ],
    );
  }

  Widget _buildNetworkLabel(String text, Color color, AppTheme theme) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        text,
        style: theme.caption.copyWith(
          fontWeight: FontWeight.w500,
          color: color,
        ),
      ),
    );
  }

  Widget? _buildTrailingIcon(bool isActive, Color iconColor) {
    if (isAdded) {
      if (onEdit == null) return null;

      return IconButton(
        icon: SvgPicture.asset(
          "assets/icons/edit.svg",
          width: 20,
          height: 20,
          colorFilter: ColorFilter.mode(iconColor, BlendMode.srcIn),
        ),
        padding: const EdgeInsets.all(8),
        onPressed: isActive ? onEdit : null,
      );
    }

    if (onAdd == null) return null;

    return IconButton(
      icon: SvgPicture.asset(
        "assets/icons/plus.svg",
        width: 20,
        height: 20,
        colorFilter: ColorFilter.mode(iconColor, BlendMode.srcIn),
      ),
      padding: const EdgeInsets.all(8),
      onPressed: isActive ? onAdd : null,
    );
  }
}

```

`lib/components/number_keyboard.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class NumberKeyboard extends StatefulWidget {
  final Function(int) onKeyPressed;
  final VoidCallback onBackspace;
  final VoidCallback? onDotPress;

  const NumberKeyboard({
    super.key,
    required this.onKeyPressed,
    required this.onBackspace,
    this.onDotPress,
  });

  @override
  NumberKeyboardState createState() => NumberKeyboardState();
}

class NumberKeyboardState extends State<NumberKeyboard>
    with SingleTickerProviderStateMixin {
  String? activeKey;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 1.1).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Widget _buildKey(BuildContext context, String value, {bool isIcon = false}) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final isActive = activeKey == value;

    void handleTap() {
      setState(() => activeKey = value);
      _controller.forward().then((_) => _controller.reverse());
      Future.delayed(const Duration(milliseconds: 200), () {
        setState(() => activeKey = null);
      });

      if (value == '←') {
        widget.onBackspace();
      } else if (value == '.') {
        widget.onDotPress?.call();
      } else {
        widget.onKeyPressed(int.parse(value));
      }
    }

    return GestureDetector(
      onTapDown: (_) {
        setState(() => activeKey = value);
        _controller.forward();
      },
      onTapUp: (_) {
        _controller.reverse();
        setState(() => activeKey = null);
        handleTap();
      },
      onTapCancel: () {
        _controller.reverse();
        setState(() => activeKey = null);
      },
      behavior: HitTestBehavior.opaque,
      child: ScaleTransition(
        scale: isActive ? _scaleAnimation : const AlwaysStoppedAnimation(1.0),
        child: Container(
          width: 80,
          height: 50,
          alignment: Alignment.center,
          child: isIcon
              ? SvgPicture.asset(
                  "assets/icons/backspace.svg",
                  width: 30,
                  height: 30,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary.withValues(alpha: isActive ? 1.0 : 0.5),
                    BlendMode.srcIn,
                  ),
                )
              : Text(
                  value,
                  style: theme.headline1.copyWith(
                    color: theme.textPrimary
                        .withValues(alpha: isActive ? 1.0 : 0.5),
                    fontSize: 32,
                    fontWeight: FontWeight.w500,
                  ),
                ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 20),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['1', '2', '3'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['4', '5', '6'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children:
                ['7', '8', '9'].map((e) => _buildKey(context, e)).toList(),
          ),
          const SizedBox(height: 6),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildKey(context, '.'),
              _buildKey(context, '0'),
              _buildKey(context, '←', isIcon: true),
            ],
          ),
        ],
      ),
    );
  }
}

```

`lib/components/option_list.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class OptionItem {
  final Widget child;
  final bool isSelected;
  final VoidCallback onSelect;

  OptionItem({
    required this.child,
    required this.isSelected,
    required this.onSelect,
  });
}

class OptionsList extends StatelessWidget {
  final List<OptionItem> options;
  final double unselectedOpacity;
  final bool disabled;
  final double disabledOpacity;

  const OptionsList({
    super.key,
    required this.options,
    this.unselectedOpacity = 0.5,
    this.disabled = false,
    this.disabledOpacity = 0.5,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    bool hasSelectedOption = options.any((option) => option.isSelected);

    return Column(
      children: options
          .map((option) => Padding(
                padding: const EdgeInsets.symmetric(vertical: 6.0),
                child: AnimatedOpacity(
                  duration: const Duration(milliseconds: 200),
                  opacity: disabled
                      ? disabledOpacity
                      : hasSelectedOption && !option.isSelected
                          ? unselectedOpacity
                          : 1.0,
                  child: GestureDetector(
                    onTap: disabled ? null : option.onSelect,
                    child: TweenAnimationBuilder<double>(
                      duration: const Duration(milliseconds: 300),
                      tween:
                          Tween(begin: 0.0, end: option.isSelected ? 1.0 : 0.0),
                      curve: Curves.easeOutCubic,
                      builder: (context, value, child) {
                        return Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 20, vertical: 16),
                          decoration: BoxDecoration(
                            color: theme.cardBackground,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: Color.lerp(
                                theme.cardBackground,
                                disabled
                                    ? theme.textSecondary
                                    : theme.primaryPurple,
                                value * 0.5,
                              )!,
                              width: 1.5,
                            ),
                          ),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Expanded(
                                child: option.child,
                              ),
                              AnimatedContainer(
                                duration: const Duration(milliseconds: 300),
                                width: 24,
                                height: 24,
                                decoration: BoxDecoration(
                                  shape: BoxShape.circle,
                                  border: Border.all(
                                    color: option.isSelected
                                        ? disabled
                                            ? theme.textSecondary
                                            : theme.primaryPurple
                                        : theme.textSecondary,
                                    width: 2,
                                  ),
                                ),
                                child: Center(
                                  child: AnimatedScale(
                                    duration: const Duration(milliseconds: 200),
                                    scale: option.isSelected ? 1.0 : 0.0,
                                    child: Container(
                                      width: 12,
                                      height: 12,
                                      decoration: BoxDecoration(
                                        shape: BoxShape.circle,
                                        color: disabled
                                            ? theme.textSecondary
                                            : theme.primaryPurple,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                ),
              ))
          .toList(),
    );
  }
}

```

`lib/components/settings_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class SettingsItem extends StatefulWidget {
  final String title;
  final String trailingSvgPath;
  final VoidCallback onTap;
  final bool isFirst;
  final bool isLast;
  final bool isGrouped;

  const SettingsItem({
    super.key,
    required this.title,
    required this.trailingSvgPath,
    required this.onTap,
    this.isFirst = false,
    this.isLast = false,
    this.isGrouped = true,
  });

  @override
  State<SettingsItem> createState() => _SettingsItemState();
}

class _SettingsItemState extends State<SettingsItem> {
  bool _isPressed = false;

  ({double iconSize, double fontSize, double padding, double borderRadius})
      _getDynamicSizes(BuildContext context) {
    const double baseIconSize = 26.0;
    const double baseFontSize = 17.0;
    const double basePadding = 16.0;
    const double baseBorderRadius = 20.0;
    double sizeMultiplier = 1.0;

    return (
      iconSize: baseIconSize * sizeMultiplier,
      fontSize: baseFontSize * sizeMultiplier,
      padding: basePadding * sizeMultiplier,
      borderRadius: baseBorderRadius * sizeMultiplier,
    );
  }

  BorderRadius? _getBorderRadius(double borderRadius) {
    if (widget.isGrouped) {
      if (widget.isFirst && widget.isLast) {
        return BorderRadius.circular(borderRadius);
      } else if (widget.isFirst) {
        return BorderRadius.vertical(top: Radius.circular(borderRadius));
      } else if (widget.isLast) {
        return BorderRadius.vertical(bottom: Radius.circular(borderRadius));
      }
    } else {
      return BorderRadius.circular(borderRadius);
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final sizes = _getDynamicSizes(context);
    final borderRadius = _getBorderRadius(sizes.borderRadius);

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) {
        setState(() => _isPressed = false);
        widget.onTap();
      },
      onTapCancel: () => setState(() => _isPressed = false),
      child: Container(
        padding: EdgeInsets.symmetric(
          horizontal: sizes.padding,
          vertical: sizes.padding * 0.8,
        ),
        decoration: BoxDecoration(
          color: _isPressed
              ? theme.background.withValues(alpha: 1.0)
              : Colors.transparent,
          borderRadius: borderRadius,
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                widget.title,
                style: theme.headline1.copyWith(
                  color: theme.textPrimary,
                  fontSize: sizes.fontSize,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            SvgPicture.asset(
              widget.trailingSvgPath,
              colorFilter: ColorFilter.mode(
                theme.textSecondary,
                BlendMode.srcIn,
              ),
              width: sizes.iconSize,
              height: sizes.iconSize,
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/components/smart_input.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'dart:math' show pi, sin;

import 'package:zilpay/state/app_state.dart';

class SmartInput extends StatefulWidget {
  final TextEditingController? controller;
  final String? hint;
  final bool obscureText;
  final Function(String)? onChanged;
  final Function()? onLeftIconTap;
  final Function()? onRightIconTap;
  final Function(String)? onSubmitted;
  final Function(bool)? onFocusChanged;
  final String? leftIconPath;
  final String? rightIconPath;
  final Color? borderColor;
  final Color? focusedBorderColor;
  final double? height;
  final double? width;
  final double? fontSize;
  final EdgeInsets? padding;
  final EdgeInsets? iconPadding;
  final bool disabled;
  final bool autofocus;
  final TextInputType keyboardType;
  final Color? textColor;
  final Color? secondaryColor;
  final Color? backgroundColor;

  const SmartInput({
    super.key,
    this.controller,
    this.hint,
    this.obscureText = false,
    this.onChanged,
    this.onLeftIconTap,
    this.onRightIconTap,
    this.onSubmitted,
    this.onFocusChanged,
    this.leftIconPath,
    this.rightIconPath,
    this.borderColor,
    this.focusedBorderColor,
    this.height = 48,
    this.width,
    this.fontSize = 16,
    this.padding,
    this.iconPadding,
    this.disabled = false,
    this.autofocus = false,
    this.keyboardType = TextInputType.text,
    this.textColor,
    this.secondaryColor,
    this.backgroundColor,
  });

  @override
  State<SmartInput> createState() => SmartInputState();
}

class SmartInputState extends State<SmartInput>
    with SingleTickerProviderStateMixin {
  late AnimationController _shakeController;
  late Animation<double> _shakeAnimation;
  final FocusNode _focusNode = FocusNode();
  bool _isFocused = false;

  @override
  void initState() {
    super.initState();
    _shakeController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _shakeAnimation = Tween<double>(begin: 0.0, end: 10.0)
        .chain(CurveTween(curve: const InputShakeCurve()))
        .animate(_shakeController);

    _focusNode.addListener(_handleFocusChange);

    if (widget.autofocus) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted && !widget.disabled) {
          FocusScope.of(context).requestFocus(_focusNode);
        }
      });
    }
  }

  void _handleFocusChange() {
    if (!mounted) return;

    setState(() {
      _isFocused = _focusNode.hasFocus;
    });

    if (widget.onFocusChanged != null) {
      widget.onFocusChanged!(_focusNode.hasFocus);
    }
  }

  void shake() {
    _shakeController.forward().then((_) {
      _shakeController.reset();
    });
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    _shakeController.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  double get _iconSize {
    final containerHeight = widget.height ?? 48;
    return containerHeight * 0.416;
  }

  Widget? _buildIcon({
    required String? iconPath,
    required Color color,
    Function()? onTap,
  }) {
    if (iconPath == null) return null;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Padding(
        padding:
            widget.iconPadding ?? const EdgeInsets.symmetric(horizontal: 16),
        child: SvgPicture.asset(
          iconPath,
          width: _iconSize,
          height: _iconSize,
          colorFilter: ColorFilter.mode(
            color,
            BlendMode.srcIn,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    final defaultBorderColor = widget.secondaryColor?.withValues(alpha: 0.3) ??
        theme.textSecondary.withValues(alpha: 0.3);
    final defaultFocusedBorderColor =
        widget.focusedBorderColor ?? theme.primaryPurple;

    final effectiveTextColor = widget.textColor ?? theme.textPrimary;
    final effectiveSecondaryColor =
        widget.secondaryColor ?? theme.textSecondary;
    final effectiveBackgroundColor =
        widget.backgroundColor ?? theme.cardBackground;

    final iconColor =
        _isFocused ? defaultFocusedBorderColor : effectiveSecondaryColor;

    Color getBorderColor() {
      if (widget.disabled) {
        return widget.borderColor ?? Colors.transparent;
      }
      if (_isFocused) {
        return defaultFocusedBorderColor;
      }
      return widget.borderColor ?? defaultBorderColor;
    }

    return AnimatedBuilder(
      animation: _shakeAnimation,
      builder: (context, child) {
        return Transform.translate(
          offset: Offset(_shakeAnimation.value, 0),
          child: Container(
            height: widget.height,
            width: widget.width,
            decoration: BoxDecoration(
              color: widget.disabled
                  ? effectiveBackgroundColor.withValues(alpha: 0.5)
                  : effectiveBackgroundColor,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: getBorderColor(),
                width: 1.0,
              ),
            ),
            child: Row(
              children: [
                if (widget.leftIconPath != null)
                  _buildIcon(
                        iconPath: widget.leftIconPath,
                        color: iconColor,
                        onTap: widget.disabled ? null : widget.onLeftIconTap,
                      ) ??
                      const SizedBox(),
                Expanded(
                  child: Padding(
                    padding: widget.padding ??
                        EdgeInsets.symmetric(
                          horizontal: widget.leftIconPath == null &&
                                  widget.rightIconPath == null
                              ? 16
                              : 8,
                        ),
                    child: TextFormField(
                      controller: widget.controller,
                      focusNode: _focusNode,
                      obscureText: widget.obscureText,
                      onChanged: widget.onChanged,
                      enabled: !widget.disabled,
                      onFieldSubmitted: (value) {
                        if (!widget.disabled) {
                          widget.onSubmitted?.call(value);
                        }
                      },
                      style: theme.bodyText1.copyWith(
                        color: widget.disabled
                            ? effectiveTextColor.withValues(alpha: 0.5)
                            : effectiveTextColor,
                        fontSize: widget.fontSize,
                      ),
                      decoration: InputDecoration(
                        border: InputBorder.none,
                        hintText: widget.hint,
                        hintStyle: theme.bodyText1.copyWith(
                          color: widget.disabled
                              ? effectiveSecondaryColor.withValues(alpha: 0.5)
                              : effectiveSecondaryColor,
                          fontSize: widget.fontSize,
                        ),
                      ),
                      autocorrect: false,
                      enableSuggestions: false,
                      autofillHints: null,
                      keyboardType: widget.keyboardType,
                    ),
                  ),
                ),
                if (widget.rightIconPath != null)
                  _buildIcon(
                        iconPath: widget.rightIconPath,
                        color: iconColor,
                        onTap: widget.disabled ? null : widget.onRightIconTap,
                      ) ??
                      const SizedBox(),
              ],
            ),
          ),
        );
      },
    );
  }
}

class InputShakeCurve extends Curve {
  const InputShakeCurve();

  @override
  double transform(double t) {
    return sin(t * pi * 5) * (1 - t);
  }
}

```

`lib/components/stakeing_card.dart`:

```dart
import 'dart:math';

import 'package:blockies/blockies.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/modals/stake_modal.dart';
import 'package:zilpay/modals/transfer.dart';
import 'package:zilpay/src/rust/api/stake.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/stake.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class StakingPoolCard extends StatelessWidget {
  final FinalOutputInfo stake;

  const StakingPoolCard({super.key, required this.stake});

  bool get isLiquidStaking => stake.token != null;
  bool get isScilla => stake.tag == "scilla";
  bool get isEVM => stake.tag == 'evm';

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final l10n = AppLocalizations.of(context)!;
    final hasRewards =
        (BigInt.tryParse(stake.rewards) ?? BigInt.zero) > BigInt.zero;
    final hasDelegation =
        (BigInt.tryParse(stake.delegAmt) ?? BigInt.zero) > BigInt.zero;
    final hasClaimAmount =
        (BigInt.tryParse(stake.claimableAmount) ?? BigInt.zero) > BigInt.zero;
    final showStakingInfo = hasRewards || hasDelegation || hasClaimAmount;
    final hasPendingWithdrawals = stake.pendingWithdrawals.isNotEmpty;

    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.08),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              children: [
                _buildCardHeader(theme, l10n),
                if (hasPendingWithdrawals) ...[
                  const SizedBox(height: 20),
                  _buildPendingWithdrawals(context, theme, l10n, appState),
                ],
                if (showStakingInfo) ...[
                  const SizedBox(height: 20),
                  _buildUserStakingInfo(context, theme, l10n, appState),
                  const SizedBox(height: 16),
                  _buildStatsRow(theme, l10n, appState),
                  if (isLiquidStaking) ...[
                    const SizedBox(height: 16),
                    _buildLiquidStakingInfo(theme, l10n, appState),
                  ],
                  if (hasRewards) ...[
                    const SizedBox(height: 16),
                    _buildClaimRewardsButton(context, theme, l10n, appState),
                  ],
                ] else ...[
                  const SizedBox(height: 16),
                  _buildStatsRow(theme, l10n, appState),
                ],
              ],
            ),
          ),
          Container(
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(
                  color: theme.textSecondary.withValues(alpha: 0.08),
                ),
              ),
            ),
            padding: const EdgeInsets.all(20),
            child: _buildActionButtons(context, appState, l10n, hasDelegation),
          ),
        ],
      ),
    );
  }

  Widget _buildCardHeader(AppTheme theme, AppLocalizations l10n) {
    String urlTemplate =
        "https://raw.githubusercontent.com/zilpay/zilpay-cdn/refs/heads/main/stakeing/zilliqa/icons/%{address}%/%{dark,light}%.webp";
    final replacements = <String, String>{
      'address': stake.address.toLowerCase(),
    };

    return Row(
      children: [
        Stack(
          children: [
            ClipRRect(
              borderRadius: BorderRadius.circular(16.0),
              child: AsyncImage(
                url: processUrlTemplate(
                  template: urlTemplate,
                  theme: theme.value,
                  replacements: replacements,
                ),
                width: 56,
                height: 56,
                fit: BoxFit.contain,
                loadingWidget: Container(
                  width: 56,
                  height: 56,
                  decoration: BoxDecoration(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: const Center(
                    child: CupertinoActivityIndicator(radius: 12.0),
                  ),
                ),
                errorWidget: Container(
                  width: 56,
                  height: 56,
                  decoration: BoxDecoration(
                    color: theme.danger.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: SvgPicture.asset(
                    'assets/icons/zil.svg',
                    width: 28,
                    height: 28,
                    colorFilter:
                        ColorFilter.mode(theme.warning, BlendMode.srcIn),
                  ),
                ),
              ),
            ),
            Positioned(
              bottom: -2,
              right: -2,
              child: Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  color: theme.cardBackground,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    width: 1,
                  ),
                ),
                child: SvgPicture.asset(
                  isScilla
                      ? 'assets/icons/scilla.svg'
                      : 'assets/icons/solidity.svg',
                  width: 16,
                  height: 16,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      stake.name,
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        letterSpacing: -0.5,
                      ),
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: isScilla
                          ? theme.success.withValues(alpha: 0.1)
                          : theme.primaryPurple.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      stake.tag.toUpperCase(),
                      style: TextStyle(
                        color: theme.primaryPurple,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                        letterSpacing: 0.5,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 6),
              if (isLiquidStaking) ...[
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 10,
                    vertical: 6,
                  ),
                  decoration: BoxDecoration(
                    color: theme.primaryPurple.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        'LP',
                        style: TextStyle(
                          color: theme.primaryPurple,
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPendingWithdrawals(
    BuildContext context,
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.warning.withValues(alpha: 0.06),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: theme.warning.withValues(alpha: 0.2),
          width: 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(6),
                decoration: BoxDecoration(
                  color: theme.warning.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: SvgPicture.asset(
                  'assets/icons/clock.svg',
                  width: 16,
                  height: 16,
                  colorFilter: ColorFilter.mode(theme.warning, BlendMode.srcIn),
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  l10n.pendingWithdrawals,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: theme.warning.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${stake.pendingWithdrawals.length}',
                  style: TextStyle(
                    color: theme.warning,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          ...stake.pendingWithdrawals.asMap().entries.map(
                (entry) => Padding(
                  padding: EdgeInsets.only(
                      bottom: entry.key < stake.pendingWithdrawals.length - 1
                          ? 12
                          : 0),
                  child: _buildPendingWithdrawalItem(
                      context, theme, l10n, appState, entry.value),
                ),
              ),
        ],
      ),
    );
  }

  Widget _buildPendingWithdrawalItem(
    BuildContext context,
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
    PendingWithdrawalInfo item,
  ) {
    final currentBlock = stake.currentBlock ?? BigInt.zero;
    final withdrawalBlock = item.withdrawalBlock;
    final blocksRemaining = withdrawalBlock > currentBlock
        ? withdrawalBlock - currentBlock
        : BigInt.zero;

    final isClaimable = item.claimable || blocksRemaining == BigInt.zero;
    final progress = blocksRemaining == BigInt.zero
        ? 1.0
        : withdrawalBlock > currentBlock
            ? 0.0
            : 1.0;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: isClaimable
              ? theme.success.withValues(alpha: 0.2)
              : theme.textSecondary.withValues(alpha: 0.1),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      l10n.amount,
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      _formatTokenAmount(item.amount, appState).$1,
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
              if (isClaimable) ...[
                CustomButton(
                  text: l10n.claimButton,
                  onPressed: () => _claimWithdrawal(context, appState, item),
                  backgroundColor: theme.success,
                  textColor: theme.buttonText,
                  height: 36,
                  width: 80,
                  borderRadius: 12,
                ),
              ],
            ],
          ),
          if (!isClaimable && blocksRemaining > BigInt.zero) ...[
            const SizedBox(height: 12),
            Row(
              children: [
                Text(
                  '${l10n.claimableIn} ${_formatTime(blocksRemaining)}',
                  style: TextStyle(
                    color: theme.warning,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                value: progress,
                backgroundColor: theme.textSecondary.withValues(alpha: 0.1),
                valueColor: AlwaysStoppedAnimation<Color>(theme.warning),
                minHeight: 6,
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _formatTime(BigInt blocks) {
    final seconds = (blocks.toDouble() * 1.5).round();
    final duration = Duration(seconds: seconds);
    if (duration.inHours > 0) {
      return '~${duration.inHours} h ${duration.inMinutes % 60} min';
    } else if (duration.inMinutes > 0) {
      return '~${duration.inMinutes} min ${duration.inSeconds % 60} sec';
    } else {
      return '~${duration.inSeconds} sec';
    }
  }

  Widget _buildUserStakingInfo(
    BuildContext context,
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
  ) {
    final hasDelegation = (double.tryParse(stake.delegAmt) ?? 0) > 0;
    final (liquidRewards, hasLiquidRewards) =
        _calculateLiquidStakingRewards(appState);
    final hasClaimableAmount =
        (BigInt.tryParse(stake.claimableAmount) ?? BigInt.zero) > BigInt.zero;

    return Row(
      children: [
        Expanded(
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.primaryPurple.withValues(alpha: 0.06),
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: theme.primaryPurple.withValues(alpha: 0.1),
                width: 1,
              ),
            ),
            child: Column(
              children: [
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: theme.primaryPurple.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: SvgPicture.asset(
                        'assets/icons/piggy.svg',
                        width: 16,
                        height: 16,
                        colorFilter: ColorFilter.mode(
                            theme.primaryPurple, BlendMode.srcIn),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        isLiquidStaking
                            ? stake.token?.symbol ?? ""
                            : l10n.stakedAmount,
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                _buildAmountDisplay(
                  theme,
                  isLiquidStaking
                      ? _formatTokenAmount(
                          stake.delegAmt,
                          appState,
                          isLSTToken: true,
                        )
                      : _formatTokenAmount(stake.delegAmt, appState),
                  hasDelegation ? theme.primaryPurple : theme.textSecondary,
                ),
                if (isLiquidStaking && hasLiquidRewards) ...[
                  const SizedBox(height: 16),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [
                          theme.success.withValues(alpha: 0.1),
                          theme.success.withValues(alpha: 0.05),
                        ],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: theme.success.withValues(alpha: 0.2),
                        width: 1,
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Container(
                              padding: const EdgeInsets.all(6),
                              decoration: BoxDecoration(
                                color: theme.success.withValues(alpha: 0.15),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: SvgPicture.asset(
                                'assets/icons/trophy.svg',
                                width: 14,
                                height: 14,
                                colorFilter: ColorFilter.mode(
                                    theme.success, BlendMode.srcIn),
                              ),
                            ),
                            const SizedBox(width: 8),
                            Text(
                              l10n.rewardsProgressTitle,
                              style: TextStyle(
                                color: theme.textSecondary,
                                fontSize: 11,
                                fontWeight: FontWeight.w600,
                                letterSpacing: 0.2,
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        Row(
                          children: [
                            Text(
                              '+',
                              style: TextStyle(
                                color: theme.success,
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            Text(
                              liquidRewards,
                              style: TextStyle(
                                color: theme.success,
                                fontSize: 14,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(width: 4),
                            Text(
                              'backed ZIL',
                              style: TextStyle(
                                color: theme.textSecondary,
                                fontSize: 11,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
                if (hasClaimableAmount) ...[
                  const SizedBox(height: 16),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [
                          theme.warning.withValues(alpha: 0.1),
                          theme.warning.withValues(alpha: 0.05),
                        ],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                      borderRadius: BorderRadius.circular(12),
                      border: Border.all(
                        color: theme.warning.withValues(alpha: 0.2),
                        width: 1,
                      ),
                    ),
                    child: Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(6),
                          decoration: BoxDecoration(
                            color: theme.warning.withValues(alpha: 0.15),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: SvgPicture.asset(
                            'assets/icons/trophy.svg',
                            width: 14,
                            height: 14,
                            colorFilter: ColorFilter.mode(
                                theme.warning, BlendMode.srcIn),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Claimable Amount',
                                style: TextStyle(
                                  color: theme.textSecondary,
                                  fontSize: 11,
                                  fontWeight: FontWeight.w600,
                                  letterSpacing: 0.2,
                                ),
                              ),
                              const SizedBox(height: 4),
                              Text(
                                _formatTokenAmount(
                                        stake.claimableAmount, appState,
                                        isLSTToken: true)
                                    .$1,
                                style: TextStyle(
                                  color: theme.warning,
                                  fontSize: 14,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                        CustomButton(
                          text: l10n.claimButton,
                          onPressed: () =>
                              _claimClaimableAmount(context, appState),
                          backgroundColor: theme.warning,
                          textColor: theme.buttonText,
                          height: 32,
                          width: 60,
                          borderRadius: 8,
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildLiquidStakingInfo(
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.primaryPurple.withValues(alpha: 0.06),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: theme.primaryPurple.withValues(alpha: 0.1),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: theme.primaryPurple.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: AsyncImage(
                  url: processTokenLogo(
                    token: stake.token!,
                    shortName: appState.chain?.shortName ?? '',
                    theme: theme.value,
                  ),
                  width: 24,
                  height: 24,
                  fit: BoxFit.contain,
                  errorWidget: Blockies(
                    seed: stake.token!.addr,
                    color: theme.secondaryPurple,
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                  loadingWidget: const Center(
                      child: CircularProgressIndicator(strokeWidth: 2)),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      "${stake.token?.symbol ?? ""} (${stake.token?.name ?? ""})",
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 12,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      _formatLSTPrice(appState),
                      style: TextStyle(
                        color: theme.primaryPurple,
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAmountDisplay(
    AppTheme theme,
    (String, String) values,
    Color valueColor,
  ) {
    final primaryValue = values.$1;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          primaryValue,
          style: TextStyle(
            color: valueColor,
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Widget _buildStatsRow(
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.08),
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          _buildStatItem(
            theme,
            "UPTIME",
            "${stake.uptime}%",
            stake.votePower == null || stake.votePower == 0
                ? theme.textSecondary
                : theme.primaryPurple,
          ),
          _buildStatItem(
            theme,
            l10n.nodes,
            stake.validators.length.toString(),
            theme.primaryPurple,
          ),
          _buildStatItem(
            theme,
            isLiquidStaking ? 'APR' : l10n.aprLabel,
            stake.apr == null || stake.apr == 0
                ? l10n.durationNotAvailable
                : '${stake.apr?.toStringAsFixed(1)}%',
            stake.apr == null || stake.apr == 0
                ? theme.textSecondary
                : theme.success,
          ),
          _buildStatItem(
            theme,
            l10n.commissionLabel,
            stake.commission == null || stake.commission == 0
                ? l10n.durationNotAvailable
                : '${stake.commission?.toStringAsFixed(1)}%',
            stake.commission == null || stake.commission == 0
                ? theme.textSecondary
                : theme.warning,
          ),
        ],
      ),
    );
  }

  Widget _buildStatItem(
      AppTheme theme, String label, String value, Color valueColor) {
    return Expanded(
      child: Column(
        children: [
          Text(
            label,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 11,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 6),
          Text(
            value,
            style: TextStyle(
              color: valueColor,
              fontSize: 14,
              fontWeight: FontWeight.w700,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildClaimRewardsButton(
    BuildContext context,
    AppTheme theme,
    AppLocalizations l10n,
    AppState appState,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.success.withValues(alpha: 0.06),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: theme.success.withValues(alpha: 0.1),
          width: 1,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: theme.success.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(10),
            ),
            child: SvgPicture.asset(
              'assets/icons/trophy.svg',
              width: 20,
              height: 20,
              colorFilter: ColorFilter.mode(theme.success, BlendMode.srcIn),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.rewardsAvailable,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  _formatTokenAmount(stake.rewards, appState).$1,
                  style: TextStyle(
                    color: theme.success,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
          CustomButton(
            text: l10n.claimButton,
            onPressed: () => _claimRewards(context, appState),
            textColor: theme.buttonText,
            backgroundColor: theme.success,
            borderRadius: 12,
            height: 40.0,
            width: 80,
          ),
        ],
      ),
    );
  }

  Widget _buildActionButtons(
    BuildContext context,
    AppState appState,
    AppLocalizations l10n,
    bool hasDelegation,
  ) {
    final theme = appState.currentTheme;

    if (isScilla && !hasDelegation) {
      return const SizedBox.shrink();
    }

    return Row(
      children: [
        if (!isScilla) ...[
          Expanded(
            child: CustomButton(
              text: l10n.stakeButton,
              disabled: !stake.canStake,
              onPressed: () => _stake(context),
              textColor: theme.buttonText,
              backgroundColor: theme.primaryPurple,
              borderRadius: 16,
              height: 48.0,
            ),
          ),
          if (hasDelegation) const SizedBox(width: 12),
        ],
        if (hasDelegation) ...[
          Expanded(
            child: CustomButton(
              text: l10n.unstakeButton,
              onPressed: () => _initUnstake(context, appState),
              textColor: theme.buttonText,
              backgroundColor: theme.danger,
              borderRadius: 16,
              height: 48.0,
            ),
          ),
        ],
      ],
    );
  }

  (String, String) _formatTokenAmount(
    String amount,
    AppState appState, {
    bool isLSTToken = false,
  }) {
    final parsedAmount = BigInt.tryParse(amount) ?? BigInt.zero;

    if (isLSTToken && stake.token != null) {
      final token = stake.token!;
      final (formattedValue, converted) = formatingAmount(
        amount: parsedAmount,
        symbol: token.symbol,
        decimals: token.decimals,
        rate: token.rate,
        appState: appState,
        compact: true,
      );
      return (formattedValue, converted);
    } else {
      final nativeToken = appState.wallet?.tokens.firstWhere(
        (t) => t.native,
      );

      if (stake.token != null) {
        final (formattedValue, converted) = formatingAmount(
          amount: parsedAmount,
          symbol: stake.token!.symbol,
          decimals: stake.token!.decimals,
          rate: 0.0,
          appState: appState,
          compact: true,
        );
        return (formattedValue, converted);
      } else if (nativeToken != null) {
        int decimals = isScilla ? 12 : 18;

        final (formattedValue, converted) = formatingAmount(
          amount: parsedAmount,
          symbol: nativeToken.symbol,
          decimals: decimals,
          rate: 0,
          appState: appState,
          compact: true,
        );
        return (formattedValue, converted);
      }
    }

    return ("0", "0");
  }

  String _formatLSTPrice(AppState appState) {
    final price = stake.token?.rate ?? 1.0;
    final nativeToken = appState.wallet?.tokens.firstWhere(
      (t) => t.native,
    );

    final symbol = nativeToken?.symbol ?? "ZIL";

    if (price >= 1000) {
      return '${(price / 1000).toStringAsFixed(2)}K $symbol';
    } else if (price >= 1) {
      return '${price.toStringAsFixed(4)} $symbol';
    } else {
      return '${price.toStringAsFixed(6)} $symbol';
    }
  }

  Future<void> _showErrorDialog(
      BuildContext context, AppState appState, Object e) async {
    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: appState.currentTheme.cardBackground,
        title: Text(
          "Error",
          style: TextStyle(color: appState.currentTheme.textPrimary),
        ),
        content: Text(
          e.toString(),
          style: TextStyle(color: appState.currentTheme.danger),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(
              "OK",
              style: TextStyle(color: appState.currentTheme.primaryPurple),
            ),
          )
        ],
      ),
    );
  }

  Future<void> _initUnstake(BuildContext context, AppState appState) async {
    try {
      final nativeToken = appState.wallet?.tokens.firstWhere(
        (t) => t.native,
        orElse: () => throw Exception('Native token not found'),
      );
      final walletIndex = BigInt.from(appState.selectedWallet);
      final accountIndex = appState.wallet!.selectedAccount;
      TransactionRequestInfo tx;

      if ((isScilla) && appState.account!.addrType == 1) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      } else if (isEVM && appState.account!.addrType == 0) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      }

      if (isScilla) {
        tx = await buildTxScillaInitUnstake(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else if (isEVM) {
        showStakeModal(
          opType: StakeOperationType.unstake,
          context: context,
          stake: stake,
        );

        return;
      } else {
        throw "invalid tx type";
      }

      showConfirmTransactionModal(
        context: context,
        tx: tx,
        to: stake.address,
        token: nativeToken!,
        amount: "0",
        onConfirm: (_) {
          Navigator.of(context).pushNamed('/', arguments: {
            'selectedIndex': 1,
          });
        },
      );
    } catch (e) {
      _showErrorDialog(context, appState, e);
    }
  }

  void _stake(BuildContext context) {
    showStakeModal(
      opType: StakeOperationType.stake,
      context: context,
      stake: stake,
    );
  }

  Future<void> _claimWithdrawal(
    BuildContext context,
    AppState appState,
    PendingWithdrawalInfo item,
  ) async {
    try {
      final nativeToken = appState.wallet?.tokens.firstWhere(
        (t) => t.native,
        orElse: () => throw Exception('Native token not found'),
      );
      final walletIndex = BigInt.from(appState.selectedWallet);
      final accountIndex = appState.wallet!.selectedAccount;
      TransactionRequestInfo tx;

      if (isScilla && appState.account!.addrType == 1) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      } else if (isEVM && appState.account!.addrType == 0) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      }

      if (isScilla) {
        tx = await buildTxScillaCompleteWithdrawal(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else if (isEVM) {
        tx = await buildTxClaimUnstakeRequest(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else {
        throw "Invalid stake type for claiming withdrawal";
      }

      showConfirmTransactionModal(
        context: context,
        tx: tx,
        to: stake.address,
        token: nativeToken!,
        amount: "0",
        onConfirm: (_) {
          Navigator.of(context).pushNamed('/', arguments: {
            'selectedIndex': 1,
          });
        },
      );
    } catch (e) {
      _showErrorDialog(context, appState, e);
    }
  }

  Future<void> _claimRewards(BuildContext context, AppState appState) async {
    try {
      final nativeToken = appState.wallet?.tokens.firstWhere(
        (t) => t.native,
        orElse: () => throw Exception('Native token not found'),
      );
      final walletIndex = BigInt.from(appState.selectedWallet);
      final accountIndex = appState.wallet!.selectedAccount;
      TransactionRequestInfo tx;

      if (isScilla && appState.account!.addrType == 1) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      } else if (isEVM && appState.account!.addrType == 0) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      }

      if (isScilla) {
        tx = await buildClaimScillaStakingRewardsTx(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else if (isEVM) {
        tx = await buildTxClaimRewardRequest(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else {
        throw "Invlid stake type";
      }

      showConfirmTransactionModal(
        context: context,
        tx: tx,
        to: stake.address,
        token: stake.token ?? nativeToken!,
        amount: "0",
        onConfirm: (_) {
          Navigator.of(context).pushNamed('/', arguments: {
            'selectedIndex': 1,
          });
        },
      );
    } catch (e) {
      _showErrorDialog(context, appState, e);
    }
  }

  Future<void> _claimClaimableAmount(
    BuildContext context,
    AppState appState,
  ) async {
    try {
      final nativeToken = appState.wallet?.tokens.firstWhere(
        (t) => t.native,
        orElse: () => throw Exception('Native token not found'),
      );
      final walletIndex = BigInt.from(appState.selectedWallet);
      final accountIndex = appState.wallet!.selectedAccount;
      TransactionRequestInfo tx;

      if (isEVM && appState.account!.addrType == 0) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
        );
      }

      if (isEVM) {
        tx = await buildTxClaimUnstakeRequest(
          walletIndex: walletIndex,
          accountIndex: accountIndex,
          stake: stake,
        );
      } else {
        throw "Invalid stake type for claiming claimable amount";
      }

      showConfirmTransactionModal(
        context: context,
        tx: tx,
        to: stake.address,
        token: stake.token ?? nativeToken!,
        amount: "0",
        onConfirm: (_) {
          Navigator.of(context).pushNamed('/', arguments: {
            'selectedIndex': 1,
          });
        },
      );
    } catch (e) {
      _showErrorDialog(context, appState, e);
    }
  }

  (String, bool) _calculateLiquidStakingRewards(AppState appState) {
    if (!isLiquidStaking || stake.token?.rate == null) {
      return ("0", false);
    }

    final lstAmount = BigInt.tryParse(stake.delegAmt) ?? BigInt.zero;
    if (lstAmount == BigInt.zero) {
      return ("0", false);
    }

    final lstPrice = stake.token!.rate;
    final decimals = stake.token!.decimals;

    final lstAmountDouble = lstAmount.toDouble() / pow(10, decimals);
    final zilBackedDouble = lstAmountDouble * lstPrice;
    final rewardsEarnedDouble = zilBackedDouble - lstAmountDouble;

    if (rewardsEarnedDouble <= 0) {
      return ("0", false);
    }

    final nativeToken = appState.wallet?.tokens.firstWhere((t) => t.native);
    final nativeDecimals = nativeToken?.decimals ?? 18;

    final rewardsBigInt =
        BigInt.from(rewardsEarnedDouble * pow(10, nativeDecimals));

    final (formattedRewards, _) = formatingAmount(
      amount: rewardsBigInt,
      symbol: nativeToken?.symbol ?? 'ZIL',
      decimals: nativeDecimals,
      rate: 0,
      appState: appState,
      compact: true,
    );

    return (formattedRewards, true);
  }
}

```

`lib/components/swipe_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class SwipeButton extends StatefulWidget {
  final double width;
  final double height;
  final String text;
  final Future<void> Function()? onSwipeComplete;
  final bool disabled;
  final Color? backgroundColor;
  final Color? textColor;
  final Color? secondaryColor;

  const SwipeButton({
    super.key,
    this.width = 300.0,
    this.height = 56.0,
    required this.text,
    this.onSwipeComplete,
    this.disabled = false,
    this.backgroundColor,
    this.textColor,
    this.secondaryColor,
  });

  @override
  State<SwipeButton> createState() => _SwipeButtonState();
}

class _SwipeButtonState extends State<SwipeButton>
    with SingleTickerProviderStateMixin {
  static const double _swipeThreshold = 0.8;

  late AnimationController _controller;
  late Animation<double> _shrinkAnimation;
  double _dragExtent = 0.0;
  bool _isDragging = false;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _shrinkAnimation = Tween<double>(begin: widget.width, end: widget.height)
        .animate(_controller)
      ..addListener(() {
        setState(() {});
      });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _onDragUpdate(DragUpdateDetails details) {
    if (_isLoading || widget.disabled) return;
    setState(() {
      _isDragging = true;
      _dragExtent += details.delta.dx;
      _dragExtent = _dragExtent.clamp(0.0, widget.width - widget.height);
    });
  }

  Future<void> _onDragEnd(DragEndDetails details) async {
    if (_isLoading || widget.disabled) return;
    final threshold = (widget.width - widget.height) * _swipeThreshold;
    if (_dragExtent >= threshold) {
      setState(() => _isLoading = true);
      await _controller.forward();
      if (widget.onSwipeComplete != null) {
        await widget.onSwipeComplete!();
      }
      await _controller.reverse();
      setState(() => _isLoading = false);
    }
    setState(() {
      _isDragging = false;
      _dragExtent = 0.0;
    });
  }

  Widget _buildSwipeThumb(Color secColor, ColorFilter colorFilter) {
    return Container(
      width: widget.height - 8,
      height: widget.height - 8,
      decoration: BoxDecoration(
        color: widget.disabled ? secColor.withValues(alpha: 0.5) : secColor,
        borderRadius: BorderRadius.circular((widget.height - 8) / 2),
        boxShadow: [
          BoxShadow(
            color: Provider.of<AppState>(context)
                .currentTheme
                .background
                .withValues(alpha: 0.3),
            blurRadius: 4,
          ),
        ],
      ),
      child: SvgPicture.asset(
        "assets/icons/right_circle_arrow.svg",
        width: widget.height - 8,
        height: widget.height - 8,
        colorFilter: colorFilter,
      ),
    );
  }

  Widget _buildDragBackground(Color secColor) {
    return Container(
      width: _isDragging ? _dragExtent + widget.height - 8 : widget.height - 8,
      height: widget.height - 8,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular((widget.height - 8) / 2),
        gradient: LinearGradient(
          colors: [
            widget.disabled
                ? secColor.withValues(alpha: 0.05)
                : secColor.withValues(alpha: 0.1),
            widget.disabled ? secColor.withValues(alpha: 0.5) : secColor,
          ],
          stops: const [0.0, 0.9],
          begin: Alignment.centerLeft,
          end: Alignment.centerRight,
        ),
      ),
      child: Row(
        children: [
          if (_isDragging) Expanded(child: Container()),
          _buildSwipeThumb(
            secColor,
            ColorFilter.mode(
              widget.disabled
                  ? Provider.of<AppState>(context)
                      .currentTheme
                      .background
                      .withValues(alpha: 0.5)
                  : Provider.of<AppState>(context).currentTheme.background,
              BlendMode.srcIn,
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final bgColor = widget.backgroundColor ?? theme.primaryPurple;
    final txtColor = widget.textColor ?? theme.textPrimary;
    final secColor = widget.secondaryColor ?? theme.secondaryPurple;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      width: _isLoading ? _shrinkAnimation.value : widget.width,
      height: widget.height,
      decoration: BoxDecoration(
        color: widget.disabled ? bgColor.withValues(alpha: 0.5) : bgColor,
        borderRadius: BorderRadius.circular(widget.height / 2),
      ),
      child: Stack(
        children: [
          if (!_isLoading)
            Center(
              child: Text(
                widget.text,
                style: theme.subtitle1.copyWith(
                  color: widget.disabled
                      ? txtColor.withValues(alpha: 0.5)
                      : txtColor,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          if (_isLoading)
            Center(
              child: SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(
                  color: txtColor,
                  strokeWidth: 3,
                ),
              ),
            ),
          if (!_isLoading)
            GestureDetector(
              onHorizontalDragUpdate: widget.disabled ? null : _onDragUpdate,
              onHorizontalDragEnd: widget.disabled ? null : _onDragEnd,
              child: Container(
                margin: const EdgeInsets.all(4),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: _buildDragBackground(secColor),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

```

`lib/components/switch_setting_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class SwitchSettingItem extends StatelessWidget {
  final String title;
  final String iconPath;
  final String description;
  final bool value;
  final ValueChanged<bool> onChanged;
  final Color? backgroundColor;

  const SwitchSettingItem({
    super.key,
    required this.title,
    required this.iconPath,
    required this.description,
    required this.value,
    required this.onChanged,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    Widget content = Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              SvgPicture.asset(
                iconPath,
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Text(
                  title,
                  style: theme.bodyText1.copyWith(
                    color: theme.textPrimary,
                  ),
                ),
              ),
              Switch(
                value: value,
                onChanged: onChanged,
                activeThumbColor: theme.primaryPurple,
              ),
            ],
          ),
          if (description.isNotEmpty) ...[
            const SizedBox(height: 4),
            Padding(
              padding: const EdgeInsets.only(left: 40),
              child: Text(
                description,
                style: theme.bodyText2.copyWith(
                  color: theme.textSecondary,
                ),
              ),
            ),
          ],
        ],
      ),
    );

    if (backgroundColor != null) {
      return Container(
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(12),
        ),
        child: content,
      );
    } else {
      return content;
    }
  }
}

```

`lib/components/tile_button.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class TileButton extends StatefulWidget {
  final String? title;
  final Widget icon;
  final VoidCallback onPressed;
  final Color backgroundColor;
  final Color textColor;
  final bool disabled;

  const TileButton({
    super.key,
    required this.icon,
    required this.onPressed,
    this.title,
    this.backgroundColor = const Color(0xFF2C2C2E),
    this.textColor = const Color(0xFF9D4BFF),
    this.disabled = false,
  });

  @override
  State<TileButton> createState() => _TileButtonState();
}

class _TileButtonState extends State<TileButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  bool _isHovered = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.90,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.fastEaseInToSlowEaseOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 1.0,
      end: 0.7,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.fastEaseInToSlowEaseOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    if (!widget.disabled) {
      _controller.forward();
    }
  }

  void _handleTapUp(TapUpDetails details) {
    if (!widget.disabled) {
      _controller.reverse();
      widget.onPressed();
    }
  }

  void _handleTapCancel() {
    if (!widget.disabled) {
      _controller.reverse();
    }
  }

  void _handleHoverChanged(bool isHovered) {
    if (!widget.disabled) {
      setState(() {
        _isHovered = isHovered;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    final bool hasTitle = widget.title != null && widget.title!.isNotEmpty;

    final double iconSize = hasTitle ? 34.0 : 20.0;
    final double borderRadius = 16.0;

    double containerSize;

    if (hasTitle) {
      final double estimatedFontSize = theme.caption.fontSize ?? 14.0;
      final double estimatedLineHeightFactor = theme.caption.height ?? 1.3;
      final double actualTextHeightForTwoLines =
          estimatedFontSize * 2 * estimatedLineHeightFactor;

      containerSize =
          12.0 + iconSize + 4.0 + actualTextHeightForTwoLines + 12.0;
    } else {
      containerSize = 48.0;
    }

    Widget buttonContent;

    if (hasTitle) {
      buttonContent = Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: iconSize,
              height: iconSize,
              child: Center(child: widget.icon),
            ),
            const SizedBox(height: 4),
            Text(
              widget.title!,
              style: theme.caption.copyWith(
                color: widget.textColor,
              ),
              overflow: TextOverflow.ellipsis,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    } else {
      buttonContent = Center(
        child: SizedBox(
          width: iconSize,
          height: iconSize,
          child: widget.icon,
        ),
      );
    }

    return MouseRegion(
      onEnter: (_) => _handleHoverChanged(true),
      onExit: (_) => _handleHoverChanged(false),
      cursor: widget.disabled
          ? SystemMouseCursors.forbidden
          : SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: _handleTapDown,
        onTapUp: _handleTapUp,
        onTapCancel: _handleTapCancel,
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: _scaleAnimation.value,
              child: Opacity(
                opacity: widget.disabled ? 0.5 : _opacityAnimation.value,
                child: Container(
                  width: containerSize,
                  height: containerSize,
                  decoration: BoxDecoration(
                    color: widget.backgroundColor,
                    borderRadius: BorderRadius.circular(borderRadius),
                    // border: Border.all(
                    //     color: theme.primaryPurple.withValues(alpha: 0.2)),
                    boxShadow: [
                      if (_isHovered && !widget.disabled)
                        BoxShadow(
                          color:
                              widget.textColor.withAlpha((0.1 * 255).round()),
                          blurRadius: 8,
                          spreadRadius: 1,
                        ),
                    ],
                  ),
                  child: buttonContent,
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

```

`lib/components/token_card.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';

class TokenCard extends StatefulWidget {
  final FTokenInfo ftoken;
  final BigInt tokenAmount;
  final bool showDivider;
  final VoidCallback? onTap;
  final bool hideBalance;

  const TokenCard({
    super.key,
    required this.tokenAmount,
    required this.ftoken,
    this.showDivider = true,
    this.onTap,
    this.hideBalance = false,
  });

  @override
  State<TokenCard> createState() => _TokenCardState();
}

class _TokenCardState extends State<TokenCard>
    with SingleTickerProviderStateMixin {
  bool isHovered = false;
  bool isPressed = false;

  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
    _animation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Widget _buildIcon(AppState state) {
    final theme = state.currentTheme;
    FTokenInfo token = FTokenInfo(
      name: widget.ftoken.name,
      symbol: widget.ftoken.symbol,
      decimals: widget.ftoken.decimals,
      addr: widget.ftoken.addr,
      addrType: widget.ftoken.addrType,
      balances: {},
      rate: 0,
      default_: widget.ftoken.default_,
      native: widget.ftoken.native,
      chainHash: widget.ftoken.chainHash,
      logo: widget.ftoken.logo ?? state.wallet?.tokens.first.logo,
    );

    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
            color: theme.primaryPurple.withValues(alpha: 0.1), width: 2),
      ),
      child: ClipOval(
        child: AsyncImage(
          url: processTokenLogo(
            token: token,
            shortName: state.chain?.shortName ?? '',
            theme: theme.value,
          ),
          width: 32,
          height: 32,
          fit: BoxFit.contain,
          errorWidget: Blockies(
            seed: widget.ftoken.addr,
            color: theme.secondaryPurple,
            bgColor: state.currentTheme.primaryPurple,
            spotColor: state.currentTheme.background,
            size: 8,
          ),
          loadingWidget:
              const Center(child: CircularProgressIndicator(strokeWidth: 2)),
        ),
      ),
    );
  }

  String maskBalance() {
    return "*******";
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final (amount, converted) = formatingAmount(
      amount: widget.tokenAmount,
      symbol: widget.ftoken.symbol,
      decimals: widget.ftoken.decimals,
      rate: widget.ftoken.rate,
      appState: appState,
    );
    final displayAmount = widget.hideBalance ? maskBalance() : amount;
    final displayConverted = widget.hideBalance ? maskBalance() : converted;

    return Column(
      children: [
        MouseRegion(
          onEnter: (_) {
            setState(() => isHovered = true);
            _controller.forward(from: 0.5);
          },
          onExit: (_) {
            setState(() => isHovered = false);
            _controller.reverse();
          },
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTapDown: (_) {
              setState(() => isPressed = true);
              _controller.forward();
            },
            onTapUp: (_) {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTapCancel: () {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTap: widget.onTap,
            child: AnimatedBuilder(
              animation: _animation,
              builder: (context, child) =>
                  Transform.scale(scale: _animation.value, child: child),
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 150),
                child: Padding(
                  padding: EdgeInsets.symmetric(
                      horizontal: adaptivePadding, vertical: adaptivePadding),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            LayoutBuilder(
                              builder: (context, constraints) {
                                return Row(
                                  children: [
                                    Flexible(
                                      child: Text(
                                        widget.ftoken.name,
                                        style: theme.bodyText1.copyWith(
                                          color: theme.textPrimary
                                              .withValues(alpha: 0.7),
                                          fontWeight: FontWeight.w500,
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Text(
                                      '(${widget.ftoken.symbol})',
                                      style: theme.caption.copyWith(
                                        color: theme.textSecondary
                                            .withValues(alpha: 0.5),
                                        fontSize: 13,
                                      ),
                                    ),
                                  ],
                                );
                              },
                            ),
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                Flexible(
                                  child: Text(
                                    displayAmount,
                                    style: theme.subtitle1.copyWith(
                                      color: theme.textPrimary,
                                      fontWeight: FontWeight.w600,
                                      letterSpacing: 0.5,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 4),
                            if (appState.wallet?.settings.currencyConvert !=
                                null)
                              Text(
                                displayConverted,
                                style: theme.bodyText2
                                    .copyWith(color: theme.textSecondary),
                              ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 12),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white.withValues(alpha: 0.05),
                          shape: BoxShape.circle,
                        ),
                        child: _buildIcon(Provider.of<AppState>(context)),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
        if (widget.showDivider)
          Container(height: 1, color: theme.textPrimary.withValues(alpha: 0.1)),
      ],
    );
  }
}

```

`lib/components/token_select_item.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';

class TokenSelectItem extends StatelessWidget {
  final FTokenInfo ftoken;
  final BigInt balance;
  final VoidCallback onTap;
  final double iconSize;

  const TokenSelectItem({
    super.key,
    required this.ftoken,
    required this.balance,
    required this.onTap,
    this.iconSize = 40.0,
  });

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final (amount, converted) = formatingAmount(
      amount: balance,
      symbol: ftoken.symbol,
      decimals: ftoken.decimals,
      rate: ftoken.rate,
      appState: appState,
    );

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
        child: Row(
          children: [
            Container(
              width: iconSize,
              height: iconSize,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(iconSize / 2),
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(iconSize / 2),
                child: AsyncImage(
                  url: processTokenLogo(
                    token: ftoken,
                    shortName: appState.chain?.shortName ?? "",
                    theme: theme.value,
                  ),
                  width: iconSize,
                  height: iconSize,
                  fit: BoxFit.contain,
                  errorWidget: Blockies(
                    seed: ftoken.addr,
                    color: theme.secondaryPurple,
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                  loadingWidget: const Center(
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    ftoken.symbol,
                    style: theme.bodyText1.copyWith(
                      color: theme.textPrimary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    ftoken.name,
                    style: theme.bodyText2.copyWith(
                      color: theme.textSecondary,
                    ),
                  ),
                ],
              ),
            ),
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  amount,
                  style: theme.bodyText1.copyWith(
                    color: theme.textPrimary,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Text(
                  converted,
                  style: theme.bodyText2.copyWith(
                    color: theme.textSecondary,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/components/token_transfer_amount.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class TokenTransferInfo extends StatelessWidget {
  final String fromAddress;
  final String toAddress;
  final String? fromName;
  final String? toName;
  final bool disabled;
  final Color? textColor;
  final Color? secondaryColor;

  const TokenTransferInfo({
    super.key,
    required this.fromAddress,
    required this.toAddress,
    this.fromName,
    this.toName,
    this.disabled = false,
    this.textColor,
    this.secondaryColor,
  });

  Future<void> _copyToClipboard(BuildContext context, String text) async {
    await Clipboard.setData(ClipboardData(text: text));
  }

  Widget _buildAddressButton(
    BuildContext context,
    String address,
    String? name,
    AppTheme theme,
    TextStyle style,
  ) {
    return Expanded(
      flex: 3,
      child: TextButton(
        onPressed: () => _copyToClipboard(context, address),
        style: TextButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          minimumSize: Size.zero,
          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
          splashFactory: NoSplash.splashFactory,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              name ?? AppLocalizations.of(context)!.tokenTransferAmountUnknown,
              style: style.copyWith(
                // style is already themed addressStyle
                fontSize: 8,
                fontWeight: FontWeight.normal, // w400 is FontWeight.normal
              ),
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 2),
            Text(
              shortenAddress(address),
              style: style, // style is already themed addressStyle
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;

    final effectiveTextColor = textColor ?? theme.textPrimary;
    final effectiveSecondaryColor = secondaryColor ?? theme.textSecondary;

    final addressStyle = theme.overline.copyWith(
      color: effectiveTextColor.withValues(alpha: 0.7),
      letterSpacing: 0.5,
      fontWeight: FontWeight.w500,
    );

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
      decoration: BoxDecoration(
        color: effectiveSecondaryColor.withValues(alpha: 0.05),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          _buildAddressButton(
            context,
            fromAddress,
            fromName,
            theme,
            addressStyle,
          ),
          Expanded(
            flex: 4,
            child: Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: effectiveSecondaryColor.withValues(alpha: 0.1),
                shape: BoxShape.circle,
              ),
              child: SvgPicture.asset(
                "assets/icons/right_arrow.svg",
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  effectiveSecondaryColor,
                  BlendMode.srcIn,
                ),
              ),
            ),
          ),
          _buildAddressButton(
            context,
            toAddress,
            toName,
            theme,
            addressStyle,
          ),
        ],
      ),
    );
  }
}

```

`lib/components/transaction_amount_display.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/state/app_state.dart';

class TransactionAmountDisplay extends StatelessWidget {
  final BigInt amount;
  final BigInt fee;
  final FTokenInfo token;
  final BigInt balance;
  final Color textColor;

  const TransactionAmountDisplay({
    super.key,
    required this.amount,
    required this.fee,
    required this.token,
    required this.balance,
    required this.textColor,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(builder: (context, constraints) {
      return Container(
        width: double.infinity,
        alignment: Alignment.center,
        child: _buildAmountDisplay(context),
      );
    });
  }

  Widget _buildAmountDisplay(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final nativeToken = appState.wallet?.tokens.first;
    final bool isNative = token.native;
    final bool isMaxTransfer = isNative && amount == balance;

    final TextStyle amountStyle = theme.bodyText1.copyWith(
      fontWeight: FontWeight.w600,
      color: textColor,
    );

    final TextStyle feeStyle = theme.overline.copyWith(
      fontWeight: FontWeight.w500,
      color: textColor.withValues(alpha: 0.8),
    );

    final TextStyle conversionAmountStyle = theme.caption.copyWith(
      // fontWeight is already normal in caption
      color: textColor.withValues(alpha: 0.6),
    );

    final TextStyle conversionFeeStyle = theme.overline.copyWith(
      // fontWeight is already normal in overline
      color: textColor.withValues(alpha: 0.6),
    );

    String amountText;
    String? feeText;
    String? amountConversion;
    String? feeConversion;
    String connector = "";

    if (isMaxTransfer) {
      final adjustedAmount = amount - fee;
      final (normalizedAmount, convertedAmount) = formatingAmount(
        amount: adjustedAmount,
        symbol: token.symbol,
        decimals: token.decimals,
        rate: token.rate,
        appState: appState,
      );
      amountText = normalizedAmount;
      amountConversion = convertedAmount;
      connector = " - ";
    } else {
      final (normalizedAmount, convertedAmount) = formatingAmount(
        amount: amount,
        symbol: token.symbol,
        decimals: token.decimals,
        rate: token.rate,
        appState: appState,
      );
      amountText = normalizedAmount;
      amountConversion = convertedAmount;
      connector = " + ";
    }

    if (nativeToken?.native == true) {
      final (normalizedFee, convertedFee) = formatingAmount(
        amount: fee,
        symbol: nativeToken!.symbol,
        decimals: nativeToken.decimals,
        rate: nativeToken.rate,
        appState: appState,
      );
      feeText = normalizedFee;
      feeConversion = convertedFee;
    }

    final bool hasConversion =
        appState.wallet?.settings.currencyConvert != null &&
            (!amountConversion.contains('-')) &&
            (feeConversion == null || !feeConversion.contains('-'));

    return Column(
      children: [
        feeText != null
            ? FittedBox(
                fit: BoxFit.scaleDown,
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(amountText,
                        style: amountStyle, overflow: TextOverflow.ellipsis),
                    Text(connector, style: amountStyle),
                    Text(feeText,
                        style: feeStyle, overflow: TextOverflow.ellipsis),
                  ],
                ),
              )
            : Text(
                amountText,
                style: amountStyle,
                textAlign: TextAlign.center,
                overflow: TextOverflow.ellipsis,
              ),
        if (hasConversion)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: feeText != null && feeConversion != null
                ? FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(amountConversion,
                            style: conversionAmountStyle,
                            overflow: TextOverflow.ellipsis),
                        Text(connector, style: conversionAmountStyle),
                        Text(feeConversion,
                            style: conversionFeeStyle,
                            overflow: TextOverflow.ellipsis),
                      ],
                    ),
                  )
                : Text(
                    amountConversion,
                    style: conversionAmountStyle,
                    textAlign: TextAlign.center,
                    overflow: TextOverflow.ellipsis,
                  ),
          ),
      ],
    );
  }
}

```

`lib/components/transaction_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:blockies/blockies.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/transactions/history.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class HistoryItem extends StatefulWidget {
  final HistoricalTransactionInfo transaction;
  final bool showDivider;
  final VoidCallback? onTap;

  const HistoryItem({
    super.key,
    required this.transaction,
    this.showDivider = true,
    this.onTap,
  });

  @override
  State<HistoryItem> createState() => _HistoryItemState();
}

class _HistoryItemState extends State<HistoryItem>
    with SingleTickerProviderStateMixin {
  bool isPressed = false;
  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
        duration: const Duration(milliseconds: 150), vsync: this);
    _animation = Tween<double>(begin: 1.0, end: 0.95)
        .animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Widget _buildIcon(AppState appState) {
    final theme = appState.currentTheme;
    final token = _findMatchingToken(appState);

    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
          shape: BoxShape.circle,
          border: Border.all(
              color: theme.primaryPurple.withValues(alpha: 0.1), width: 2)),
      child: ClipOval(
        child: AsyncImage(
          url: widget.transaction.icon ??
              (token != null
                  ? processTokenLogo(
                      token: token,
                      shortName: appState.chain?.shortName ?? "",
                      theme: theme.value,
                    )
                  : null),
          width: 32,
          height: 32,
          fit: BoxFit.contain,
          errorWidget: Blockies(
              seed: widget.transaction.transactionHash,
              color: theme.secondaryPurple,
              bgColor: theme.primaryPurple,
              spotColor: theme.background,
              size: 8),
          loadingWidget:
              const Center(child: CircularProgressIndicator(strokeWidth: 2)),
        ),
      ),
    );
  }

  FTokenInfo? _findMatchingToken(AppState appState) {
    if (appState.wallet == null ||
        widget.transaction.tokenInfo == null ||
        appState.account == null) {
      return null;
    }

    try {
      return appState.wallet!.tokens.firstWhere((t) =>
          t.symbol == widget.transaction.tokenInfo?.symbol &&
          t.addrType == appState.account?.addrType);
    } catch (_) {
      return null;
    }
  }

  Color _getStatusColor(AppTheme theme) {
    switch (widget.transaction.status) {
      case TransactionStatusInfo.confirmed:
        return theme.success;
      case TransactionStatusInfo.pending:
        return theme.warning;
      case TransactionStatusInfo.rejected:
        return theme.danger;
    }
  }

  String _formatDateTime() {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(
      widget.transaction.timestamp.toInt() * 1000,
    );

    final day = dateTime.day.toString().padLeft(2, '0');
    final month = dateTime.month.toString().padLeft(2, '0');
    final year = dateTime.year.toString();
    final hour = dateTime.hour.toString().padLeft(2, '0');
    final minute = dateTime.minute.toString().padLeft(2, '0');

    return '$day.$month.$year $hour:$minute';
  }

  Widget _buildAmountWithPrice(AppState appState) {
    final theme = appState.currentTheme;
    final token = _findMatchingToken(appState);
    final baseToken = appState.wallet?.tokens.first;

    final amount = BigInt.tryParse(
            widget.transaction.tokenInfo?.value ?? widget.transaction.amount) ??
        BigInt.zero;

    final decimals = (widget.transaction.tokenInfo?.decimals ??
            token?.decimals ??
            baseToken?.decimals) ??
        1;

    final symbol = (widget.transaction.tokenInfo?.symbol ??
            token?.symbol ??
            baseToken?.symbol) ??
        "";

    final rate = token?.rate ?? baseToken?.rate ?? 0;

    final (formattedValue, convertedValue) = formatingAmount(
      amount: amount,
      symbol: symbol,
      decimals: decimals,
      rate: rate,
      appState: appState,
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(formattedValue,
            style: theme.bodyText1.copyWith(
                color: theme.textPrimary,
                fontWeight: FontWeight.w600,
                letterSpacing: 0.5),
            overflow: TextOverflow.ellipsis),
        if (convertedValue.isNotEmpty && convertedValue != '0')
          const SizedBox(height: 2),
        Text(convertedValue,
            style: theme.bodyText2
                .copyWith(color: theme.textSecondary.withValues(alpha: 0.7))),
      ],
    );
  }

  Widget _buildFeeWithPrice(AppState appState) {
    final theme = appState.currentTheme;
    final token = appState.wallet?.tokens.first;

    if (token == null) {
      return const SizedBox.shrink();
    }

    final decimals =
        widget.transaction.chainType == "EVM" && token.decimals < 18
            ? 18
            : token.decimals;

    final (formattedValue, convertedValue) = formatingAmount(
      amount: widget.transaction.fee,
      symbol: token.symbol,
      decimals: decimals,
      rate: token.rate,
      appState: appState,
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.end,
      children: [
        Text(
          formattedValue,
          style: theme.bodyText2.copyWith(color: theme.textSecondary),
          overflow: TextOverflow.ellipsis,
        ),
        if (convertedValue.isNotEmpty && convertedValue != '0')
          const SizedBox(height: 2),
        Text(
          convertedValue,
          style: theme.caption.copyWith(
            color: theme.textSecondary.withValues(alpha: 0.7),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Column(
      children: [
        MouseRegion(
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTapDown: (_) {
              setState(() => isPressed = true);
              _controller.forward();
            },
            onTapUp: (_) {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTapCancel: () {
              setState(() => isPressed = false);
              _controller.reverse();
            },
            onTap: widget.onTap,
            child: AnimatedBuilder(
              animation: _animation,
              builder: (context, child) =>
                  Transform.scale(scale: _animation.value, child: child),
              child: Padding(
                padding: EdgeInsets.all(adaptivePadding),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 8, vertical: 4),
                                    decoration: BoxDecoration(
                                        color: _getStatusColor(theme)
                                            .withValues(alpha: 0.1),
                                        borderRadius:
                                            BorderRadius.circular(12)),
                                    child: Text(
                                        widget.transaction.status.name
                                            .toUpperCase(),
                                        style: theme.caption.copyWith(
                                            color: _getStatusColor(theme),
                                            fontWeight: FontWeight.w600)),
                                  ),
                                  const SizedBox(width: 8),
                                  Flexible(
                                    child: Text(
                                        widget.transaction.title ??
                                            l10n
                                                .transactionDetailsModal_transaction,
                                        style: theme.bodyText1.copyWith(
                                            color: theme.textPrimary
                                                .withValues(alpha: 0.7),
                                            fontWeight: FontWeight.w500),
                                        overflow: TextOverflow.ellipsis),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 8),
                              _buildAmountWithPrice(state),
                            ],
                          ),
                        ),
                        const SizedBox(width: 12),
                        _buildIcon(state),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(
                          _formatDateTime(),
                          style: theme.bodyText2.copyWith(
                            color: theme.textSecondary.withValues(alpha: 0.7),
                          ),
                        ),
                        _buildFeeWithPrice(state),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
        if (widget.showDivider)
          Container(height: 1, color: theme.textPrimary.withValues(alpha: 0.1)),
      ],
    );
  }
}

```

`lib/components/view_item.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class WalletListItem extends StatefulWidget {
  final String title;
  final String subtitle;
  final dynamic icon;
  final VoidCallback? onTap;
  final bool disabled;

  const WalletListItem({
    super.key,
    required this.title,
    required this.subtitle,
    required this.icon,
    this.onTap,
    this.disabled = false,
  });

  @override
  State<WalletListItem> createState() => _WalletListItemState();
}

class _WalletListItemState extends State<WalletListItem>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 1.0,
      end: 0.7,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final opacity = widget.disabled ? 0.5 : 1.0;

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: GestureDetector(
        onTapDown: widget.disabled ? null : (_) => _controller.forward(),
        onTapUp: widget.disabled ? null : (_) => _controller.reverse(),
        onTapCancel: widget.disabled ? null : () => _controller.reverse(),
        onTap: widget.disabled ? null : widget.onTap,
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Transform.scale(
              scale: widget.disabled ? 1.0 : _scaleAnimation.value,
              child: Container(
                decoration: BoxDecoration(
                  color: theme.cardBackground.withValues(
                    alpha: widget.disabled ? opacity : _opacityAnimation.value,
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: child,
              ),
            );
          },
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Opacity(opacity: opacity, child: _buildIcon()),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        widget.title,
                        style: theme.bodyText1.copyWith(
                          color: theme.textPrimary.withValues(alpha: opacity),
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        widget.subtitle,
                        style: theme.bodyText2.copyWith(
                          color: theme.textSecondary.withValues(alpha: opacity),
                        ),
                      ),
                    ],
                  ),
                ),
                Opacity(
                  opacity: opacity,
                  child: SvgPicture.asset(
                    'assets/icons/chevron_right.svg',
                    width: 24,
                    height: 24,
                    colorFilter: ColorFilter.mode(
                      theme.textSecondary,
                      BlendMode.srcIn,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildIcon() {
    if (widget.icon is IconData) {
      return Icon(widget.icon as IconData);
    } else if (widget.icon is Widget) {
      return widget.icon;
    } else if (widget.icon is String) {
      return Image.asset(
        widget.icon,
        width: 24,
        height: 24,
      );
    }
    return Container();
  }
}

```

`lib/components/wallet_card.dart`:

```dart
import 'package:flutter/widgets.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/address_avatar.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';

class WalletCard extends StatefulWidget {
  final AccountInfo account;
  final VoidCallback onTap;
  final bool isSelected;
  final double? width;
  final double? height;
  final double? fontSize;
  final double avatarSize;

  const WalletCard({
    super.key,
    required this.account,
    required this.onTap,
    this.isSelected = false,
    this.width,
    this.height,
    this.fontSize,
    this.avatarSize = 50,
  });

  @override
  State<WalletCard> createState() => _WalletCardState();
}

class _WalletCardState extends State<WalletCard>
    with SingleTickerProviderStateMixin {
  bool isHovered = false;
  bool isPressed = false;

  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 1.0,
      end: 0.95,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return MouseRegion(
      onEnter: (_) {
        setState(() => isHovered = true);
        _controller.forward(from: 0.5);
      },
      onExit: (_) {
        setState(() => isHovered = false);
        _controller.reverse();
      },
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) {
          setState(() => isPressed = true);
          _controller.forward();
        },
        onTapUp: (_) {
          setState(() => isPressed = false);
          _controller.reverse();
        },
        onTapCancel: () {
          setState(() => isPressed = false);
          _controller.reverse();
        },
        onTap: widget.onTap,
        child: AnimatedBuilder(
          animation: _animation,
          builder: (context, child) => Transform.scale(
            scale: _animation.value,
            child: child,
          ),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 150),
            width: widget.width,
            height: widget.height,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: widget.isSelected
                  ? theme.primaryPurple.withValues(alpha: 0.1)
                  : const Color(0x00000000),
            ),
            child: Padding(
              padding: EdgeInsets.symmetric(
                horizontal: adaptivePadding,
                vertical: 4,
              ),
              child: Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      color: theme.textPrimary.withValues(alpha: 0.05),
                      shape: BoxShape.circle,
                    ),
                    child: AvatarAddress(
                      avatarSize: widget.avatarSize,
                      account: widget.account,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          widget.account.name,
                          style: theme.bodyText1.copyWith(
                            color: theme.textPrimary.withValues(alpha: 0.7),
                            fontSize: widget.fontSize ?? 16,
                            fontWeight: FontWeight.w500,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 2),
                        Text(
                          shortenAddress(widget.account.addr,
                              leftSize: 8, rightSize: 8),
                          style: theme.bodyText2.copyWith(
                            color: theme.textPrimary.withValues(alpha: 0.5),
                            fontSize: (widget.fontSize ?? 16) - 2,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/components/wallet_header.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/address_avatar.dart';
import 'package:zilpay/components/copy_content.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/modals/wallet_header.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/state/app_state.dart';

class WalletHeader extends StatefulWidget {
  final AccountInfo account;
  final Function()? onTap;
  final VoidCallback onSettings;

  const WalletHeader({
    super.key,
    required this.account,
    required this.onSettings,
    this.onTap,
  });

  @override
  State<WalletHeader> createState() => _WalletHeaderState();
}

class _WalletHeaderState extends State<WalletHeader>
    with SingleTickerProviderStateMixin {
  double _opacity = 1.0;
  bool _isAnimated = true;

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _isAnimated = false;
      _opacity = 0.5;
    });
  }

  void _handleTapUp(TapUpDetails details) {
    setState(() {
      _isAnimated = true;
      _opacity = 1.0;
    });
  }

  void _handleTapCancel() {
    setState(() {
      _isAnimated = true;
      _opacity = 1.0;
    });
  }

  void _showWalletModal() {
    showWalletModal(
      context: context,
      onManageWallet: () {
        Navigator.pop(context);
        Navigator.pushNamed(context, '/login');
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 0.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              GestureDetector(
                behavior: HitTestBehavior.opaque,
                onTapDown: _handleTapDown,
                onTapUp: _handleTapUp,
                onTapCancel: _handleTapCancel,
                onTap: () {
                  _showWalletModal();
                  widget.onTap?.call();
                },
                child: AnimatedOpacity(
                  opacity: _opacity,
                  duration: Duration(milliseconds: _isAnimated ? 150 : 0),
                  child: AvatarAddress(
                    avatarSize: 50,
                    account: widget.account,
                  ),
                ),
              ),
              HoverSvgIcon(
                assetName: 'assets/icons/gear.svg',
                width: 32,
                height: 32,
                padding: const EdgeInsets.fromLTRB(16, 0, 0, 0),
                color: theme.textSecondary,
                onTap: widget.onSettings,
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                widget.account.name,
                style: theme.headline2.copyWith(
                  color: theme.textPrimary,
                  fontSize: theme.headline2.fontSize,
                ),
              ),
              const SizedBox(width: 8),
              CopyContent(
                address: widget.account.addr,
              ),
            ],
          ),
        ],
      ),
    );
  }
}

```

`lib/components/wallet_option.dart`:

```dart
import 'dart:ui';
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/state/app_state.dart';

class WalletOption extends StatelessWidget {
  final String title;
  final String address;
  final int walletIndex;
  final bool isSelected;
  final VoidCallback onTap;
  final List<String>? icons;
  final EdgeInsetsGeometry? padding;

  const WalletOption({
    super.key,
    required this.title,
    required this.address,
    required this.isSelected,
    required this.onTap,
    required this.walletIndex,
    this.icons,
    this.padding = const EdgeInsets.all(16.0),
  });

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = Provider.of<AppState>(context).currentTheme;
    final wallet = appState.wallets[walletIndex];
    final chain = appState.getChain(wallet.defaultChainHash);

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Container(
        decoration: BoxDecoration(
          color: theme.cardBackground.withValues(alpha: 0.7),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: isSelected ? theme.primaryPurple : Colors.transparent,
            width: 2,
          ),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(16),
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
            child: Padding(
              padding: padding!,
              child: Row(
                children: [
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: theme.primaryPurple.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: AsyncImage(
                      url: viewChain(theme: theme.value, network: chain!),
                      width: 32,
                      height: 32,
                      fit: BoxFit.contain,
                      errorWidget: Blockies(
                        seed: appState.wallet!.walletAddress,
                        color: theme.secondaryPurple,
                        bgColor: theme.primaryPurple,
                        spotColor: theme.background,
                        size: 8,
                      ),
                      loadingWidget: const Center(
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          title,
                          style: theme.bodyText1.copyWith(
                            color: theme.textPrimary,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          address,
                          style: theme.bodyText2.copyWith(
                            color: theme.textSecondary,
                          ),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ],
                    ),
                  ),
                  if (icons != null) ...[
                    const SizedBox(width: 8),
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: icons!
                          .map((iconPath) => Padding(
                                padding: const EdgeInsets.all(4),
                                child: SvgPicture.asset(
                                  iconPath,
                                  width: 24,
                                  height: 24,
                                  colorFilter: ColorFilter.mode(
                                      isSelected
                                          ? theme.primaryPurple
                                          : theme.textPrimary,
                                      BlendMode.srcIn),
                                ),
                              ))
                          .toList(),
                    ),
                  ],
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/components/wallet_selector_card.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/jazzicon.dart';
import 'package:zilpay/modals/select_address.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';

class WalletSelectionCard extends StatefulWidget {
  final String? walletName;
  final String? address;
  final Function(QRcodeScanResultInfo, String) onChange;

  const WalletSelectionCard({
    super.key,
    this.walletName,
    this.address,
    required this.onChange,
  });

  @override
  State<WalletSelectionCard> createState() => _WalletSelectionCardState();
}

class _WalletSelectionCardState extends State<WalletSelectionCard> {
  bool isPressed = false;

  @override
  void initState() {
    super.initState();

    if (widget.address == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showAccountsModal();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return MouseRegion(
      onEnter: (_) => setState(() => isPressed = true),
      onExit: (_) => setState(() => isPressed = false),
      child: GestureDetector(
        onTapDown: (_) => setState(() => isPressed = true),
        onTapUp: (_) => setState(() => isPressed = false),
        onTapCancel: () => setState(() => isPressed = false),
        onTap: _showAccountsModal,
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: isPressed
                ? theme.cardBackground.withValues(alpha: 0.6)
                : Colors.transparent,
            border: Border.all(
              color: theme.textSecondary.withValues(alpha: 0.2),
              width: 1.5,
            ),
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            children: [
              Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.primaryPurple.withValues(alpha: 0.1),
                    width: 1,
                  ),
                ),
                child: ClipOval(
                  child: widget.address != null
                      ? Jazzicon(
                          diameter: 30,
                          seed: widget.address!,
                          theme: theme,
                          shapeCount: 4,
                        )
                      : null,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.walletName ?? "",
                      style: theme.subtitle1.copyWith(
                        color: theme.textPrimary,
                        fontSize: 18, // subtitle1 is 20, adjusting
                        fontWeight: FontWeight.w600, // subtitle1 is w500
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      widget.address ?? "",
                      style: theme.caption.copyWith(
                        color: theme.textSecondary,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _showAccountsModal() {
    showAddressSelectModal(
      context: context,
      onAddressSelected: widget.onChange,
    );
  }
}

```

`lib/components/wor_count_selector.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/state/app_state.dart';

class WordCountSelector extends StatelessWidget {
  final List<int> wordCounts;
  final int selectedCount;
  final Function(int) onCountChanged;

  const WordCountSelector({
    super.key,
    required this.wordCounts,
    required this.selectedCount,
    required this.onCountChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Container(
        width: double.infinity,
        height: 48,
        decoration: BoxDecoration(
          color: theme.cardBackground,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Stack(
          children: [
            AnimatedAlign(
              alignment: Alignment(
                -1 +
                    2 *
                        (wordCounts.indexOf(selectedCount) /
                            (wordCounts.length - 1)),
                0,
              ),
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
              child: FractionallySizedBox(
                widthFactor: 1 / wordCounts.length,
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.primaryPurple,
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            Row(
              children: List.generate(
                wordCounts.length,
                (index) => Expanded(
                  child: GestureDetector(
                    onTap: () => onCountChanged(wordCounts[index]),
                    behavior: HitTestBehavior.opaque,
                    child: Center(
                      child: AnimatedDefaultTextStyle(
                        duration: const Duration(milliseconds: 300),
                        style: theme.subtitle1.copyWith(
                          fontSize: 18, // subtitle1 is 20, adjusting
                          color: selectedCount == wordCounts[index]
                              ? Colors.white
                              : theme.textSecondary,
                          fontWeight: selectedCount == wordCounts[index]
                              ? FontWeight.bold
                              : FontWeight.normal, // subtitle1 is w500 by default
                        ),
                        child: Text(wordCounts[index].toString()),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/config/argon.dart`:

```dart
import 'package:zilpay/src/rust/models/settings.dart';

class Argon2DefaultParams {
  static WalletArgonParamsInfo owaspDefault({String secret = ''}) {
    return WalletArgonParamsInfo(
      secret: secret,
      memory: 6553,
      iterations: 2,
      threads: 1,
    );
  }

  static WalletArgonParamsInfo lowMemory({String secret = ''}) {
    return WalletArgonParamsInfo(
      memory: 64 * 1024,
      iterations: 3,
      threads: 1,
      secret: secret,
    );
  }

  static WalletArgonParamsInfo secure({String secret = ''}) {
    return WalletArgonParamsInfo(
      memory: 256 * 1024,
      iterations: 4,
      threads: 4,
      secret: secret,
    );
  }
}

```

`lib/config/eip1193.dart`:

```dart
enum Web3EIP1193Method {
  ethRequestAccounts('eth_requestAccounts'),
  ethAccounts('eth_accounts'),
  ethSign('eth_sign'),
  ethSendTransaction('eth_sendTransaction'),
  ethGetBalance('eth_getBalance'),
  ethGetTransactionByHash('eth_getTransactionByHash'),
  ethGetTransactionReceipt('eth_getTransactionReceipt'),
  ethCall('eth_call'),
  ethEstimateGas('eth_estimateGas'),
  ethBlockNumber('eth_blockNumber'),
  ethGetBlockByNumber('eth_getBlockByNumber'),
  ethGetBlockByHash('eth_getBlockByHash'),
  ethSubscribe('eth_subscribe'),
  ethUnsubscribe('eth_unsubscribe'),
  netVersion('net_version'),
  ethChainId('eth_chainId'),
  ethGetCode('eth_getCode'),
  ethGetStorageAt('eth_getStorageAt'),
  ethGasPrice('eth_gasPrice'),
  ethSignTypedData('eth_signTypedData'),
  ethSignTypedDataV4('eth_signTypedData_v4'),
  ethGetTransactionCount('eth_getTransactionCount'),
  personalSign('personal_sign'),

  walletAddEthereumChain('wallet_addEthereumChain'),
  walletSwitchEthereumChain('wallet_switchEthereumChain'),
  walletWatchAsset('wallet_watchAsset'),
  walletGetPermissions('wallet_getPermissions'),
  walletRequestPermissions('wallet_requestPermissions'),
  walletScanQRCode('wallet_scanQRCode'),
  ethGetEncryptionPublicKey('eth_getEncryptionPublicKey'),
  ethDecrypt('eth_decrypt');

  final String value;
  const Web3EIP1193Method(this.value);
}

enum Web3EIP1193ErrorCode {
  userRejectedRequest(4001),
  unauthorized(4100),
  unsupportedMethod(4200),
  disconnected(4900),
  chainDisconnected(4901),
  internalError(-32603),
  chainNotAdded(4902),
  invalidInput(-32000),
  resourceUnavailable(-32002);

  final int code;
  const Web3EIP1193ErrorCode(this.code);
}

```

`lib/config/evm_messages.dart`:

```dart
class EVMMessages {
  static const String request = 'ZILPAY_REQUEST';
  static const String response = 'ZILPAY_RESPONSE';
  static const String connect = 'connect';
  static const String disconnect = 'disconnect';
  static const String chainChanged = 'chainChanged';
  static const String accountsChanged = 'accountsChanged';
  static const String requestAccounts = 'eth_requestAccounts';
  static const String getAccounts = 'eth_accounts';
  static const String signMessage = 'eth_sign';
  static const String personalSign = 'personal_sign';
  static const String signTypedData = 'eth_signTypedData';
  static const String sendTransaction = 'eth_sendTransaction';
  static const String switchChain = 'wallet_switchEthereumChain';
}

```

`lib/config/ftokens.dart`:

```dart
const zeroEVM = "0x0000000000000000000000000000000000000000";
const zeroZIL = "zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz";

const baseThreshold = 0.0000001;

```

`lib/config/search_engines.dart`:

```dart
class SearchEngine {
  final String name;
  final String description;
  final String url;

  const SearchEngine({
    required this.name,
    required this.description,
    required this.url,
  });
}

const List<SearchEngine> baseSearchEngines = [
  SearchEngine(
    name: 'DuckDuckGo',
    description: 'A search engine that doesn\'t track your actions.',
    url: 'https://duckduckgo.com/?q=',
  ),
  SearchEngine(
    name: 'Perplexity',
    description: 'An AI-powered search engine.',
    url: 'https://www.perplexity.ai/search?q=',
  ),
  SearchEngine(
    name: 'Google',
    description: 'The most popular search engine in the world.',
    url: 'https://www.google.com/search?q=',
  ),
  SearchEngine(
    name: 'Bing',
    description: 'Search engine by Microsoft.',
    url: 'https://www.bing.com/search?q=',
  ),
  SearchEngine(
    name: 'Yandex',
    description: 'A popular search engine in Russia.',
    url: 'https://ya.ru/search/?text=',
  ),
  SearchEngine(
    name: 'Baidu',
    description: 'The leading search engine in China.',
    url: 'https://www.baidu.com/s?wd=',
  ),
  SearchEngine(
    name: 'Ecosia',
    description: 'A search engine that plants trees with your search queries.',
    url: 'https://www.ecosia.org/search?q=',
  ),
];

```

`lib/config/zilliqa_legacy_messages.dart`:

```dart
/// Zilliqa Legacy Messages Configuration
/// Defines message types for communication between the wallet and dApps
class ZilliqaLegacyMessages {
  static const String _appPrefix = 'zil-pay';

  // Wallet State Messages
  static const String getWalletData = '@/$_appPrefix/injected-get-wallet-data';
  static const String addressChanged = '@/$_appPrefix/address-changed';
  static const String networkChanged = '@/$_appPrefix/network-changed';

  static const String watchBlock = '@/$_appPrefix/request-watch_block';

  // Content Proxy Messages
  static const String contentProxyMethod =
      '@/$_appPrefix/request-through-content';
  static const String contentProxyResult =
      '@/$_appPrefix/response-from-content';

  // Transaction Messages
  static const String callToSignTx = '@/$_appPrefix/request-to-sign-tx';
  static const String txResult = '@/$_appPrefix/response-tx-result';

  // Message Signing Messages
  static const String signMessage = '@/$_appPrefix/request-to-sign-message';
  static const String signMessageResponse =
      '@/$_appPrefix/response-sign-message';

  // Block Updates
  static const String newBlock = '@/$_appPrefix/new-block-created';

  // DApp Connection Messages
  static const String connectApp = '@/$_appPrefix/request-to-connect-dapp';
  static const String responseToDapp = '@/$_appPrefix/response-dapp-connect';
  static const String disconnectApp =
      '@/$_appPrefix/request-to-disconnect-dapp';

  static const List<String> allTypes = [
    getWalletData,
    addressChanged,
    networkChanged,
    contentProxyMethod,
    contentProxyResult,
    callToSignTx,
    txResult,
    signMessage,
    signMessageResponse,
    newBlock,
    connectApp,
    responseToDapp,
    disconnectApp,
  ];
}

```

`lib/l10n/app_localizations.dart`:

```dart
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart' as intl;

import 'app_localizations_en.dart';
import 'app_localizations_ja.dart';
import 'app_localizations_ru.dart';
import 'app_localizations_zh.dart';

// ignore_for_file: type=lint

/// Callers can lookup localized strings with an instance of AppLocalizations
/// returned by `AppLocalizations.of(context)`.
///
/// Applications need to include `AppLocalizations.delegate()` in their app's
/// `localizationDelegates` list, and the locales they support in the app's
/// `supportedLocales` list. For example:
///
/// ```dart
/// import 'l10n/app_localizations.dart';
///
/// return MaterialApp(
///   localizationsDelegates: AppLocalizations.localizationsDelegates,
///   supportedLocales: AppLocalizations.supportedLocales,
///   home: MyApplicationHome(),
/// );
/// ```
///
/// ## Update pubspec.yaml
///
/// Please make sure to update your pubspec.yaml to include the following
/// packages:
///
/// ```yaml
/// dependencies:
///   # Internationalization support.
///   flutter_localizations:
///     sdk: flutter
///   intl: any # Use the pinned version from flutter_localizations
///
///   # Rest of dependencies
/// ```
///
/// ## iOS Applications
///
/// iOS applications define key application metadata, including supported
/// locales, in an Info.plist file that is built into the application bundle.
/// To configure the locales supported by your app, you’ll need to edit this
/// file.
///
/// First, open your project’s ios/Runner.xcworkspace Xcode workspace file.
/// Then, in the Project Navigator, open the Info.plist file under the Runner
/// project’s Runner folder.
///
/// Next, select the Information Property List item, select Add Item from the
/// Editor menu, then select Localizations from the pop-up menu.
///
/// Select and expand the newly-created Localizations item then, for each
/// locale your application supports, add a new item and select the locale
/// you wish to add from the pop-up menu in the Value field. This list should
/// be consistent with the languages listed in the AppLocalizations.supportedLocales
/// property.
abstract class AppLocalizations {
  AppLocalizations(String locale) : localeName = intl.Intl.canonicalizedLocale(locale.toString());

  final String localeName;

  static AppLocalizations? of(BuildContext context) {
    return Localizations.of<AppLocalizations>(context, AppLocalizations);
  }

  static const LocalizationsDelegate<AppLocalizations> delegate = _AppLocalizationsDelegate();

  /// A list of this localizations delegate along with the default localizations
  /// delegates.
  ///
  /// Returns a list of localizations delegates containing this delegate along with
  /// GlobalMaterialLocalizations.delegate, GlobalCupertinoLocalizations.delegate,
  /// and GlobalWidgetsLocalizations.delegate.
  ///
  /// Additional delegates can be added by appending to this list in
  /// MaterialApp. This list does not have to be used at all if a custom list
  /// of delegates is preferred or required.
  static const List<LocalizationsDelegate<dynamic>> localizationsDelegates = <LocalizationsDelegate<dynamic>>[
    delegate,
    GlobalMaterialLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ];

  /// A list of this localizations delegate's supported locales.
  static const List<Locale> supportedLocales = <Locale>[
    Locale('en'),
    Locale('ja'),
    Locale('ru'),
    Locale('zh')
  ];

  /// The title of the application
  ///
  /// In en, this message translates to:
  /// **'ZilPay Wallet'**
  String get appTitle;

  /// Button text to restore from ZilPay 1.0
  ///
  /// In en, this message translates to:
  /// **'Restore ZilPay 1.0!'**
  String get initialPagerestoreZilPay;

  /// Button text to begin using the app
  ///
  /// In en, this message translates to:
  /// **'Get Started'**
  String get initialPagegetStarted;

  /// Title for the RestoreRKStorage page showing wallet migration
  ///
  /// In en, this message translates to:
  /// **'Migrate ZilPay 1.0 to 2.0'**
  String get restoreRKStorageTitle;

  /// Prompt text instructing user to enter password for account migration on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Accounts to migrate to ZilPay 2.0. Enter password.'**
  String get restoreRKStorageAccountsPrompt;

  /// Hint text for password input field on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get restoreRKStoragePasswordHint;

  /// Error message when password field is empty on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Enter password'**
  String get restoreRKStorageEnterPassword;

  /// Prefix for error messages on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Error:'**
  String get restoreRKStorageErrorPrefix;

  /// Text for restore button on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Restore'**
  String get restoreRKStorageRestoreButton;

  /// Text for skip button on RestoreRKStorage page
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get restoreRKStorageSkipButton;

  /// Label for balance display in AccountItem widget
  ///
  /// In en, this message translates to:
  /// **'Balance:'**
  String get accountItemBalanceLabel;

  /// Title for the SendTokenPage (currently empty as per original code)
  ///
  /// In en, this message translates to:
  /// **''**
  String get sendTokenPageTitle;

  /// Text for the submit button on SendTokenPage
  ///
  /// In en, this message translates to:
  /// **'Submit'**
  String get sendTokenPageSubmitButton;

  /// Title for the AboutPage
  ///
  /// In en, this message translates to:
  /// **'About'**
  String get aboutPageTitle;

  /// Application name displayed in logo section on AboutPage
  ///
  /// In en, this message translates to:
  /// **'ZilPay'**
  String get aboutPageAppName;

  /// Description text below app name on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Your Secure Blockchain Wallet'**
  String get aboutPageAppDescription;

  /// Title for application info section on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Application Info'**
  String get aboutPageAppInfoTitle;

  /// Label for version info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Version'**
  String get aboutPageVersionLabel;

  /// Label for build date on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Build Date'**
  String get aboutPageBuildDateLabel;

  /// Value for build date on AboutPage
  ///
  /// In en, this message translates to:
  /// **'March 10, 2025'**
  String get aboutPageBuildDateValue;

  /// Label for platform info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Platform'**
  String get aboutPagePlatformLabel;

  /// Title for developer section on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Developer'**
  String get aboutPageDeveloperTitle;

  /// Label for author info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Author'**
  String get aboutPageAuthorLabel;

  /// Value for author info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Rinat (hicaru)'**
  String get aboutPageAuthorValue;

  /// Label for website info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Website'**
  String get aboutPageWebsiteLabel;

  /// Value for website info on AboutPage
  ///
  /// In en, this message translates to:
  /// **'https://zilpay.io'**
  String get aboutPageWebsiteValue;

  /// Title for legal section on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Legal'**
  String get aboutPageLegalTitle;

  /// Text for privacy policy link on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Privacy Policy'**
  String get aboutPagePrivacyPolicy;

  /// Text for terms of service link on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Terms of Service'**
  String get aboutPageTermsOfService;

  /// Text for licenses link on AboutPage
  ///
  /// In en, this message translates to:
  /// **'Licenses'**
  String get aboutPageLicenses;

  /// Legal text for license page from AboutPage
  ///
  /// In en, this message translates to:
  /// **'© 2025 ZilPay. All rights reserved.'**
  String get aboutPageLegalese;

  /// Title for the LanguagePage
  ///
  /// In en, this message translates to:
  /// **'Language'**
  String get languagePageTitle;

  /// System language option name on LanguagePage
  ///
  /// In en, this message translates to:
  /// **'System'**
  String get languagePageSystem;

  /// Title for the SecretKeyGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'Secret Key'**
  String get secretKeyGeneratorPageTitle;

  /// Label for private key display on SecretKeyGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'Private Key'**
  String get secretKeyGeneratorPagePrivateKey;

  /// Label for public key display on SecretKeyGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'Public Key'**
  String get secretKeyGeneratorPagePublicKey;

  /// Text for backup confirmation checkbox on SecretKeyGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'I have backup secret key'**
  String get secretKeyGeneratorPageBackupCheckbox;

  /// Text for next button on SecretKeyGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get secretKeyGeneratorPageNextButton;

  /// Title for the WalletPage (empty as per original implementation)
  ///
  /// In en, this message translates to:
  /// **''**
  String get walletPageTitle;

  /// Hint text for wallet name input on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Wallet name'**
  String get walletPageWalletNameHint;

  /// Title for preferences section on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Wallet preferences'**
  String get walletPagePreferencesTitle;

  /// Label for manage connections preference item on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Manage connections'**
  String get walletPageManageConnections;

  /// Label for backup preference item on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Backup'**
  String get walletPageBackup;

  /// Text for delete wallet button on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Delete Wallet'**
  String get walletPageDeleteWallet;

  /// Reason text for biometric authentication prompt on WalletPage
  ///
  /// In en, this message translates to:
  /// **'Enable biometric authentication'**
  String get walletPageBiometricReason;

  /// Title for the NetworkPage (empty as per original implementation)
  ///
  /// In en, this message translates to:
  /// **''**
  String get networkPageTitle;

  /// Label for testnet toggle switch on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Show Testnet'**
  String get networkPageShowTestnet;

  /// Hint text for search input on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get networkPageSearchHint;

  /// Section title for added networks on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Added Networks'**
  String get networkPageAddedNetworks;

  /// Section title for available networks on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Available Networks'**
  String get networkPageAvailableNetworks;

  /// Error message prefix when loading networks fails on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Failed to load network chains: '**
  String get networkPageLoadError;

  /// Error message prefix when adding a network fails on NetworkPage
  ///
  /// In en, this message translates to:
  /// **'Failed to add network: '**
  String get networkPageAddError;

  /// Title for the ReceivePage
  ///
  /// In en, this message translates to:
  /// **'Receive'**
  String get receivePageTitle;

  /// Warning message displayed on ReceivePage with chain name and token symbol placeholders
  ///
  /// In en, this message translates to:
  /// **'Only send {chainName}({tokenSymbol}) assets to this address. Other assets will be lost forever.'**
  String receivePageWarning(Object chainName, Object tokenSymbol);

  /// Hint text for account name input on ReceivePage
  ///
  /// In en, this message translates to:
  /// **'Account name'**
  String get receivePageAccountNameHint;

  /// Title for the amount input dialog on ReceivePage
  ///
  /// In en, this message translates to:
  /// **'Enter Amount'**
  String get receivePageAmountDialogTitle;

  /// Hint text for the amount input field in dialog on ReceivePage
  ///
  /// In en, this message translates to:
  /// **'0.0'**
  String get receivePageAmountDialogHint;

  /// Cancel button text in amount dialog on ReceivePage
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get receivePageAmountDialogCancel;

  /// Confirm button text in amount dialog on ReceivePage
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get receivePageAmountDialogConfirm;

  /// Title for the SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Security'**
  String get securityPageTitle;

  /// Section title for network privacy settings on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Network Privacy'**
  String get securityPageNetworkPrivacy;

  /// Label for ENS domains toggle on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Show ENS domains in address bar'**
  String get securityPageEnsDomains;

  /// Description for ENS domains setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Keep in mind that using this feature exposes your IP address to IPFS third-party services.'**
  String get securityPageEnsDescription;

  /// Label for IPFS gateway setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'IPFS gateway'**
  String get securityPageIpfsGateway;

  /// Description for IPFS gateway setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'ZIlPay uses third-party services to show images of your NFTs stored on IPFS, display information related to ENS(ZNS) addresses entered in your browser\'s address bar, and fetch icons for different tokens. Your IP address may be exposed to these services when you\'re using them.'**
  String get securityPageIpfsDescription;

  /// Label for tokens fetcher setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Tokens fetcher'**
  String get securityPageTokensFetcherTitle;

  /// Label for tokens fetcher setting on SecurityPage. If enabled, tokens will be automatically fetched from the server and can be added.
  ///
  /// In en, this message translates to:
  /// **'tokens fetcher setting on SecurityPage. If enabled, tokens will be automatically fetched from the server and can be added.'**
  String get securityPageTokensFetcherDescription;

  /// Label for node ranking setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Node ranking'**
  String get securityPageNodeRanking;

  /// Description for node ranking setting on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Make requests to ZilPay server for fetch best node'**
  String get securityPageNodeDescription;

  /// Section title for encryption level settings on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Encryption Level'**
  String get securityPageEncryptionLevel;

  /// Label for protection progress bar in encryption card on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Protection'**
  String get securityPageProtection;

  /// Label for CPU load progress bar in encryption card on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'CPU Load'**
  String get securityPageCpuLoad;

  /// Name of AES256 encryption algorithm on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'AES256'**
  String get securityPageAes256;

  /// Name of KUZNECHIK-GOST encryption algorithm on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'KUZNECHIK-GOST'**
  String get securityPageKuznechikGost;

  /// Name of NTRUPrime encryption algorithm on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'NTRUPrime'**
  String get securityPageNtruPrime;

  /// Name of Cyber encryption algorithm on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Cyber'**
  String get securityPageCyber;

  /// Fallback name for unknown encryption algorithm on SecurityPage
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get securityPageUnknown;

  /// Label indicating Do Not Track is enabled in the WebViewPage app bar
  ///
  /// In en, this message translates to:
  /// **'DNT'**
  String get webViewPageDntLabel;

  /// Label indicating Incognito mode is enabled in the WebViewPage app bar
  ///
  /// In en, this message translates to:
  /// **'Incognito'**
  String get webViewPageIncognitoLabel;

  /// Error message title when web page fails to load on WebViewPage
  ///
  /// In en, this message translates to:
  /// **'Failed to load'**
  String get webViewPageLoadError;

  /// Button text to retry loading the web page on WebViewPage
  ///
  /// In en, this message translates to:
  /// **'Try Again'**
  String get webViewPageTryAgain;

  /// Title for the SecretPhraseGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'New Wallet'**
  String get secretPhraseGeneratorPageTitle;

  /// Text for backup confirmation checkbox on SecretPhraseGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'I have backup words'**
  String get secretPhraseGeneratorPageBackupCheckbox;

  /// Text for next button on SecretPhraseGeneratorPage
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get secretPhraseGeneratorPageNextButton;

  /// Label displayed when using a testnet on HomePage
  ///
  /// In en, this message translates to:
  /// **'Testnet'**
  String get homePageTestnetLabel;

  /// Label displayed when shows error on home page
  ///
  /// In en, this message translates to:
  /// **'No signal'**
  String get homePageErrorTitle;

  /// A Receive Tile Button title
  ///
  /// In en, this message translates to:
  /// **'Send'**
  String get homePageSendButton;

  /// No description provided for @homePageReceiveButton.
  ///
  /// In en, this message translates to:
  /// **'Receive'**
  String get homePageReceiveButton;

  /// Title for the RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'Reveal Secret Key'**
  String get revealSecretKeyTitle;

  /// Hint text for password input on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get revealSecretKeyPasswordHint;

  /// Error message prefix for invalid password on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'invalid password, error:'**
  String get revealSecretKeyInvalidPassword;

  /// Text for submit button on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'Submit'**
  String get revealSecretKeySubmitButton;

  /// Text for done button after revealing secret key on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get revealSecretKeyDoneButton;

  /// Title for scam alert section on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'SCAM ALERT'**
  String get revealSecretKeyScamAlertTitle;

  /// Message content for scam alert section on RevealSecretKey page
  ///
  /// In en, this message translates to:
  /// **'Never share your secret key with anyone. Never input it on any website.'**
  String get revealSecretKeyScamAlertMessage;

  /// Label for Testnet switch on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Testnet'**
  String get setupNetworkSettingsPageTestnetSwitch;

  /// Hint text for search input on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get setupNetworkSettingsPageSearchHint;

  /// Message when no networks are available on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'No networks available'**
  String get setupNetworkSettingsPageNoNetworks;

  /// Message when no networks match search query on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'No networks found for \"{searchQuery}\"'**
  String setupNetworkSettingsPageNoResults(Object searchQuery);

  /// Text for Next button on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get setupNetworkSettingsPageNextButton;

  /// Label indicating Testnet in network item on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Testnet'**
  String get setupNetworkSettingsPageTestnetLabel;

  /// Label indicating Mainnet in network item on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Mainnet'**
  String get setupNetworkSettingsPageMainnetLabel;

  /// Label prefix for Chain ID in network item on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Chain ID:'**
  String get setupNetworkSettingsPageChainIdLabel;

  /// Label prefix for Token in network item on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Token:'**
  String get setupNetworkSettingsPageTokenLabel;

  /// Label prefix for Explorer in network item on SetupNetworkSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Explorer:'**
  String get setupNetworkSettingsPageExplorerLabel;

  /// Title for the Appearance Settings page
  ///
  /// In en, this message translates to:
  /// **'Appearance Settings'**
  String get appearanceSettingsPageTitle;

  /// Title for the Compact Numbers switch setting
  ///
  /// In en, this message translates to:
  /// **'Compact Numbers'**
  String get appearanceSettingsPageCompactNumbersTitle;

  /// Description for the Compact Numbers switch setting
  ///
  /// In en, this message translates to:
  /// **'Enable to display abbreviated numbers (e.g., 20K instead of 20,000).'**
  String get appearanceSettingsPageCompactNumbersDescription;

  /// Title for the Device Settings theme option
  ///
  /// In en, this message translates to:
  /// **'Device settings'**
  String get appearanceSettingsPageDeviceSettingsTitle;

  /// Subtitle for the Device Settings theme option
  ///
  /// In en, this message translates to:
  /// **'System default'**
  String get appearanceSettingsPageDeviceSettingsSubtitle;

  /// Description for the Device Settings theme option
  ///
  /// In en, this message translates to:
  /// **'Default to your device\'s appearance. Your wallet theme will automatically adjust based on your system settings.'**
  String get appearanceSettingsPageDeviceSettingsDescription;

  /// Title for the Dark Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Dark Mode'**
  String get appearanceSettingsPageDarkModeTitle;

  /// Subtitle for the Dark Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Always dark'**
  String get appearanceSettingsPageDarkModeSubtitle;

  /// Description for the Dark Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Keep the dark theme enabled at all times, regardless of your device settings.'**
  String get appearanceSettingsPageDarkModeDescription;

  /// Title for the Light Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Light mode'**
  String get appearanceSettingsPageLightModeTitle;

  /// Subtitle for the Light Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Always light'**
  String get appearanceSettingsPageLightModeSubtitle;

  /// Description for the Light Mode theme option
  ///
  /// In en, this message translates to:
  /// **'Keep the light theme enabled at all times, regardless of your device settings.'**
  String get appearanceSettingsPageLightModeDescription;

  /// Reason text for biometric authentication prompt on the Login page
  ///
  /// In en, this message translates to:
  /// **'Please authenticate'**
  String get loginPageBiometricReason;

  /// Default title for a wallet item when no custom name is provided on the Login page
  ///
  /// In en, this message translates to:
  /// **'Wallet {index}'**
  String loginPageWalletTitle(Object index);

  /// Hint text for the password input field on the Login page
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get loginPagePasswordHint;

  /// Text for the unlock button on the Login page
  ///
  /// In en, this message translates to:
  /// **'Unlock'**
  String get loginPageUnlockButton;

  /// Welcome message displayed on the Login page
  ///
  /// In en, this message translates to:
  /// **'Welcome back'**
  String get loginPageWelcomeBack;

  /// Title for the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'Restore Secret Key'**
  String get secretKeyRestorePageTitle;

  /// Hint text for the private key input field on the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'Private Key'**
  String get secretKeyRestorePageHint;

  /// Error message displayed when the private key format is invalid on the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'Invalid private key format'**
  String get secretKeyRestorePageInvalidFormat;

  /// Title for the private key display section on the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'Private Key'**
  String get secretKeyRestorePageKeyTitle;

  /// Label for the backup confirmation checkbox on the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'I have backed up my secret key'**
  String get secretKeyRestorePageBackupLabel;

  /// Text for the Next button on the Secret Key Restore page
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get secretKeyRestorePageNextButton;

  /// Title for the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Add New Account'**
  String get addAccountPageTitle;

  /// Subtitle for the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Create BIP39 Account'**
  String get addAccountPageSubtitle;

  /// Default account name format for the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Account {index}'**
  String addAccountPageDefaultName(Object index);

  /// Hint text for the account name input field on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Account name'**
  String get addAccountPageNameHint;

  /// Label for the BIP39 index counter on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'BIP39 Index'**
  String get addAccountPageBip39Index;

  /// Label for the biometrics option on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Use Biometrics'**
  String get addAccountPageUseBiometrics;

  /// Hint text for the password input field on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get addAccountPagePasswordHint;

  /// Label for the Zilliqa Legacy switch on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Zilliqa Legacy'**
  String get addAccountPageZilliqaLegacy;

  /// Reason text for biometric authentication prompt on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Authenticate to create a new account'**
  String get addAccountPageBiometricReason;

  /// Error message for biometric authentication failure on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Biometric authentication failed: {error}'**
  String addAccountPageBiometricError(Object error);

  /// Error message when an account with the given index already exists on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Account with index {index} already exists'**
  String addAccountPageIndexExists(Object index);

  /// Error message when biometric authentication fails on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Biometric authentication failed'**
  String get addAccountPageBiometricFailed;

  /// Error message when account creation fails on the Add Account page
  ///
  /// In en, this message translates to:
  /// **'Failed to create account: {error}'**
  String addAccountPageCreateFailed(Object error);

  /// Title for the Address Book page
  ///
  /// In en, this message translates to:
  /// **'Address Book'**
  String get addressBookPageTitle;

  /// Message displayed when the address book is empty on the Address Book page
  ///
  /// In en, this message translates to:
  /// **'Your contacts and their wallet address will\nappear here.'**
  String get addressBookPageEmptyMessage;

  /// Title for the delete contact confirmation dialog
  ///
  /// In en, this message translates to:
  /// **'Delete Contact'**
  String get addressBookPageDeleteConfirmationTitle;

  /// Confirmation message when attempting to delete a contact.
  ///
  /// In en, this message translates to:
  /// **'Are you sure you want to delete {contactName} from your address book?'**
  String addressBookPageDeleteConfirmationMessage(String contactName);

  /// Tooltip for the delete icon button for a contact.
  ///
  /// In en, this message translates to:
  /// **'Delete {contactName}'**
  String addressBookPageDeleteTooltip(String contactName);

  /// Label for the cancel button, typically in dialogs
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get cancel;

  /// Label for the delete button, typically in dialogs or for destructive actions
  ///
  /// In en, this message translates to:
  /// **'Delete'**
  String get delete;

  /// Label for the Connected tab on the Browser page
  ///
  /// In en, this message translates to:
  /// **'Connected'**
  String get browserPageConnectedTab;

  /// Label for the Explore tab on the Browser page
  ///
  /// In en, this message translates to:
  /// **'Explore'**
  String get browserPageExploreTab;

  /// Message displayed when there are no apps to explore on the Browser page
  ///
  /// In en, this message translates to:
  /// **'No apps to explore yet'**
  String get browserPageNoExploreApps;

  /// Hint text for the search bar on the Browser page
  ///
  /// In en, this message translates to:
  /// **'Search with {engine} or enter address'**
  String browserPageSearchHint(Object engine);

  /// Message displayed when there are no connected apps on the Browser page
  ///
  /// In en, this message translates to:
  /// **'No connected apps'**
  String get browserPageNoConnectedApps;

  /// Title displayed at the top of the HistoryPage component
  ///
  /// In en, this message translates to:
  /// **'Transaction History'**
  String get historyPageTitle;

  /// Message shown in the HistoryPage when there are no transactions to display
  ///
  /// In en, this message translates to:
  /// **'No transactions yet'**
  String get historyPageNoTransactions;

  /// Hint text displayed in the search input field on the HistoryPage
  ///
  /// In en, this message translates to:
  /// **'Search transactions...'**
  String get historyPageSearchHint;

  /// Title displayed in the app bar of the NotificationsSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Notifications'**
  String get notificationsSettingsPageTitle;

  /// Title for the push notifications switch setting in the NotificationsSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Push notifications'**
  String get notificationsSettingsPagePushTitle;

  /// Description text for the push notifications switch setting in the NotificationsSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Get notifications when tx sent and confirm, Notifications from connected apps.'**
  String get notificationsSettingsPagePushDescription;

  /// Title for the wallets section in the NotificationsSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Wallets'**
  String get notificationsSettingsPageWalletsTitle;

  /// Description text for the wallets section in the NotificationsSettingsPage
  ///
  /// In en, this message translates to:
  /// **'Notifications from wallets'**
  String get notificationsSettingsPageWalletsDescription;

  /// Prefix used for unnamed wallets in the NotificationsSettingsPage, followed by wallet number
  ///
  /// In en, this message translates to:
  /// **'Wallet'**
  String get notificationsSettingsPageWalletPrefix;

  /// Title displayed in the app bar of the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'Reveal Secret Phrase'**
  String get revealSecretPhraseTitle;

  /// Hint text displayed in the password input field of the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get revealSecretPhrasePasswordHint;

  /// Error message prefix shown when password validation fails in the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'invalid password, error:'**
  String get revealSecretPhraseInvalidPassword;

  /// the label for wait until time done, and secret phrase reveal
  ///
  /// In en, this message translates to:
  /// **'Your seed phrase will be revealed after:'**
  String get revealSecretPhraseRevealAfter;

  /// Text on the submit button in the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'Submit'**
  String get revealSecretPhraseSubmitButton;

  /// Text on the done button displayed after revealing the secret phrase in the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get revealSecretPhraseDoneButton;

  /// Title of the scam alert section in the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'SCAM ALERT'**
  String get revealSecretPhraseScamAlertTitle;

  /// Description text in the scam alert section of the RevealSecretPhrase component
  ///
  /// In en, this message translates to:
  /// **'Never share your secret phrase with anyone. Never input it on any website.'**
  String get revealSecretPhraseScamAlertDescription;

  /// Title displayed in the app bar of the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Encryption Setup'**
  String get cipherSettingsPageTitle;

  /// Text on the advanced settings button in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Advanced'**
  String get cipherSettingsPageAdvancedButton;

  /// Title for the standard encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Standard Encryption'**
  String get cipherSettingsPageStandardTitle;

  /// Subtitle for the standard encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'AES-256 + KUZNECHIK-GOST'**
  String get cipherSettingsPageStandardSubtitle;

  /// Description for the standard encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Basic encryption with AES-256 and GOST standard KUZNECHIK.'**
  String get cipherSettingsPageStandardDescription;

  /// Title for the hybrid encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Hybrid Encryption'**
  String get cipherSettingsPageHybridTitle;

  /// Subtitle for the hybrid encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'CYBER + KUZNECHIK-GOST'**
  String get cipherSettingsPageHybridSubtitle;

  /// Description for the hybrid encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Hybrid encryption combining CYBER and KUZNECHIK-GOST algorithms.'**
  String get cipherSettingsPageHybridDescription;

  /// Title for the quantum-resistant encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Quantum-Resistant'**
  String get cipherSettingsPageQuantumTitle;

  /// Subtitle for the quantum-resistant encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'CYBER + KUZNECHIK + NTRUP1277'**
  String get cipherSettingsPageQuantumSubtitle;

  /// Description for the quantum-resistant encryption option in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Advanced quantum-resistant encryption with NTRUP1277.'**
  String get cipherSettingsPageQuantumDescription;

  /// Warning text displayed when quantum-resistant encryption is selected in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Quantum-resistant encryption may impact performance'**
  String get cipherSettingsPageQuantumWarning;

  /// Text on the confirm button in the CipherSettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get cipherSettingsPageConfirmButton;

  /// Title displayed in the app bar of the SecretPhraseVerifyPage component
  ///
  /// In en, this message translates to:
  /// **'Verify Secret'**
  String get secretPhraseVerifyPageTitle;

  /// Text on the skip button in the SecretPhraseVerifyPage component
  ///
  /// In en, this message translates to:
  /// **'Skip'**
  String get secretPhraseVerifyPageSkipButton;

  /// Subtitle text displayed below the app bar in the SecretPhraseVerifyPage component
  ///
  /// In en, this message translates to:
  /// **'Verify Bip39 Secret'**
  String get secretPhraseVerifyPageSubtitle;

  /// Text on the next button in the SecretPhraseVerifyPage component
  ///
  /// In en, this message translates to:
  /// **'Next'**
  String get secretPhraseVerifyPageNextButton;

  /// Title displayed in the app bar of the RestoreSecretPhrasePage component
  ///
  /// In en, this message translates to:
  /// **'Restore Wallet'**
  String get restoreSecretPhrasePageTitle;

  /// Text on the restore button in the RestoreSecretPhrasePage component
  ///
  /// In en, this message translates to:
  /// **'Restore'**
  String get restoreSecretPhrasePageRestoreButton;

  /// Text displayed when BIP39 checksum validation fails
  ///
  /// In en, this message translates to:
  /// **'Checksum validation failed'**
  String get checksumValidationFailed;

  /// Text for the checkbox to proceed despite invalid checksum
  ///
  /// In en, this message translates to:
  /// **'Continue despite checksum error?'**
  String get proceedDespiteInvalidChecksum;

  /// Title displayed in the app bar of the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Settings'**
  String get settingsPageTitle;

  /// Label for the Zilliqa Legacy switch in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Zilliqa Legacy'**
  String get settingsPageZilliqaLegacy;

  /// Label for the Currency settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Currency'**
  String get settingsPageCurrency;

  /// Label for the Appearance settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Appearance'**
  String get settingsPageAppearance;

  /// Label for the Notifications settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Notifications'**
  String get settingsPageNotifications;

  /// Label for the Address Book settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Address book'**
  String get settingsPageAddressBook;

  /// Label for the Security & Privacy settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Security & privacy'**
  String get settingsPageSecurityPrivacy;

  /// Label for the Networks settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Networks'**
  String get settingsPageNetworks;

  /// Label for the Language settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Language'**
  String get settingsPageLanguage;

  /// Label for the Browser settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Browser'**
  String get settingsPageBrowser;

  /// Label for the Telegram settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Telegram'**
  String get settingsPageTelegram;

  /// Label for the Twitter settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'Twitter'**
  String get settingsPageTwitter;

  /// Label for the GitHub settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'GitHub'**
  String get settingsPageGitHub;

  /// Label for the About settings item in the SettingsPage component
  ///
  /// In en, this message translates to:
  /// **'About'**
  String get settingsPageAbout;

  /// Title displayed in the app bar of the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Password Setup'**
  String get passwordSetupPageTitle;

  /// Subtitle text displayed at the top of the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Create Password'**
  String get passwordSetupPageSubtitle;

  /// Hint text for the wallet name input field in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Wallet Name'**
  String get passwordSetupPageWalletNameHint;

  /// Hint text for the password input field in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get passwordSetupPagePasswordHint;

  /// Hint text for the confirm password input field in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Confirm Password'**
  String get passwordSetupPageConfirmPasswordHint;

  /// Error message displayed when wallet name is empty in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Wallet name cannot be empty'**
  String get passwordSetupPageEmptyWalletNameError;

  /// Error message displayed when wallet name exceeds length limit in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Wallet name is too long'**
  String get passwordSetupPageLongWalletNameError;

  /// Error message displayed when password is too short in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Password must be at least 8 characters'**
  String get passwordSetupPageShortPasswordError;

  /// Error message displayed when passwords do not match in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Passwords do not match'**
  String get passwordSetupPageMismatchPasswordError;

  /// Label for the Zilliqa Legacy switch in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Legacy'**
  String get passwordSetupPageLegacyLabel;

  /// Text on the create password button in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Create Password'**
  String get passwordSetupPageCreateButton;

  /// Reason text displayed during biometric authentication in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Please authenticate to enable quick access'**
  String get passwordSetupPageAuthReason;

  /// Type label used in wallet name generation for seed-based wallets in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Seed'**
  String get passwordSetupPageSeedType;

  /// Type label used in wallet name generation for key-based wallets in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Key'**
  String get passwordSetupPageKeyType;

  /// Default network name used in wallet name generation when no specific network is provided in the PasswordSetupPage component
  ///
  /// In en, this message translates to:
  /// **'Universal'**
  String get passwordSetupPageUniversalNetwork;

  /// Title for the Browser Settings page
  ///
  /// In en, this message translates to:
  /// **'Browser Settings'**
  String get browserSettingsTitle;

  /// Section title for browser options
  ///
  /// In en, this message translates to:
  /// **'Browser Options'**
  String get browserSettingsBrowserOptions;

  /// Title for search engine setting
  ///
  /// In en, this message translates to:
  /// **'Search Engine'**
  String get browserSettingsSearchEngine;

  /// Description for search engine setting
  ///
  /// In en, this message translates to:
  /// **'Configure your default search engine'**
  String get browserSettingsSearchEngineDescription;

  /// Title for search engine selection modal
  ///
  /// In en, this message translates to:
  /// **'Search Engine'**
  String get browserSettingsSearchEngineTitle;

  /// Title for content blocking setting
  ///
  /// In en, this message translates to:
  /// **'Content Blocking'**
  String get browserSettingsContentBlocking;

  /// Description for content blocking setting
  ///
  /// In en, this message translates to:
  /// **'Configure content blocking settings'**
  String get browserSettingsContentBlockingDescription;

  /// Title for content blocking selection modal
  ///
  /// In en, this message translates to:
  /// **'Content Blocking'**
  String get browserSettingsContentBlockingTitle;

  /// Section title for privacy and security settings
  ///
  /// In en, this message translates to:
  /// **'Privacy & Security'**
  String get browserSettingsPrivacySecurity;

  /// Title for cookies setting
  ///
  /// In en, this message translates to:
  /// **'Cookies'**
  String get browserSettingsCookies;

  /// Description for cookies setting
  ///
  /// In en, this message translates to:
  /// **'Allow websites to save and read cookies'**
  String get browserSettingsCookiesDescription;

  /// Title for do not track setting
  ///
  /// In en, this message translates to:
  /// **'Do Not Track'**
  String get browserSettingsDoNotTrack;

  /// Description for do not track setting
  ///
  /// In en, this message translates to:
  /// **'Request websites not to track your browsing'**
  String get browserSettingsDoNotTrackDescription;

  /// Title for incognito mode setting
  ///
  /// In en, this message translates to:
  /// **'Incognito Mode'**
  String get browserSettingsIncognitoMode;

  /// Description for incognito mode setting
  ///
  /// In en, this message translates to:
  /// **'Browse without saving history or cookies'**
  String get browserSettingsIncognitoModeDescription;

  /// Section title for performance settings
  ///
  /// In en, this message translates to:
  /// **'Performance'**
  String get browserSettingsPerformance;

  /// Title for cache setting
  ///
  /// In en, this message translates to:
  /// **'Cache'**
  String get browserSettingsCache;

  /// Section title for clear data options in browser settings
  ///
  /// In en, this message translates to:
  /// **'Clear Data'**
  String get browserSettingsClearData;

  /// Button text for clearing browser data
  ///
  /// In en, this message translates to:
  /// **'Clear'**
  String get browserSettingsClear;

  /// Title for the clear cookies option
  ///
  /// In en, this message translates to:
  /// **'Clear Cookies'**
  String get browserSettingsClearCookies;

  /// Description explaining what clearing cookies does
  ///
  /// In en, this message translates to:
  /// **'Delete all cookies stored by websites'**
  String get browserSettingsClearCookiesDescription;

  /// Title for the clear cache option
  ///
  /// In en, this message translates to:
  /// **'Clear Cache'**
  String get browserSettingsClearCache;

  /// Description explaining what clearing cache does
  ///
  /// In en, this message translates to:
  /// **'Delete temporary files and images stored during browsing'**
  String get browserSettingsClearCacheDescription;

  /// Title for the clear local storage option
  ///
  /// In en, this message translates to:
  /// **'Clear Local Storage'**
  String get browserSettingsClearLocalStorage;

  /// Description explaining what clearing local storage does
  ///
  /// In en, this message translates to:
  /// **'Delete website data stored locally on your device'**
  String get browserSettingsClearLocalStorageDescription;

  /// Description for cache setting
  ///
  /// In en, this message translates to:
  /// **'Store website data for faster loading'**
  String get browserSettingsCacheDescription;

  /// Title for the Generate Wallet Options page
  ///
  /// In en, this message translates to:
  /// **'Generate Wallet'**
  String get genWalletOptionsTitle;

  /// Title for BIP39 wallet generation option
  ///
  /// In en, this message translates to:
  /// **'BIP39'**
  String get genWalletOptionsBIP39Title;

  /// Subtitle for BIP39 wallet generation option
  ///
  /// In en, this message translates to:
  /// **'Generate Mnemonic phrase'**
  String get genWalletOptionsBIP39Subtitle;

  /// Title for SLIP-0039 wallet generation option
  ///
  /// In en, this message translates to:
  /// **'SLIP-0039'**
  String get genWalletOptionsSLIP0039Title;

  /// Subtitle for SLIP-0039 wallet generation option
  ///
  /// In en, this message translates to:
  /// **'Generate Mnemonic phrase with share'**
  String get genWalletOptionsSLIP0039Subtitle;

  /// Title for Private Key wallet generation option
  ///
  /// In en, this message translates to:
  /// **'Private Key'**
  String get genWalletOptionsPrivateKeyTitle;

  /// Subtitle for Private Key wallet generation option
  ///
  /// In en, this message translates to:
  /// **'Generate just one private key'**
  String get genWalletOptionsPrivateKeySubtitle;

  /// Title for the Add Wallet Options page
  ///
  /// In en, this message translates to:
  /// **'Add Wallet'**
  String get addWalletOptionsTitle;

  /// Title for new wallet option
  ///
  /// In en, this message translates to:
  /// **'New Wallet'**
  String get addWalletOptionsNewWalletTitle;

  /// Subtitle for new wallet option
  ///
  /// In en, this message translates to:
  /// **'Create new wallet'**
  String get addWalletOptionsNewWalletSubtitle;

  /// Title for existing wallet option
  ///
  /// In en, this message translates to:
  /// **'Existing Wallet'**
  String get addWalletOptionsExistingWalletTitle;

  /// Subtitle for existing wallet option
  ///
  /// In en, this message translates to:
  /// **'Import wallet with a 24 secret recovery words'**
  String get addWalletOptionsExistingWalletSubtitle;

  /// Title for pair with Ledger option
  ///
  /// In en, this message translates to:
  /// **'Pair with Ledger'**
  String get addWalletOptionsPairWithLedgerTitle;

  /// Subtitle for pair with Ledger option
  ///
  /// In en, this message translates to:
  /// **'Hardware module, Bluetooth'**
  String get addWalletOptionsPairWithLedgerSubtitle;

  /// Section title for other wallet options
  ///
  /// In en, this message translates to:
  /// **'Other options'**
  String get addWalletOptionsOtherOptions;

  /// Title for watch account option
  ///
  /// In en, this message translates to:
  /// **'Watch Account'**
  String get addWalletOptionsWatchAccountTitle;

  /// Subtitle for watch account option
  ///
  /// In en, this message translates to:
  /// **'For monitor wallet activity without recovery phrase'**
  String get addWalletOptionsWatchAccountSubtitle;

  /// Title for the Currency Conversion page
  ///
  /// In en, this message translates to:
  /// **'Primary Currency'**
  String get currencyConversionTitle;

  /// Hint text for the currency search input
  ///
  /// In en, this message translates to:
  /// **'Search currencies...'**
  String get currencyConversionSearchHint;

  /// Title for the currency engine selection
  ///
  /// In en, this message translates to:
  /// **'Currency Engine'**
  String get currencyConversionEngineTitle;

  /// Description for the currency engine selection
  ///
  /// In en, this message translates to:
  /// **'Engine for fetching currency rates'**
  String get currencyConversionEngineDescription;

  /// Title for the currency engine selector modal
  ///
  /// In en, this message translates to:
  /// **'Select Currency Engine'**
  String get currencyConversionEngineSelectorTitle;

  /// Title for the 'None' engine option
  ///
  /// In en, this message translates to:
  /// **'None'**
  String get currencyConversionEngineNone;

  /// Subtitle for the 'None' engine option
  ///
  /// In en, this message translates to:
  /// **'No engine selected'**
  String get currencyConversionEngineNoneSubtitle;

  /// Title for the 'Coingecko' engine option
  ///
  /// In en, this message translates to:
  /// **'Coingecko'**
  String get currencyConversionEngineCoingecko;

  /// Subtitle for the 'Coingecko' engine option
  ///
  /// In en, this message translates to:
  /// **'Fetch rates from Coingecko'**
  String get currencyConversionEngineCoingeckoSubtitle;

  /// Title for the Restore Wallet Options page
  ///
  /// In en, this message translates to:
  /// **'Restore Wallet'**
  String get restoreWalletOptionsTitle;

  /// Title for BIP39 restore option
  ///
  /// In en, this message translates to:
  /// **'BIP39'**
  String get restoreWalletOptionsBIP39Title;

  /// Subtitle for BIP39 restore option
  ///
  /// In en, this message translates to:
  /// **'Restore with Mnemonic phrase'**
  String get restoreWalletOptionsBIP39Subtitle;

  /// Title for SLIP-0039 restore option
  ///
  /// In en, this message translates to:
  /// **'SLIP-0039'**
  String get restoreWalletOptionsSLIP0039Title;

  /// Subtitle for SLIP-0039 restore option
  ///
  /// In en, this message translates to:
  /// **'Restore with Shared Mnemonic phrase'**
  String get restoreWalletOptionsSLIP0039Subtitle;

  /// Title for Private Key restore option
  ///
  /// In en, this message translates to:
  /// **'Private Key'**
  String get restoreWalletOptionsPrivateKeyTitle;

  /// Subtitle for Private Key restore option
  ///
  /// In en, this message translates to:
  /// **'Restore with private key'**
  String get restoreWalletOptionsPrivateKeySubtitle;

  /// Title for keystore restore option
  ///
  /// In en, this message translates to:
  /// **'Keystore File'**
  String get restoreWalletOptionsKeyStoreTitle;

  /// Subtitle for keystore restore option
  ///
  /// In en, this message translates to:
  /// **'Restore wallet using password-encrypted backup file'**
  String get restoreWalletOptionsKeyStoreSubtitle;

  /// Title for QR code restore option
  ///
  /// In en, this message translates to:
  /// **'QRcode'**
  String get restoreWalletOptionsQRCodeTitle;

  /// Subtitle for QR code restore option
  ///
  /// In en, this message translates to:
  /// **'Restore wallet by QRcode scanning'**
  String get restoreWalletOptionsQRCodeSubtitle;

  /// Title for low memory Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Low Memory'**
  String get argonSettingsModalContentLowMemoryTitle;

  /// Subtitle for low memory Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'64KB RAM, 3 iterations'**
  String get argonSettingsModalContentLowMemorySubtitle;

  /// Description for low memory Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Minimal memory usage, suitable for low-end devices.'**
  String get argonSettingsModalContentLowMemoryDescription;

  /// Title for OWASP default Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'OWASP Default'**
  String get argonSettingsModalContentOwaspTitle;

  /// Subtitle for OWASP default Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'6.5MB RAM, 2 iterations'**
  String get argonSettingsModalContentOwaspSubtitle;

  /// Description for OWASP default Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Recommended by OWASP for general use.'**
  String get argonSettingsModalContentOwaspDescription;

  /// Title for secure Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Secure'**
  String get argonSettingsModalContentSecureTitle;

  /// Subtitle for secure Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'256MB RAM, 4 iterations'**
  String get argonSettingsModalContentSecureSubtitle;

  /// Description for secure Argon2 parameter option in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'High security with increased memory and iterations.'**
  String get argonSettingsModalContentSecureDescription;

  /// Hint text for secret input field in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Enter secret (optional)'**
  String get argonSettingsModalContentSecretHint;

  /// Text for confirm button in ArgonSettingsModalContent
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get argonSettingsModalContentConfirmButton;

  /// Hint text for the password input field in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get confirmTransactionContentPasswordHint;

  /// Text displayed on the swipe button when confirmation is not possible in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Unable to confirm'**
  String get confirmTransactionContentUnableToConfirm;

  /// Text displayed on the swipe button to confirm the transaction in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get confirmTransactionContentConfirm;

  /// Error message shown when the user has insufficient balance to complete the transaction in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Insufficient balance'**
  String get confirmTransactionContentInsufficientBalance;

  /// Error message thrown when no active account is found in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'No active account'**
  String get confirmTransactionContentNoActiveAccount;

  /// Error message displayed when transfer details fail to load in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Failed to load transfer details'**
  String get confirmTransactionContentFailedLoadTransfer;

  /// Text displayed on the edit gas button in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Edit gas'**
  String get confirmTransactionEditGasButtonText;

  /// Reason text displayed during authentication prompt in the ConfirmTransactionContent modal.
  ///
  /// In en, this message translates to:
  /// **'Please authenticate'**
  String get authReason;

  /// Warning text displayed at the bottom of the AddChainModalContent modal to alert users about potential risks.
  ///
  /// In en, this message translates to:
  /// **'Beware of network scams and security risks.'**
  String get addChainModalContentWarning;

  /// Text on the swipe button to confirm adding the chain in the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Approve'**
  String get addChainModalContentApprove;

  /// Title for the details section in the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Details'**
  String get addChainModalContentDetails;

  /// Label for the network name field in the details section of the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Network Name:'**
  String get addChainModalContentNetworkName;

  /// Label for the currency symbol field in the details section of the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Currency Symbol:'**
  String get addChainModalContentCurrencySymbol;

  /// Label for the chain ID field in the details section of the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Chain ID:'**
  String get addChainModalContentChainId;

  /// Label for the block explorer URL field in the details section of the AddChainModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Block Explorer:'**
  String get addChainModalContentBlockExplorer;

  /// Title text for the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Add Contact'**
  String get addAddressModalTitle;

  /// Description text explaining the purpose of the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Enter the contact name and wallet address to add to your address book.'**
  String get addAddressModalDescription;

  /// Hint text for the name input field in the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Name'**
  String get addAddressModalNameHint;

  /// Hint text for the wallet address input field in the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Wallet Address'**
  String get addAddressModalAddressHint;

  /// Error message displayed when the name field is empty in the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Name cannot be empty'**
  String get addAddressModalNameEmptyError;

  /// Error message displayed when the address field is empty in the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Address cannot be empty'**
  String get addAddressModalAddressEmptyError;

  /// Text on the button to confirm adding a contact in the AddAddressModal modal.
  ///
  /// In en, this message translates to:
  /// **'Add Contact'**
  String get addAddressModalButton;

  /// Hint text for the search input field in the TokenSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get tokenSelectModalContentSearchHint;

  /// Reason text for authentication prompt in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Please authenticate to sign the message'**
  String get signMessageModalContentAuthReason;

  /// Error message format when signing fails in the SignMessageModalContent modal, with {error} placeholder for the error details.
  ///
  /// In en, this message translates to:
  /// **'Failed to sign: {error}'**
  String signMessageModalContentFailedToSign(Object error);

  /// Title text for the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Sign Message'**
  String get signMessageModalContentTitle;

  /// Description text explaining the purpose of the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Review and sign the following message with your wallet.'**
  String get signMessageModalContentDescription;

  /// Label for the domain field in the typed data section of the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Domain:'**
  String get signMessageModalContentDomain;

  /// Label for the chain ID field in the typed data section of the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Chain ID:'**
  String get signMessageModalContentChainId;

  /// Label for the verifying contract field in the typed data section of the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Contract:'**
  String get signMessageModalContentContract;

  /// Label for the primary type field in the typed data section of the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Type:'**
  String get signMessageModalContentType;

  /// Text displayed when no message data is provided in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'No data'**
  String get signMessageModalContentNoData;

  /// Hint text for the password input field in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get signMessageModalContentPasswordHint;

  /// Text displayed on the swipe button while processing in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Processing...'**
  String get signMessageModalContentProcessing;

  /// Text displayed on the swipe button to confirm signing in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Sign Message'**
  String get signMessageModalContentSign;

  /// Text displayed below the progress indicator when scanning for Ledger devices in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Scanning Ledger devices...'**
  String get signMessageModalContentScanning;

  /// Error message displayed when no Ledger devices are found after scanning in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'No Ledger devices found'**
  String get signMessageModalContentNoLedgerDevices;

  /// Error message displayed when no wallet is selected in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Wallet not selected'**
  String get signMessageModalContentWalletNotSelected;

  /// Error message displayed when no Ledger device is selected in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Ledger device not selected'**
  String get signMessageModalContentLedgerNotSelected;

  /// Error message format when scanning for Ledger devices fails in the SignMessageModalContent modal, with {error} placeholder for the error details.
  ///
  /// In en, this message translates to:
  /// **'Failed to scan Ledger devices: {error}'**
  String signMessageModalContentFailedToScanLedger(Object error);

  /// Error message format when signing a message with a Ledger device fails in the SignMessageModalContent modal, with {error} placeholder for the error details.
  ///
  /// In en, this message translates to:
  /// **'Failed to sign message: {error}'**
  String signMessageModalContentFailedToSignMessage(Object error);

  /// Error message displayed when Bluetooth is not enabled during Ledger device scanning in the SignMessageModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Bluetooth is turned off. Please enable it to scan for Ledger devices.'**
  String get signMessageModalContentBluetoothOff;

  /// Title text for the DeleteWalletModal modal.
  ///
  /// In en, this message translates to:
  /// **'Delete Wallet'**
  String get deleteWalletModalTitle;

  /// Warning text about the irreversible nature of deleting a wallet in the DeleteWalletModal modal.
  ///
  /// In en, this message translates to:
  /// **'Warning: This action cannot be undone. Your wallet can only be recovered using your secret phrase. If you don\'t have access to it, you will permanently lose all funds associated with this account.'**
  String get deleteWalletModalWarning;

  /// Additional warning text emphasizing the importance of the secret phrase in the DeleteWalletModal modal.
  ///
  /// In en, this message translates to:
  /// **'Please make sure you have access to your secret phrase before proceeding.'**
  String get deleteWalletModalSecretPhraseWarning;

  /// Hint text for the password input field in the DeleteWalletModal modal.
  ///
  /// In en, this message translates to:
  /// **'Enter Password'**
  String get deleteWalletModalPasswordHint;

  /// Text on the button to confirm wallet deletion in the DeleteWalletModal modal.
  ///
  /// In en, this message translates to:
  /// **'Submit'**
  String get deleteWalletModalSubmit;

  /// Hint text for the search input field in the ManageTokensModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Search'**
  String get manageTokensModalContentSearchHint;

  /// Title text for the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Select Address'**
  String get addressSelectModalContentTitle;

  /// Hint text for the search input field in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Search / Address / ENS'**
  String get addressSelectModalContentSearchHint;

  /// Default name used for an unknown address or QR code result in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get addressSelectModalContentUnknown;

  /// Section title for the 'My Accounts' list in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'My Accounts'**
  String get addressSelectModalContentMyAccounts;

  /// Section title for the 'Address Book' list in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Address Book'**
  String get addressSelectModalContentAddressBook;

  /// Section title for the 'History' list in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'History'**
  String get addressSelectModalContentHistory;

  /// Label shown on addresses that belong to the sender account in the AddressSelectModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Sender'**
  String get addressSelectModalContentSender;

  /// Title text for the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Change Password'**
  String get changePasswordModalTitle;

  /// Description text explaining the purpose of the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Enter your current password and choose a new password to update your wallet security.'**
  String get changePasswordModalDescription;

  /// Hint text for the current password input field in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Current Password'**
  String get changePasswordModalCurrentPasswordHint;

  /// Hint text for the new password input field in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'New Password'**
  String get changePasswordModalNewPasswordHint;

  /// Hint text for the confirm new password input field in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Confirm New Password'**
  String get changePasswordModalConfirmPasswordHint;

  /// Error message displayed when the current password field is empty in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Current password cannot be empty'**
  String get changePasswordModalCurrentPasswordEmptyError;

  /// Error message displayed when the new password is less than 6 characters in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Password must be at least 6 characters'**
  String get changePasswordModalPasswordLengthError;

  /// Error message displayed when the new password and confirmation do not match in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Passwords do not match'**
  String get changePasswordModalPasswordsMismatchError;

  /// Text on the button to confirm password change in the ChangePasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Change Password'**
  String get changePasswordModalButton;

  /// Title text for the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Confirm Password'**
  String get confirmPasswordModalTitle;

  /// Description text explaining the purpose of the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Enter your password to continue.'**
  String get confirmPasswordModalDescription;

  /// Hint text for the password input field in the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Password'**
  String get confirmPasswordModalHint;

  /// Error message displayed when the password field is empty in the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Password cannot be empty'**
  String get confirmPasswordModalEmptyError;

  /// Prefix for generic error messages followed by the specific error in the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Error:'**
  String get confirmPasswordModalGenericError;

  /// Text on the button to confirm the password in the ConfirmPasswordModal modal.
  ///
  /// In en, this message translates to:
  /// **'Confirm'**
  String get confirmPasswordModalButton;

  /// Title text for the QRScannerModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Scan'**
  String get qrScannerModalContentTitle;

  /// Prefix for error message when camera initialization fails in the QRScannerModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Camera initialization error:'**
  String get qrScannerModalContentCameraInitError;

  /// Prefix for error message when toggling the torch fails in the QRScannerModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Failed to toggle torch:'**
  String get qrScannerModalContentTorchError;

  /// Text on the button to open app settings when camera permission is denied on iOS in the QRScannerModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Open Settings'**
  String get qrScannerModalContentOpenSettings;

  /// Title text for the network token section in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Network Token'**
  String get chainInfoModalContentTokenTitle;

  /// Title text for the network information section in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Network Information'**
  String get chainInfoModalContentNetworkInfoTitle;

  /// Label for the chain field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Chain'**
  String get chainInfoModalContentChainLabel;

  /// Label for the short name field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Short Name'**
  String get chainInfoModalContentShortNameLabel;

  /// Label for the chain ID field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Chain ID'**
  String get chainInfoModalContentChainIdLabel;

  /// Label for the Slip44 field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Slip44'**
  String get chainInfoModalContentSlip44Label;

  /// Label for the chain IDs field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Chain IDs'**
  String get chainInfoModalContentChainIdsLabel;

  /// Label for the testnet field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Testnet'**
  String get chainInfoModalContentTestnetLabel;

  /// Text displayed for a true testnet value in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Yes'**
  String get chainInfoModalContentYes;

  /// Text displayed for a false testnet value in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'No'**
  String get chainInfoModalContentNo;

  /// Label for the diff block time field in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Diff Block Time'**
  String get chainInfoModalContentDiffBlockTimeLabel;

  /// Label for the fallback enabled switch in the network information section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Fallback Enabled'**
  String get chainInfoModalContentFallbackEnabledLabel;

  /// Label for the decimals field in the first token section of the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Decimals'**
  String get chainInfoModalContentDecimalsLabel;

  /// Title text for the RPC nodes section in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'RPC Nodes'**
  String get chainInfoModalContentRpcNodesTitle;

  /// Title text for the explorers section in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Explorers'**
  String get chainInfoModalContentExplorersTitle;

  /// Title text for the delete network section in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Delete Network'**
  String get chainInfoModalContentDeleteProviderTitle;

  /// Text displayed on the swipe button for deleting a network in the ChainInfoModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Delete network'**
  String get chainInfoModalContentSwipeToDelete;

  /// Title text for the SwitchChainNetworkContent modal.
  ///
  /// In en, this message translates to:
  /// **'Select Network'**
  String get switchChainNetworkContentTitle;

  /// Text on the swipe button to confirm network switch in the SwitchChainNetworkContent modal.
  ///
  /// In en, this message translates to:
  /// **'Switch Network'**
  String get switchChainNetworkContentButton;

  /// Label displayed next to a testnet network name in the SwitchChainNetworkContent modal.
  ///
  /// In en, this message translates to:
  /// **'Testnet'**
  String get switchChainNetworkContentTestnetLabel;

  /// Label prefix for the chain ID in the network details row of the SwitchChainNetworkContent modal.
  ///
  /// In en, this message translates to:
  /// **'ID:'**
  String get switchChainNetworkContentIdLabel;

  /// Title text for the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Add suggested token'**
  String get watchAssetModalContentTitle;

  /// Description text explaining the purpose of the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Review and add the following token suggested by the app.'**
  String get watchAssetModalContentDescription;

  /// Label for the token column in the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Token'**
  String get watchAssetModalContentTokenLabel;

  /// Label for the balance column in the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Balance'**
  String get watchAssetModalContentBalanceLabel;

  /// Text on the swipe button while loading balance in the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Balance...'**
  String get watchAssetModalContentLoadingButton;

  /// Text on the swipe button to confirm adding the token in the WatchAssetModalContent modal.
  ///
  /// In en, this message translates to:
  /// **'Add'**
  String get watchAssetModalContentAddButton;

  /// Hint text for the search input in the ConnectedDappsModalContent component
  ///
  /// In en, this message translates to:
  /// **'Search DApps'**
  String get connectedDappsModalSearchHint;

  /// Text displayed when no DApps are connected in the ConnectedDappsModalContent component
  ///
  /// In en, this message translates to:
  /// **'No connected DApps'**
  String get connectedDappsModalNoDapps;

  /// Text showing when a DApp was last connected in the DappListItem component, where {time} is a placeholder for the formatted time
  ///
  /// In en, this message translates to:
  /// **'Connected {time}'**
  String dappListItemConnected(Object time);

  /// Text indicating a DApp was connected very recently in the DappListItem component
  ///
  /// In en, this message translates to:
  /// **'just now'**
  String get dappListItemJustNow;

  /// Title for the secret recovery phrase option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Reveal Secret Recovery Phrase'**
  String get secretRecoveryModalRevealPhraseTitle;

  /// Description text for the secret recovery phrase option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'If you ever change browsers or move computers, you will need this Secret Recovery Phrase to access your accounts. Save them somewhere safe and secret.'**
  String get secretRecoveryModalRevealPhraseDescription;

  /// Button text for revealing the secret recovery phrase in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Reveal'**
  String get secretRecoveryModalRevealPhraseButton;

  /// Title for the private keys option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Show Private Keys'**
  String get secretRecoveryModalShowKeysTitle;

  /// Description text for the private keys option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Warning: Never disclose this key. Anyone with your private keys can steal any assets held in your account.'**
  String get secretRecoveryModalShowKeysDescription;

  /// Button text for exporting private keys in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Export'**
  String get secretRecoveryModalShowKeysButton;

  /// Title text for the keystore backup option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Keystore Backup'**
  String get secretRecoveryModalKeystoreBackupTitle;

  /// Description text for the keystore backup option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Save your private keys in a password-protected encrypted keystore file. This provides an additional layer of security for your wallet.'**
  String get secretRecoveryModalKeystoreBackupDescription;

  /// Button text for the keystore backup option in the SecretRecoveryModal component
  ///
  /// In en, this message translates to:
  /// **'Create Keystore Backup'**
  String get secretRecoveryModalKeystoreBackupButton;

  /// Title for the backup confirmation modal in the BackupConfirmationContent component
  ///
  /// In en, this message translates to:
  /// **'Backup Confirmation'**
  String get backupConfirmationContentTitle;

  /// Warning message about the importance of keeping seed phrases safe and in correct order
  ///
  /// In en, this message translates to:
  /// **'WARNING: If you lose or forget your seed phrase in the exact order, you will lose your funds permanently. Never share your seed phrase with anyone or they may steal your funds. BIP39 recovery is strict - any mistake in the words during recovery will result in loss of funds.'**
  String get backupConfirmationWarning;

  /// Confirmation item indicating the user has written down the backup in the BackupConfirmationContent component
  ///
  /// In en, this message translates to:
  /// **'I have written down all'**
  String get backupConfirmationContentWrittenDown;

  /// Confirmation item indicating the user has safely stored the backup in the BackupConfirmationContent component
  ///
  /// In en, this message translates to:
  /// **'I have safely stored the backup'**
  String get backupConfirmationContentSafelyStored;

  /// Confirmation item indicating the user is confident they won't lose the backup in the BackupConfirmationContent component
  ///
  /// In en, this message translates to:
  /// **'I am sure I won\'t lose the backup'**
  String get backupConfirmationContentWontLose;

  /// Confirmation item indicating the user understands not to share the backup words in the BackupConfirmationContent component
  ///
  /// In en, this message translates to:
  /// **'I understand not to share these words with anyone'**
  String get backupConfirmationContentNotShare;

  /// Error message displayed when the Counter widget reaches its maximum value
  ///
  /// In en, this message translates to:
  /// **'Maximum value reached'**
  String get counterMaxValueError;

  /// Error message displayed when the Counter widget reaches its minimum value
  ///
  /// In en, this message translates to:
  /// **'Minimum value reached'**
  String get counterMinValueError;

  /// Text displayed for enabling Face ID in the BiometricSwitch widget
  ///
  /// In en, this message translates to:
  /// **'Enable Face ID'**
  String get biometricSwitchFaceId;

  /// Text displayed for enabling Fingerprint in the BiometricSwitch widget
  ///
  /// In en, this message translates to:
  /// **'Enable Fingerprint'**
  String get biometricSwitchFingerprint;

  /// Text displayed for enabling Biometric Login in the BiometricSwitch widget
  ///
  /// In en, this message translates to:
  /// **'Enable Biometric Login'**
  String get biometricSwitchBiometric;

  /// Text displayed for enabling Device PIN in the BiometricSwitch widget
  ///
  /// In en, this message translates to:
  /// **'Enable Device PIN'**
  String get biometricSwitchPinCode;

  /// Title for the low gas fee option in GasEIP1559 widget
  ///
  /// In en, this message translates to:
  /// **'Low'**
  String get gasFeeOptionLow;

  /// Title for the market gas fee option in GasEIP1559 widget
  ///
  /// In en, this message translates to:
  /// **'Market'**
  String get gasFeeOptionMarket;

  /// Title for the aggressive gas fee option in GasEIP1559 widget
  ///
  /// In en, this message translates to:
  /// **'Aggressive'**
  String get gasFeeOptionAggressive;

  /// Label for estimated gas in GasDetails widget
  ///
  /// In en, this message translates to:
  /// **'Estimated Gas:'**
  String get gasDetailsEstimatedGas;

  /// Label for gas price in GasDetails widget
  ///
  /// In en, this message translates to:
  /// **'Gas Price:'**
  String get gasDetailsGasPrice;

  /// Label for base fee in GasDetails widget
  ///
  /// In en, this message translates to:
  /// **'Base Fee:'**
  String get gasDetailsBaseFee;

  /// Label for priority fee in GasDetails widget
  ///
  /// In en, this message translates to:
  /// **'Priority Fee:'**
  String get gasDetailsPriorityFee;

  /// Label for max fee in GasDetails widget
  ///
  /// In en, this message translates to:
  /// **'Max Fee:'**
  String get gasDetailsMaxFee;

  /// Text displayed when the sender or recipient name is not provided in the TokenTransferAmount widget
  ///
  /// In en, this message translates to:
  /// **'Unknown'**
  String get tokenTransferAmountUnknown;

  /// Title for the transaction details section in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Transaction'**
  String get transactionDetailsModal_transaction;

  /// Label for transaction hash in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Hash'**
  String get transactionDetailsModal_hash;

  /// Label for transaction signature in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Sig'**
  String get transactionDetailsModal_sig;

  /// Label for transaction timestamp in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Timestamp'**
  String get transactionDetailsModal_timestamp;

  /// Label for block number in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Block Number'**
  String get transactionDetailsModal_blockNumber;

  /// Label for transaction nonce in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Nonce'**
  String get transactionDetailsModal_nonce;

  /// Title for addresses section in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Addresses'**
  String get transactionDetailsModal_addresses;

  /// Label for sender address in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Sender'**
  String get transactionDetailsModal_sender;

  /// Label for recipient address in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Recipient'**
  String get transactionDetailsModal_recipient;

  /// Label for contract address in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Contract Address'**
  String get transactionDetailsModal_contractAddress;

  /// Title for network section in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Network'**
  String get transactionDetailsModal_network;

  /// Label for chain type in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Chain Type'**
  String get transactionDetailsModal_chainType;

  /// Label for network name in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Network'**
  String get transactionDetailsModal_networkName;

  /// Title for gas and fees section in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Gas & Fees'**
  String get transactionDetailsModal_gasFees;

  /// Label for transaction fee in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Fee'**
  String get transactionDetailsModal_fee;

  /// Label for gas used in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Gas Used'**
  String get transactionDetailsModal_gasUsed;

  /// Label for gas limit in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Gas Limit'**
  String get transactionDetailsModal_gasLimit;

  /// Label for gas price in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Gas Price'**
  String get transactionDetailsModal_gasPrice;

  /// Label for effective gas price in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Effective Gas Price'**
  String get transactionDetailsModal_effectiveGasPrice;

  /// Label for blob gas used in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Blob Gas Used'**
  String get transactionDetailsModal_blobGasUsed;

  /// Label for blob gas price in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Blob Gas Price'**
  String get transactionDetailsModal_blobGasPrice;

  /// Title for error section in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Error'**
  String get transactionDetailsModal_error;

  /// Label for error message in TransactionDetailsModal
  ///
  /// In en, this message translates to:
  /// **'Error Message'**
  String get transactionDetailsModal_errorMessage;

  /// Title for transfer section in _AmountSection
  ///
  /// In en, this message translates to:
  /// **'Transfer'**
  String get amountSection_transfer;

  /// Status text for pending transaction in _AmountSection
  ///
  /// In en, this message translates to:
  /// **'Pending'**
  String get amountSection_pending;

  /// Status text for confirmed transaction in _AmountSection
  ///
  /// In en, this message translates to:
  /// **'Confirmed'**
  String get amountSection_confirmed;

  /// Status text for rejected transaction in _AmountSection
  ///
  /// In en, this message translates to:
  /// **'Rejected'**
  String get amountSection_rejected;

  /// Text for the swipe button in _AppConnectModalContent
  ///
  /// In en, this message translates to:
  /// **'Swipe to Connect'**
  String get appConnectModalContent_swipeToConnect;

  /// Text shown when no accounts are available in _AppConnectModalContent
  ///
  /// In en, this message translates to:
  /// **'No accounts available'**
  String get appConnectModalContent_noAccounts;

  /// Menu item text for sharing the current page
  ///
  /// In en, this message translates to:
  /// **'Share'**
  String get browserActionMenuShare;

  /// Menu item text for copying the current page link
  ///
  /// In en, this message translates to:
  /// **'Copy Link'**
  String get browserActionMenuCopyLink;

  /// Menu item text for closing the current page or tab
  ///
  /// In en, this message translates to:
  /// **'Close'**
  String get browserActionMenuClose;

  /// Title for the Keystore Backup screen
  ///
  /// In en, this message translates to:
  /// **'Keystore Backup'**
  String get keystoreBackupTitle;

  /// Title for the warning alert on the Keystore Backup screen
  ///
  /// In en, this message translates to:
  /// **'Secure Your Keystore File'**
  String get keystoreBackupWarningTitle;

  /// Warning message explaining the importance of securing the keystore file
  ///
  /// In en, this message translates to:
  /// **'The keystore file contains your encrypted private keys. Keep this file in a secure location and never share it with anyone. You will need the password you create to decrypt this file.'**
  String get keystoreBackupWarningMessage;

  /// Placeholder text for the password confirmation field
  ///
  /// In en, this message translates to:
  /// **'Confirm Password'**
  String get keystoreBackupConfirmPasswordHint;

  /// Text for the button to create a keystore backup
  ///
  /// In en, this message translates to:
  /// **'Create Backup'**
  String get keystoreBackupCreateButton;

  /// Error message shown when the entered passwords don't match
  ///
  /// In en, this message translates to:
  /// **'Passwords do not match'**
  String get keystoreBackupPasswordsDoNotMatch;

  /// Error message shown when the password is too short
  ///
  /// In en, this message translates to:
  /// **'Password must be at least 8 characters'**
  String get keystoreBackupPasswordTooShort;

  /// Prefix for error messages when backup creation fails
  ///
  /// In en, this message translates to:
  /// **'Error creating backup:'**
  String get keystoreBackupError;

  /// Text for the button to share the created keystore file
  ///
  /// In en, this message translates to:
  /// **'Share Keystore File'**
  String get keystoreBackupShareButton;

  /// Text for the button to dismiss the screen after backup is complete
  ///
  /// In en, this message translates to:
  /// **'Done'**
  String get keystoreBackupDoneButton;

  /// Title for the success message when backup is created
  ///
  /// In en, this message translates to:
  /// **'Backup Created Successfully'**
  String get keystoreBackupSuccessTitle;

  /// Message explaining that backup creation was successful and reminding about security
  ///
  /// In en, this message translates to:
  /// **'Your keystore file has been created. Remember to keep both the file and your password safe.'**
  String get keystoreBackupSuccessMessage;

  /// Button text to open file picker and save keystore file
  ///
  /// In en, this message translates to:
  /// **'Save to File'**
  String get keystoreBackupSaveAsButton;

  /// Dialog title for the file save picker
  ///
  /// In en, this message translates to:
  /// **'Save Keystore File'**
  String get keystoreBackupSaveDialogTitle;

  /// Message shown when keystore was saved successfully
  ///
  /// In en, this message translates to:
  /// **'Keystore file saved successfully'**
  String get keystoreBackupSavedSuccess;

  /// Error message when keystore file save failed
  ///
  /// In en, this message translates to:
  /// **'Failed to save keystore file'**
  String get keystoreBackupSaveFailed;

  /// Label for displaying the temporary file location
  ///
  /// In en, this message translates to:
  /// **'Temporary file location'**
  String get keystoreBackupTempLocation;

  /// Hint text for the keystore password input field
  ///
  /// In en, this message translates to:
  /// **'Enter your keystore password'**
  String get keystorePasswordHint;

  /// Button text to restore the wallet from keystore
  ///
  /// In en, this message translates to:
  /// **'Restore Wallet'**
  String get keystoreRestoreButton;

  /// title when we have keystore files
  ///
  /// In en, this message translates to:
  /// **'Please select a valid .zp file'**
  String get keystoreRestoreExtError;

  /// No description provided for @keystoreRestoreNoFile.
  ///
  /// In en, this message translates to:
  /// **'No keystore files found'**
  String get keystoreRestoreNoFile;

  /// No description provided for @keystoreRestoreFilesTitle.
  ///
  /// In en, this message translates to:
  /// **'Keystore Files'**
  String get keystoreRestoreFilesTitle;

  /// Title of the dialog for editing gas parameters
  ///
  /// In en, this message translates to:
  /// **'Edit Gas Parameters'**
  String get editGasDialogTitle;

  /// Label for gas price input field in the gas edit dialog
  ///
  /// In en, this message translates to:
  /// **'Gas Price'**
  String get editGasDialogGasPrice;

  /// Label for max priority fee input field in the gas edit dialog
  ///
  /// In en, this message translates to:
  /// **'Max Priority Fee'**
  String get editGasDialogMaxPriorityFee;

  /// Label for gas limit input field in the gas edit dialog
  ///
  /// In en, this message translates to:
  /// **'Gas Limit'**
  String get editGasDialogGasLimit;

  /// Button text to cancel gas parameter changes
  ///
  /// In en, this message translates to:
  /// **'Cancel'**
  String get editGasDialogCancel;

  /// Button text to save gas parameter changes
  ///
  /// In en, this message translates to:
  /// **'Save'**
  String get editGasDialogSave;

  /// Error message shown when invalid gas values are entered
  ///
  /// In en, this message translates to:
  /// **'Invalid gas values. Please check your inputs.'**
  String get editGasDialogInvalidGasValues;

  /// Title for the app bar in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Add Ledger Account'**
  String get addLedgerAccountPageAppBarTitle;

  /// Button text for fetching accounts from a Ledger device in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Get Accounts'**
  String get addLedgerAccountPageGetAccountsButton;

  /// Button text for creating a new wallet in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Create'**
  String get addLedgerAccountPageCreateButton;

  /// Button text for adding accounts to an existing wallet in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Add'**
  String get addLedgerAccountPageAddButton;

  /// Message displayed while scanning for Ledger devices in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Scanning for Ledger devices...'**
  String get addLedgerAccountPageScanningMessage;

  /// Message displayed when no Ledger devices are found in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'No Ledger devices found'**
  String get addLedgerAccountPageNoDevicesMessage;

  /// Error message displayed when Bluetooth is disabled in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Bluetooth is turned off. Please enable it to scan for Ledger devices.'**
  String get addLedgerAccountPageBluetoothOffError;

  /// Error message displayed when the wallet name is empty in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Wallet name cannot be empty'**
  String get addLedgerAccountPageEmptyWalletNameError;

  /// Error message displayed when the wallet name exceeds the maximum length in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Wallet name is too long (max 24 characters)'**
  String get addLedgerAccountPageWalletNameTooLongError;

  /// Error message displayed when scanning for Ledger devices fails in the AddLedgerAccountPage component, with a placeholder for the error details
  ///
  /// In en, this message translates to:
  /// **'Failed to scan for Ledger devices: {error}'**
  String addLedgerAccountPageFailedToScanError(Object error);

  /// Error message displayed when network or Ledger data is missing in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'Network or Ledger data is missing'**
  String get addLedgerAccountPageNetworkOrLedgerMissingError;

  /// Error message displayed when no accounts are selected for creating a wallet in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'No accounts selected'**
  String get addLedgerAccountPageNoAccountsSelectedError;

  /// Error message displayed when no wallet is selected for adding accounts in the AddLedgerAccountPage component
  ///
  /// In en, this message translates to:
  /// **'No wallet selected'**
  String get addLedgerAccountPageNoWalletSelectedError;

  /// Title for the transaction history toggle in the address book settings.
  ///
  /// In en, this message translates to:
  /// **'Transaction History'**
  String get transactionHistoryTitle;

  /// Description for the toggle that enables displaying transaction history addresses in the address book.
  ///
  /// In en, this message translates to:
  /// **'Show addresses from transaction history in the address book.'**
  String get transactionHistoryDescription;

  /// Title for the Zilliqa Staking page
  ///
  /// In en, this message translates to:
  /// **'Zilliqa Staking'**
  String get zilStakePageTitle;

  /// Message displayed when no staking pools are available
  ///
  /// In en, this message translates to:
  /// **'No Staking Pools Found'**
  String get noStakingPoolsFound;

  /// Label for sorting by Annual Percentage Rate
  ///
  /// In en, this message translates to:
  /// **'APR'**
  String get aprSort;

  /// Label for sorting by Commission
  ///
  /// In en, this message translates to:
  /// **'Commission'**
  String get commissionSort;

  /// Label for sorting by Total Value Locked
  ///
  /// In en, this message translates to:
  /// **'TVL'**
  String get tvlSort;

  /// Text for the claim rewards button
  ///
  /// In en, this message translates to:
  /// **'Claim'**
  String get claimButton;

  /// Text for the stake button
  ///
  /// In en, this message translates to:
  /// **'Stake'**
  String get stakeButton;

  /// Text for the unstake button
  ///
  /// In en, this message translates to:
  /// **'Unstake'**
  String get unstakeButton;

  /// Text for the reinvest button
  ///
  /// In en, this message translates to:
  /// **'Reinvest'**
  String get reinvest;

  /// Label for APR in the staking pool card
  ///
  /// In en, this message translates to:
  /// **'APR'**
  String get aprLabel;

  /// Label for Commission in the staking pool card
  ///
  /// In en, this message translates to:
  /// **'Commission'**
  String get commissionLabel;

  /// Label for TVL in the staking pool card
  ///
  /// In en, this message translates to:
  /// **'TVL'**
  String get tvlLabel;

  /// Badge text for liquidity pool staking
  ///
  /// In en, this message translates to:
  /// **'LP Staking'**
  String get lpStakingBadge;

  /// Label for the amount of tokens staked by user
  ///
  /// In en, this message translates to:
  /// **'Staked'**
  String get stakedAmount;

  /// Label for the rewards available to claim
  ///
  /// In en, this message translates to:
  /// **'Rewards'**
  String get rewardsAvailable;

  /// Title for the pending withdrawals section
  ///
  /// In en, this message translates to:
  /// **'Pending Withdrawals'**
  String get pendingWithdrawals;

  /// Label for the amount in a transaction or a list
  ///
  /// In en, this message translates to:
  /// **'Amount'**
  String get amount;

  /// Text indicating the time remaining until something is claimable
  ///
  /// In en, this message translates to:
  /// **'Claimable in'**
  String get claimableIn;

  /// Plural form of the word block, used for blockchain blocks count
  ///
  /// In en, this message translates to:
  /// **'blocks'**
  String get blocks;

  /// Label for the unbonding period
  ///
  /// In en, this message translates to:
  /// **'Unbonding Period'**
  String get unbondingPeriod;

  /// Label for the current blockchain block number
  ///
  /// In en, this message translates to:
  /// **'Current Block'**
  String get currentBlock;

  /// Label for the contract or validator version
  ///
  /// In en, this message translates to:
  /// **'Version'**
  String get version;

  /// This shows the staking rewards you've earned, reflected as an increase in your Liquid Staking Token's value in ZIL. You'll receive these earnings when you unstake.
  ///
  /// In en, this message translates to:
  /// **'Rewards Progress'**
  String get rewardsProgressTitle;

  /// No description provided for @durationDay.
  ///
  /// In en, this message translates to:
  /// **'d'**
  String get durationDay;

  /// No description provided for @durationHour.
  ///
  /// In en, this message translates to:
  /// **'h'**
  String get durationHour;

  /// No description provided for @durationMinute.
  ///
  /// In en, this message translates to:
  /// **'m'**
  String get durationMinute;

  /// No description provided for @durationLessThanAMinute.
  ///
  /// In en, this message translates to:
  /// **'< 1m'**
  String get durationLessThanAMinute;

  /// No description provided for @durationNotAvailable.
  ///
  /// In en, this message translates to:
  /// **'N/A'**
  String get durationNotAvailable;

  /// No description provided for @nodes.
  ///
  /// In en, this message translates to:
  /// **'nodes'**
  String get nodes;
}

class _AppLocalizationsDelegate extends LocalizationsDelegate<AppLocalizations> {
  const _AppLocalizationsDelegate();

  @override
  Future<AppLocalizations> load(Locale locale) {
    return SynchronousFuture<AppLocalizations>(lookupAppLocalizations(locale));
  }

  @override
  bool isSupported(Locale locale) => <String>['en', 'ja', 'ru', 'zh'].contains(locale.languageCode);

  @override
  bool shouldReload(_AppLocalizationsDelegate old) => false;
}

AppLocalizations lookupAppLocalizations(Locale locale) {


  // Lookup logic when only language code is specified.
  switch (locale.languageCode) {
    case 'en': return AppLocalizationsEn();
    case 'ja': return AppLocalizationsJa();
    case 'ru': return AppLocalizationsRu();
    case 'zh': return AppLocalizationsZh();
  }

  throw FlutterError(
    'AppLocalizations.delegate failed to load unsupported locale "$locale". This is likely '
    'an issue with the localizations generation tool. Please file an issue '
    'on GitHub with a reproducible sample app and the gen-l10n configuration '
    'that was used.'
  );
}

```

`lib/l10n/app_localizations_en.dart`:

```dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for English (`en`).
class AppLocalizationsEn extends AppLocalizations {
  AppLocalizationsEn([String locale = 'en']) : super(locale);

  @override
  String get appTitle => 'ZilPay Wallet';

  @override
  String get initialPagerestoreZilPay => 'Restore ZilPay 1.0!';

  @override
  String get initialPagegetStarted => 'Get Started';

  @override
  String get restoreRKStorageTitle => 'Migrate ZilPay 1.0 to 2.0';

  @override
  String get restoreRKStorageAccountsPrompt => 'Accounts to migrate to ZilPay 2.0. Enter password.';

  @override
  String get restoreRKStoragePasswordHint => 'Password';

  @override
  String get restoreRKStorageEnterPassword => 'Enter password';

  @override
  String get restoreRKStorageErrorPrefix => 'Error:';

  @override
  String get restoreRKStorageRestoreButton => 'Restore';

  @override
  String get restoreRKStorageSkipButton => 'Skip';

  @override
  String get accountItemBalanceLabel => 'Balance:';

  @override
  String get sendTokenPageTitle => '';

  @override
  String get sendTokenPageSubmitButton => 'Submit';

  @override
  String get aboutPageTitle => 'About';

  @override
  String get aboutPageAppName => 'ZilPay';

  @override
  String get aboutPageAppDescription => 'Your Secure Blockchain Wallet';

  @override
  String get aboutPageAppInfoTitle => 'Application Info';

  @override
  String get aboutPageVersionLabel => 'Version';

  @override
  String get aboutPageBuildDateLabel => 'Build Date';

  @override
  String get aboutPageBuildDateValue => 'March 10, 2025';

  @override
  String get aboutPagePlatformLabel => 'Platform';

  @override
  String get aboutPageDeveloperTitle => 'Developer';

  @override
  String get aboutPageAuthorLabel => 'Author';

  @override
  String get aboutPageAuthorValue => 'Rinat (hicaru)';

  @override
  String get aboutPageWebsiteLabel => 'Website';

  @override
  String get aboutPageWebsiteValue => 'https://zilpay.io';

  @override
  String get aboutPageLegalTitle => 'Legal';

  @override
  String get aboutPagePrivacyPolicy => 'Privacy Policy';

  @override
  String get aboutPageTermsOfService => 'Terms of Service';

  @override
  String get aboutPageLicenses => 'Licenses';

  @override
  String get aboutPageLegalese => '© 2025 ZilPay. All rights reserved.';

  @override
  String get languagePageTitle => 'Language';

  @override
  String get languagePageSystem => 'System';

  @override
  String get secretKeyGeneratorPageTitle => 'Secret Key';

  @override
  String get secretKeyGeneratorPagePrivateKey => 'Private Key';

  @override
  String get secretKeyGeneratorPagePublicKey => 'Public Key';

  @override
  String get secretKeyGeneratorPageBackupCheckbox => 'I have backup secret key';

  @override
  String get secretKeyGeneratorPageNextButton => 'Next';

  @override
  String get walletPageTitle => '';

  @override
  String get walletPageWalletNameHint => 'Wallet name';

  @override
  String get walletPagePreferencesTitle => 'Wallet preferences';

  @override
  String get walletPageManageConnections => 'Manage connections';

  @override
  String get walletPageBackup => 'Backup';

  @override
  String get walletPageDeleteWallet => 'Delete Wallet';

  @override
  String get walletPageBiometricReason => 'Enable biometric authentication';

  @override
  String get networkPageTitle => '';

  @override
  String get networkPageShowTestnet => 'Show Testnet';

  @override
  String get networkPageSearchHint => 'Search';

  @override
  String get networkPageAddedNetworks => 'Added Networks';

  @override
  String get networkPageAvailableNetworks => 'Available Networks';

  @override
  String get networkPageLoadError => 'Failed to load network chains: ';

  @override
  String get networkPageAddError => 'Failed to add network: ';

  @override
  String get receivePageTitle => 'Receive';

  @override
  String receivePageWarning(Object chainName, Object tokenSymbol) {
    return 'Only send $chainName($tokenSymbol) assets to this address. Other assets will be lost forever.';
  }

  @override
  String get receivePageAccountNameHint => 'Account name';

  @override
  String get receivePageAmountDialogTitle => 'Enter Amount';

  @override
  String get receivePageAmountDialogHint => '0.0';

  @override
  String get receivePageAmountDialogCancel => 'Cancel';

  @override
  String get receivePageAmountDialogConfirm => 'Confirm';

  @override
  String get securityPageTitle => 'Security';

  @override
  String get securityPageNetworkPrivacy => 'Network Privacy';

  @override
  String get securityPageEnsDomains => 'Show ENS domains in address bar';

  @override
  String get securityPageEnsDescription => 'Keep in mind that using this feature exposes your IP address to IPFS third-party services.';

  @override
  String get securityPageIpfsGateway => 'IPFS gateway';

  @override
  String get securityPageIpfsDescription => 'ZIlPay uses third-party services to show images of your NFTs stored on IPFS, display information related to ENS(ZNS) addresses entered in your browser\'s address bar, and fetch icons for different tokens. Your IP address may be exposed to these services when you\'re using them.';

  @override
  String get securityPageTokensFetcherTitle => 'Tokens fetcher';

  @override
  String get securityPageTokensFetcherDescription => 'tokens fetcher setting on SecurityPage. If enabled, tokens will be automatically fetched from the server and can be added.';

  @override
  String get securityPageNodeRanking => 'Node ranking';

  @override
  String get securityPageNodeDescription => 'Make requests to ZilPay server for fetch best node';

  @override
  String get securityPageEncryptionLevel => 'Encryption Level';

  @override
  String get securityPageProtection => 'Protection';

  @override
  String get securityPageCpuLoad => 'CPU Load';

  @override
  String get securityPageAes256 => 'AES256';

  @override
  String get securityPageKuznechikGost => 'KUZNECHIK-GOST';

  @override
  String get securityPageNtruPrime => 'NTRUPrime';

  @override
  String get securityPageCyber => 'Cyber';

  @override
  String get securityPageUnknown => 'Unknown';

  @override
  String get webViewPageDntLabel => 'DNT';

  @override
  String get webViewPageIncognitoLabel => 'Incognito';

  @override
  String get webViewPageLoadError => 'Failed to load';

  @override
  String get webViewPageTryAgain => 'Try Again';

  @override
  String get secretPhraseGeneratorPageTitle => 'New Wallet';

  @override
  String get secretPhraseGeneratorPageBackupCheckbox => 'I have backup words';

  @override
  String get secretPhraseGeneratorPageNextButton => 'Next';

  @override
  String get homePageTestnetLabel => 'Testnet';

  @override
  String get homePageErrorTitle => 'No signal';

  @override
  String get homePageSendButton => 'Send';

  @override
  String get homePageReceiveButton => 'Receive';

  @override
  String get revealSecretKeyTitle => 'Reveal Secret Key';

  @override
  String get revealSecretKeyPasswordHint => 'Password';

  @override
  String get revealSecretKeyInvalidPassword => 'invalid password, error:';

  @override
  String get revealSecretKeySubmitButton => 'Submit';

  @override
  String get revealSecretKeyDoneButton => 'Done';

  @override
  String get revealSecretKeyScamAlertTitle => 'SCAM ALERT';

  @override
  String get revealSecretKeyScamAlertMessage => 'Never share your secret key with anyone. Never input it on any website.';

  @override
  String get setupNetworkSettingsPageTestnetSwitch => 'Testnet';

  @override
  String get setupNetworkSettingsPageSearchHint => 'Search';

  @override
  String get setupNetworkSettingsPageNoNetworks => 'No networks available';

  @override
  String setupNetworkSettingsPageNoResults(Object searchQuery) {
    return 'No networks found for \"$searchQuery\"';
  }

  @override
  String get setupNetworkSettingsPageNextButton => 'Next';

  @override
  String get setupNetworkSettingsPageTestnetLabel => 'Testnet';

  @override
  String get setupNetworkSettingsPageMainnetLabel => 'Mainnet';

  @override
  String get setupNetworkSettingsPageChainIdLabel => 'Chain ID:';

  @override
  String get setupNetworkSettingsPageTokenLabel => 'Token:';

  @override
  String get setupNetworkSettingsPageExplorerLabel => 'Explorer:';

  @override
  String get appearanceSettingsPageTitle => 'Appearance Settings';

  @override
  String get appearanceSettingsPageCompactNumbersTitle => 'Compact Numbers';

  @override
  String get appearanceSettingsPageCompactNumbersDescription => 'Enable to display abbreviated numbers (e.g., 20K instead of 20,000).';

  @override
  String get appearanceSettingsPageDeviceSettingsTitle => 'Device settings';

  @override
  String get appearanceSettingsPageDeviceSettingsSubtitle => 'System default';

  @override
  String get appearanceSettingsPageDeviceSettingsDescription => 'Default to your device\'s appearance. Your wallet theme will automatically adjust based on your system settings.';

  @override
  String get appearanceSettingsPageDarkModeTitle => 'Dark Mode';

  @override
  String get appearanceSettingsPageDarkModeSubtitle => 'Always dark';

  @override
  String get appearanceSettingsPageDarkModeDescription => 'Keep the dark theme enabled at all times, regardless of your device settings.';

  @override
  String get appearanceSettingsPageLightModeTitle => 'Light mode';

  @override
  String get appearanceSettingsPageLightModeSubtitle => 'Always light';

  @override
  String get appearanceSettingsPageLightModeDescription => 'Keep the light theme enabled at all times, regardless of your device settings.';

  @override
  String get loginPageBiometricReason => 'Please authenticate';

  @override
  String loginPageWalletTitle(Object index) {
    return 'Wallet $index';
  }

  @override
  String get loginPagePasswordHint => 'Password';

  @override
  String get loginPageUnlockButton => 'Unlock';

  @override
  String get loginPageWelcomeBack => 'Welcome back';

  @override
  String get secretKeyRestorePageTitle => 'Restore Secret Key';

  @override
  String get secretKeyRestorePageHint => 'Private Key';

  @override
  String get secretKeyRestorePageInvalidFormat => 'Invalid private key format';

  @override
  String get secretKeyRestorePageKeyTitle => 'Private Key';

  @override
  String get secretKeyRestorePageBackupLabel => 'I have backed up my secret key';

  @override
  String get secretKeyRestorePageNextButton => 'Next';

  @override
  String get addAccountPageTitle => 'Add New Account';

  @override
  String get addAccountPageSubtitle => 'Create BIP39 Account';

  @override
  String addAccountPageDefaultName(Object index) {
    return 'Account $index';
  }

  @override
  String get addAccountPageNameHint => 'Account name';

  @override
  String get addAccountPageBip39Index => 'BIP39 Index';

  @override
  String get addAccountPageUseBiometrics => 'Use Biometrics';

  @override
  String get addAccountPagePasswordHint => 'Password';

  @override
  String get addAccountPageZilliqaLegacy => 'Zilliqa Legacy';

  @override
  String get addAccountPageBiometricReason => 'Authenticate to create a new account';

  @override
  String addAccountPageBiometricError(Object error) {
    return 'Biometric authentication failed: $error';
  }

  @override
  String addAccountPageIndexExists(Object index) {
    return 'Account with index $index already exists';
  }

  @override
  String get addAccountPageBiometricFailed => 'Biometric authentication failed';

  @override
  String addAccountPageCreateFailed(Object error) {
    return 'Failed to create account: $error';
  }

  @override
  String get addressBookPageTitle => 'Address Book';

  @override
  String get addressBookPageEmptyMessage => 'Your contacts and their wallet address will\nappear here.';

  @override
  String get addressBookPageDeleteConfirmationTitle => 'Delete Contact';

  @override
  String addressBookPageDeleteConfirmationMessage(String contactName) {
    return 'Are you sure you want to delete $contactName from your address book?';
  }

  @override
  String addressBookPageDeleteTooltip(String contactName) {
    return 'Delete $contactName';
  }

  @override
  String get cancel => 'Cancel';

  @override
  String get delete => 'Delete';

  @override
  String get browserPageConnectedTab => 'Connected';

  @override
  String get browserPageExploreTab => 'Explore';

  @override
  String get browserPageNoExploreApps => 'No apps to explore yet';

  @override
  String browserPageSearchHint(Object engine) {
    return 'Search with $engine or enter address';
  }

  @override
  String get browserPageNoConnectedApps => 'No connected apps';

  @override
  String get historyPageTitle => 'Transaction History';

  @override
  String get historyPageNoTransactions => 'No transactions yet';

  @override
  String get historyPageSearchHint => 'Search transactions...';

  @override
  String get notificationsSettingsPageTitle => 'Notifications';

  @override
  String get notificationsSettingsPagePushTitle => 'Push notifications';

  @override
  String get notificationsSettingsPagePushDescription => 'Get notifications when tx sent and confirm, Notifications from connected apps.';

  @override
  String get notificationsSettingsPageWalletsTitle => 'Wallets';

  @override
  String get notificationsSettingsPageWalletsDescription => 'Notifications from wallets';

  @override
  String get notificationsSettingsPageWalletPrefix => 'Wallet';

  @override
  String get revealSecretPhraseTitle => 'Reveal Secret Phrase';

  @override
  String get revealSecretPhrasePasswordHint => 'Password';

  @override
  String get revealSecretPhraseInvalidPassword => 'invalid password, error:';

  @override
  String get revealSecretPhraseRevealAfter => 'Your seed phrase will be revealed after:';

  @override
  String get revealSecretPhraseSubmitButton => 'Submit';

  @override
  String get revealSecretPhraseDoneButton => 'Done';

  @override
  String get revealSecretPhraseScamAlertTitle => 'SCAM ALERT';

  @override
  String get revealSecretPhraseScamAlertDescription => 'Never share your secret phrase with anyone. Never input it on any website.';

  @override
  String get cipherSettingsPageTitle => 'Encryption Setup';

  @override
  String get cipherSettingsPageAdvancedButton => 'Advanced';

  @override
  String get cipherSettingsPageStandardTitle => 'Standard Encryption';

  @override
  String get cipherSettingsPageStandardSubtitle => 'AES-256 + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageStandardDescription => 'Basic encryption with AES-256 and GOST standard KUZNECHIK.';

  @override
  String get cipherSettingsPageHybridTitle => 'Hybrid Encryption';

  @override
  String get cipherSettingsPageHybridSubtitle => 'CYBER + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageHybridDescription => 'Hybrid encryption combining CYBER and KUZNECHIK-GOST algorithms.';

  @override
  String get cipherSettingsPageQuantumTitle => 'Quantum-Resistant';

  @override
  String get cipherSettingsPageQuantumSubtitle => 'CYBER + KUZNECHIK + NTRUP1277';

  @override
  String get cipherSettingsPageQuantumDescription => 'Advanced quantum-resistant encryption with NTRUP1277.';

  @override
  String get cipherSettingsPageQuantumWarning => 'Quantum-resistant encryption may impact performance';

  @override
  String get cipherSettingsPageConfirmButton => 'Confirm';

  @override
  String get secretPhraseVerifyPageTitle => 'Verify Secret';

  @override
  String get secretPhraseVerifyPageSkipButton => 'Skip';

  @override
  String get secretPhraseVerifyPageSubtitle => 'Verify Bip39 Secret';

  @override
  String get secretPhraseVerifyPageNextButton => 'Next';

  @override
  String get restoreSecretPhrasePageTitle => 'Restore Wallet';

  @override
  String get restoreSecretPhrasePageRestoreButton => 'Restore';

  @override
  String get checksumValidationFailed => 'Checksum validation failed';

  @override
  String get proceedDespiteInvalidChecksum => 'Continue despite checksum error?';

  @override
  String get settingsPageTitle => 'Settings';

  @override
  String get settingsPageZilliqaLegacy => 'Zilliqa Legacy';

  @override
  String get settingsPageCurrency => 'Currency';

  @override
  String get settingsPageAppearance => 'Appearance';

  @override
  String get settingsPageNotifications => 'Notifications';

  @override
  String get settingsPageAddressBook => 'Address book';

  @override
  String get settingsPageSecurityPrivacy => 'Security & privacy';

  @override
  String get settingsPageNetworks => 'Networks';

  @override
  String get settingsPageLanguage => 'Language';

  @override
  String get settingsPageBrowser => 'Browser';

  @override
  String get settingsPageTelegram => 'Telegram';

  @override
  String get settingsPageTwitter => 'Twitter';

  @override
  String get settingsPageGitHub => 'GitHub';

  @override
  String get settingsPageAbout => 'About';

  @override
  String get passwordSetupPageTitle => 'Password Setup';

  @override
  String get passwordSetupPageSubtitle => 'Create Password';

  @override
  String get passwordSetupPageWalletNameHint => 'Wallet Name';

  @override
  String get passwordSetupPagePasswordHint => 'Password';

  @override
  String get passwordSetupPageConfirmPasswordHint => 'Confirm Password';

  @override
  String get passwordSetupPageEmptyWalletNameError => 'Wallet name cannot be empty';

  @override
  String get passwordSetupPageLongWalletNameError => 'Wallet name is too long';

  @override
  String get passwordSetupPageShortPasswordError => 'Password must be at least 8 characters';

  @override
  String get passwordSetupPageMismatchPasswordError => 'Passwords do not match';

  @override
  String get passwordSetupPageLegacyLabel => 'Legacy';

  @override
  String get passwordSetupPageCreateButton => 'Create Password';

  @override
  String get passwordSetupPageAuthReason => 'Please authenticate to enable quick access';

  @override
  String get passwordSetupPageSeedType => 'Seed';

  @override
  String get passwordSetupPageKeyType => 'Key';

  @override
  String get passwordSetupPageUniversalNetwork => 'Universal';

  @override
  String get browserSettingsTitle => 'Browser Settings';

  @override
  String get browserSettingsBrowserOptions => 'Browser Options';

  @override
  String get browserSettingsSearchEngine => 'Search Engine';

  @override
  String get browserSettingsSearchEngineDescription => 'Configure your default search engine';

  @override
  String get browserSettingsSearchEngineTitle => 'Search Engine';

  @override
  String get browserSettingsContentBlocking => 'Content Blocking';

  @override
  String get browserSettingsContentBlockingDescription => 'Configure content blocking settings';

  @override
  String get browserSettingsContentBlockingTitle => 'Content Blocking';

  @override
  String get browserSettingsPrivacySecurity => 'Privacy & Security';

  @override
  String get browserSettingsCookies => 'Cookies';

  @override
  String get browserSettingsCookiesDescription => 'Allow websites to save and read cookies';

  @override
  String get browserSettingsDoNotTrack => 'Do Not Track';

  @override
  String get browserSettingsDoNotTrackDescription => 'Request websites not to track your browsing';

  @override
  String get browserSettingsIncognitoMode => 'Incognito Mode';

  @override
  String get browserSettingsIncognitoModeDescription => 'Browse without saving history or cookies';

  @override
  String get browserSettingsPerformance => 'Performance';

  @override
  String get browserSettingsCache => 'Cache';

  @override
  String get browserSettingsClearData => 'Clear Data';

  @override
  String get browserSettingsClear => 'Clear';

  @override
  String get browserSettingsClearCookies => 'Clear Cookies';

  @override
  String get browserSettingsClearCookiesDescription => 'Delete all cookies stored by websites';

  @override
  String get browserSettingsClearCache => 'Clear Cache';

  @override
  String get browserSettingsClearCacheDescription => 'Delete temporary files and images stored during browsing';

  @override
  String get browserSettingsClearLocalStorage => 'Clear Local Storage';

  @override
  String get browserSettingsClearLocalStorageDescription => 'Delete website data stored locally on your device';

  @override
  String get browserSettingsCacheDescription => 'Store website data for faster loading';

  @override
  String get genWalletOptionsTitle => 'Generate Wallet';

  @override
  String get genWalletOptionsBIP39Title => 'BIP39';

  @override
  String get genWalletOptionsBIP39Subtitle => 'Generate Mnemonic phrase';

  @override
  String get genWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get genWalletOptionsSLIP0039Subtitle => 'Generate Mnemonic phrase with share';

  @override
  String get genWalletOptionsPrivateKeyTitle => 'Private Key';

  @override
  String get genWalletOptionsPrivateKeySubtitle => 'Generate just one private key';

  @override
  String get addWalletOptionsTitle => 'Add Wallet';

  @override
  String get addWalletOptionsNewWalletTitle => 'New Wallet';

  @override
  String get addWalletOptionsNewWalletSubtitle => 'Create new wallet';

  @override
  String get addWalletOptionsExistingWalletTitle => 'Existing Wallet';

  @override
  String get addWalletOptionsExistingWalletSubtitle => 'Import wallet with a 24 secret recovery words';

  @override
  String get addWalletOptionsPairWithLedgerTitle => 'Pair with Ledger';

  @override
  String get addWalletOptionsPairWithLedgerSubtitle => 'Hardware module, Bluetooth';

  @override
  String get addWalletOptionsOtherOptions => 'Other options';

  @override
  String get addWalletOptionsWatchAccountTitle => 'Watch Account';

  @override
  String get addWalletOptionsWatchAccountSubtitle => 'For monitor wallet activity without recovery phrase';

  @override
  String get currencyConversionTitle => 'Primary Currency';

  @override
  String get currencyConversionSearchHint => 'Search currencies...';

  @override
  String get currencyConversionEngineTitle => 'Currency Engine';

  @override
  String get currencyConversionEngineDescription => 'Engine for fetching currency rates';

  @override
  String get currencyConversionEngineSelectorTitle => 'Select Currency Engine';

  @override
  String get currencyConversionEngineNone => 'None';

  @override
  String get currencyConversionEngineNoneSubtitle => 'No engine selected';

  @override
  String get currencyConversionEngineCoingecko => 'Coingecko';

  @override
  String get currencyConversionEngineCoingeckoSubtitle => 'Fetch rates from Coingecko';

  @override
  String get restoreWalletOptionsTitle => 'Restore Wallet';

  @override
  String get restoreWalletOptionsBIP39Title => 'BIP39';

  @override
  String get restoreWalletOptionsBIP39Subtitle => 'Restore with Mnemonic phrase';

  @override
  String get restoreWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get restoreWalletOptionsSLIP0039Subtitle => 'Restore with Shared Mnemonic phrase';

  @override
  String get restoreWalletOptionsPrivateKeyTitle => 'Private Key';

  @override
  String get restoreWalletOptionsPrivateKeySubtitle => 'Restore with private key';

  @override
  String get restoreWalletOptionsKeyStoreTitle => 'Keystore File';

  @override
  String get restoreWalletOptionsKeyStoreSubtitle => 'Restore wallet using password-encrypted backup file';

  @override
  String get restoreWalletOptionsQRCodeTitle => 'QRcode';

  @override
  String get restoreWalletOptionsQRCodeSubtitle => 'Restore wallet by QRcode scanning';

  @override
  String get argonSettingsModalContentLowMemoryTitle => 'Low Memory';

  @override
  String get argonSettingsModalContentLowMemorySubtitle => '64KB RAM, 3 iterations';

  @override
  String get argonSettingsModalContentLowMemoryDescription => 'Minimal memory usage, suitable for low-end devices.';

  @override
  String get argonSettingsModalContentOwaspTitle => 'OWASP Default';

  @override
  String get argonSettingsModalContentOwaspSubtitle => '6.5MB RAM, 2 iterations';

  @override
  String get argonSettingsModalContentOwaspDescription => 'Recommended by OWASP for general use.';

  @override
  String get argonSettingsModalContentSecureTitle => 'Secure';

  @override
  String get argonSettingsModalContentSecureSubtitle => '256MB RAM, 4 iterations';

  @override
  String get argonSettingsModalContentSecureDescription => 'High security with increased memory and iterations.';

  @override
  String get argonSettingsModalContentSecretHint => 'Enter secret (optional)';

  @override
  String get argonSettingsModalContentConfirmButton => 'Confirm';

  @override
  String get confirmTransactionContentPasswordHint => 'Password';

  @override
  String get confirmTransactionContentUnableToConfirm => 'Unable to confirm';

  @override
  String get confirmTransactionContentConfirm => 'Confirm';

  @override
  String get confirmTransactionContentInsufficientBalance => 'Insufficient balance';

  @override
  String get confirmTransactionContentNoActiveAccount => 'No active account';

  @override
  String get confirmTransactionContentFailedLoadTransfer => 'Failed to load transfer details';

  @override
  String get confirmTransactionEditGasButtonText => 'Edit gas';

  @override
  String get authReason => 'Please authenticate';

  @override
  String get addChainModalContentWarning => 'Beware of network scams and security risks.';

  @override
  String get addChainModalContentApprove => 'Approve';

  @override
  String get addChainModalContentDetails => 'Details';

  @override
  String get addChainModalContentNetworkName => 'Network Name:';

  @override
  String get addChainModalContentCurrencySymbol => 'Currency Symbol:';

  @override
  String get addChainModalContentChainId => 'Chain ID:';

  @override
  String get addChainModalContentBlockExplorer => 'Block Explorer:';

  @override
  String get addAddressModalTitle => 'Add Contact';

  @override
  String get addAddressModalDescription => 'Enter the contact name and wallet address to add to your address book.';

  @override
  String get addAddressModalNameHint => 'Name';

  @override
  String get addAddressModalAddressHint => 'Wallet Address';

  @override
  String get addAddressModalNameEmptyError => 'Name cannot be empty';

  @override
  String get addAddressModalAddressEmptyError => 'Address cannot be empty';

  @override
  String get addAddressModalButton => 'Add Contact';

  @override
  String get tokenSelectModalContentSearchHint => 'Search';

  @override
  String get signMessageModalContentAuthReason => 'Please authenticate to sign the message';

  @override
  String signMessageModalContentFailedToSign(Object error) {
    return 'Failed to sign: $error';
  }

  @override
  String get signMessageModalContentTitle => 'Sign Message';

  @override
  String get signMessageModalContentDescription => 'Review and sign the following message with your wallet.';

  @override
  String get signMessageModalContentDomain => 'Domain:';

  @override
  String get signMessageModalContentChainId => 'Chain ID:';

  @override
  String get signMessageModalContentContract => 'Contract:';

  @override
  String get signMessageModalContentType => 'Type:';

  @override
  String get signMessageModalContentNoData => 'No data';

  @override
  String get signMessageModalContentPasswordHint => 'Password';

  @override
  String get signMessageModalContentProcessing => 'Processing...';

  @override
  String get signMessageModalContentSign => 'Sign Message';

  @override
  String get signMessageModalContentScanning => 'Scanning Ledger devices...';

  @override
  String get signMessageModalContentNoLedgerDevices => 'No Ledger devices found';

  @override
  String get signMessageModalContentWalletNotSelected => 'Wallet not selected';

  @override
  String get signMessageModalContentLedgerNotSelected => 'Ledger device not selected';

  @override
  String signMessageModalContentFailedToScanLedger(Object error) {
    return 'Failed to scan Ledger devices: $error';
  }

  @override
  String signMessageModalContentFailedToSignMessage(Object error) {
    return 'Failed to sign message: $error';
  }

  @override
  String get signMessageModalContentBluetoothOff => 'Bluetooth is turned off. Please enable it to scan for Ledger devices.';

  @override
  String get deleteWalletModalTitle => 'Delete Wallet';

  @override
  String get deleteWalletModalWarning => 'Warning: This action cannot be undone. Your wallet can only be recovered using your secret phrase. If you don\'t have access to it, you will permanently lose all funds associated with this account.';

  @override
  String get deleteWalletModalSecretPhraseWarning => 'Please make sure you have access to your secret phrase before proceeding.';

  @override
  String get deleteWalletModalPasswordHint => 'Enter Password';

  @override
  String get deleteWalletModalSubmit => 'Submit';

  @override
  String get manageTokensModalContentSearchHint => 'Search';

  @override
  String get addressSelectModalContentTitle => 'Select Address';

  @override
  String get addressSelectModalContentSearchHint => 'Search / Address / ENS';

  @override
  String get addressSelectModalContentUnknown => 'Unknown';

  @override
  String get addressSelectModalContentMyAccounts => 'My Accounts';

  @override
  String get addressSelectModalContentAddressBook => 'Address Book';

  @override
  String get addressSelectModalContentHistory => 'History';

  @override
  String get addressSelectModalContentSender => 'Sender';

  @override
  String get changePasswordModalTitle => 'Change Password';

  @override
  String get changePasswordModalDescription => 'Enter your current password and choose a new password to update your wallet security.';

  @override
  String get changePasswordModalCurrentPasswordHint => 'Current Password';

  @override
  String get changePasswordModalNewPasswordHint => 'New Password';

  @override
  String get changePasswordModalConfirmPasswordHint => 'Confirm New Password';

  @override
  String get changePasswordModalCurrentPasswordEmptyError => 'Current password cannot be empty';

  @override
  String get changePasswordModalPasswordLengthError => 'Password must be at least 6 characters';

  @override
  String get changePasswordModalPasswordsMismatchError => 'Passwords do not match';

  @override
  String get changePasswordModalButton => 'Change Password';

  @override
  String get confirmPasswordModalTitle => 'Confirm Password';

  @override
  String get confirmPasswordModalDescription => 'Enter your password to continue.';

  @override
  String get confirmPasswordModalHint => 'Password';

  @override
  String get confirmPasswordModalEmptyError => 'Password cannot be empty';

  @override
  String get confirmPasswordModalGenericError => 'Error:';

  @override
  String get confirmPasswordModalButton => 'Confirm';

  @override
  String get qrScannerModalContentTitle => 'Scan';

  @override
  String get qrScannerModalContentCameraInitError => 'Camera initialization error:';

  @override
  String get qrScannerModalContentTorchError => 'Failed to toggle torch:';

  @override
  String get qrScannerModalContentOpenSettings => 'Open Settings';

  @override
  String get chainInfoModalContentTokenTitle => 'Network Token';

  @override
  String get chainInfoModalContentNetworkInfoTitle => 'Network Information';

  @override
  String get chainInfoModalContentChainLabel => 'Chain';

  @override
  String get chainInfoModalContentShortNameLabel => 'Short Name';

  @override
  String get chainInfoModalContentChainIdLabel => 'Chain ID';

  @override
  String get chainInfoModalContentSlip44Label => 'Slip44';

  @override
  String get chainInfoModalContentChainIdsLabel => 'Chain IDs';

  @override
  String get chainInfoModalContentTestnetLabel => 'Testnet';

  @override
  String get chainInfoModalContentYes => 'Yes';

  @override
  String get chainInfoModalContentNo => 'No';

  @override
  String get chainInfoModalContentDiffBlockTimeLabel => 'Diff Block Time';

  @override
  String get chainInfoModalContentFallbackEnabledLabel => 'Fallback Enabled';

  @override
  String get chainInfoModalContentDecimalsLabel => 'Decimals';

  @override
  String get chainInfoModalContentRpcNodesTitle => 'RPC Nodes';

  @override
  String get chainInfoModalContentExplorersTitle => 'Explorers';

  @override
  String get chainInfoModalContentDeleteProviderTitle => 'Delete Network';

  @override
  String get chainInfoModalContentSwipeToDelete => 'Delete network';

  @override
  String get switchChainNetworkContentTitle => 'Select Network';

  @override
  String get switchChainNetworkContentButton => 'Switch Network';

  @override
  String get switchChainNetworkContentTestnetLabel => 'Testnet';

  @override
  String get switchChainNetworkContentIdLabel => 'ID:';

  @override
  String get watchAssetModalContentTitle => 'Add suggested token';

  @override
  String get watchAssetModalContentDescription => 'Review and add the following token suggested by the app.';

  @override
  String get watchAssetModalContentTokenLabel => 'Token';

  @override
  String get watchAssetModalContentBalanceLabel => 'Balance';

  @override
  String get watchAssetModalContentLoadingButton => 'Balance...';

  @override
  String get watchAssetModalContentAddButton => 'Add';

  @override
  String get connectedDappsModalSearchHint => 'Search DApps';

  @override
  String get connectedDappsModalNoDapps => 'No connected DApps';

  @override
  String dappListItemConnected(Object time) {
    return 'Connected $time';
  }

  @override
  String get dappListItemJustNow => 'just now';

  @override
  String get secretRecoveryModalRevealPhraseTitle => 'Reveal Secret Recovery Phrase';

  @override
  String get secretRecoveryModalRevealPhraseDescription => 'If you ever change browsers or move computers, you will need this Secret Recovery Phrase to access your accounts. Save them somewhere safe and secret.';

  @override
  String get secretRecoveryModalRevealPhraseButton => 'Reveal';

  @override
  String get secretRecoveryModalShowKeysTitle => 'Show Private Keys';

  @override
  String get secretRecoveryModalShowKeysDescription => 'Warning: Never disclose this key. Anyone with your private keys can steal any assets held in your account.';

  @override
  String get secretRecoveryModalShowKeysButton => 'Export';

  @override
  String get secretRecoveryModalKeystoreBackupTitle => 'Keystore Backup';

  @override
  String get secretRecoveryModalKeystoreBackupDescription => 'Save your private keys in a password-protected encrypted keystore file. This provides an additional layer of security for your wallet.';

  @override
  String get secretRecoveryModalKeystoreBackupButton => 'Create Keystore Backup';

  @override
  String get backupConfirmationContentTitle => 'Backup Confirmation';

  @override
  String get backupConfirmationWarning => 'WARNING: If you lose or forget your seed phrase in the exact order, you will lose your funds permanently. Never share your seed phrase with anyone or they may steal your funds. BIP39 recovery is strict - any mistake in the words during recovery will result in loss of funds.';

  @override
  String get backupConfirmationContentWrittenDown => 'I have written down all';

  @override
  String get backupConfirmationContentSafelyStored => 'I have safely stored the backup';

  @override
  String get backupConfirmationContentWontLose => 'I am sure I won\'t lose the backup';

  @override
  String get backupConfirmationContentNotShare => 'I understand not to share these words with anyone';

  @override
  String get counterMaxValueError => 'Maximum value reached';

  @override
  String get counterMinValueError => 'Minimum value reached';

  @override
  String get biometricSwitchFaceId => 'Enable Face ID';

  @override
  String get biometricSwitchFingerprint => 'Enable Fingerprint';

  @override
  String get biometricSwitchBiometric => 'Enable Biometric Login';

  @override
  String get biometricSwitchPinCode => 'Enable Device PIN';

  @override
  String get gasFeeOptionLow => 'Low';

  @override
  String get gasFeeOptionMarket => 'Market';

  @override
  String get gasFeeOptionAggressive => 'Aggressive';

  @override
  String get gasDetailsEstimatedGas => 'Estimated Gas:';

  @override
  String get gasDetailsGasPrice => 'Gas Price:';

  @override
  String get gasDetailsBaseFee => 'Base Fee:';

  @override
  String get gasDetailsPriorityFee => 'Priority Fee:';

  @override
  String get gasDetailsMaxFee => 'Max Fee:';

  @override
  String get tokenTransferAmountUnknown => 'Unknown';

  @override
  String get transactionDetailsModal_transaction => 'Transaction';

  @override
  String get transactionDetailsModal_hash => 'Hash';

  @override
  String get transactionDetailsModal_sig => 'Sig';

  @override
  String get transactionDetailsModal_timestamp => 'Timestamp';

  @override
  String get transactionDetailsModal_blockNumber => 'Block Number';

  @override
  String get transactionDetailsModal_nonce => 'Nonce';

  @override
  String get transactionDetailsModal_addresses => 'Addresses';

  @override
  String get transactionDetailsModal_sender => 'Sender';

  @override
  String get transactionDetailsModal_recipient => 'Recipient';

  @override
  String get transactionDetailsModal_contractAddress => 'Contract Address';

  @override
  String get transactionDetailsModal_network => 'Network';

  @override
  String get transactionDetailsModal_chainType => 'Chain Type';

  @override
  String get transactionDetailsModal_networkName => 'Network';

  @override
  String get transactionDetailsModal_gasFees => 'Gas & Fees';

  @override
  String get transactionDetailsModal_fee => 'Fee';

  @override
  String get transactionDetailsModal_gasUsed => 'Gas Used';

  @override
  String get transactionDetailsModal_gasLimit => 'Gas Limit';

  @override
  String get transactionDetailsModal_gasPrice => 'Gas Price';

  @override
  String get transactionDetailsModal_effectiveGasPrice => 'Effective Gas Price';

  @override
  String get transactionDetailsModal_blobGasUsed => 'Blob Gas Used';

  @override
  String get transactionDetailsModal_blobGasPrice => 'Blob Gas Price';

  @override
  String get transactionDetailsModal_error => 'Error';

  @override
  String get transactionDetailsModal_errorMessage => 'Error Message';

  @override
  String get amountSection_transfer => 'Transfer';

  @override
  String get amountSection_pending => 'Pending';

  @override
  String get amountSection_confirmed => 'Confirmed';

  @override
  String get amountSection_rejected => 'Rejected';

  @override
  String get appConnectModalContent_swipeToConnect => 'Swipe to Connect';

  @override
  String get appConnectModalContent_noAccounts => 'No accounts available';

  @override
  String get browserActionMenuShare => 'Share';

  @override
  String get browserActionMenuCopyLink => 'Copy Link';

  @override
  String get browserActionMenuClose => 'Close';

  @override
  String get keystoreBackupTitle => 'Keystore Backup';

  @override
  String get keystoreBackupWarningTitle => 'Secure Your Keystore File';

  @override
  String get keystoreBackupWarningMessage => 'The keystore file contains your encrypted private keys. Keep this file in a secure location and never share it with anyone. You will need the password you create to decrypt this file.';

  @override
  String get keystoreBackupConfirmPasswordHint => 'Confirm Password';

  @override
  String get keystoreBackupCreateButton => 'Create Backup';

  @override
  String get keystoreBackupPasswordsDoNotMatch => 'Passwords do not match';

  @override
  String get keystoreBackupPasswordTooShort => 'Password must be at least 8 characters';

  @override
  String get keystoreBackupError => 'Error creating backup:';

  @override
  String get keystoreBackupShareButton => 'Share Keystore File';

  @override
  String get keystoreBackupDoneButton => 'Done';

  @override
  String get keystoreBackupSuccessTitle => 'Backup Created Successfully';

  @override
  String get keystoreBackupSuccessMessage => 'Your keystore file has been created. Remember to keep both the file and your password safe.';

  @override
  String get keystoreBackupSaveAsButton => 'Save to File';

  @override
  String get keystoreBackupSaveDialogTitle => 'Save Keystore File';

  @override
  String get keystoreBackupSavedSuccess => 'Keystore file saved successfully';

  @override
  String get keystoreBackupSaveFailed => 'Failed to save keystore file';

  @override
  String get keystoreBackupTempLocation => 'Temporary file location';

  @override
  String get keystorePasswordHint => 'Enter your keystore password';

  @override
  String get keystoreRestoreButton => 'Restore Wallet';

  @override
  String get keystoreRestoreExtError => 'Please select a valid .zp file';

  @override
  String get keystoreRestoreNoFile => 'No keystore files found';

  @override
  String get keystoreRestoreFilesTitle => 'Keystore Files';

  @override
  String get editGasDialogTitle => 'Edit Gas Parameters';

  @override
  String get editGasDialogGasPrice => 'Gas Price';

  @override
  String get editGasDialogMaxPriorityFee => 'Max Priority Fee';

  @override
  String get editGasDialogGasLimit => 'Gas Limit';

  @override
  String get editGasDialogCancel => 'Cancel';

  @override
  String get editGasDialogSave => 'Save';

  @override
  String get editGasDialogInvalidGasValues => 'Invalid gas values. Please check your inputs.';

  @override
  String get addLedgerAccountPageAppBarTitle => 'Add Ledger Account';

  @override
  String get addLedgerAccountPageGetAccountsButton => 'Get Accounts';

  @override
  String get addLedgerAccountPageCreateButton => 'Create';

  @override
  String get addLedgerAccountPageAddButton => 'Add';

  @override
  String get addLedgerAccountPageScanningMessage => 'Scanning for Ledger devices...';

  @override
  String get addLedgerAccountPageNoDevicesMessage => 'No Ledger devices found';

  @override
  String get addLedgerAccountPageBluetoothOffError => 'Bluetooth is turned off. Please enable it to scan for Ledger devices.';

  @override
  String get addLedgerAccountPageEmptyWalletNameError => 'Wallet name cannot be empty';

  @override
  String get addLedgerAccountPageWalletNameTooLongError => 'Wallet name is too long (max 24 characters)';

  @override
  String addLedgerAccountPageFailedToScanError(Object error) {
    return 'Failed to scan for Ledger devices: $error';
  }

  @override
  String get addLedgerAccountPageNetworkOrLedgerMissingError => 'Network or Ledger data is missing';

  @override
  String get addLedgerAccountPageNoAccountsSelectedError => 'No accounts selected';

  @override
  String get addLedgerAccountPageNoWalletSelectedError => 'No wallet selected';

  @override
  String get transactionHistoryTitle => 'Transaction History';

  @override
  String get transactionHistoryDescription => 'Show addresses from transaction history in the address book.';

  @override
  String get zilStakePageTitle => 'Zilliqa Staking';

  @override
  String get noStakingPoolsFound => 'No Staking Pools Found';

  @override
  String get aprSort => 'APR';

  @override
  String get commissionSort => 'Commission';

  @override
  String get tvlSort => 'TVL';

  @override
  String get claimButton => 'Claim';

  @override
  String get stakeButton => 'Stake';

  @override
  String get unstakeButton => 'Unstake';

  @override
  String get reinvest => 'Reinvest';

  @override
  String get aprLabel => 'APR';

  @override
  String get commissionLabel => 'Commission';

  @override
  String get tvlLabel => 'TVL';

  @override
  String get lpStakingBadge => 'LP Staking';

  @override
  String get stakedAmount => 'Staked';

  @override
  String get rewardsAvailable => 'Rewards';

  @override
  String get pendingWithdrawals => 'Pending Withdrawals';

  @override
  String get amount => 'Amount';

  @override
  String get claimableIn => 'Claimable in';

  @override
  String get blocks => 'blocks';

  @override
  String get unbondingPeriod => 'Unbonding Period';

  @override
  String get currentBlock => 'Current Block';

  @override
  String get version => 'Version';

  @override
  String get rewardsProgressTitle => 'Rewards Progress';

  @override
  String get durationDay => 'd';

  @override
  String get durationHour => 'h';

  @override
  String get durationMinute => 'm';

  @override
  String get durationLessThanAMinute => '< 1m';

  @override
  String get durationNotAvailable => 'N/A';

  @override
  String get nodes => 'nodes';
}

```

`lib/l10n/app_localizations_ja.dart`:

```dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Japanese (`ja`).
class AppLocalizationsJa extends AppLocalizations {
  AppLocalizationsJa([String locale = 'ja']) : super(locale);

  @override
  String get appTitle => 'ZilPay ウォレット';

  @override
  String get initialPagerestoreZilPay => 'ZilPay 1.0を復元!';

  @override
  String get initialPagegetStarted => '始める';

  @override
  String get restoreRKStorageTitle => 'ZilPay 1.0から2.0への移行';

  @override
  String get restoreRKStorageAccountsPrompt => 'ZilPay 2.0に移行するアカウント。パスワードを入力してください。';

  @override
  String get restoreRKStoragePasswordHint => 'パスワード';

  @override
  String get restoreRKStorageEnterPassword => 'パスワードを入力';

  @override
  String get restoreRKStorageErrorPrefix => 'エラー:';

  @override
  String get restoreRKStorageRestoreButton => '復元';

  @override
  String get restoreRKStorageSkipButton => 'スキップ';

  @override
  String get accountItemBalanceLabel => '残高:';

  @override
  String get sendTokenPageTitle => '';

  @override
  String get sendTokenPageSubmitButton => '送信';

  @override
  String get aboutPageTitle => 'アプリについて';

  @override
  String get aboutPageAppName => 'ZilPay';

  @override
  String get aboutPageAppDescription => '安全なブロックチェーンウォレット';

  @override
  String get aboutPageAppInfoTitle => 'アプリ情報';

  @override
  String get aboutPageVersionLabel => 'バージョン';

  @override
  String get aboutPageBuildDateLabel => 'ビルド日';

  @override
  String get aboutPageBuildDateValue => '2025年3月10日';

  @override
  String get aboutPagePlatformLabel => 'プラットフォーム';

  @override
  String get aboutPageDeveloperTitle => '開発者';

  @override
  String get aboutPageAuthorLabel => '作者';

  @override
  String get aboutPageAuthorValue => 'Rinat (hicaru)';

  @override
  String get aboutPageWebsiteLabel => 'ウェブサイト';

  @override
  String get aboutPageWebsiteValue => 'https://zilpay.io';

  @override
  String get aboutPageLegalTitle => '法的情報';

  @override
  String get aboutPagePrivacyPolicy => 'プライバシーポリシー';

  @override
  String get aboutPageTermsOfService => '利用規約';

  @override
  String get aboutPageLicenses => 'ライセンス';

  @override
  String get aboutPageLegalese => '© 2025 ZilPay. 全ての権利を保有。';

  @override
  String get languagePageTitle => '言語';

  @override
  String get languagePageSystem => 'システム';

  @override
  String get secretKeyGeneratorPageTitle => '秘密鍵';

  @override
  String get secretKeyGeneratorPagePrivateKey => 'プライベートキー';

  @override
  String get secretKeyGeneratorPagePublicKey => 'パブリックキー';

  @override
  String get secretKeyGeneratorPageBackupCheckbox => '秘密鍵をバックアップしました';

  @override
  String get secretKeyGeneratorPageNextButton => '次へ';

  @override
  String get walletPageTitle => '';

  @override
  String get walletPageWalletNameHint => 'ウォレット名';

  @override
  String get walletPagePreferencesTitle => 'ウォレット設定';

  @override
  String get walletPageManageConnections => '接続の管理';

  @override
  String get walletPageBackup => 'バックアップ';

  @override
  String get walletPageDeleteWallet => 'ウォレットを削除';

  @override
  String get walletPageBiometricReason => '生体認証を有効にする';

  @override
  String get networkPageTitle => '';

  @override
  String get networkPageShowTestnet => 'テストネットを表示';

  @override
  String get networkPageSearchHint => '検索';

  @override
  String get networkPageAddedNetworks => '追加したネットワーク';

  @override
  String get networkPageAvailableNetworks => '利用可能なネットワーク';

  @override
  String get networkPageLoadError => 'ネットワークチェーンの読み込みに失敗: ';

  @override
  String get networkPageAddError => 'ネットワークの追加に失敗: ';

  @override
  String get receivePageTitle => '受信';

  @override
  String receivePageWarning(Object chainName, Object tokenSymbol) {
    return 'このアドレスには$chainName($tokenSymbol)資産のみを送信してください。他の資産は永久に失われます。';
  }

  @override
  String get receivePageAccountNameHint => 'アカウント名';

  @override
  String get receivePageAmountDialogTitle => '金額を入力';

  @override
  String get receivePageAmountDialogHint => '0.0';

  @override
  String get receivePageAmountDialogCancel => 'キャンセル';

  @override
  String get receivePageAmountDialogConfirm => '確認';

  @override
  String get securityPageTitle => 'セキュリティ';

  @override
  String get securityPageNetworkPrivacy => 'ネットワークプライバシー';

  @override
  String get securityPageEnsDomains => 'アドレスバーにENSドメインを表示';

  @override
  String get securityPageEnsDescription => 'この機能を使用すると、IPアドレスがIPFSサードパーティサービスに公開されることに注意してください。';

  @override
  String get securityPageIpfsGateway => 'IPFSゲートウェイ';

  @override
  String get securityPageIpfsDescription => 'ZIlPayは、IPFS上のNFT画像の表示、ブラウザのアドレスバーに入力されたENS(ZNS)アドレスに関する情報の表示、およびトークンアイコンの取得にサードパーティサービスを使用します。これらのサービスを利用する際、IPアドレスが公開される可能性があります。';

  @override
  String get securityPageTokensFetcherTitle => 'トークンフェッチャー';

  @override
  String get securityPageTokensFetcherDescription => 'セキュリティページのトークンフェッチャー設定。有効にすると、トークンがサーバーから自動的に取得され、追加できます。';

  @override
  String get securityPageNodeRanking => 'ノードランキング';

  @override
  String get securityPageNodeDescription => '最適なノードを取得するためにZilPayサーバーにリクエストを送信';

  @override
  String get securityPageEncryptionLevel => '暗号化レベル';

  @override
  String get securityPageProtection => '保護';

  @override
  String get securityPageCpuLoad => 'CPU負荷';

  @override
  String get securityPageAes256 => 'AES256';

  @override
  String get securityPageKuznechikGost => 'KUZNECHIK-GOST';

  @override
  String get securityPageNtruPrime => 'NTRUPrime';

  @override
  String get securityPageCyber => 'サイバー';

  @override
  String get securityPageUnknown => '不明';

  @override
  String get webViewPageDntLabel => 'DNT';

  @override
  String get webViewPageIncognitoLabel => 'シークレット';

  @override
  String get webViewPageLoadError => '読み込みに失敗';

  @override
  String get webViewPageTryAgain => '再試行';

  @override
  String get secretPhraseGeneratorPageTitle => '新しいウォレット';

  @override
  String get secretPhraseGeneratorPageBackupCheckbox => '単語をバックアップしました';

  @override
  String get secretPhraseGeneratorPageNextButton => '次へ';

  @override
  String get homePageTestnetLabel => 'テストネット';

  @override
  String get homePageErrorTitle => '信号なし';

  @override
  String get homePageSendButton => '送信';

  @override
  String get homePageReceiveButton => '受信';

  @override
  String get revealSecretKeyTitle => '秘密鍵を表示';

  @override
  String get revealSecretKeyPasswordHint => 'パスワード';

  @override
  String get revealSecretKeyInvalidPassword => '無効なパスワード、エラー:';

  @override
  String get revealSecretKeySubmitButton => '送信';

  @override
  String get revealSecretKeyDoneButton => '完了';

  @override
  String get revealSecretKeyScamAlertTitle => '詐欺警告';

  @override
  String get revealSecretKeyScamAlertMessage => '秘密鍵を他人と共有したり、いかなるウェブサイトにも入力したりしないでください。';

  @override
  String get setupNetworkSettingsPageTestnetSwitch => 'テストネット';

  @override
  String get setupNetworkSettingsPageSearchHint => '検索';

  @override
  String get setupNetworkSettingsPageNoNetworks => '利用可能なネットワークがありません';

  @override
  String setupNetworkSettingsPageNoResults(Object searchQuery) {
    return '\"$searchQuery\"に一致するネットワークが見つかりません';
  }

  @override
  String get setupNetworkSettingsPageNextButton => '次へ';

  @override
  String get setupNetworkSettingsPageTestnetLabel => 'テストネット';

  @override
  String get setupNetworkSettingsPageMainnetLabel => 'メインネット';

  @override
  String get setupNetworkSettingsPageChainIdLabel => 'チェーンID:';

  @override
  String get setupNetworkSettingsPageTokenLabel => 'トークン:';

  @override
  String get setupNetworkSettingsPageExplorerLabel => 'エクスプローラー:';

  @override
  String get appearanceSettingsPageTitle => '外観設定';

  @override
  String get appearanceSettingsPageCompactNumbersTitle => 'コンパクト数字';

  @override
  String get appearanceSettingsPageCompactNumbersDescription => '省略形の数字を表示します（例：20,000の代わりに20K）。';

  @override
  String get appearanceSettingsPageDeviceSettingsTitle => 'デバイス設定';

  @override
  String get appearanceSettingsPageDeviceSettingsSubtitle => 'システムデフォルト';

  @override
  String get appearanceSettingsPageDeviceSettingsDescription => 'デバイスの外観に合わせます。ウォレットのテーマはシステム設定に基づいて自動的に調整されます。';

  @override
  String get appearanceSettingsPageDarkModeTitle => 'ダークモード';

  @override
  String get appearanceSettingsPageDarkModeSubtitle => '常にダーク';

  @override
  String get appearanceSettingsPageDarkModeDescription => 'デバイス設定に関係なく、常にダークテーマを有効にします。';

  @override
  String get appearanceSettingsPageLightModeTitle => 'ライトモード';

  @override
  String get appearanceSettingsPageLightModeSubtitle => '常にライト';

  @override
  String get appearanceSettingsPageLightModeDescription => 'デバイス設定に関係なく、常にライトテーマを有効にします。';

  @override
  String get loginPageBiometricReason => '認証してください';

  @override
  String loginPageWalletTitle(Object index) {
    return 'ウォレット $index';
  }

  @override
  String get loginPagePasswordHint => 'パスワード';

  @override
  String get loginPageUnlockButton => 'ロック解除';

  @override
  String get loginPageWelcomeBack => 'おかえりなさい';

  @override
  String get secretKeyRestorePageTitle => '秘密鍵を復元';

  @override
  String get secretKeyRestorePageHint => 'プライベートキー';

  @override
  String get secretKeyRestorePageInvalidFormat => '無効なプライベートキー形式';

  @override
  String get secretKeyRestorePageKeyTitle => 'プライベートキー';

  @override
  String get secretKeyRestorePageBackupLabel => '秘密鍵をバックアップしました';

  @override
  String get secretKeyRestorePageNextButton => '次へ';

  @override
  String get addAccountPageTitle => '新しいアカウントを追加';

  @override
  String get addAccountPageSubtitle => 'BIP39アカウントを作成';

  @override
  String addAccountPageDefaultName(Object index) {
    return 'アカウント $index';
  }

  @override
  String get addAccountPageNameHint => 'アカウント名';

  @override
  String get addAccountPageBip39Index => 'BIP39インデックス';

  @override
  String get addAccountPageUseBiometrics => '生体認証を使用';

  @override
  String get addAccountPagePasswordHint => 'パスワード';

  @override
  String get addAccountPageZilliqaLegacy => 'Zilliqaレガシー';

  @override
  String get addAccountPageBiometricReason => '新しいアカウントを作成するために認証';

  @override
  String addAccountPageBiometricError(Object error) {
    return '生体認証に失敗: $error';
  }

  @override
  String addAccountPageIndexExists(Object index) {
    return 'インデックス$indexのアカウントはすでに存在します';
  }

  @override
  String get addAccountPageBiometricFailed => '生体認証に失敗しました';

  @override
  String addAccountPageCreateFailed(Object error) {
    return 'アカウントの作成に失敗: $error';
  }

  @override
  String get addressBookPageTitle => 'アドレス帳';

  @override
  String get addressBookPageEmptyMessage => '連絡先とそのウォレットアドレスが\nここに表示されます。';

  @override
  String get addressBookPageDeleteConfirmationTitle => '連絡先を削除';

  @override
  String addressBookPageDeleteConfirmationMessage(String contactName) {
    return '本当に$contactNameをアドレス帳から削除しますか？';
  }

  @override
  String addressBookPageDeleteTooltip(String contactName) {
    return '$contactNameを削除';
  }

  @override
  String get cancel => 'キャンセル';

  @override
  String get delete => '削除';

  @override
  String get browserPageConnectedTab => '接続済み';

  @override
  String get browserPageExploreTab => '探索';

  @override
  String get browserPageNoExploreApps => '探索するアプリがまだありません';

  @override
  String browserPageSearchHint(Object engine) {
    return '$engineで検索するかアドレスを入力';
  }

  @override
  String get browserPageNoConnectedApps => '接続されたアプリはありません';

  @override
  String get historyPageTitle => 'トランザクション履歴';

  @override
  String get historyPageNoTransactions => 'トランザクションがありません';

  @override
  String get historyPageSearchHint => 'トランザクションを検索...';

  @override
  String get notificationsSettingsPageTitle => '通知';

  @override
  String get notificationsSettingsPagePushTitle => 'プッシュ通知';

  @override
  String get notificationsSettingsPagePushDescription => 'トランザクションの送信と確認、接続されたアプリからの通知を受け取ります。';

  @override
  String get notificationsSettingsPageWalletsTitle => 'ウォレット';

  @override
  String get notificationsSettingsPageWalletsDescription => 'ウォレットからの通知';

  @override
  String get notificationsSettingsPageWalletPrefix => 'ウォレット';

  @override
  String get revealSecretPhraseTitle => '秘密フレーズを表示';

  @override
  String get revealSecretPhrasePasswordHint => 'パスワード';

  @override
  String get revealSecretPhraseInvalidPassword => '無効なパスワード、エラー:';

  @override
  String get revealSecretPhraseRevealAfter => 'シードフレーズは次の時間後に表示されます:';

  @override
  String get revealSecretPhraseSubmitButton => '送信';

  @override
  String get revealSecretPhraseDoneButton => '完了';

  @override
  String get revealSecretPhraseScamAlertTitle => '詐欺警告';

  @override
  String get revealSecretPhraseScamAlertDescription => '秘密フレーズを他人と共有したり、いかなるウェブサイトにも入力したりしないでください。';

  @override
  String get cipherSettingsPageTitle => '暗号化設定';

  @override
  String get cipherSettingsPageAdvancedButton => '詳細';

  @override
  String get cipherSettingsPageStandardTitle => '標準暗号化';

  @override
  String get cipherSettingsPageStandardSubtitle => 'AES-256 + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageStandardDescription => 'AES-256とGOST標準KUZNECHIKによる基本的な暗号化。';

  @override
  String get cipherSettingsPageHybridTitle => 'ハイブリッド暗号化';

  @override
  String get cipherSettingsPageHybridSubtitle => 'CYBER + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageHybridDescription => 'CYBERとKUZNECHIK-GOSTアルゴリズムを組み合わせたハイブリッド暗号化。';

  @override
  String get cipherSettingsPageQuantumTitle => '量子耐性';

  @override
  String get cipherSettingsPageQuantumSubtitle => 'CYBER + KUZNECHIK + NTRUP1277';

  @override
  String get cipherSettingsPageQuantumDescription => 'NTRUP1277による高度な量子耐性暗号化。';

  @override
  String get cipherSettingsPageQuantumWarning => '量子耐性暗号化はパフォーマンスに影響を与える可能性があります';

  @override
  String get cipherSettingsPageConfirmButton => '確認';

  @override
  String get secretPhraseVerifyPageTitle => '秘密を確認';

  @override
  String get secretPhraseVerifyPageSkipButton => 'スキップ';

  @override
  String get secretPhraseVerifyPageSubtitle => 'Bip39秘密を確認';

  @override
  String get secretPhraseVerifyPageNextButton => '次へ';

  @override
  String get restoreSecretPhrasePageTitle => 'ウォレットを復元';

  @override
  String get restoreSecretPhrasePageRestoreButton => '復元';

  @override
  String get checksumValidationFailed => 'チェックサム検証に失敗しました';

  @override
  String get proceedDespiteInvalidChecksum => 'チェックサムエラーがありますが続行しますか？';

  @override
  String get settingsPageTitle => '設定';

  @override
  String get settingsPageZilliqaLegacy => 'Zilliqaレガシー';

  @override
  String get settingsPageCurrency => '通貨';

  @override
  String get settingsPageAppearance => '外観';

  @override
  String get settingsPageNotifications => '通知';

  @override
  String get settingsPageAddressBook => 'アドレス帳';

  @override
  String get settingsPageSecurityPrivacy => 'セキュリティとプライバシー';

  @override
  String get settingsPageNetworks => 'ネットワーク';

  @override
  String get settingsPageLanguage => '言語';

  @override
  String get settingsPageBrowser => 'ブラウザ';

  @override
  String get settingsPageTelegram => 'Telegram';

  @override
  String get settingsPageTwitter => 'Twitter';

  @override
  String get settingsPageGitHub => 'GitHub';

  @override
  String get settingsPageAbout => 'アプリについて';

  @override
  String get passwordSetupPageTitle => 'パスワード設定';

  @override
  String get passwordSetupPageSubtitle => 'パスワードを作成';

  @override
  String get passwordSetupPageWalletNameHint => 'ウォレット名';

  @override
  String get passwordSetupPagePasswordHint => 'パスワード';

  @override
  String get passwordSetupPageConfirmPasswordHint => 'パスワードを確認';

  @override
  String get passwordSetupPageEmptyWalletNameError => 'ウォレット名は空にできません';

  @override
  String get passwordSetupPageLongWalletNameError => 'ウォレット名が長すぎます';

  @override
  String get passwordSetupPageShortPasswordError => 'パスワードは8文字以上である必要があります';

  @override
  String get passwordSetupPageMismatchPasswordError => 'パスワードが一致しません';

  @override
  String get passwordSetupPageLegacyLabel => 'レガシー';

  @override
  String get passwordSetupPageCreateButton => 'パスワードを作成';

  @override
  String get passwordSetupPageAuthReason => 'クイックアクセスを有効にするために認証してください';

  @override
  String get passwordSetupPageSeedType => 'シード';

  @override
  String get passwordSetupPageKeyType => 'キー';

  @override
  String get passwordSetupPageUniversalNetwork => 'ユニバーサル';

  @override
  String get browserSettingsTitle => 'ブラウザ設定';

  @override
  String get browserSettingsBrowserOptions => 'ブラウザオプション';

  @override
  String get browserSettingsSearchEngine => '検索エンジン';

  @override
  String get browserSettingsSearchEngineDescription => 'デフォルトの検索エンジンを設定';

  @override
  String get browserSettingsSearchEngineTitle => '検索エンジン';

  @override
  String get browserSettingsContentBlocking => 'コンテンツブロック';

  @override
  String get browserSettingsContentBlockingDescription => 'コンテンツブロック設定を構成';

  @override
  String get browserSettingsContentBlockingTitle => 'コンテンツブロック';

  @override
  String get browserSettingsPrivacySecurity => 'プライバシーとセキュリティ';

  @override
  String get browserSettingsCookies => 'クッキー';

  @override
  String get browserSettingsCookiesDescription => 'ウェブサイトによるクッキーの保存と読み取りを許可';

  @override
  String get browserSettingsDoNotTrack => '追跡拒否';

  @override
  String get browserSettingsDoNotTrackDescription => 'ブラウジングを追跡しないようウェブサイトに要求';

  @override
  String get browserSettingsIncognitoMode => 'シークレットモード';

  @override
  String get browserSettingsIncognitoModeDescription => '履歴やクッキーを保存せずにブラウズ';

  @override
  String get browserSettingsPerformance => 'パフォーマンス';

  @override
  String get browserSettingsCache => 'キャッシュ';

  @override
  String get browserSettingsClearData => 'データを消去';

  @override
  String get browserSettingsClear => '消去';

  @override
  String get browserSettingsClearCookies => 'Cookieを消去';

  @override
  String get browserSettingsClearCookiesDescription => 'ウェブサイトによって保存されたすべてのCookieを削除';

  @override
  String get browserSettingsClearCache => 'キャッシュを消去';

  @override
  String get browserSettingsClearCacheDescription => 'ブラウジング中に保存された一時ファイルや画像を削除';

  @override
  String get browserSettingsClearLocalStorage => 'ローカルストレージを消去';

  @override
  String get browserSettingsClearLocalStorageDescription => 'デバイスに保存されているウェブサイトのデータを削除';

  @override
  String get browserSettingsCacheDescription => 'より速い読み込みのためにウェブサイトのデータを保存';

  @override
  String get genWalletOptionsTitle => 'ウォレットを生成';

  @override
  String get genWalletOptionsBIP39Title => 'BIP39';

  @override
  String get genWalletOptionsBIP39Subtitle => 'ニーモニックフレーズを生成';

  @override
  String get genWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get genWalletOptionsSLIP0039Subtitle => '共有付きニーモニックフレーズを生成';

  @override
  String get genWalletOptionsPrivateKeyTitle => 'プライベートキー';

  @override
  String get genWalletOptionsPrivateKeySubtitle => '1つのプライベートキーのみを生成';

  @override
  String get addWalletOptionsTitle => 'ウォレットを追加';

  @override
  String get addWalletOptionsNewWalletTitle => '新しいウォレット';

  @override
  String get addWalletOptionsNewWalletSubtitle => '新しいウォレットを作成';

  @override
  String get addWalletOptionsExistingWalletTitle => '既存のウォレット';

  @override
  String get addWalletOptionsExistingWalletSubtitle => '24の秘密回復単語でウォレットをインポート';

  @override
  String get addWalletOptionsPairWithLedgerTitle => 'Ledgerとペアリング';

  @override
  String get addWalletOptionsPairWithLedgerSubtitle => 'ハードウェアモジュール、Bluetooth';

  @override
  String get addWalletOptionsOtherOptions => 'その他のオプション';

  @override
  String get addWalletOptionsWatchAccountTitle => 'アカウントを監視';

  @override
  String get addWalletOptionsWatchAccountSubtitle => '回復フレーズなしでウォレットの活動をモニター';

  @override
  String get currencyConversionTitle => '主要通貨';

  @override
  String get currencyConversionSearchHint => '通貨を検索...';

  @override
  String get currencyConversionEngineTitle => '通貨エンジン';

  @override
  String get currencyConversionEngineDescription => '通貨レートを取得するエンジン';

  @override
  String get currencyConversionEngineSelectorTitle => '通貨エンジンを選択';

  @override
  String get currencyConversionEngineNone => 'なし';

  @override
  String get currencyConversionEngineNoneSubtitle => 'エンジンが選択されていません';

  @override
  String get currencyConversionEngineCoingecko => 'Coingecko';

  @override
  String get currencyConversionEngineCoingeckoSubtitle => 'Coingeckoからレートを取得';

  @override
  String get restoreWalletOptionsTitle => 'ウォレットを復元';

  @override
  String get restoreWalletOptionsBIP39Title => 'BIP39';

  @override
  String get restoreWalletOptionsBIP39Subtitle => 'ニーモニックフレーズで復元';

  @override
  String get restoreWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get restoreWalletOptionsSLIP0039Subtitle => '共有ニーモニックフレーズで復元';

  @override
  String get restoreWalletOptionsPrivateKeyTitle => 'プライベートキー';

  @override
  String get restoreWalletOptionsPrivateKeySubtitle => 'プライベートキーで復元';

  @override
  String get restoreWalletOptionsKeyStoreTitle => 'キーストアファイル';

  @override
  String get restoreWalletOptionsKeyStoreSubtitle => 'パスワードで暗号化されたバックアップファイルを使用してウォレットを復元';

  @override
  String get restoreWalletOptionsQRCodeTitle => 'QRコード';

  @override
  String get restoreWalletOptionsQRCodeSubtitle => 'QRコードスキャンでウォレットを復元';

  @override
  String get argonSettingsModalContentLowMemoryTitle => '低メモリ';

  @override
  String get argonSettingsModalContentLowMemorySubtitle => '64KB RAM、3反復';

  @override
  String get argonSettingsModalContentLowMemoryDescription => '最小メモリ使用量、低スペックデバイスに適しています。';

  @override
  String get argonSettingsModalContentOwaspTitle => 'OWASPデフォルト';

  @override
  String get argonSettingsModalContentOwaspSubtitle => '6.5MB RAM、2反復';

  @override
  String get argonSettingsModalContentOwaspDescription => '一般使用向けにOWASPが推奨。';

  @override
  String get argonSettingsModalContentSecureTitle => '安全';

  @override
  String get argonSettingsModalContentSecureSubtitle => '256MB RAM、4反復';

  @override
  String get argonSettingsModalContentSecureDescription => 'メモリと反復回数を増やした高セキュリティ。';

  @override
  String get argonSettingsModalContentSecretHint => '秘密を入力（任意）';

  @override
  String get argonSettingsModalContentConfirmButton => '確認';

  @override
  String get confirmTransactionContentPasswordHint => 'パスワード';

  @override
  String get confirmTransactionContentUnableToConfirm => '確認できません';

  @override
  String get confirmTransactionContentConfirm => '確認';

  @override
  String get confirmTransactionContentInsufficientBalance => '残高不足';

  @override
  String get confirmTransactionContentNoActiveAccount => 'アクティブなアカウントがありません';

  @override
  String get confirmTransactionContentFailedLoadTransfer => '送金詳細の読み込みに失敗';

  @override
  String get confirmTransactionEditGasButtonText => '編集';

  @override
  String get authReason => '認証してください';

  @override
  String get addChainModalContentWarning => 'ネットワーク詐欺とセキュリティリスクに注意してください。';

  @override
  String get addChainModalContentApprove => '承認';

  @override
  String get addChainModalContentDetails => '詳細';

  @override
  String get addChainModalContentNetworkName => 'ネットワーク名:';

  @override
  String get addChainModalContentCurrencySymbol => '通貨記号:';

  @override
  String get addChainModalContentChainId => 'チェーンID:';

  @override
  String get addChainModalContentBlockExplorer => 'ブロックエクスプローラー:';

  @override
  String get addAddressModalTitle => '連絡先を追加';

  @override
  String get addAddressModalDescription => 'アドレス帳に追加する連絡先名とウォレットアドレスを入力してください。';

  @override
  String get addAddressModalNameHint => '名前';

  @override
  String get addAddressModalAddressHint => 'ウォレットアドレス';

  @override
  String get addAddressModalNameEmptyError => '名前は空にできません';

  @override
  String get addAddressModalAddressEmptyError => 'アドレスは空にできません';

  @override
  String get addAddressModalButton => '連絡先を追加';

  @override
  String get tokenSelectModalContentSearchHint => '検索';

  @override
  String get signMessageModalContentAuthReason => 'メッセージに署名するために認証してください';

  @override
  String signMessageModalContentFailedToSign(Object error) {
    return '署名に失敗しました: $error';
  }

  @override
  String get signMessageModalContentTitle => 'メッセージに署名';

  @override
  String get signMessageModalContentDescription => 'ウォレットを使用して以下のメッセージを確認し、署名してください。';

  @override
  String get signMessageModalContentDomain => 'ドメイン：';

  @override
  String get signMessageModalContentChainId => 'チェーンID：';

  @override
  String get signMessageModalContentContract => 'コントラクト：';

  @override
  String get signMessageModalContentType => 'タイプ：';

  @override
  String get signMessageModalContentNoData => 'データなし';

  @override
  String get signMessageModalContentPasswordHint => 'パスワード';

  @override
  String get signMessageModalContentProcessing => '処理中...';

  @override
  String get signMessageModalContentSign => 'メッセージに署名';

  @override
  String get signMessageModalContentScanning => 'Ledgerデバイスをスキャン中...';

  @override
  String get signMessageModalContentNoLedgerDevices => 'Ledgerデバイスが見つかりませんでした';

  @override
  String get signMessageModalContentWalletNotSelected => 'ウォレットが選択されていません';

  @override
  String get signMessageModalContentLedgerNotSelected => 'Ledgerデバイスが選択されていません';

  @override
  String signMessageModalContentFailedToScanLedger(Object error) {
    return 'Ledgerデバイスのスキャンに失敗しました: $error';
  }

  @override
  String signMessageModalContentFailedToSignMessage(Object error) {
    return 'メッセージの署名に失敗しました: $error';
  }

  @override
  String get signMessageModalContentBluetoothOff => 'Bluetoothがオフになっています。Ledgerデバイスのスキャンには有効にしてください。';

  @override
  String get deleteWalletModalTitle => 'ウォレットを削除';

  @override
  String get deleteWalletModalWarning => '警告：この操作は元に戻せません。ウォレットは秘密フレーズを使用してのみ復元できます。アクセスできない場合、このアカウントに関連するすべての資金が永久に失われます。';

  @override
  String get deleteWalletModalSecretPhraseWarning => '続行する前に、秘密フレーズにアクセスできることを確認してください。';

  @override
  String get deleteWalletModalPasswordHint => 'パスワードを入力';

  @override
  String get deleteWalletModalSubmit => '送信';

  @override
  String get manageTokensModalContentSearchHint => '検索';

  @override
  String get addressSelectModalContentTitle => 'アドレスを選択';

  @override
  String get addressSelectModalContentSearchHint => '検索 / アドレス / ENS';

  @override
  String get addressSelectModalContentUnknown => '不明';

  @override
  String get addressSelectModalContentMyAccounts => 'マイアカウント';

  @override
  String get addressSelectModalContentAddressBook => 'アドレス帳';

  @override
  String get addressSelectModalContentHistory => '履歴';

  @override
  String get addressSelectModalContentSender => '送信者';

  @override
  String get changePasswordModalTitle => 'パスワード変更';

  @override
  String get changePasswordModalDescription => '現在のパスワードを入力し、ウォレットのセキュリティを更新するための新しいパスワードを選択してください。';

  @override
  String get changePasswordModalCurrentPasswordHint => '現在のパスワード';

  @override
  String get changePasswordModalNewPasswordHint => '新しいパスワード';

  @override
  String get changePasswordModalConfirmPasswordHint => '新しいパスワードを確認';

  @override
  String get changePasswordModalCurrentPasswordEmptyError => '現在のパスワードは空にできません';

  @override
  String get changePasswordModalPasswordLengthError => 'パスワードは6文字以上である必要があります';

  @override
  String get changePasswordModalPasswordsMismatchError => 'パスワードが一致しません';

  @override
  String get changePasswordModalButton => 'パスワード変更';

  @override
  String get confirmPasswordModalTitle => 'パスワードを確認';

  @override
  String get confirmPasswordModalDescription => '続行するにはパスワードを入力してください。';

  @override
  String get confirmPasswordModalHint => 'パスワード';

  @override
  String get confirmPasswordModalEmptyError => 'パスワードは空にできません';

  @override
  String get confirmPasswordModalGenericError => 'エラー:';

  @override
  String get confirmPasswordModalButton => '確認';

  @override
  String get qrScannerModalContentTitle => 'スキャン';

  @override
  String get qrScannerModalContentCameraInitError => 'カメラ初期化エラー:';

  @override
  String get qrScannerModalContentTorchError => 'トーチの切り替えに失敗:';

  @override
  String get qrScannerModalContentOpenSettings => '設定を開く';

  @override
  String get chainInfoModalContentTokenTitle => 'ネットワークトークン';

  @override
  String get chainInfoModalContentNetworkInfoTitle => 'ネットワーク情報';

  @override
  String get chainInfoModalContentChainLabel => 'チェーン';

  @override
  String get chainInfoModalContentShortNameLabel => '略称';

  @override
  String get chainInfoModalContentChainIdLabel => 'チェーンID';

  @override
  String get chainInfoModalContentSlip44Label => 'Slip44';

  @override
  String get chainInfoModalContentChainIdsLabel => 'チェーンID群';

  @override
  String get chainInfoModalContentTestnetLabel => 'テストネット';

  @override
  String get chainInfoModalContentYes => 'はい';

  @override
  String get chainInfoModalContentNo => 'いいえ';

  @override
  String get chainInfoModalContentDiffBlockTimeLabel => 'ブロック時間差';

  @override
  String get chainInfoModalContentFallbackEnabledLabel => 'フォールバック有効';

  @override
  String get chainInfoModalContentDecimalsLabel => '小数点';

  @override
  String get chainInfoModalContentRpcNodesTitle => 'RPCノード';

  @override
  String get chainInfoModalContentExplorersTitle => 'エクスプローラー';

  @override
  String get chainInfoModalContentDeleteProviderTitle => 'ネットワークを削除';

  @override
  String get chainInfoModalContentSwipeToDelete => '削除';

  @override
  String get switchChainNetworkContentTitle => 'ネットワークを選択';

  @override
  String get switchChainNetworkContentButton => 'ネットワークを切り替え';

  @override
  String get switchChainNetworkContentTestnetLabel => 'テストネット';

  @override
  String get switchChainNetworkContentIdLabel => 'ID:';

  @override
  String get watchAssetModalContentTitle => '提案されたトークンを追加';

  @override
  String get watchAssetModalContentDescription => 'アプリによって提案された以下のトークンを確認して追加します。';

  @override
  String get watchAssetModalContentTokenLabel => 'トークン';

  @override
  String get watchAssetModalContentBalanceLabel => '残高';

  @override
  String get watchAssetModalContentLoadingButton => '残高...';

  @override
  String get watchAssetModalContentAddButton => '追加';

  @override
  String get connectedDappsModalSearchHint => 'DAppsを検索';

  @override
  String get connectedDappsModalNoDapps => '接続されたDAppsはありません';

  @override
  String dappListItemConnected(Object time) {
    return '$timeに接続';
  }

  @override
  String get dappListItemJustNow => 'たった今';

  @override
  String get secretRecoveryModalRevealPhraseTitle => '秘密回復フレーズを表示';

  @override
  String get secretRecoveryModalRevealPhraseDescription => 'ブラウザを変更したりコンピュータを移動する場合、アカウントにアクセスするにはこの秘密回復フレーズが必要です。安全で秘密の場所に保存してください。';

  @override
  String get secretRecoveryModalRevealPhraseButton => '表示';

  @override
  String get secretRecoveryModalShowKeysTitle => 'プライベートキーを表示';

  @override
  String get secretRecoveryModalShowKeysDescription => '警告：このキーを誰にも公開しないでください。プライベートキーを持つ人は、あなたのアカウントにある資産を盗むことができます。';

  @override
  String get secretRecoveryModalShowKeysButton => 'エクスポート';

  @override
  String get secretRecoveryModalKeystoreBackupTitle => 'キーストアバックアップ';

  @override
  String get secretRecoveryModalKeystoreBackupDescription => 'パスワードで保護された暗号化されたキーストアファイルに秘密鍵を保存します。これにより、ウォレットにさらなるセキュリティ層が提供されます。';

  @override
  String get secretRecoveryModalKeystoreBackupButton => 'キーストアバックアップを作成';

  @override
  String get backupConfirmationContentTitle => 'バックアップ確認';

  @override
  String get backupConfirmationWarning => '警告：シードフレーズを正確な順序で紛失または忘れた場合、資金は永久に失われます。シードフレーズを他人と共有しないでください。共有すると資金が盗まれる可能性があります。BIP39リカバリーは厳格であり、復元時の単語の間違いは資金の損失につながります。';

  @override
  String get backupConfirmationContentWrittenDown => 'すべてを書き留めました';

  @override
  String get backupConfirmationContentSafelyStored => 'バックアップを安全に保管しました';

  @override
  String get backupConfirmationContentWontLose => 'バックアップを失わないよう注意します';

  @override
  String get backupConfirmationContentNotShare => 'これらの単語を誰とも共有しないことを理解しています';

  @override
  String get counterMaxValueError => '最大値に達しました';

  @override
  String get counterMinValueError => '最小値に達しました';

  @override
  String get biometricSwitchFaceId => 'Face IDを有効にする';

  @override
  String get biometricSwitchFingerprint => '指紋認証を有効にする';

  @override
  String get biometricSwitchBiometric => '生体認証ログインを有効にする';

  @override
  String get biometricSwitchPinCode => 'デバイスPINを有効にする';

  @override
  String get gasFeeOptionLow => '低';

  @override
  String get gasFeeOptionMarket => '市場';

  @override
  String get gasFeeOptionAggressive => '積極的';

  @override
  String get gasDetailsEstimatedGas => '推定ガス:';

  @override
  String get gasDetailsGasPrice => 'ガス価格:';

  @override
  String get gasDetailsBaseFee => '基本料金:';

  @override
  String get gasDetailsPriorityFee => '優先料金:';

  @override
  String get gasDetailsMaxFee => '最大料金:';

  @override
  String get tokenTransferAmountUnknown => '不明';

  @override
  String get transactionDetailsModal_transaction => '取引';

  @override
  String get transactionDetailsModal_hash => 'ハッシュ';

  @override
  String get transactionDetailsModal_sig => '署名';

  @override
  String get transactionDetailsModal_timestamp => 'タイムスタンプ';

  @override
  String get transactionDetailsModal_blockNumber => 'ブロック番号';

  @override
  String get transactionDetailsModal_nonce => 'ナンス';

  @override
  String get transactionDetailsModal_addresses => 'アドレス';

  @override
  String get transactionDetailsModal_sender => '送信者';

  @override
  String get transactionDetailsModal_recipient => '受信者';

  @override
  String get transactionDetailsModal_contractAddress => 'コントラクトアドレス';

  @override
  String get transactionDetailsModal_network => 'ネットワーク';

  @override
  String get transactionDetailsModal_chainType => 'チェーンタイプ';

  @override
  String get transactionDetailsModal_networkName => 'ネットワーク';

  @override
  String get transactionDetailsModal_gasFees => 'ガスと手数料';

  @override
  String get transactionDetailsModal_fee => '手数料';

  @override
  String get transactionDetailsModal_gasUsed => '使用ガス';

  @override
  String get transactionDetailsModal_gasLimit => 'ガス制限';

  @override
  String get transactionDetailsModal_gasPrice => 'ガス価格';

  @override
  String get transactionDetailsModal_effectiveGasPrice => '有効ガス価格';

  @override
  String get transactionDetailsModal_blobGasUsed => 'ブロブガス使用量';

  @override
  String get transactionDetailsModal_blobGasPrice => 'ブロブガス価格';

  @override
  String get transactionDetailsModal_error => 'エラー';

  @override
  String get transactionDetailsModal_errorMessage => 'エラーメッセージ';

  @override
  String get amountSection_transfer => '送金';

  @override
  String get amountSection_pending => '保留中';

  @override
  String get amountSection_confirmed => '確認済み';

  @override
  String get amountSection_rejected => '拒否済み';

  @override
  String get appConnectModalContent_swipeToConnect => 'スワイプして接続';

  @override
  String get appConnectModalContent_noAccounts => 'アカウントがありません';

  @override
  String get browserActionMenuShare => '共有';

  @override
  String get browserActionMenuCopyLink => 'リンクをコピー';

  @override
  String get browserActionMenuClose => '閉じる';

  @override
  String get keystoreBackupTitle => 'キーストアバックアップ';

  @override
  String get keystoreBackupWarningTitle => 'キーストアファイルを安全に保管';

  @override
  String get keystoreBackupWarningMessage => 'キーストアファイルには暗号化された秘密鍵が含まれています。このファイルを安全な場所に保管し、誰とも共有しないでください。このファイルを復号化するには、作成したパスワードが必要です。';

  @override
  String get keystoreBackupConfirmPasswordHint => 'パスワードを確認';

  @override
  String get keystoreBackupCreateButton => 'バックアップを作成';

  @override
  String get keystoreBackupPasswordsDoNotMatch => 'パスワードが一致しません';

  @override
  String get keystoreBackupPasswordTooShort => 'パスワードは8文字以上である必要があります';

  @override
  String get keystoreBackupError => 'バックアップ作成エラー：';

  @override
  String get keystoreBackupShareButton => 'キーストアファイルを共有';

  @override
  String get keystoreBackupDoneButton => '完了';

  @override
  String get keystoreBackupSuccessTitle => 'バックアップの作成に成功';

  @override
  String get keystoreBackupSuccessMessage => 'キーストアファイルが作成されました。ファイルとパスワードの両方を安全に保管することを忘れないでください。';

  @override
  String get keystoreBackupSaveAsButton => 'ファイルとして保存';

  @override
  String get keystoreBackupSaveDialogTitle => 'キーストアファイルを保存';

  @override
  String get keystoreBackupSavedSuccess => 'キーストアファイルが正常に保存されました';

  @override
  String get keystoreBackupSaveFailed => 'キーストアファイルの保存に失敗しました';

  @override
  String get keystoreBackupTempLocation => '一時ファイルの場所';

  @override
  String get keystorePasswordHint => 'キーストアのパスワードを入力してください';

  @override
  String get keystoreRestoreButton => 'ウォレットを復元';

  @override
  String get keystoreRestoreExtError => '有効な.zpファイルを選択してください';

  @override
  String get keystoreRestoreNoFile => 'キーストアファイルが見つかりません';

  @override
  String get keystoreRestoreFilesTitle => 'キーストアファイル';

  @override
  String get editGasDialogTitle => 'ガスパラメータの編集';

  @override
  String get editGasDialogGasPrice => 'ガス価格';

  @override
  String get editGasDialogMaxPriorityFee => '最大優先手数料';

  @override
  String get editGasDialogGasLimit => 'ガスリミット';

  @override
  String get editGasDialogCancel => 'キャンセル';

  @override
  String get editGasDialogSave => '保存';

  @override
  String get editGasDialogInvalidGasValues => '無効なガス値です。入力を確認してください。';

  @override
  String get addLedgerAccountPageAppBarTitle => 'Ledgerアカウントを追加';

  @override
  String get addLedgerAccountPageGetAccountsButton => 'アカウントを取得';

  @override
  String get addLedgerAccountPageCreateButton => '作成';

  @override
  String get addLedgerAccountPageAddButton => '追加';

  @override
  String get addLedgerAccountPageScanningMessage => 'Ledgerデバイスをスキャン中...';

  @override
  String get addLedgerAccountPageNoDevicesMessage => 'Ledgerデバイスが見つかりません';

  @override
  String get addLedgerAccountPageBluetoothOffError => 'Bluetoothがオフになっています。Ledgerデバイスをスキャンするためにオンにしてください。';

  @override
  String get addLedgerAccountPageEmptyWalletNameError => 'ウォレット名は空にできません';

  @override
  String get addLedgerAccountPageWalletNameTooLongError => 'ウォレット名が長すぎます（最大24文字）';

  @override
  String addLedgerAccountPageFailedToScanError(Object error) {
    return 'Ledgerデバイスのスキャンに失敗しました：$error';
  }

  @override
  String get addLedgerAccountPageNetworkOrLedgerMissingError => 'ネットワークまたはLedgerデータが不足しています';

  @override
  String get addLedgerAccountPageNoAccountsSelectedError => 'アカウントが選択されていません';

  @override
  String get addLedgerAccountPageNoWalletSelectedError => 'ウォレットが選択されていません';

  @override
  String get transactionHistoryTitle => '取引履歴';

  @override
  String get transactionHistoryDescription => 'アドレス帳に取引履歴からのアドレスを表示します。';

  @override
  String get zilStakePageTitle => 'Zilliqa ステーキング';

  @override
  String get noStakingPoolsFound => 'ステーキングプールが見つかりません';

  @override
  String get aprSort => 'APR';

  @override
  String get commissionSort => '手数料';

  @override
  String get tvlSort => 'TVL';

  @override
  String get claimButton => '請求';

  @override
  String get stakeButton => 'ステーク';

  @override
  String get unstakeButton => 'アンステーク';

  @override
  String get reinvest => '再投資';

  @override
  String get aprLabel => 'APR';

  @override
  String get commissionLabel => '手数料';

  @override
  String get tvlLabel => 'TVL';

  @override
  String get lpStakingBadge => 'LP ステーキング';

  @override
  String get stakedAmount => 'ステーク済み';

  @override
  String get rewardsAvailable => '報酬';

  @override
  String get pendingWithdrawals => '保留中の出金';

  @override
  String get amount => '量';

  @override
  String get claimableIn => '請求可能まで';

  @override
  String get blocks => 'ブロック';

  @override
  String get unbondingPeriod => 'アンボンディング期間';

  @override
  String get currentBlock => '現在のブロック';

  @override
  String get version => 'バージョン';

  @override
  String get rewardsProgressTitle => '報酬の進捗';

  @override
  String get durationDay => '日';

  @override
  String get durationHour => '時間';

  @override
  String get durationMinute => '分';

  @override
  String get durationLessThanAMinute => '< 1分';

  @override
  String get durationNotAvailable => '適用外';

  @override
  String get nodes => 'ノード';
}

```

`lib/l10n/app_localizations_ru.dart`:

```dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Russian (`ru`).
class AppLocalizationsRu extends AppLocalizations {
  AppLocalizationsRu([String locale = 'ru']) : super(locale);

  @override
  String get appTitle => 'ZilPay Кошелек';

  @override
  String get initialPagerestoreZilPay => 'Восстановить ZilPay 1.0!';

  @override
  String get initialPagegetStarted => 'Начать';

  @override
  String get restoreRKStorageTitle => 'Перенос ZilPay 1.0 в 2.0';

  @override
  String get restoreRKStorageAccountsPrompt => 'Аккаунты для переноса в ZilPay 2.0. Введите пароль.';

  @override
  String get restoreRKStoragePasswordHint => 'Пароль';

  @override
  String get restoreRKStorageEnterPassword => 'Введите пароль';

  @override
  String get restoreRKStorageErrorPrefix => 'Ошибка:';

  @override
  String get restoreRKStorageRestoreButton => 'Восстановить';

  @override
  String get restoreRKStorageSkipButton => 'Пропустить';

  @override
  String get accountItemBalanceLabel => 'Баланс:';

  @override
  String get sendTokenPageTitle => '';

  @override
  String get sendTokenPageSubmitButton => 'Отправить';

  @override
  String get aboutPageTitle => 'О приложении';

  @override
  String get aboutPageAppName => 'ZilPay';

  @override
  String get aboutPageAppDescription => 'Ваш безопасный блокчейн-кошелек';

  @override
  String get aboutPageAppInfoTitle => 'Информация о приложении';

  @override
  String get aboutPageVersionLabel => 'Версия';

  @override
  String get aboutPageBuildDateLabel => 'Дата сборки';

  @override
  String get aboutPageBuildDateValue => '10 марта 2025';

  @override
  String get aboutPagePlatformLabel => 'Платформа';

  @override
  String get aboutPageDeveloperTitle => 'Разработчик';

  @override
  String get aboutPageAuthorLabel => 'Автор';

  @override
  String get aboutPageAuthorValue => 'Rinat (hicaru)';

  @override
  String get aboutPageWebsiteLabel => 'Веб-сайт';

  @override
  String get aboutPageWebsiteValue => 'https://zilpay.io';

  @override
  String get aboutPageLegalTitle => 'Юридическая информация';

  @override
  String get aboutPagePrivacyPolicy => 'Политика конфиденциальности';

  @override
  String get aboutPageTermsOfService => 'Условия использования';

  @override
  String get aboutPageLicenses => 'Лицензии';

  @override
  String get aboutPageLegalese => '© 2025 ZilPay. Все права защищены.';

  @override
  String get languagePageTitle => 'Язык';

  @override
  String get languagePageSystem => 'Системный';

  @override
  String get secretKeyGeneratorPageTitle => 'Секретный ключ';

  @override
  String get secretKeyGeneratorPagePrivateKey => 'Приватный ключ';

  @override
  String get secretKeyGeneratorPagePublicKey => 'Публичный ключ';

  @override
  String get secretKeyGeneratorPageBackupCheckbox => 'Я сделал резервную копию секретного ключа';

  @override
  String get secretKeyGeneratorPageNextButton => 'Далее';

  @override
  String get walletPageTitle => '';

  @override
  String get walletPageWalletNameHint => 'Название кошелька';

  @override
  String get walletPagePreferencesTitle => 'Настройки кошелька';

  @override
  String get walletPageManageConnections => 'Управление подключениями';

  @override
  String get walletPageBackup => 'Резервная копия';

  @override
  String get walletPageDeleteWallet => 'Удалить кошелек';

  @override
  String get walletPageBiometricReason => 'Включить биометрическую аутентификацию';

  @override
  String get networkPageTitle => '';

  @override
  String get networkPageShowTestnet => 'Показать тестовую сеть';

  @override
  String get networkPageSearchHint => 'Поиск';

  @override
  String get networkPageAddedNetworks => 'Добавленные сети';

  @override
  String get networkPageAvailableNetworks => 'Доступные сети';

  @override
  String get networkPageLoadError => 'Не удалось загрузить сети: ';

  @override
  String get networkPageAddError => 'Не удалось добавить сеть: ';

  @override
  String get receivePageTitle => 'Получить';

  @override
  String receivePageWarning(Object chainName, Object tokenSymbol) {
    return 'Отправляйте только активы $chainName($tokenSymbol) на этот адрес. Другие активы будут потеряны навсегда.';
  }

  @override
  String get receivePageAccountNameHint => 'Имя аккаунта';

  @override
  String get receivePageAmountDialogTitle => 'Введите сумму';

  @override
  String get receivePageAmountDialogHint => '0.0';

  @override
  String get receivePageAmountDialogCancel => 'Отмена';

  @override
  String get receivePageAmountDialogConfirm => 'Подтвердить';

  @override
  String get securityPageTitle => 'Безопасность';

  @override
  String get securityPageNetworkPrivacy => 'Приватность сети';

  @override
  String get securityPageEnsDomains => 'Показывать ENS домены в адресной строке';

  @override
  String get securityPageEnsDescription => 'Имейте в виду, что использование этой функции раскрывает ваш IP-адрес сторонним сервисам IPFS.';

  @override
  String get securityPageIpfsGateway => 'IPFS шлюз';

  @override
  String get securityPageIpfsDescription => 'ZIlPay использует сторонние сервисы для отображения изображений ваших NFT, хранящихся в IPFS, информации, связанной с ENS(ZNS) адресами в адресной строке браузера, и получения иконок для различных токенов. Ваш IP-адрес может быть раскрыт этим сервисам при их использовании.';

  @override
  String get securityPageTokensFetcherTitle => 'Получатель токенов';

  @override
  String get securityPageTokensFetcherDescription => 'Настройка получения токенов на странице безопасности. Если включена, токены будут автоматически запрашиваться с сервера и могут быть добавлены.';

  @override
  String get securityPageNodeRanking => 'Ранжирование узлов';

  @override
  String get securityPageNodeDescription => 'Отправлять запросы на сервер ZilPay для получения лучшего узла';

  @override
  String get securityPageEncryptionLevel => 'Уровень шифрования';

  @override
  String get securityPageProtection => 'Защита';

  @override
  String get securityPageCpuLoad => 'Нагрузка ЦП';

  @override
  String get securityPageAes256 => 'AES256';

  @override
  String get securityPageKuznechikGost => 'КУЗНЕЧИК-ГОСТ';

  @override
  String get securityPageNtruPrime => 'NTRUPrime';

  @override
  String get securityPageCyber => 'Cyber';

  @override
  String get securityPageUnknown => 'Неизвестно';

  @override
  String get webViewPageDntLabel => 'DNT';

  @override
  String get webViewPageIncognitoLabel => 'Инкогнито';

  @override
  String get webViewPageLoadError => 'Ошибка загрузки';

  @override
  String get webViewPageTryAgain => 'Попробовать снова';

  @override
  String get secretPhraseGeneratorPageTitle => 'Новый кошелек';

  @override
  String get secretPhraseGeneratorPageBackupCheckbox => 'Я сохранил секретные слова';

  @override
  String get secretPhraseGeneratorPageNextButton => 'Далее';

  @override
  String get homePageTestnetLabel => 'Тестовая сеть';

  @override
  String get homePageErrorTitle => 'Нет сигнала';

  @override
  String get homePageSendButton => 'Отправить';

  @override
  String get homePageReceiveButton => 'Получить';

  @override
  String get revealSecretKeyTitle => 'Показать секретный ключ';

  @override
  String get revealSecretKeyPasswordHint => 'Пароль';

  @override
  String get revealSecretKeyInvalidPassword => 'неверный пароль, ошибка:';

  @override
  String get revealSecretKeySubmitButton => 'Отправить';

  @override
  String get revealSecretKeyDoneButton => 'Готово';

  @override
  String get revealSecretKeyScamAlertTitle => 'ВНИМАНИЕ МОШЕННИЧЕСТВО';

  @override
  String get revealSecretKeyScamAlertMessage => 'Никогда не делитесь своим секретным ключом с кем-либо. Никогда не вводите его на каких-либо сайтах.';

  @override
  String get setupNetworkSettingsPageTestnetSwitch => 'Тестовая сеть';

  @override
  String get setupNetworkSettingsPageSearchHint => 'Поиск';

  @override
  String get setupNetworkSettingsPageNoNetworks => 'Нет доступных сетей';

  @override
  String setupNetworkSettingsPageNoResults(Object searchQuery) {
    return 'Не найдено сетей для \"$searchQuery\"';
  }

  @override
  String get setupNetworkSettingsPageNextButton => 'Далее';

  @override
  String get setupNetworkSettingsPageTestnetLabel => 'Тестовая сеть';

  @override
  String get setupNetworkSettingsPageMainnetLabel => 'Основная сеть';

  @override
  String get setupNetworkSettingsPageChainIdLabel => 'ID цепи:';

  @override
  String get setupNetworkSettingsPageTokenLabel => 'Токен:';

  @override
  String get setupNetworkSettingsPageExplorerLabel => 'Обозреватель:';

  @override
  String get appearanceSettingsPageTitle => 'Настройки внешнего вида';

  @override
  String get appearanceSettingsPageCompactNumbersTitle => 'Компактные числа';

  @override
  String get appearanceSettingsPageCompactNumbersDescription => 'Включите для отображения сокращенных чисел (например, 20K вместо 20,000).';

  @override
  String get appearanceSettingsPageDeviceSettingsTitle => 'Настройки устройства';

  @override
  String get appearanceSettingsPageDeviceSettingsSubtitle => 'Системные настройки';

  @override
  String get appearanceSettingsPageDeviceSettingsDescription => 'По умолчанию использовать настройки устройства. Тема кошелька будет автоматически настраиваться в соответствии с системными настройками.';

  @override
  String get appearanceSettingsPageDarkModeTitle => 'Темный режим';

  @override
  String get appearanceSettingsPageDarkModeSubtitle => 'Всегда темная';

  @override
  String get appearanceSettingsPageDarkModeDescription => 'Всегда использовать темную тему, независимо от настроек устройства.';

  @override
  String get appearanceSettingsPageLightModeTitle => 'Светлый режим';

  @override
  String get appearanceSettingsPageLightModeSubtitle => 'Всегда светлая';

  @override
  String get appearanceSettingsPageLightModeDescription => 'Всегда использовать светлую тему, независимо от настроек устройства.';

  @override
  String get loginPageBiometricReason => 'Пожалуйста, пройдите аутентификацию';

  @override
  String loginPageWalletTitle(Object index) {
    return 'Кошелек $index';
  }

  @override
  String get loginPagePasswordHint => 'Пароль';

  @override
  String get loginPageUnlockButton => 'Разблокировать';

  @override
  String get loginPageWelcomeBack => 'С возвращением';

  @override
  String get secretKeyRestorePageTitle => 'Восстановление секретного ключа';

  @override
  String get secretKeyRestorePageHint => 'Приватный ключ';

  @override
  String get secretKeyRestorePageInvalidFormat => 'Неверный формат приватного ключа';

  @override
  String get secretKeyRestorePageKeyTitle => 'Приватный ключ';

  @override
  String get secretKeyRestorePageBackupLabel => 'Я сделал резервную копию моего секретного ключа';

  @override
  String get secretKeyRestorePageNextButton => 'Далее';

  @override
  String get addAccountPageTitle => 'Добавить новый аккаунт';

  @override
  String get addAccountPageSubtitle => 'Создать BIP39 аккаунт';

  @override
  String addAccountPageDefaultName(Object index) {
    return 'Аккаунт $index';
  }

  @override
  String get addAccountPageNameHint => 'Имя аккаунта';

  @override
  String get addAccountPageBip39Index => 'BIP39 индекс';

  @override
  String get addAccountPageUseBiometrics => 'Использовать биометрию';

  @override
  String get addAccountPagePasswordHint => 'Пароль';

  @override
  String get addAccountPageZilliqaLegacy => 'Zilliqa Legacy';

  @override
  String get addAccountPageBiometricReason => 'Пройдите аутентификацию для создания нового аккаунта';

  @override
  String addAccountPageBiometricError(Object error) {
    return 'Ошибка биометрической аутентификации: $error';
  }

  @override
  String addAccountPageIndexExists(Object index) {
    return 'Аккаунт с индексом $index уже существует';
  }

  @override
  String get addAccountPageBiometricFailed => 'Биометрическая аутентификация не удалась';

  @override
  String addAccountPageCreateFailed(Object error) {
    return 'Не удалось создать аккаунт: $error';
  }

  @override
  String get addressBookPageTitle => 'Адресная книга';

  @override
  String get addressBookPageEmptyMessage => 'Ваши контакты и их адреса кошельков\nпоявятся здесь.';

  @override
  String get addressBookPageDeleteConfirmationTitle => 'Удалить контакт';

  @override
  String addressBookPageDeleteConfirmationMessage(String contactName) {
    return 'Вы уверены, что хотите удалить $contactName из вашей адресной книги?';
  }

  @override
  String addressBookPageDeleteTooltip(String contactName) {
    return 'Удалить $contactName';
  }

  @override
  String get cancel => 'Отмена';

  @override
  String get delete => 'Удалить';

  @override
  String get browserPageConnectedTab => 'Подключенные';

  @override
  String get browserPageExploreTab => 'Обзор';

  @override
  String get browserPageNoExploreApps => 'Пока нет приложений для обзора';

  @override
  String browserPageSearchHint(Object engine) {
    return 'Искать с помощью $engine или введите адрес';
  }

  @override
  String get browserPageNoConnectedApps => 'Нет подключенных приложений';

  @override
  String get historyPageTitle => 'История транзакций';

  @override
  String get historyPageNoTransactions => 'Пока нет транзакций';

  @override
  String get historyPageSearchHint => 'Поиск транзакций...';

  @override
  String get notificationsSettingsPageTitle => 'Уведомления';

  @override
  String get notificationsSettingsPagePushTitle => 'Push-уведомления';

  @override
  String get notificationsSettingsPagePushDescription => 'Получать уведомления о отправке и подтверждении транзакций, уведомления от подключенных приложений.';

  @override
  String get notificationsSettingsPageWalletsTitle => 'Кошельки';

  @override
  String get notificationsSettingsPageWalletsDescription => 'Уведомления от кошельков';

  @override
  String get notificationsSettingsPageWalletPrefix => 'Кошелек';

  @override
  String get revealSecretPhraseTitle => 'Показать секретную фразу';

  @override
  String get revealSecretPhrasePasswordHint => 'Пароль';

  @override
  String get revealSecretPhraseInvalidPassword => 'неверный пароль, ошибка:';

  @override
  String get revealSecretPhraseRevealAfter => 'Ваша секретная фраза будет раскрыта через:';

  @override
  String get revealSecretPhraseSubmitButton => 'Отправить';

  @override
  String get revealSecretPhraseDoneButton => 'Готово';

  @override
  String get revealSecretPhraseScamAlertTitle => 'ВНИМАНИЕ МОШЕННИЧЕСТВО';

  @override
  String get revealSecretPhraseScamAlertDescription => 'Никогда не делитесь своей секретной фразой с кем-либо. Никогда не вводите её на каких-либо сайтах.';

  @override
  String get cipherSettingsPageTitle => 'Настройка шифрования';

  @override
  String get cipherSettingsPageAdvancedButton => 'Продвинутые';

  @override
  String get cipherSettingsPageStandardTitle => 'Стандартное шифрование';

  @override
  String get cipherSettingsPageStandardSubtitle => 'AES-256 + КУЗНЕЧИК-ГОСТ';

  @override
  String get cipherSettingsPageStandardDescription => 'Базовое шифрование с AES-256 и стандартом ГОСТ КУЗНЕЧИК.';

  @override
  String get cipherSettingsPageHybridTitle => 'Гибридное шифрование';

  @override
  String get cipherSettingsPageHybridSubtitle => 'CYBER + КУЗНЕЧИК-ГОСТ';

  @override
  String get cipherSettingsPageHybridDescription => 'Гибридное шифрование, комбинирующее алгоритмы CYBER и КУЗНЕЧИК-ГОСТ.';

  @override
  String get cipherSettingsPageQuantumTitle => 'Квантово-устойчивое';

  @override
  String get cipherSettingsPageQuantumSubtitle => 'CYBER + КУЗНЕЧИК + NTRUP1277';

  @override
  String get cipherSettingsPageQuantumDescription => 'Продвинутое квантово-устойчивое шифрование с NTRUP1277.';

  @override
  String get cipherSettingsPageQuantumWarning => 'Квантово-устойчивое шифрование может повлиять на производительность';

  @override
  String get cipherSettingsPageConfirmButton => 'Подтвердить';

  @override
  String get secretPhraseVerifyPageTitle => 'Проверка секрета';

  @override
  String get secretPhraseVerifyPageSkipButton => 'Пропустить';

  @override
  String get secretPhraseVerifyPageSubtitle => 'Проверка Bip39 секрета';

  @override
  String get secretPhraseVerifyPageNextButton => 'Далее';

  @override
  String get restoreSecretPhrasePageTitle => 'Восстановить кошелек';

  @override
  String get restoreSecretPhrasePageRestoreButton => 'Восстановить';

  @override
  String get checksumValidationFailed => 'Проверка контрольной суммы не пройдена';

  @override
  String get proceedDespiteInvalidChecksum => 'Продолжить, несмотря на ошибку контрольной суммы?';

  @override
  String get settingsPageTitle => 'Настройки';

  @override
  String get settingsPageZilliqaLegacy => 'Zilliqa Legacy';

  @override
  String get settingsPageCurrency => 'Валюта';

  @override
  String get settingsPageAppearance => 'Внешний вид';

  @override
  String get settingsPageNotifications => 'Уведомления';

  @override
  String get settingsPageAddressBook => 'Адресная книга';

  @override
  String get settingsPageSecurityPrivacy => 'Безопасность и конфиденциальность';

  @override
  String get settingsPageNetworks => 'Сети';

  @override
  String get settingsPageLanguage => 'Язык';

  @override
  String get settingsPageBrowser => 'Браузер';

  @override
  String get settingsPageTelegram => 'Telegram';

  @override
  String get settingsPageTwitter => 'Twitter';

  @override
  String get settingsPageGitHub => 'GitHub';

  @override
  String get settingsPageAbout => 'О приложении';

  @override
  String get passwordSetupPageTitle => 'Настройка пароля';

  @override
  String get passwordSetupPageSubtitle => 'Создать пароль';

  @override
  String get passwordSetupPageWalletNameHint => 'Название кошелька';

  @override
  String get passwordSetupPagePasswordHint => 'Пароль';

  @override
  String get passwordSetupPageConfirmPasswordHint => 'Подтвердите пароль';

  @override
  String get passwordSetupPageEmptyWalletNameError => 'Название кошелька не может быть пустым';

  @override
  String get passwordSetupPageLongWalletNameError => 'Название кошелька слишком длинное';

  @override
  String get passwordSetupPageShortPasswordError => 'Пароль должен содержать не менее 8 символов';

  @override
  String get passwordSetupPageMismatchPasswordError => 'Пароли не совпадают';

  @override
  String get passwordSetupPageLegacyLabel => 'Legacy';

  @override
  String get passwordSetupPageCreateButton => 'Создать пароль';

  @override
  String get passwordSetupPageAuthReason => 'Пожалуйста, пройдите аутентификацию для быстрого доступа';

  @override
  String get passwordSetupPageSeedType => 'Seed';

  @override
  String get passwordSetupPageKeyType => 'Ключ';

  @override
  String get passwordSetupPageUniversalNetwork => 'Универсальный';

  @override
  String get browserSettingsTitle => 'Настройки браузера';

  @override
  String get browserSettingsBrowserOptions => 'Параметры браузера';

  @override
  String get browserSettingsSearchEngine => 'Поисковая система';

  @override
  String get browserSettingsSearchEngineDescription => 'Настройте поисковую систему по умолчанию';

  @override
  String get browserSettingsSearchEngineTitle => 'Поисковая система';

  @override
  String get browserSettingsContentBlocking => 'Блокировка контента';

  @override
  String get browserSettingsContentBlockingDescription => 'Настройте параметры блокировки контента';

  @override
  String get browserSettingsContentBlockingTitle => 'Блокировка контента';

  @override
  String get browserSettingsPrivacySecurity => 'Конфиденциальность и безопасность';

  @override
  String get browserSettingsCookies => 'Куки';

  @override
  String get browserSettingsCookiesDescription => 'Разрешить сайтам сохранять и читать куки';

  @override
  String get browserSettingsDoNotTrack => 'Не отслеживать';

  @override
  String get browserSettingsDoNotTrackDescription => 'Запрашивать у сайтов не отслеживать ваш просмотр';

  @override
  String get browserSettingsIncognitoMode => 'Режим инкогнито';

  @override
  String get browserSettingsIncognitoModeDescription => 'Просмотр без сохранения истории и куков';

  @override
  String get browserSettingsPerformance => 'Производительность';

  @override
  String get browserSettingsCache => 'Кэш';

  @override
  String get browserSettingsClearData => 'Очистить данные';

  @override
  String get browserSettingsClear => 'Очистить';

  @override
  String get browserSettingsClearCookies => 'Очистить куки';

  @override
  String get browserSettingsClearCookiesDescription => 'Удалить все куки, сохраненные веб-сайтами';

  @override
  String get browserSettingsClearCache => 'Очистить кэш';

  @override
  String get browserSettingsClearCacheDescription => 'Удалить временные файлы и изображения, сохраненные во время просмотра';

  @override
  String get browserSettingsClearLocalStorage => 'Очистить локальное хранилище';

  @override
  String get browserSettingsClearLocalStorageDescription => 'Удалить данные веб-сайтов, хранящиеся локально на вашем устройстве';

  @override
  String get browserSettingsCacheDescription => 'Хранить данные веб-сайтов для более быстрой загрузки';

  @override
  String get genWalletOptionsTitle => 'Создать кошелек';

  @override
  String get genWalletOptionsBIP39Title => 'BIP39';

  @override
  String get genWalletOptionsBIP39Subtitle => 'Создать мнемоническую фразу';

  @override
  String get genWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get genWalletOptionsSLIP0039Subtitle => 'Создать мнемоническую фразу с долями';

  @override
  String get genWalletOptionsPrivateKeyTitle => 'Приватный ключ';

  @override
  String get genWalletOptionsPrivateKeySubtitle => 'Создать только один приватный ключ';

  @override
  String get addWalletOptionsTitle => 'Добавить кошелек';

  @override
  String get addWalletOptionsNewWalletTitle => 'Новый кошелек';

  @override
  String get addWalletOptionsNewWalletSubtitle => 'Создать новый кошелек';

  @override
  String get addWalletOptionsExistingWalletTitle => 'Существующий кошелек';

  @override
  String get addWalletOptionsExistingWalletSubtitle => 'Импортировать кошелек с 24 секретными словами';

  @override
  String get addWalletOptionsPairWithLedgerTitle => 'Подключить Ledger';

  @override
  String get addWalletOptionsPairWithLedgerSubtitle => 'Аппаратный модуль, Bluetooth';

  @override
  String get addWalletOptionsOtherOptions => 'Другие варианты';

  @override
  String get addWalletOptionsWatchAccountTitle => 'Наблюдать за аккаунтом';

  @override
  String get addWalletOptionsWatchAccountSubtitle => 'Для мониторинга активности кошелька без фразы восстановления';

  @override
  String get currencyConversionTitle => 'Основная валюта';

  @override
  String get currencyConversionSearchHint => 'Поиск валют...';

  @override
  String get currencyConversionEngineTitle => 'Источник курсов валют';

  @override
  String get currencyConversionEngineDescription => 'Источник получения курсов валют';

  @override
  String get currencyConversionEngineSelectorTitle => 'Выбрать источник курсов валют';

  @override
  String get currencyConversionEngineNone => 'Нет';

  @override
  String get currencyConversionEngineNoneSubtitle => 'Источник не выбран';

  @override
  String get currencyConversionEngineCoingecko => 'Coingecko';

  @override
  String get currencyConversionEngineCoingeckoSubtitle => 'Получать курсы из Coingecko';

  @override
  String get restoreWalletOptionsTitle => 'Восстановить кошелек';

  @override
  String get restoreWalletOptionsBIP39Title => 'BIP39';

  @override
  String get restoreWalletOptionsBIP39Subtitle => 'Восстановить с помощью мнемонической фразы';

  @override
  String get restoreWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get restoreWalletOptionsSLIP0039Subtitle => 'Восстановить с помощью разделенной мнемонической фразы';

  @override
  String get restoreWalletOptionsPrivateKeyTitle => 'Приватный ключ';

  @override
  String get restoreWalletOptionsPrivateKeySubtitle => 'Восстановить с помощью приватного ключа';

  @override
  String get restoreWalletOptionsKeyStoreTitle => 'Файл Keystore';

  @override
  String get restoreWalletOptionsKeyStoreSubtitle => 'Восстановление кошелька с помощью зашифрованного паролем файла резервной копии';

  @override
  String get restoreWalletOptionsQRCodeTitle => 'QR-код';

  @override
  String get restoreWalletOptionsQRCodeSubtitle => 'Восстановить кошелек сканированием QR-кода';

  @override
  String get argonSettingsModalContentLowMemoryTitle => 'Низкая память';

  @override
  String get argonSettingsModalContentLowMemorySubtitle => '64KB RAM, 3 итерации';

  @override
  String get argonSettingsModalContentLowMemoryDescription => 'Минимальное использование памяти, подходит для устройств с низкими характеристиками.';

  @override
  String get argonSettingsModalContentOwaspTitle => 'OWASP по умолчанию';

  @override
  String get argonSettingsModalContentOwaspSubtitle => '6.5MB RAM, 2 итерации';

  @override
  String get argonSettingsModalContentOwaspDescription => 'Рекомендовано OWASP для общего использования.';

  @override
  String get argonSettingsModalContentSecureTitle => 'Безопасный';

  @override
  String get argonSettingsModalContentSecureSubtitle => '256MB RAM, 4 итерации';

  @override
  String get argonSettingsModalContentSecureDescription => 'Высокая безопасность с увеличенной памятью и итерациями.';

  @override
  String get argonSettingsModalContentSecretHint => 'Введите секрет (опционально)';

  @override
  String get argonSettingsModalContentConfirmButton => 'Подтвердить';

  @override
  String get confirmTransactionContentPasswordHint => 'Пароль';

  @override
  String get confirmTransactionContentUnableToConfirm => 'Невозможно подтвердить';

  @override
  String get confirmTransactionContentConfirm => 'Подтвердить';

  @override
  String get confirmTransactionContentInsufficientBalance => 'Недостаточный баланс';

  @override
  String get confirmTransactionContentNoActiveAccount => 'Нет активного аккаунта';

  @override
  String get confirmTransactionContentFailedLoadTransfer => 'Не удалось загрузить детали перевода';

  @override
  String get confirmTransactionEditGasButtonText => 'Изменить Газ';

  @override
  String get authReason => 'Пожалуйста, пройдите аутентификацию';

  @override
  String get addChainModalContentWarning => 'Остерегайтесь сетевых мошенничеств и рисков безопасности.';

  @override
  String get addChainModalContentApprove => 'Подтвердить';

  @override
  String get addChainModalContentDetails => 'Детали';

  @override
  String get addChainModalContentNetworkName => 'Название сети:';

  @override
  String get addChainModalContentCurrencySymbol => 'Символ валюты:';

  @override
  String get addChainModalContentChainId => 'ID цепи:';

  @override
  String get addChainModalContentBlockExplorer => 'Обозреватель блоков:';

  @override
  String get addAddressModalTitle => 'Добавить контакт';

  @override
  String get addAddressModalDescription => 'Введите имя контакта и адрес кошелька для добавления в адресную книгу.';

  @override
  String get addAddressModalNameHint => 'Имя';

  @override
  String get addAddressModalAddressHint => 'Адрес кошелька';

  @override
  String get addAddressModalNameEmptyError => 'Имя не может быть пустым';

  @override
  String get addAddressModalAddressEmptyError => 'Адрес не может быть пустым';

  @override
  String get addAddressModalButton => 'Добавить контакт';

  @override
  String get tokenSelectModalContentSearchHint => 'Поиск';

  @override
  String get signMessageModalContentAuthReason => 'Пожалуйста, авторизуйтесь для подписи сообщения';

  @override
  String signMessageModalContentFailedToSign(Object error) {
    return 'Не удалось подписать: $error';
  }

  @override
  String get signMessageModalContentTitle => 'Подписать сообщение';

  @override
  String get signMessageModalContentDescription => 'Просмотрите и подпишите следующее сообщение с помощью вашего кошелька.';

  @override
  String get signMessageModalContentDomain => 'Домен:';

  @override
  String get signMessageModalContentChainId => 'ID цепи:';

  @override
  String get signMessageModalContentContract => 'Контракт:';

  @override
  String get signMessageModalContentType => 'Тип:';

  @override
  String get signMessageModalContentNoData => 'Нет данных';

  @override
  String get signMessageModalContentPasswordHint => 'Пароль';

  @override
  String get signMessageModalContentProcessing => 'Обработка...';

  @override
  String get signMessageModalContentSign => 'Подписать сообщение';

  @override
  String get signMessageModalContentScanning => 'Сканирование устройств Ledger...';

  @override
  String get signMessageModalContentNoLedgerDevices => 'Устройства Ledger не найдены';

  @override
  String get signMessageModalContentWalletNotSelected => 'Кошелёк не выбран';

  @override
  String get signMessageModalContentLedgerNotSelected => 'Устройство Ledger не выбрано';

  @override
  String signMessageModalContentFailedToScanLedger(Object error) {
    return 'Не удалось сканировать устройства Ledger: $error';
  }

  @override
  String signMessageModalContentFailedToSignMessage(Object error) {
    return 'Не удалось подписать сообщение: $error';
  }

  @override
  String get signMessageModalContentBluetoothOff => 'Bluetooth выключен. Пожалуйста, включите его для сканирования устройств Ledger.';

  @override
  String get deleteWalletModalTitle => 'Удалить кошелек';

  @override
  String get deleteWalletModalWarning => 'Внимание: Это действие нельзя отменить. Ваш кошелек можно восстановить только с помощью секретной фразы. Если у вас нет к ней доступа, вы навсегда потеряете все средства, связанные с этим аккаунтом.';

  @override
  String get deleteWalletModalSecretPhraseWarning => 'Пожалуйста, убедитесь, что у вас есть доступ к вашей секретной фразе, прежде чем продолжить.';

  @override
  String get deleteWalletModalPasswordHint => 'Введите пароль';

  @override
  String get deleteWalletModalSubmit => 'Отправить';

  @override
  String get manageTokensModalContentSearchHint => 'Поиск';

  @override
  String get addressSelectModalContentTitle => 'Выберите адрес';

  @override
  String get addressSelectModalContentSearchHint => 'Поиск / Адрес / ENS';

  @override
  String get addressSelectModalContentUnknown => 'Неизвестно';

  @override
  String get addressSelectModalContentMyAccounts => 'Мои аккаунты';

  @override
  String get addressSelectModalContentAddressBook => 'Адресная книга';

  @override
  String get addressSelectModalContentHistory => 'История';

  @override
  String get addressSelectModalContentSender => 'Отправитель';

  @override
  String get changePasswordModalTitle => 'Изменить пароль';

  @override
  String get changePasswordModalDescription => 'Введите ваш текущий пароль и выберите новый пароль для обновления безопасности вашего кошелька.';

  @override
  String get changePasswordModalCurrentPasswordHint => 'Текущий пароль';

  @override
  String get changePasswordModalNewPasswordHint => 'Новый пароль';

  @override
  String get changePasswordModalConfirmPasswordHint => 'Подтвердите новый пароль';

  @override
  String get changePasswordModalCurrentPasswordEmptyError => 'Текущий пароль не может быть пустым';

  @override
  String get changePasswordModalPasswordLengthError => 'Пароль должен быть не менее 6 символов';

  @override
  String get changePasswordModalPasswordsMismatchError => 'Пароли не совпадают';

  @override
  String get changePasswordModalButton => 'Изменить пароль';

  @override
  String get confirmPasswordModalTitle => 'Подтвердить пароль';

  @override
  String get confirmPasswordModalDescription => 'Введите пароль для продолжения.';

  @override
  String get confirmPasswordModalHint => 'Пароль';

  @override
  String get confirmPasswordModalEmptyError => 'Пароль не может быть пустым';

  @override
  String get confirmPasswordModalGenericError => 'Ошибка:';

  @override
  String get confirmPasswordModalButton => 'Подтвердить';

  @override
  String get qrScannerModalContentTitle => 'Сканировать';

  @override
  String get qrScannerModalContentCameraInitError => 'Ошибка инициализации камеры:';

  @override
  String get qrScannerModalContentTorchError => 'Не удалось переключить вспышку:';

  @override
  String get qrScannerModalContentOpenSettings => 'Открыть настройки';

  @override
  String get chainInfoModalContentTokenTitle => 'Токен сети';

  @override
  String get chainInfoModalContentNetworkInfoTitle => 'Информация о сети';

  @override
  String get chainInfoModalContentChainLabel => 'Цепочка';

  @override
  String get chainInfoModalContentShortNameLabel => 'Краткое название';

  @override
  String get chainInfoModalContentChainIdLabel => 'ID цепочки';

  @override
  String get chainInfoModalContentSlip44Label => 'Slip44';

  @override
  String get chainInfoModalContentChainIdsLabel => 'ID цепочек';

  @override
  String get chainInfoModalContentTestnetLabel => 'Тестовая сеть';

  @override
  String get chainInfoModalContentYes => 'Да';

  @override
  String get chainInfoModalContentNo => 'Нет';

  @override
  String get chainInfoModalContentDiffBlockTimeLabel => 'Время блока';

  @override
  String get chainInfoModalContentFallbackEnabledLabel => 'Включен резервный режим';

  @override
  String get chainInfoModalContentDecimalsLabel => 'Десятичные знаки';

  @override
  String get chainInfoModalContentRpcNodesTitle => 'RPC-узлы';

  @override
  String get chainInfoModalContentExplorersTitle => 'Обозреватели';

  @override
  String get chainInfoModalContentDeleteProviderTitle => 'Удалить сеть';

  @override
  String get chainInfoModalContentSwipeToDelete => 'Удалить сеть';

  @override
  String get switchChainNetworkContentTitle => 'Выбрать сеть';

  @override
  String get switchChainNetworkContentButton => 'Переключить сеть';

  @override
  String get switchChainNetworkContentTestnetLabel => 'Тестовая сеть';

  @override
  String get switchChainNetworkContentIdLabel => 'ID:';

  @override
  String get watchAssetModalContentTitle => 'Добавить предложенный токен';

  @override
  String get watchAssetModalContentDescription => 'Просмотрите и добавьте следующий токен, предложенный приложением.';

  @override
  String get watchAssetModalContentTokenLabel => 'Токен';

  @override
  String get watchAssetModalContentBalanceLabel => 'Баланс';

  @override
  String get watchAssetModalContentLoadingButton => 'Баланс...';

  @override
  String get watchAssetModalContentAddButton => 'Добавить';

  @override
  String get connectedDappsModalSearchHint => 'Поиск DApps';

  @override
  String get connectedDappsModalNoDapps => 'Нет подключенных DApps';

  @override
  String dappListItemConnected(Object time) {
    return 'Подключено $time';
  }

  @override
  String get dappListItemJustNow => 'только что';

  @override
  String get secretRecoveryModalRevealPhraseTitle => 'Показать фразу восстановления';

  @override
  String get secretRecoveryModalRevealPhraseDescription => 'Если вы когда-либо смените браузер или компьютер, вам понадобится эта секретная фраза восстановления для доступа к вашим аккаунтам. Сохраните её в безопасном и секретном месте.';

  @override
  String get secretRecoveryModalRevealPhraseButton => 'Показать';

  @override
  String get secretRecoveryModalShowKeysTitle => 'Показать приватные ключи';

  @override
  String get secretRecoveryModalShowKeysDescription => 'Внимание: Никогда не раскрывайте этот ключ. Любой, кто имеет ваши приватные ключи, может украсть любые активы, хранящиеся на вашем аккаунте.';

  @override
  String get secretRecoveryModalShowKeysButton => 'Экспорт';

  @override
  String get secretRecoveryModalKeystoreBackupTitle => 'Резервное копирование Keystore';

  @override
  String get secretRecoveryModalKeystoreBackupDescription => 'Сохраните ваши приватные ключи в зашифрованном файле keystore, защищенном паролем. Это обеспечивает дополнительный уровень безопасности для вашего кошелька.';

  @override
  String get secretRecoveryModalKeystoreBackupButton => 'Создать Keystore';

  @override
  String get backupConfirmationContentTitle => 'Подтверждение резервного копирования';

  @override
  String get backupConfirmationWarning => 'ВНИМАНИЕ: Если вы потеряете или забудете вашу seed-фразу в точном порядке, вы навсегда потеряете ваши средства. Никогда не делитесь вашей seed-фразой с кем-либо, иначе ваши средства могут быть украдены. Восстановление BIP39 очень строгое - любая ошибка в словах при восстановлении приведет к потере средств.';

  @override
  String get backupConfirmationContentWrittenDown => 'Я записал всё';

  @override
  String get backupConfirmationContentSafelyStored => 'Я надежно сохранил резервную копию';

  @override
  String get backupConfirmationContentWontLose => 'Я уверен, что не потеряю резервную копию';

  @override
  String get backupConfirmationContentNotShare => 'Я понимаю, что нельзя делиться этими словами с кем-либо';

  @override
  String get counterMaxValueError => 'Достигнуто максимальное значение';

  @override
  String get counterMinValueError => 'Достигнуто минимальное значение';

  @override
  String get biometricSwitchFaceId => 'Включить Face ID';

  @override
  String get biometricSwitchFingerprint => 'Включить отпечаток пальца';

  @override
  String get biometricSwitchBiometric => 'Включить биометрический вход';

  @override
  String get biometricSwitchPinCode => 'Включить PIN-код устройства';

  @override
  String get gasFeeOptionLow => 'Низкий';

  @override
  String get gasFeeOptionMarket => 'Рыночный';

  @override
  String get gasFeeOptionAggressive => 'Агрессивный';

  @override
  String get gasDetailsEstimatedGas => 'Расчетный газ:';

  @override
  String get gasDetailsGasPrice => 'Цена газа:';

  @override
  String get gasDetailsBaseFee => 'Базовая комиссия:';

  @override
  String get gasDetailsPriorityFee => 'Приоритетная комиссия:';

  @override
  String get gasDetailsMaxFee => 'Максимальная комиссия:';

  @override
  String get tokenTransferAmountUnknown => 'Неизвестно';

  @override
  String get transactionDetailsModal_transaction => 'Транзакция';

  @override
  String get transactionDetailsModal_hash => 'Хэш';

  @override
  String get transactionDetailsModal_sig => 'Подпись';

  @override
  String get transactionDetailsModal_timestamp => 'Временная метка';

  @override
  String get transactionDetailsModal_blockNumber => 'Номер блока';

  @override
  String get transactionDetailsModal_nonce => 'Нонс';

  @override
  String get transactionDetailsModal_addresses => 'Адреса';

  @override
  String get transactionDetailsModal_sender => 'Отправитель';

  @override
  String get transactionDetailsModal_recipient => 'Получатель';

  @override
  String get transactionDetailsModal_contractAddress => 'Адрес контракта';

  @override
  String get transactionDetailsModal_network => 'Сеть';

  @override
  String get transactionDetailsModal_chainType => 'Тип цепи';

  @override
  String get transactionDetailsModal_networkName => 'Сеть';

  @override
  String get transactionDetailsModal_gasFees => 'Газ и комиссии';

  @override
  String get transactionDetailsModal_fee => 'Комиссия';

  @override
  String get transactionDetailsModal_gasUsed => 'Использованный газ';

  @override
  String get transactionDetailsModal_gasLimit => 'Лимит газа';

  @override
  String get transactionDetailsModal_gasPrice => 'Цена газа';

  @override
  String get transactionDetailsModal_effectiveGasPrice => 'Эффективная цена газа';

  @override
  String get transactionDetailsModal_blobGasUsed => 'Использованный блоб-газ';

  @override
  String get transactionDetailsModal_blobGasPrice => 'Цена блоб-газа';

  @override
  String get transactionDetailsModal_error => 'Ошибка';

  @override
  String get transactionDetailsModal_errorMessage => 'Сообщение об ошибке';

  @override
  String get amountSection_transfer => 'Перевод';

  @override
  String get amountSection_pending => 'В ожидании';

  @override
  String get amountSection_confirmed => 'Подтверждено';

  @override
  String get amountSection_rejected => 'Отклонено';

  @override
  String get appConnectModalContent_swipeToConnect => 'Проведите для подключения';

  @override
  String get appConnectModalContent_noAccounts => 'Нет доступных аккаунтов';

  @override
  String get browserActionMenuShare => 'Поделиться';

  @override
  String get browserActionMenuCopyLink => 'Копировать ссылку';

  @override
  String get browserActionMenuClose => 'Закрыть';

  @override
  String get keystoreBackupTitle => 'Резервное копирование Keystore';

  @override
  String get keystoreBackupWarningTitle => 'Защитите Ваш Keystore Файл';

  @override
  String get keystoreBackupWarningMessage => 'Файл keystore содержит ваши зашифрованные приватные ключи. Храните этот файл в безопасном месте и никогда не передавайте его никому. Для расшифровки этого файла вам понадобится созданный вами пароль.';

  @override
  String get keystoreBackupConfirmPasswordHint => 'Подтвердить Пароль';

  @override
  String get keystoreBackupCreateButton => 'Создать Резервную Копию';

  @override
  String get keystoreBackupPasswordsDoNotMatch => 'Пароли не совпадают';

  @override
  String get keystoreBackupPasswordTooShort => 'Пароль должен содержать не менее 8 символов';

  @override
  String get keystoreBackupError => 'Ошибка создания резервной копии:';

  @override
  String get keystoreBackupShareButton => 'Поделиться Файлом Keystore';

  @override
  String get keystoreBackupDoneButton => 'Готово';

  @override
  String get keystoreBackupSuccessTitle => 'Резервная Копия Успешно Создана';

  @override
  String get keystoreBackupSuccessMessage => 'Ваш файл keystore был создан. Обязательно храните в безопасности как файл, так и ваш пароль.';

  @override
  String get keystoreBackupSaveAsButton => 'Сохранить в файл';

  @override
  String get keystoreBackupSaveDialogTitle => 'Сохранить файл Keystore';

  @override
  String get keystoreBackupSavedSuccess => 'Файл keystore успешно сохранен';

  @override
  String get keystoreBackupSaveFailed => 'Не удалось сохранить файл keystore';

  @override
  String get keystoreBackupTempLocation => 'Расположение временного файла';

  @override
  String get keystorePasswordHint => 'Введите пароль от keystore';

  @override
  String get keystoreRestoreButton => 'Восстановить кошелек';

  @override
  String get keystoreRestoreExtError => 'Пожалуйста, выберите действительный файл .zp';

  @override
  String get keystoreRestoreNoFile => 'Файлы хранилища ключей не найдены';

  @override
  String get keystoreRestoreFilesTitle => 'Файлы хранилища ключей';

  @override
  String get editGasDialogTitle => 'Изменить параметры газа';

  @override
  String get editGasDialogGasPrice => 'Цена газа';

  @override
  String get editGasDialogMaxPriorityFee => 'Макс. приоритетная комиссия';

  @override
  String get editGasDialogGasLimit => 'Лимит газа';

  @override
  String get editGasDialogCancel => 'Отмена';

  @override
  String get editGasDialogSave => 'Сохранить';

  @override
  String get editGasDialogInvalidGasValues => 'Недопустимые значения газа. Проверьте ваши данные.';

  @override
  String get addLedgerAccountPageAppBarTitle => 'Добавить аккаунт Ledger';

  @override
  String get addLedgerAccountPageGetAccountsButton => 'Получить аккаунты';

  @override
  String get addLedgerAccountPageCreateButton => 'Создать';

  @override
  String get addLedgerAccountPageAddButton => 'Добавить';

  @override
  String get addLedgerAccountPageScanningMessage => 'Сканирование устройств Ledger...';

  @override
  String get addLedgerAccountPageNoDevicesMessage => 'Устройства Ledger не найдены';

  @override
  String get addLedgerAccountPageBluetoothOffError => 'Bluetooth выключен. Пожалуйста, включите его для сканирования устройств Ledger.';

  @override
  String get addLedgerAccountPageEmptyWalletNameError => 'Имя кошелька не может быть пустым';

  @override
  String get addLedgerAccountPageWalletNameTooLongError => 'Имя кошелька слишком длинное (максимум 24 символа)';

  @override
  String addLedgerAccountPageFailedToScanError(Object error) {
    return 'Не удалось отсканировать устройства Ledger: $error';
  }

  @override
  String get addLedgerAccountPageNetworkOrLedgerMissingError => 'Отсутствуют данные сети или Ledger';

  @override
  String get addLedgerAccountPageNoAccountsSelectedError => 'Аккаунты не выбраны';

  @override
  String get addLedgerAccountPageNoWalletSelectedError => 'Кошелёк не выбран';

  @override
  String get transactionHistoryTitle => 'История транзакций';

  @override
  String get transactionHistoryDescription => 'Показывать адреса из истории транзакций';

  @override
  String get zilStakePageTitle => 'Стейкинг Zilliqa';

  @override
  String get noStakingPoolsFound => 'Пулы для стейкинга не найдены';

  @override
  String get aprSort => 'APR';

  @override
  String get commissionSort => 'Комиссия';

  @override
  String get tvlSort => 'TVL';

  @override
  String get claimButton => 'Забрать';

  @override
  String get stakeButton => 'Стейкать';

  @override
  String get unstakeButton => 'Отозвать';

  @override
  String get reinvest => 'Реинвест';

  @override
  String get aprLabel => 'APR';

  @override
  String get commissionLabel => 'Комиссия';

  @override
  String get tvlLabel => 'TVL';

  @override
  String get lpStakingBadge => 'LP';

  @override
  String get stakedAmount => 'Заблокировано';

  @override
  String get rewardsAvailable => 'Награды';

  @override
  String get pendingWithdrawals => 'Ожидающие выводы';

  @override
  String get amount => 'Сумма';

  @override
  String get claimableIn => 'Доступно через';

  @override
  String get blocks => 'блоков';

  @override
  String get unbondingPeriod => 'Период отвязки';

  @override
  String get currentBlock => 'Текущий блок';

  @override
  String get version => 'Версия';

  @override
  String get rewardsProgressTitle => 'Прогресс награждения';

  @override
  String get durationDay => 'д';

  @override
  String get durationHour => 'ч';

  @override
  String get durationMinute => 'м';

  @override
  String get durationLessThanAMinute => '< 1м';

  @override
  String get durationNotAvailable => 'Н/Д';

  @override
  String get nodes => 'узлы';
}

```

`lib/l10n/app_localizations_zh.dart`:

```dart
// ignore: unused_import
import 'package:intl/intl.dart' as intl;
import 'app_localizations.dart';

// ignore_for_file: type=lint

/// The translations for Chinese (`zh`).
class AppLocalizationsZh extends AppLocalizations {
  AppLocalizationsZh([String locale = 'zh']) : super(locale);

  @override
  String get appTitle => 'ZilPay 钱包';

  @override
  String get initialPagerestoreZilPay => '恢复 ZilPay 1.0！';

  @override
  String get initialPagegetStarted => '开始使用';

  @override
  String get restoreRKStorageTitle => '将 ZilPay 1.0 迁移至 2.0';

  @override
  String get restoreRKStorageAccountsPrompt => '要迁移到 ZilPay 2.0 的账户。请输入密码。';

  @override
  String get restoreRKStoragePasswordHint => '密码';

  @override
  String get restoreRKStorageEnterPassword => '请输入密码';

  @override
  String get restoreRKStorageErrorPrefix => '错误：';

  @override
  String get restoreRKStorageRestoreButton => '恢复';

  @override
  String get restoreRKStorageSkipButton => '跳过';

  @override
  String get accountItemBalanceLabel => '余额：';

  @override
  String get sendTokenPageTitle => '';

  @override
  String get sendTokenPageSubmitButton => '提交';

  @override
  String get aboutPageTitle => '关于';

  @override
  String get aboutPageAppName => 'ZilPay';

  @override
  String get aboutPageAppDescription => '您的安全区块链钱包';

  @override
  String get aboutPageAppInfoTitle => '应用程序信息';

  @override
  String get aboutPageVersionLabel => '版本';

  @override
  String get aboutPageBuildDateLabel => '构建日期';

  @override
  String get aboutPageBuildDateValue => '2025年3月10日';

  @override
  String get aboutPagePlatformLabel => '平台';

  @override
  String get aboutPageDeveloperTitle => '开发者';

  @override
  String get aboutPageAuthorLabel => '作者';

  @override
  String get aboutPageAuthorValue => 'Rinat (hicaru)';

  @override
  String get aboutPageWebsiteLabel => '网站';

  @override
  String get aboutPageWebsiteValue => 'https://zilpay.io';

  @override
  String get aboutPageLegalTitle => '法律信息';

  @override
  String get aboutPagePrivacyPolicy => '隐私政策';

  @override
  String get aboutPageTermsOfService => '服务条款';

  @override
  String get aboutPageLicenses => '许可证';

  @override
  String get aboutPageLegalese => '© 2025 ZilPay。保留所有权利。';

  @override
  String get languagePageTitle => '语言';

  @override
  String get languagePageSystem => '系统';

  @override
  String get secretKeyGeneratorPageTitle => '密钥';

  @override
  String get secretKeyGeneratorPagePrivateKey => '私钥';

  @override
  String get secretKeyGeneratorPagePublicKey => '公钥';

  @override
  String get secretKeyGeneratorPageBackupCheckbox => '我已备份私钥';

  @override
  String get secretKeyGeneratorPageNextButton => '下一步';

  @override
  String get walletPageTitle => '';

  @override
  String get walletPageWalletNameHint => '钱包名称';

  @override
  String get walletPagePreferencesTitle => '钱包设置';

  @override
  String get walletPageManageConnections => '管理连接';

  @override
  String get walletPageBackup => '备份';

  @override
  String get walletPageDeleteWallet => '删除钱包';

  @override
  String get walletPageBiometricReason => '启用生物识别认证';

  @override
  String get networkPageTitle => '';

  @override
  String get networkPageShowTestnet => '显示测试网';

  @override
  String get networkPageSearchHint => '搜索';

  @override
  String get networkPageAddedNetworks => '已添加的网络';

  @override
  String get networkPageAvailableNetworks => '可用网络';

  @override
  String get networkPageLoadError => '加载网络链失败：';

  @override
  String get networkPageAddError => '添加网络失败：';

  @override
  String get receivePageTitle => '接收';

  @override
  String receivePageWarning(Object chainName, Object tokenSymbol) {
    return '仅向此地址发送 $chainName($tokenSymbol) 资产。其他资产将永久丢失。';
  }

  @override
  String get receivePageAccountNameHint => '账户名称';

  @override
  String get receivePageAmountDialogTitle => '输入金额';

  @override
  String get receivePageAmountDialogHint => '0.0';

  @override
  String get receivePageAmountDialogCancel => '取消';

  @override
  String get receivePageAmountDialogConfirm => '确认';

  @override
  String get securityPageTitle => '安全';

  @override
  String get securityPageNetworkPrivacy => '网络隐私';

  @override
  String get securityPageEnsDomains => '在地址栏中显示 ENS 域名';

  @override
  String get securityPageEnsDescription => '请注意，使用此功能会将您的 IP 地址暴露给第三方 IPFS 服务。';

  @override
  String get securityPageIpfsGateway => 'IPFS 网关';

  @override
  String get securityPageIpfsDescription => 'ZIlPay 使用第三方服务来显示存储在 IPFS 上的 NFT 图像，显示与浏览器地址栏中输入的 ENS（ZNS）地址相关的信息，以及获取不同代币的图标。当您使用这些服务时，您的 IP 地址可能会暴露给这些服务。';

  @override
  String get securityPageTokensFetcherTitle => '令牌获取器';

  @override
  String get securityPageTokensFetcherDescription => '安全页面上的令牌获取器设置。如果启用，将自动从服务器获取令牌并可添加。';

  @override
  String get securityPageNodeRanking => '节点排名';

  @override
  String get securityPageNodeDescription => '向 ZilPay 服务器发出请求以获取最佳节点';

  @override
  String get securityPageEncryptionLevel => '加密级别';

  @override
  String get securityPageProtection => '保护';

  @override
  String get securityPageCpuLoad => 'CPU 负载';

  @override
  String get securityPageAes256 => 'AES256';

  @override
  String get securityPageKuznechikGost => 'KUZNECHIK-GOST';

  @override
  String get securityPageNtruPrime => 'NTRUPrime';

  @override
  String get securityPageCyber => 'Cyber';

  @override
  String get securityPageUnknown => '未知';

  @override
  String get webViewPageDntLabel => 'DNT';

  @override
  String get webViewPageIncognitoLabel => '隐身模式';

  @override
  String get webViewPageLoadError => '加载失败';

  @override
  String get webViewPageTryAgain => '重试';

  @override
  String get secretPhraseGeneratorPageTitle => '新钱包';

  @override
  String get secretPhraseGeneratorPageBackupCheckbox => '我已备份助记词';

  @override
  String get secretPhraseGeneratorPageNextButton => '下一步';

  @override
  String get homePageTestnetLabel => '测试网';

  @override
  String get homePageErrorTitle => '无信号';

  @override
  String get homePageSendButton => '发送';

  @override
  String get homePageReceiveButton => '接收';

  @override
  String get revealSecretKeyTitle => '显示私钥';

  @override
  String get revealSecretKeyPasswordHint => '密码';

  @override
  String get revealSecretKeyInvalidPassword => '密码无效，错误：';

  @override
  String get revealSecretKeySubmitButton => '提交';

  @override
  String get revealSecretKeyDoneButton => '完成';

  @override
  String get revealSecretKeyScamAlertTitle => '诈骗警告';

  @override
  String get revealSecretKeyScamAlertMessage => '绝不与任何人分享您的私钥。绝不在任何网站上输入。';

  @override
  String get setupNetworkSettingsPageTestnetSwitch => '测试网';

  @override
  String get setupNetworkSettingsPageSearchHint => '搜索';

  @override
  String get setupNetworkSettingsPageNoNetworks => '没有可用的网络';

  @override
  String setupNetworkSettingsPageNoResults(Object searchQuery) {
    return '未找到与\"$searchQuery\"匹配的网络';
  }

  @override
  String get setupNetworkSettingsPageNextButton => '下一步';

  @override
  String get setupNetworkSettingsPageTestnetLabel => '测试网';

  @override
  String get setupNetworkSettingsPageMainnetLabel => '主网';

  @override
  String get setupNetworkSettingsPageChainIdLabel => '链 ID：';

  @override
  String get setupNetworkSettingsPageTokenLabel => '代币：';

  @override
  String get setupNetworkSettingsPageExplorerLabel => '浏览器：';

  @override
  String get appearanceSettingsPageTitle => '外观设置';

  @override
  String get appearanceSettingsPageCompactNumbersTitle => '简洁数字';

  @override
  String get appearanceSettingsPageCompactNumbersDescription => '启用后显示简短数字（例如，20K 而不是 20,000）。';

  @override
  String get appearanceSettingsPageDeviceSettingsTitle => '设备设置';

  @override
  String get appearanceSettingsPageDeviceSettingsSubtitle => '系统默认';

  @override
  String get appearanceSettingsPageDeviceSettingsDescription => '默认使用您设备的外观。您的钱包主题将根据系统设置自动调整。';

  @override
  String get appearanceSettingsPageDarkModeTitle => '深色模式';

  @override
  String get appearanceSettingsPageDarkModeSubtitle => '始终深色';

  @override
  String get appearanceSettingsPageDarkModeDescription => '始终启用深色主题，无论设备设置如何。';

  @override
  String get appearanceSettingsPageLightModeTitle => '浅色模式';

  @override
  String get appearanceSettingsPageLightModeSubtitle => '始终浅色';

  @override
  String get appearanceSettingsPageLightModeDescription => '始终启用浅色主题，无论设备设置如何。';

  @override
  String get loginPageBiometricReason => '请进行认证';

  @override
  String loginPageWalletTitle(Object index) {
    return '钱包 $index';
  }

  @override
  String get loginPagePasswordHint => '密码';

  @override
  String get loginPageUnlockButton => '解锁';

  @override
  String get loginPageWelcomeBack => '欢迎回来';

  @override
  String get secretKeyRestorePageTitle => '恢复私钥';

  @override
  String get secretKeyRestorePageHint => '私钥';

  @override
  String get secretKeyRestorePageInvalidFormat => '无效的私钥格式';

  @override
  String get secretKeyRestorePageKeyTitle => '私钥';

  @override
  String get secretKeyRestorePageBackupLabel => '我已备份我的私钥';

  @override
  String get secretKeyRestorePageNextButton => '下一步';

  @override
  String get addAccountPageTitle => '添加新账户';

  @override
  String get addAccountPageSubtitle => '创建 BIP39 账户';

  @override
  String addAccountPageDefaultName(Object index) {
    return '账户 $index';
  }

  @override
  String get addAccountPageNameHint => '账户名称';

  @override
  String get addAccountPageBip39Index => 'BIP39 索引';

  @override
  String get addAccountPageUseBiometrics => '使用生物识别';

  @override
  String get addAccountPagePasswordHint => '密码';

  @override
  String get addAccountPageZilliqaLegacy => 'Zilliqa 传统';

  @override
  String get addAccountPageBiometricReason => '认证以创建新账户';

  @override
  String addAccountPageBiometricError(Object error) {
    return '生物识别认证失败：$error';
  }

  @override
  String addAccountPageIndexExists(Object index) {
    return '索引为 $index 的账户已存在';
  }

  @override
  String get addAccountPageBiometricFailed => '生物识别认证失败';

  @override
  String addAccountPageCreateFailed(Object error) {
    return '创建账户失败：$error';
  }

  @override
  String get addressBookPageTitle => '地址簿';

  @override
  String get addressBookPageEmptyMessage => '您的联系人及其钱包地址将\n在此处显示。';

  @override
  String get addressBookPageDeleteConfirmationTitle => '删除联系人';

  @override
  String addressBookPageDeleteConfirmationMessage(String contactName) {
    return '您确定要从地址簿中删除$contactName吗？';
  }

  @override
  String addressBookPageDeleteTooltip(String contactName) {
    return '删除$contactName';
  }

  @override
  String get cancel => '取消';

  @override
  String get delete => '删除';

  @override
  String get browserPageConnectedTab => '已连接';

  @override
  String get browserPageExploreTab => '探索';

  @override
  String get browserPageNoExploreApps => '暂无可探索的应用';

  @override
  String browserPageSearchHint(Object engine) {
    return '使用 $engine 搜索或输入地址';
  }

  @override
  String get browserPageNoConnectedApps => '无已连接的应用';

  @override
  String get historyPageTitle => '交易历史';

  @override
  String get historyPageNoTransactions => '暂无交易';

  @override
  String get historyPageSearchHint => '搜索交易...';

  @override
  String get notificationsSettingsPageTitle => '通知';

  @override
  String get notificationsSettingsPagePushTitle => '推送通知';

  @override
  String get notificationsSettingsPagePushDescription => '在交易发送和确认时获取通知，以及来自已连接应用的通知。';

  @override
  String get notificationsSettingsPageWalletsTitle => '钱包';

  @override
  String get notificationsSettingsPageWalletsDescription => '来自钱包的通知';

  @override
  String get notificationsSettingsPageWalletPrefix => '钱包';

  @override
  String get revealSecretPhraseTitle => '显示助记词';

  @override
  String get revealSecretPhrasePasswordHint => '密码';

  @override
  String get revealSecretPhraseInvalidPassword => '密码无效，错误：';

  @override
  String get revealSecretPhraseRevealAfter => '您的助记词将在以下时间后显示:';

  @override
  String get revealSecretPhraseSubmitButton => '提交';

  @override
  String get revealSecretPhraseDoneButton => '完成';

  @override
  String get revealSecretPhraseScamAlertTitle => '诈骗警告';

  @override
  String get revealSecretPhraseScamAlertDescription => '绝不与任何人分享您的助记词。绝不在任何网站上输入。';

  @override
  String get cipherSettingsPageTitle => '加密设置';

  @override
  String get cipherSettingsPageAdvancedButton => '高级';

  @override
  String get cipherSettingsPageStandardTitle => '标准加密';

  @override
  String get cipherSettingsPageStandardSubtitle => 'AES-256 + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageStandardDescription => '使用 AES-256 和 GOST 标准 KUZNECHIK 的基本加密。';

  @override
  String get cipherSettingsPageHybridTitle => '混合加密';

  @override
  String get cipherSettingsPageHybridSubtitle => 'CYBER + KUZNECHIK-GOST';

  @override
  String get cipherSettingsPageHybridDescription => '结合 CYBER 和 KUZNECHIK-GOST 算法的混合加密。';

  @override
  String get cipherSettingsPageQuantumTitle => '抗量子';

  @override
  String get cipherSettingsPageQuantumSubtitle => 'CYBER + KUZNECHIK + NTRUP1277';

  @override
  String get cipherSettingsPageQuantumDescription => '使用 NTRUP1277 的高级抗量子加密。';

  @override
  String get cipherSettingsPageQuantumWarning => '抗量子加密可能影响性能';

  @override
  String get cipherSettingsPageConfirmButton => '确认';

  @override
  String get secretPhraseVerifyPageTitle => '验证密钥';

  @override
  String get secretPhraseVerifyPageSkipButton => '跳过';

  @override
  String get secretPhraseVerifyPageSubtitle => '验证 Bip39 密钥';

  @override
  String get secretPhraseVerifyPageNextButton => '下一步';

  @override
  String get restoreSecretPhrasePageTitle => '恢复钱包';

  @override
  String get restoreSecretPhrasePageRestoreButton => '恢复';

  @override
  String get checksumValidationFailed => '校验和验证失败';

  @override
  String get proceedDespiteInvalidChecksum => '尽管校验和错误仍继续？';

  @override
  String get settingsPageTitle => '设置';

  @override
  String get settingsPageZilliqaLegacy => 'Zilliqa 传统';

  @override
  String get settingsPageCurrency => '货币';

  @override
  String get settingsPageAppearance => '外观';

  @override
  String get settingsPageNotifications => '通知';

  @override
  String get settingsPageAddressBook => '地址簿';

  @override
  String get settingsPageSecurityPrivacy => '安全与隐私';

  @override
  String get settingsPageNetworks => '网络';

  @override
  String get settingsPageLanguage => '语言';

  @override
  String get settingsPageBrowser => '浏览器';

  @override
  String get settingsPageTelegram => 'Telegram';

  @override
  String get settingsPageTwitter => 'Twitter';

  @override
  String get settingsPageGitHub => 'GitHub';

  @override
  String get settingsPageAbout => '关于';

  @override
  String get passwordSetupPageTitle => '密码设置';

  @override
  String get passwordSetupPageSubtitle => '创建密码';

  @override
  String get passwordSetupPageWalletNameHint => '钱包名称';

  @override
  String get passwordSetupPagePasswordHint => '密码';

  @override
  String get passwordSetupPageConfirmPasswordHint => '确认密码';

  @override
  String get passwordSetupPageEmptyWalletNameError => '钱包名称不能为空';

  @override
  String get passwordSetupPageLongWalletNameError => '钱包名称过长';

  @override
  String get passwordSetupPageShortPasswordError => '密码至少需要 8 个字符';

  @override
  String get passwordSetupPageMismatchPasswordError => '密码不匹配';

  @override
  String get passwordSetupPageLegacyLabel => '传统';

  @override
  String get passwordSetupPageCreateButton => '创建密码';

  @override
  String get passwordSetupPageAuthReason => '请认证以启用快速访问';

  @override
  String get passwordSetupPageSeedType => '种子';

  @override
  String get passwordSetupPageKeyType => '密钥';

  @override
  String get passwordSetupPageUniversalNetwork => '通用';

  @override
  String get browserSettingsTitle => '浏览器设置';

  @override
  String get browserSettingsBrowserOptions => '浏览器选项';

  @override
  String get browserSettingsSearchEngine => '搜索引擎';

  @override
  String get browserSettingsSearchEngineDescription => '配置您的默认搜索引擎';

  @override
  String get browserSettingsSearchEngineTitle => '搜索引擎';

  @override
  String get browserSettingsContentBlocking => '内容拦截';

  @override
  String get browserSettingsContentBlockingDescription => '配置内容拦截设置';

  @override
  String get browserSettingsContentBlockingTitle => '内容拦截';

  @override
  String get browserSettingsPrivacySecurity => '隐私与安全';

  @override
  String get browserSettingsCookies => 'Cookie';

  @override
  String get browserSettingsCookiesDescription => '允许网站保存和读取 cookie';

  @override
  String get browserSettingsDoNotTrack => '请勿跟踪';

  @override
  String get browserSettingsDoNotTrackDescription => '请求网站不要跟踪您的浏览';

  @override
  String get browserSettingsIncognitoMode => '隐身模式';

  @override
  String get browserSettingsIncognitoModeDescription => '浏览时不保存历史记录或 cookie';

  @override
  String get browserSettingsPerformance => '性能';

  @override
  String get browserSettingsCache => '缓存';

  @override
  String get browserSettingsClearData => '清除数据';

  @override
  String get browserSettingsClear => '清除';

  @override
  String get browserSettingsClearCookies => '清除 Cookie';

  @override
  String get browserSettingsClearCookiesDescription => '删除网站存储的所有 cookie';

  @override
  String get browserSettingsClearCache => '清除缓存';

  @override
  String get browserSettingsClearCacheDescription => '删除浏览时存储的临时文件和图像';

  @override
  String get browserSettingsClearLocalStorage => '清除本地存储';

  @override
  String get browserSettingsClearLocalStorageDescription => '删除本地设备上存储的网站数据';

  @override
  String get browserSettingsCacheDescription => '存储网站数据以加快加载速度';

  @override
  String get genWalletOptionsTitle => '生成钱包';

  @override
  String get genWalletOptionsBIP39Title => 'BIP39';

  @override
  String get genWalletOptionsBIP39Subtitle => '生成助记词';

  @override
  String get genWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get genWalletOptionsSLIP0039Subtitle => '生成带分享的助记词';

  @override
  String get genWalletOptionsPrivateKeyTitle => '私钥';

  @override
  String get genWalletOptionsPrivateKeySubtitle => '仅生成一个私钥';

  @override
  String get addWalletOptionsTitle => '添加钱包';

  @override
  String get addWalletOptionsNewWalletTitle => '新钱包';

  @override
  String get addWalletOptionsNewWalletSubtitle => '创建新钱包';

  @override
  String get addWalletOptionsExistingWalletTitle => '现有钱包';

  @override
  String get addWalletOptionsExistingWalletSubtitle => '使用 24 个助记词导入钱包';

  @override
  String get addWalletOptionsPairWithLedgerTitle => '与 Ledger 配对';

  @override
  String get addWalletOptionsPairWithLedgerSubtitle => '硬件模块，蓝牙';

  @override
  String get addWalletOptionsOtherOptions => '其他选项';

  @override
  String get addWalletOptionsWatchAccountTitle => '观察账户';

  @override
  String get addWalletOptionsWatchAccountSubtitle => '用于监控钱包活动，无需恢复短语';

  @override
  String get currencyConversionTitle => '主要货币';

  @override
  String get currencyConversionSearchHint => '搜索货币...';

  @override
  String get currencyConversionEngineTitle => '货币引擎';

  @override
  String get currencyConversionEngineDescription => '获取货币汇率的引擎';

  @override
  String get currencyConversionEngineSelectorTitle => '选择货币引擎';

  @override
  String get currencyConversionEngineNone => '无';

  @override
  String get currencyConversionEngineNoneSubtitle => '未选择引擎';

  @override
  String get currencyConversionEngineCoingecko => 'Coingecko';

  @override
  String get currencyConversionEngineCoingeckoSubtitle => '从 Coingecko 获取汇率';

  @override
  String get restoreWalletOptionsTitle => '恢复钱包';

  @override
  String get restoreWalletOptionsBIP39Title => 'BIP39';

  @override
  String get restoreWalletOptionsBIP39Subtitle => '使用助记词恢复';

  @override
  String get restoreWalletOptionsSLIP0039Title => 'SLIP-0039';

  @override
  String get restoreWalletOptionsSLIP0039Subtitle => '使用共享助记词恢复';

  @override
  String get restoreWalletOptionsPrivateKeyTitle => '私钥';

  @override
  String get restoreWalletOptionsPrivateKeySubtitle => '使用私钥恢复';

  @override
  String get restoreWalletOptionsKeyStoreTitle => '密钥库文件';

  @override
  String get restoreWalletOptionsKeyStoreSubtitle => '使用密码加密的备份文件恢复钱包';

  @override
  String get restoreWalletOptionsQRCodeTitle => '二维码';

  @override
  String get restoreWalletOptionsQRCodeSubtitle => '通过扫描二维码恢复钱包';

  @override
  String get argonSettingsModalContentLowMemoryTitle => '低内存';

  @override
  String get argonSettingsModalContentLowMemorySubtitle => '64KB RAM，3 次迭代';

  @override
  String get argonSettingsModalContentLowMemoryDescription => '最小内存使用，适用于低端设备。';

  @override
  String get argonSettingsModalContentOwaspTitle => 'OWASP 默认';

  @override
  String get argonSettingsModalContentOwaspSubtitle => '6.5MB RAM，2 次迭代';

  @override
  String get argonSettingsModalContentOwaspDescription => 'OWASP 推荐的一般用途。';

  @override
  String get argonSettingsModalContentSecureTitle => '安全';

  @override
  String get argonSettingsModalContentSecureSubtitle => '256MB RAM，4 次迭代';

  @override
  String get argonSettingsModalContentSecureDescription => '增加内存和迭代次数的高安全性。';

  @override
  String get argonSettingsModalContentSecretHint => '输入密钥（可选）';

  @override
  String get argonSettingsModalContentConfirmButton => '确认';

  @override
  String get confirmTransactionContentPasswordHint => '密码';

  @override
  String get confirmTransactionContentUnableToConfirm => '无法确认';

  @override
  String get confirmTransactionContentConfirm => '确认';

  @override
  String get confirmTransactionContentInsufficientBalance => '余额不足';

  @override
  String get confirmTransactionContentNoActiveAccount => '无活动账户';

  @override
  String get confirmTransactionContentFailedLoadTransfer => '加载转账详情失败';

  @override
  String get confirmTransactionEditGasButtonText => '编辑';

  @override
  String get authReason => '请进行认证';

  @override
  String get addChainModalContentWarning => '警惕网络诈骗和安全风险。';

  @override
  String get addChainModalContentApprove => '批准';

  @override
  String get addChainModalContentDetails => '详情';

  @override
  String get addChainModalContentNetworkName => '网络名称：';

  @override
  String get addChainModalContentCurrencySymbol => '货币符号：';

  @override
  String get addChainModalContentChainId => '链 ID：';

  @override
  String get addChainModalContentBlockExplorer => '区块浏览器：';

  @override
  String get addAddressModalTitle => '添加联系人';

  @override
  String get addAddressModalDescription => '输入联系人姓名和钱包地址以添加到您的地址簿。';

  @override
  String get addAddressModalNameHint => '姓名';

  @override
  String get addAddressModalAddressHint => '钱包地址';

  @override
  String get addAddressModalNameEmptyError => '姓名不能为空';

  @override
  String get addAddressModalAddressEmptyError => '地址不能为空';

  @override
  String get addAddressModalButton => '添加联系人';

  @override
  String get tokenSelectModalContentSearchHint => '搜索';

  @override
  String get signMessageModalContentAuthReason => '请进行身份验证以签署消息';

  @override
  String signMessageModalContentFailedToSign(Object error) {
    return '签名失败：$error';
  }

  @override
  String get signMessageModalContentTitle => '签署消息';

  @override
  String get signMessageModalContentDescription => '使用您的钱包审阅并签署以下消息。';

  @override
  String get signMessageModalContentDomain => '域名：';

  @override
  String get signMessageModalContentChainId => '链ID：';

  @override
  String get signMessageModalContentContract => '合约：';

  @override
  String get signMessageModalContentType => '类型：';

  @override
  String get signMessageModalContentNoData => '无数据';

  @override
  String get signMessageModalContentPasswordHint => '密码';

  @override
  String get signMessageModalContentProcessing => '处理中...';

  @override
  String get signMessageModalContentSign => '签署消息';

  @override
  String get signMessageModalContentScanning => '正在扫描Ledger设备...';

  @override
  String get signMessageModalContentNoLedgerDevices => '未找到Ledger设备';

  @override
  String get signMessageModalContentWalletNotSelected => '未选择钱包';

  @override
  String get signMessageModalContentLedgerNotSelected => '未选择Ledger设备';

  @override
  String signMessageModalContentFailedToScanLedger(Object error) {
    return '扫描Ledger设备失败：$error';
  }

  @override
  String signMessageModalContentFailedToSignMessage(Object error) {
    return '消息签名失败：$error';
  }

  @override
  String get signMessageModalContentBluetoothOff => '蓝牙已关闭。请启用蓝牙以扫描Ledger设备。';

  @override
  String get deleteWalletModalTitle => '删除钱包';

  @override
  String get deleteWalletModalWarning => '警告：此操作无法撤销。您的钱包只能使用助记词恢复。如果您无法访问助记词，您将永久失去与此账户关联的所有资金。';

  @override
  String get deleteWalletModalSecretPhraseWarning => '请确保您能够访问您的助记词，然后再继续。';

  @override
  String get deleteWalletModalPasswordHint => '输入密码';

  @override
  String get deleteWalletModalSubmit => '提交';

  @override
  String get manageTokensModalContentSearchHint => '搜索';

  @override
  String get addressSelectModalContentTitle => '选择地址';

  @override
  String get addressSelectModalContentSearchHint => '搜索 / 地址 / ENS';

  @override
  String get addressSelectModalContentUnknown => '未知';

  @override
  String get addressSelectModalContentMyAccounts => '我的账户';

  @override
  String get addressSelectModalContentAddressBook => '地址簿';

  @override
  String get addressSelectModalContentHistory => '历史';

  @override
  String get addressSelectModalContentSender => '发送方';

  @override
  String get changePasswordModalTitle => '更改密码';

  @override
  String get changePasswordModalDescription => '输入您当前的密码并选择新密码以更新您的钱包安全性。';

  @override
  String get changePasswordModalCurrentPasswordHint => '当前密码';

  @override
  String get changePasswordModalNewPasswordHint => '新密码';

  @override
  String get changePasswordModalConfirmPasswordHint => '确认新密码';

  @override
  String get changePasswordModalCurrentPasswordEmptyError => '当前密码不能为空';

  @override
  String get changePasswordModalPasswordLengthError => '密码必须至少有 6 个字符';

  @override
  String get changePasswordModalPasswordsMismatchError => '密码不匹配';

  @override
  String get changePasswordModalButton => '更改密码';

  @override
  String get confirmPasswordModalTitle => '确认密码';

  @override
  String get confirmPasswordModalDescription => '输入您的密码以继续。';

  @override
  String get confirmPasswordModalHint => '密码';

  @override
  String get confirmPasswordModalEmptyError => '密码不能为空';

  @override
  String get confirmPasswordModalGenericError => '错误：';

  @override
  String get confirmPasswordModalButton => '确认';

  @override
  String get qrScannerModalContentTitle => '扫描';

  @override
  String get qrScannerModalContentCameraInitError => '相机初始化错误：';

  @override
  String get qrScannerModalContentTorchError => '切换手电筒失败：';

  @override
  String get qrScannerModalContentOpenSettings => '打开设置';

  @override
  String get chainInfoModalContentTokenTitle => '网络代币';

  @override
  String get chainInfoModalContentNetworkInfoTitle => '网络信息';

  @override
  String get chainInfoModalContentChainLabel => '链';

  @override
  String get chainInfoModalContentShortNameLabel => '简称';

  @override
  String get chainInfoModalContentChainIdLabel => '链 ID';

  @override
  String get chainInfoModalContentSlip44Label => 'Slip44';

  @override
  String get chainInfoModalContentChainIdsLabel => '链 ID';

  @override
  String get chainInfoModalContentTestnetLabel => '测试网';

  @override
  String get chainInfoModalContentYes => '是';

  @override
  String get chainInfoModalContentNo => '否';

  @override
  String get chainInfoModalContentDiffBlockTimeLabel => '区块时间差异';

  @override
  String get chainInfoModalContentFallbackEnabledLabel => '启用回退';

  @override
  String get chainInfoModalContentDecimalsLabel => '小数位';

  @override
  String get chainInfoModalContentRpcNodesTitle => 'RPC 节点';

  @override
  String get chainInfoModalContentExplorersTitle => '浏览器';

  @override
  String get chainInfoModalContentDeleteProviderTitle => '删除网络';

  @override
  String get chainInfoModalContentSwipeToDelete => '删除网络';

  @override
  String get switchChainNetworkContentTitle => '选择网络';

  @override
  String get switchChainNetworkContentButton => '切换网络';

  @override
  String get switchChainNetworkContentTestnetLabel => '测试网';

  @override
  String get switchChainNetworkContentIdLabel => 'ID：';

  @override
  String get watchAssetModalContentTitle => '添加建议的代币';

  @override
  String get watchAssetModalContentDescription => '查看并添加应用建议的以下代币。';

  @override
  String get watchAssetModalContentTokenLabel => '代币';

  @override
  String get watchAssetModalContentBalanceLabel => '余额';

  @override
  String get watchAssetModalContentLoadingButton => '余额...';

  @override
  String get watchAssetModalContentAddButton => '添加';

  @override
  String get connectedDappsModalSearchHint => '搜索 DApps';

  @override
  String get connectedDappsModalNoDapps => '无已连接的 DApps';

  @override
  String dappListItemConnected(Object time) {
    return '已连接 $time';
  }

  @override
  String get dappListItemJustNow => '刚刚';

  @override
  String get secretRecoveryModalRevealPhraseTitle => '显示助记词';

  @override
  String get secretRecoveryModalRevealPhraseDescription => '如果您更换浏览器或更换电脑，您将需要这个助记词来访问您的账户。将它们保存在安全且隐秘的地方。';

  @override
  String get secretRecoveryModalRevealPhraseButton => '显示';

  @override
  String get secretRecoveryModalShowKeysTitle => '显示私钥';

  @override
  String get secretRecoveryModalShowKeysDescription => '警告：绝不要泄露此密钥。任何拥有您私钥的人都可以窃取您账户中的任何资产。';

  @override
  String get secretRecoveryModalShowKeysButton => '导出';

  @override
  String get secretRecoveryModalKeystoreBackupTitle => '密钥库备份';

  @override
  String get secretRecoveryModalKeystoreBackupDescription => '将您的私钥保存在密码保护的加密密钥库文件中。这为您的钱包提供了额外的安全层。';

  @override
  String get secretRecoveryModalKeystoreBackupButton => '创建密钥库备份';

  @override
  String get backupConfirmationContentTitle => '备份确认';

  @override
  String get backupConfirmationWarning => '警告：如果您丢失或忘记助记词的确切顺序，您将永久失去您的资金。绝不与任何人分享您的助记词，否则他们可能会窃取您的资金。BIP39恢复是严格的 - 恢复过程中任何单词错误都将导致资金损失。';

  @override
  String get backupConfirmationContentWrittenDown => '我已经写下了全部内容';

  @override
  String get backupConfirmationContentSafelyStored => '我已安全存储备份';

  @override
  String get backupConfirmationContentWontLose => '我确信不会丢失备份';

  @override
  String get backupConfirmationContentNotShare => '我明白不要与任何人分享这些单词';

  @override
  String get counterMaxValueError => '已达到最大值';

  @override
  String get counterMinValueError => '已达到最小值';

  @override
  String get biometricSwitchFaceId => '启用面容ID';

  @override
  String get biometricSwitchFingerprint => '启用指纹';

  @override
  String get biometricSwitchBiometric => '启用生物识别登录';

  @override
  String get biometricSwitchPinCode => '启用设备PIN码';

  @override
  String get gasFeeOptionLow => '低';

  @override
  String get gasFeeOptionMarket => '市场';

  @override
  String get gasFeeOptionAggressive => '激进';

  @override
  String get gasDetailsEstimatedGas => '估计gas用量：';

  @override
  String get gasDetailsGasPrice => 'gas价格：';

  @override
  String get gasDetailsBaseFee => '基础费用：';

  @override
  String get gasDetailsPriorityFee => '优先费用：';

  @override
  String get gasDetailsMaxFee => '最高费用：';

  @override
  String get tokenTransferAmountUnknown => '未知';

  @override
  String get transactionDetailsModal_transaction => '交易';

  @override
  String get transactionDetailsModal_hash => '哈希';

  @override
  String get transactionDetailsModal_sig => '签名';

  @override
  String get transactionDetailsModal_timestamp => '时间戳';

  @override
  String get transactionDetailsModal_blockNumber => '区块号';

  @override
  String get transactionDetailsModal_nonce => '随机数';

  @override
  String get transactionDetailsModal_addresses => '地址';

  @override
  String get transactionDetailsModal_sender => '发送方';

  @override
  String get transactionDetailsModal_recipient => '接收方';

  @override
  String get transactionDetailsModal_contractAddress => '合约地址';

  @override
  String get transactionDetailsModal_network => '网络';

  @override
  String get transactionDetailsModal_chainType => '链类型';

  @override
  String get transactionDetailsModal_networkName => '网络';

  @override
  String get transactionDetailsModal_gasFees => 'Gas和费用';

  @override
  String get transactionDetailsModal_fee => '费用';

  @override
  String get transactionDetailsModal_gasUsed => '已用Gas';

  @override
  String get transactionDetailsModal_gasLimit => 'Gas限制';

  @override
  String get transactionDetailsModal_gasPrice => 'Gas价格';

  @override
  String get transactionDetailsModal_effectiveGasPrice => '有效Gas价格';

  @override
  String get transactionDetailsModal_blobGasUsed => '已用Blob Gas';

  @override
  String get transactionDetailsModal_blobGasPrice => 'Blob Gas价格';

  @override
  String get transactionDetailsModal_error => '错误';

  @override
  String get transactionDetailsModal_errorMessage => '错误信息';

  @override
  String get amountSection_transfer => '转账';

  @override
  String get amountSection_pending => '待处理';

  @override
  String get amountSection_confirmed => '已确认';

  @override
  String get amountSection_rejected => '已拒绝';

  @override
  String get appConnectModalContent_swipeToConnect => '滑动连接';

  @override
  String get appConnectModalContent_noAccounts => '无可用账户';

  @override
  String get browserActionMenuShare => '分享';

  @override
  String get browserActionMenuCopyLink => '复制链接';

  @override
  String get browserActionMenuClose => '关闭';

  @override
  String get keystoreBackupTitle => '密钥库备份';

  @override
  String get keystoreBackupWarningTitle => '保护您的密钥库文件';

  @override
  String get keystoreBackupWarningMessage => '密钥库文件包含您的加密私钥。将此文件保存在安全位置，绝不与任何人分享。您需要创建的密码来解密此文件。';

  @override
  String get keystoreBackupConfirmPasswordHint => '确认密码';

  @override
  String get keystoreBackupCreateButton => '创建备份';

  @override
  String get keystoreBackupPasswordsDoNotMatch => '密码不匹配';

  @override
  String get keystoreBackupPasswordTooShort => '密码必须至少8个字符';

  @override
  String get keystoreBackupError => '创建备份错误：';

  @override
  String get keystoreBackupShareButton => '分享密钥库文件';

  @override
  String get keystoreBackupDoneButton => '完成';

  @override
  String get keystoreBackupSuccessTitle => '备份创建成功';

  @override
  String get keystoreBackupSuccessMessage => '您的密钥库文件已创建。请记住保管好文件和密码。';

  @override
  String get keystoreBackupSaveAsButton => '保存至文件';

  @override
  String get keystoreBackupSaveDialogTitle => '保存密钥库文件';

  @override
  String get keystoreBackupSavedSuccess => '密钥库文件保存成功';

  @override
  String get keystoreBackupSaveFailed => '密钥库文件保存失败';

  @override
  String get keystoreBackupTempLocation => '临时文件位置';

  @override
  String get keystorePasswordHint => '输入您的密钥库密码';

  @override
  String get keystoreRestoreButton => '恢复钱包';

  @override
  String get keystoreRestoreExtError => '请选择有效的.zp文件';

  @override
  String get keystoreRestoreNoFile => '未找到密钥库文件';

  @override
  String get keystoreRestoreFilesTitle => '密钥库文件';

  @override
  String get editGasDialogTitle => '编辑燃料参数';

  @override
  String get editGasDialogGasPrice => '燃料价格';

  @override
  String get editGasDialogMaxPriorityFee => '最大优先费用';

  @override
  String get editGasDialogGasLimit => '燃料限制';

  @override
  String get editGasDialogCancel => '取消';

  @override
  String get editGasDialogSave => '保存';

  @override
  String get editGasDialogInvalidGasValues => '燃料值无效。请检查您的输入。';

  @override
  String get addLedgerAccountPageAppBarTitle => '添加Ledger账户';

  @override
  String get addLedgerAccountPageGetAccountsButton => '获取账户';

  @override
  String get addLedgerAccountPageCreateButton => '创建';

  @override
  String get addLedgerAccountPageAddButton => '添加';

  @override
  String get addLedgerAccountPageScanningMessage => '正在扫描Ledger设备...';

  @override
  String get addLedgerAccountPageNoDevicesMessage => '未找到Ledger设备';

  @override
  String get addLedgerAccountPageBluetoothOffError => '蓝牙已关闭。请启用蓝牙以扫描Ledger设备。';

  @override
  String get addLedgerAccountPageEmptyWalletNameError => '钱包名称不能为空';

  @override
  String get addLedgerAccountPageWalletNameTooLongError => '钱包名称过长（最多24个字符）';

  @override
  String addLedgerAccountPageFailedToScanError(Object error) {
    return '无法扫描Ledger设备：$error';
  }

  @override
  String get addLedgerAccountPageNetworkOrLedgerMissingError => '缺少网络或Ledger数据';

  @override
  String get addLedgerAccountPageNoAccountsSelectedError => '未选择任何账户';

  @override
  String get addLedgerAccountPageNoWalletSelectedError => '未选择钱包';

  @override
  String get transactionHistoryTitle => '交易历史';

  @override
  String get transactionHistoryDescription => '在地址簿中显示来自交易历史的地址。';

  @override
  String get zilStakePageTitle => 'Zilliqa 质押';

  @override
  String get noStakingPoolsFound => '未找到质押池';

  @override
  String get aprSort => '年化率';

  @override
  String get commissionSort => '佣金';

  @override
  String get tvlSort => '总锁定价值';

  @override
  String get claimButton => '领取';

  @override
  String get stakeButton => '质押';

  @override
  String get unstakeButton => '取消质押';

  @override
  String get reinvest => '再投资';

  @override
  String get aprLabel => '年化率';

  @override
  String get commissionLabel => '佣金';

  @override
  String get tvlLabel => '总锁定价值';

  @override
  String get lpStakingBadge => 'LP 质押';

  @override
  String get stakedAmount => '已质押';

  @override
  String get rewardsAvailable => '可用奖励';

  @override
  String get pendingWithdrawals => '待处理提款';

  @override
  String get amount => '数量';

  @override
  String get claimableIn => '可领取于';

  @override
  String get blocks => '区块';

  @override
  String get unbondingPeriod => '解绑期';

  @override
  String get currentBlock => '当前区块';

  @override
  String get version => '版本';

  @override
  String get rewardsProgressTitle => '收益进度';

  @override
  String get durationDay => '天';

  @override
  String get durationHour => '小时';

  @override
  String get durationMinute => '分钟';

  @override
  String get durationLessThanAMinute => '< 1分钟';

  @override
  String get durationNotAvailable => '不适用';

  @override
  String get nodes => '节点';
}

```

`lib/ledger/common.dart`:

```dart
class LedgerAccount {
  final String publicKey;
  final String address;
  final int index;

  LedgerAccount({
    required this.publicKey,
    required this.address,
    required this.index,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LedgerAccount &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          index == other.index);

  @override
  int get hashCode => Object.hash(publicKey, index);
}

```

`lib/ledger/ethereum/ethereum_eip712_hashed_message_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumEIP712HashedMessageOperation
    extends LedgerRawOperation<Uint8List> {
  final int accountIndex;
  final Uint8List domainSeparator;
  final Uint8List hashStructMessage;

  EthereumEIP712HashedMessageOperation(
      {this.accountIndex = 0,
      required this.domainSeparator,
      required this.hashStructMessage});

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(0xe0);
    writer.writeUint8(0x0c);
    writer.writeUint8(0x00);
    writer.writeUint8(0x00);

    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    final buffer = Uint8List(1 + paths.length * 4 + 32 + 32);
    var offset = 0;
    buffer[0] = paths.length;
    for (var index = 0; index < paths.length; index++) {
      buffer.buffer
          .asByteData()
          .setUint32(1 + 4 * index, paths[index], Endian.big);
    }
    offset = 1 + 4 * paths.length;
    buffer.setAll(offset, domainSeparator);
    offset += 32;
    buffer.setAll(offset, hashStructMessage);

    final List<int> bufferBytes = buffer.buffer.asUint8List();
    writer.writeUint8(buffer.lengthInBytes);
    writer.write(bufferBytes);

    return [writer.toBytes()];
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    return bytes;
  }
}

```

`lib/ledger/ethereum/ethereum_ledger_application.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/ethereum_eip712_hashed_message_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_personal_message_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_public_key_operation.dart';
import 'package:zilpay/ledger/ethereum/ethereum_transaction_operation.dart';
import 'package:zilpay/ledger/ethereum/models.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';

class EthereumLedgerApp {
  final LedgerConnection ledger;
  final LedgerTransformer? transformer;

  EthereumLedgerApp(
    this.ledger, {
    this.transformer,
  });

  Future<List<LedgerAccount>> getAccounts(List<int> accountIndices) async {
    final List<LedgerAccount> accounts = [];

    for (final index in accountIndices) {
      final account = await ledger.sendOperation<LedgerAccount>(
        EthereumPublicKeyOperation(accountIndex: index),
        transformer: transformer,
      );
      accounts.add(account);
    }

    return accounts;
  }

  Future<EthLedgerSignature> signPersonalMessage(
    Uint8List message,
    int accountIndex,
  ) async {
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumPersonalMessageOperation(
          accountIndex: accountIndex, message: message),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  Future<EthLedgerSignature> signEIP712HashedMessage(
    Eip712Hashes hashes,
    int accountIndex,
  ) async {
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumEIP712HashedMessageOperation(
        accountIndex: accountIndex,
        domainSeparator: hashes.domainSeparator,
        hashStructMessage: hashes.hashStructMessage,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  Future<EthLedgerSignature> signTransaction(
    TransactionRequestInfo transaction,
    int walletIndex,
    int accountIndex,
  ) async {
    final txRLP = await encodeTxRlp(
      tx: transaction,
      walletIndex: BigInt.from(walletIndex),
      accountIndex: BigInt.from(accountIndex),
    );
    final signatureBytes = await ledger.sendOperation<Uint8List>(
      EthereumTransactionOperation(
        accountIndex: accountIndex,
        transaction: txRLP,
        connectionType: ledger.connectionType,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return EthLedgerSignature.fromLedgerResponse(signatureBytes);
  }

  static void _checkResult(Uint8List result) {
    if (result.length != 2) {
      return;
    }

    int status = (result[0] << 8) | result[1];

    switch (status) {
      case 0x9000: // APDU_RESPONSE_OK
        break;

      case 0x5515:
        throw Exception('Device is locked');

      case 0x6967:
        throw Exception('Operation rejected');

      case 0x6985: // APDU_RESPONSE_CONDITION_NOT_SATISFIED
        throw Exception('Condition not satisfied (possibly rejected by user)');

      case 0x0000: // APDU_NO_RESPONSE
        throw Exception('No response from device');

      case 0x6001: // APDU_RESPONSE_MODE_CHECK_FAILED
        throw Exception('Mode check failed');

      case 0x6501: // APDU_RESPONSE_TX_TYPE_NOT_SUPPORTED
        throw Exception('Transaction type not supported');

      case 0x6502: // APDU_RESPONSE_CHAINID_OUT_BUF_SMALL
        throw Exception('Chain ID buffer too small');

      case 0x6800: // APDU_RESPONSE_INTERNAL_ERROR
        throw Exception('Internal device error');

      case 0x6982: // APDU_RESPONSE_SECURITY_NOT_SATISFIED
        throw Exception('Security conditions not satisfied');

      case 0x6983: // APDU_RESPONSE_WRONG_DATA_LENGTH
        throw Exception('Incorrect data length');

      case 0x6984: // APDU_RESPONSE_PLUGIN_NOT_INSTALLED
        throw Exception('Plugin not installed');

      case 0x6a00: // APDU_RESPONSE_ERROR_NO_INFO
        throw Exception('Error with no additional information');

      case 0x6a80: // APDU_RESPONSE_INVALID_DATA
        throw Exception('Invalid data');

      case 0x6a84: // APDU_RESPONSE_INSUFFICIENT_MEMORY
        throw Exception('Insufficient memory');

      case 0x6a88: // APDU_RESPONSE_REF_DATA_NOT_FOUND
        throw Exception('Reference data not found');

      case 0x6b00: // APDU_RESPONSE_INVALID_P1_P2
        throw Exception('Invalid P1 or P2 parameters');

      case 0x6d00: // APDU_RESPONSE_INVALID_INS
        throw Exception('Invalid instruction');

      case 0x6e00: // APDU_RESPONSE_INVALID_CLA
        throw Exception('Invalid class');

      case 0x6f00: // APDU_RESPONSE_UNKNOWN
        throw Exception('Unknown error');

      case 0x911c: // APDU_RESPONSE_CMD_CODE_NOT_SUPPORTED
        throw Exception('Command code not supported');

      default:
        throw Exception(
            'Unknown status code: 0x${status.toRadixString(16).padLeft(4, '0')}');
    }
  }
}

```

`lib/ledger/ethereum/ethereum_personal_message_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumPersonalMessageOperation extends LedgerRawOperation<Uint8List> {
  final int accountIndex;
  final Uint8List message;

  EthereumPersonalMessageOperation(
      {this.accountIndex = 0, required this.message});

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    final output = <Uint8List>[];
    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    int offset = 0;
    while (offset != message.length) {
      final writer = ByteDataWriter();
      writer.writeUint8(0xe0);
      writer.writeUint8(0x08);

      int maxChunkSize = offset == 0 ? 150 - 1 - paths.length * 4 - 4 : 150;
      int chunkSize = offset + maxChunkSize > message.length
          ? message.length - offset
          : maxChunkSize;
      ByteData buffer = ByteData(
          offset == 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);
      if (offset == 0) {
        buffer.setUint8(0, paths.length);
        for (int i = 0; i < paths.length; i++) {
          buffer.setUint32(1 + 4 * i, paths[i], Endian.big);
        }
        buffer.setUint32(1 + 4 * paths.length, message.length, Endian.big);
        buffer.buffer.asUint8List().setAll(1 + 4 * paths.length + 4,
            message.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x00);
      } else {
        buffer.buffer
            .asUint8List()
            .setAll(0, message.sublist(offset, offset + chunkSize));
        writer.writeUint8(0x80);
      }

      writer.writeUint8(0x00);

      final List<int> bufferBytes = buffer.buffer.asUint8List();
      writer.writeUint8(buffer.lengthInBytes);
      writer.write(bufferBytes);

      offset += chunkSize;

      output.add(writer.toBytes());
    }

    return output;
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    return bytes;
  }
}

```

`lib/ledger/ethereum/ethereum_public_key_operation.dart`:

```dart
import 'dart:convert';
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

class EthereumPublicKeyOperation extends LedgerRawOperation<LedgerAccount> {
  final int accountIndex;

  EthereumPublicKeyOperation({
    this.accountIndex = 0,
  });

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(0xe0); // CLA (class of instruction)
    writer.writeUint8(0x02); // INS (instruction code) - GET_PUBLIC_KEY
    writer.writeUint8(0x00); // P1 parameter
    writer.writeUint8(0x00); // P2 parameter

    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    final int bufferSize = 1 + paths.length * 4;
    final ByteData buffer = ByteData(bufferSize)..setUint8(0, paths.length);
    for (int i = 0; i < paths.length; i++) {
      buffer.setUint32(1 + 4 * i, paths[i], Endian.big);
    }

    final List<int> bufferBytes = buffer.buffer.asUint8List();
    writer.writeUint8(buffer.lengthInBytes); // CDATA length
    writer.write(bufferBytes); // CDATA

    return [writer.toBytes()];
  }

  @override
  Future<LedgerAccount> read(ByteDataReader reader) async {
    final bytes = reader.read(reader.remainingLength);
    int publicKeyLength = bytes[0];
    int addressLength = bytes[1 + publicKeyLength];
    final publicKey =
        bytesToHex(bytes.sublist(1, 1 + publicKeyLength), include0x: true);
    final address =
        '0x${utf8.decode(bytes.sublist(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength))}';
    return LedgerAccount(
      publicKey: publicKey,
      address: address,
      index: accountIndex,
    );
  }
}

```

`lib/ledger/ethereum/ethereum_transaction_operation.dart`:

```dart
import 'dart:async';
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';

const int ETH_CLA = 0xe0;
const int ETH_INS_SIGN = 0x04;
const int P1_FIRST_CHUNK = 0x00;
const int P1_MORE_CHUNKS = 0x80;
const int P2_UNUSED = 0x00;
const int MAX_APDU_PAYLOAD_SIZE = 250;
const int ETH_SIGNATURE_LENGTH = 65;

class EthereumTransactionOperation extends LedgerComplexOperation<Uint8List> {
  final int accountIndex;
  final Uint8List transaction;
  final ConnectionType connectionType;

  const EthereumTransactionOperation({
    required this.accountIndex,
    required this.transaction,
    required this.connectionType,
  });

  @override
  Future<Uint8List> invoke(LedgerSendFct send) async {
    final List<int> paths = splitPath(getWalletDerivationPath(accountIndex));
    if (paths.isEmpty) {
      throw Exception('Derivation path is empty');
    }

    final pathWriter = ByteDataWriter();
    pathWriter.writeUint8(paths.length);
    for (var pathElement in paths) {
      pathWriter.writeUint32(pathElement, Endian.big);
    }
    final pathBytes = pathWriter.toBytes();

    int offset = 0;
    ByteDataReader? responseReader;

    final firstChunkSize = min(
      transaction.length,
      MAX_APDU_PAYLOAD_SIZE - pathBytes.length,
    );

    if (firstChunkSize < 0) {
      throw Exception(
          'Transaction data is too small to fit with derivation path in the first chunk.');
    }

    final firstPayloadWriter = ByteDataWriter();
    firstPayloadWriter.write(pathBytes);
    firstPayloadWriter
        .write(transaction.sublist(offset, offset + firstChunkSize));
    final firstPayload = firstPayloadWriter.toBytes();

    responseReader = await send(
      LedgerSimpleOperation(
        cla: ETH_CLA,
        ins: ETH_INS_SIGN,
        p1: P1_FIRST_CHUNK,
        p2: P2_UNUSED,
        data: firstPayload,
        prependDataLength: true,
        debugName: 'Sign Ethereum Txn Chunk 1',
      ),
    );

    offset += firstChunkSize;
    while (offset < transaction.length) {
      final remainingBytes = transaction.length - offset;
      final currentChunkSize = min(remainingBytes, MAX_APDU_PAYLOAD_SIZE);

      final nextPayload =
          transaction.sublist(offset, offset + currentChunkSize);

      responseReader = await send(
        LedgerSimpleOperation(
          cla: ETH_CLA,
          ins: ETH_INS_SIGN,
          p1: P1_MORE_CHUNKS,
          p2: P2_UNUSED,
          data: nextPayload,
          prependDataLength: true,
          debugName: 'Sign Ethereum Txn Chunk N',
        ),
      );

      offset += currentChunkSize;
    }

    if (responseReader == null) {
      throw LedgerDeviceException(
        message:
            'No response received from Ledger device after sending transaction data.',
        connectionType: connectionType,
      );
    }

    if (responseReader.remainingLength < ETH_SIGNATURE_LENGTH) {
      throw LedgerDeviceException(
        message:
            'Signature response too short. Expected $ETH_SIGNATURE_LENGTH bytes, got ${responseReader.remainingLength}',
        connectionType: connectionType,
      );
    }

    final signatureBytes = responseReader.read(ETH_SIGNATURE_LENGTH);

    return signatureBytes;
  }
}

```

`lib/ledger/ethereum/models.dart`:

```dart
import 'dart:typed_data';

import 'package:zilpay/ledger/ethereum/utils.dart';

class EthLedgerSignature {
  final int v;
  final Uint8List r;
  final Uint8List s;

  EthLedgerSignature({required this.v, required this.r, required this.s});

  String toHexString() {
    if (r.length != 32 || s.length != 32) {
      throw ArgumentError('r and s must be 32 bytes long');
    }

    final buffer = Uint8List(65);
    buffer.setRange(0, 32, r);
    buffer.setRange(32, 64, s);
    buffer[64] = v;

    return bytesToHex(buffer, include0x: true);
  }

  Uint8List toBytes() {
    if (r.length != 32 || s.length != 32) {
      throw ArgumentError('r and s must be 32 bytes long');
    }

    final buffer = Uint8List(65);
    buffer.setRange(0, 32, r);
    buffer.setRange(32, 64, s);
    buffer[64] = v;

    return buffer;
  }

  static EthLedgerSignature fromBytes(Uint8List bytes) {
    if (bytes.length != 65) {
      throw ArgumentError(
          'Bytes must be 65 bytes long to form a valid signature');
    }

    final v = bytes[64];
    final r = Uint8List.sublistView(bytes, 0, 32);
    final s = Uint8List.sublistView(bytes, 32, 64);

    return EthLedgerSignature(v: v, r: r, s: s);
  }

  static EthLedgerSignature fromLedgerResponse(Uint8List bytes) {
    if (bytes.length < 65) {
      throw FormatException('Response too short to contain valid signature');
    }

    int v = bytes[0];
    Uint8List r = Uint8List.sublistView(bytes, 1, 1 + 32);
    Uint8List s = Uint8List.sublistView(bytes, 1 + 32, 1 + 32 + 32);

    return EthLedgerSignature(v: v, r: r, s: s);
  }
}

```

`lib/ledger/ethereum/utils.dart`:

```dart
String getWalletDerivationPath(int accountIndex) {
  if (accountIndex < 0) {
    throw ArgumentError('accountIndex должен быть >= 0');
  }
  return "m/44'/60'/0'/0/$accountIndex";
}

List<int> splitPath(String path) {
  List<int> result = [];
  List<String> components = path.split("/");

  for (var element in components) {
    if (element.isEmpty || element == "m") continue;

    int number = int.tryParse(element.replaceAll("'", "")) ?? 0;

    if (element.length > 1 && element[element.length - 1] == "'") {
      number += 0x80000000;
    }

    result.add(number);
  }

  return result;
}

String bytesToHex(List<int> bytes, {bool include0x = false}) {
  final buffer = StringBuffer();
  if (include0x) {
    buffer.write('0x');
  }

  for (final byte in bytes) {
    buffer.write(byte.toRadixString(16).padLeft(2, '0'));
  }

  return buffer.toString();
}

```

`lib/ledger/zilliqa/zilliqa_ledger_application.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/utils.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_public_key_operation.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_sign_hash_operation.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_sign_tx_operation.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';

class ZilliqaLedgerApp {
  final LedgerConnection ledger;
  final LedgerTransformer? transformer;

  ZilliqaLedgerApp(
    this.ledger, {
    this.transformer,
  });

  Future<List<LedgerAccount>> getPublicAddress(
    List<int> accountIndices,
  ) async {
    final List<LedgerAccount> accounts = [];

    for (final index in accountIndices) {
      final account = await ledger.sendOperation<LedgerAccount>(
        ZilliqaPublicAddressOperation(index),
        transformer: transformer,
      );

      accounts.add(account);
    }

    return accounts;
  }

  Future<String> signHash(
    Uint8List hashBytes,
    int accountIndex,
  ) async {
    final signature = await ledger.sendOperation<Uint8List>(
      ZilliqaSignHashOperation(
        accountIndex,
        hashBytes,
      ),
      transformer: transformer,
    );

    _checkResult(signature);

    return bytesToHex(signature);
  }

  Future<Uint8List> signTransaction(
    TransactionRequestInfo transaction,
    int walletIndex,
    int accountIndex,
  ) async {
    final protoBuf = await encodeTxRlp(
      tx: transaction,
      walletIndex: BigInt.from(walletIndex),
      accountIndex: BigInt.from(accountIndex),
    );

    final signatureBytes = await ledger.sendOperation<Uint8List>(
      SignZilliqaTransactionOperation(
        keyIndex: accountIndex,
        transactionBytes: protoBuf,
        connectionType: ledger.connectionType,
      ),
      transformer: transformer,
    );

    _checkResult(signatureBytes);

    return signatureBytes;
  }

  static void _checkResult(Uint8List result) {
    if (result.length != 2) {
      return;
    }

    int status = (result[0] << 8) | result[1];

    switch (status) {
      case 0x9000:
        break;
      case 0x5515:
        throw Exception('Device is locked');
      case 0x6967:
        throw Exception('Operation rejected');
      case 0x6985:
        throw Exception('Condition not satisfied (possibly rejected by user)');
      case 0x6a80:
        throw Exception('Invalid data');
      case 0x6f00:
        throw Exception('Unknown error');
      default:
        throw Exception(
            'Unknown status code: 0x${status.toRadixString(16).padLeft(4, '0')}');
    }
  }
}

```

`lib/ledger/zilliqa/zilliqa_public_key_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';
import 'package:zilpay/ledger/common.dart';

class ZilliqaPublicAddressOperation extends LedgerRawOperation<LedgerAccount> {
  static const cla = 0xE0;
  static const ins = 0x02;
  static const pubKeyByteLen = 33;
  static const bech32AddrLen = 39;

  final int accountIndex;

  ZilliqaPublicAddressOperation(this.accountIndex);

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(cla); // CLA
    writer.writeUint8(ins); // INS: getPublicAddress
    writer.writeUint8(0x00); // P1
    writer.writeUint8(0x01); // P2: request public address
    writer.writeUint8(0x04); // Data length (4 bytes for index)
    writer.writeInt32(accountIndex, Endian.little); // Account index

    return [writer.toBytes()];
  }

  @override
  Future<LedgerAccount> read(ByteDataReader reader) async {
    final publicKeyBytes = reader.read(pubKeyByteLen);
    final publicKey = publicKeyBytes
        .map((byte) => byte.toRadixString(16).padLeft(2, '0'))
        .join();

    final addressBytes = reader.read(bech32AddrLen);
    final address = String.fromCharCodes(addressBytes);

    return LedgerAccount(
      publicKey: publicKey,
      address: address,
      index: accountIndex,
    );
  }
}

```

`lib/ledger/zilliqa/zilliqa_sign_hash_operation.dart`:

```dart
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';

class ZilliqaSignHashOperation extends LedgerRawOperation<Uint8List> {
  static const cla = 0xE0;
  static const ins = 0x08;
  static const sigByteLen = 64;

  final int accountIndex;
  final Uint8List hash;

  ZilliqaSignHashOperation(this.accountIndex, this.hash);

  @override
  Future<List<Uint8List>> write(ByteDataWriter writer) async {
    writer.writeUint8(cla); // CLA
    writer.writeUint8(ins); // INS: signHash
    writer.writeUint8(0x00); // P1
    writer.writeUint8(0x00); // P2

    writer.writeUint8(4 + hash.length);
    writer.writeInt32(accountIndex, Endian.little);
    writer.write(hash);

    return [writer.toBytes()];
  }

  @override
  Future<Uint8List> read(ByteDataReader reader) async {
    final signatureBytes = reader.read(sigByteLen);

    return signatureBytes;
  }
}

```

`lib/ledger/zilliqa/zilliqa_sign_tx_operation.dart`:

```dart
import 'dart:async';
import 'dart:math';
import 'dart:typed_data';

import 'package:ledger_flutter_plus/ledger_flutter_plus_dart.dart';

const int CLA = 0xe0;
const int INS_SIGN_TXN = 0x04;
const int P1_FIRST = 0x00;
const int P2_FIRST = 0x00;
const int STREAM_LEN = 128;
const int SIG_BYTE_LEN = 64;

class SignZilliqaTransactionOperation
    extends LedgerComplexOperation<Uint8List> {
  final int keyIndex;
  final Uint8List transactionBytes;
  final ConnectionType connectionType;

  const SignZilliqaTransactionOperation({
    required this.keyIndex,
    required this.transactionBytes,
    required this.connectionType,
  });

  @override
  Future<Uint8List> invoke(LedgerSendFct send) async {
    Uint8List txnBytes = transactionBytes;
    int txnOffset = 0;

    final indexBytesWriter = ByteDataWriter(endian: Endian.little);
    indexBytesWriter.writeInt32(keyIndex);
    final indexBytes = indexBytesWriter.toBytes();

    final firstChunkSize = min(txnBytes.length, STREAM_LEN);
    final txn1Bytes = txnBytes.sublist(txnOffset, txnOffset + firstChunkSize);
    txnOffset += firstChunkSize;
    final hostBytesLeft = txnBytes.length - txnOffset;

    final hostBytesLeftWriter = ByteDataWriter(endian: Endian.little);
    hostBytesLeftWriter.writeInt32(hostBytesLeft);
    final hostBytesLeftBytes = hostBytesLeftWriter.toBytes();

    final txn1SizeWriter = ByteDataWriter(endian: Endian.little);
    txn1SizeWriter.writeInt32(txn1Bytes.length);
    final txn1SizeBytes = txn1SizeWriter.toBytes();

    final firstPayloadWriter = ByteDataWriter();
    firstPayloadWriter.write(indexBytes);
    firstPayloadWriter.write(hostBytesLeftBytes);
    firstPayloadWriter.write(txn1SizeBytes);
    firstPayloadWriter.write(txn1Bytes);
    final firstPayload = firstPayloadWriter.toBytes();

    ByteDataReader responseReader = await send(
      LedgerSimpleOperation(
        cla: CLA,
        ins: INS_SIGN_TXN,
        p1: P1_FIRST,
        p2: P2_FIRST,
        data: firstPayload,
        prependDataLength: true,
        debugName: 'Sign Zilliqa Txn Chunk 1',
      ),
    );

    while (txnOffset < txnBytes.length) {
      final currentChunkSize = min(txnBytes.length - txnOffset, STREAM_LEN);
      final txnNBytes =
          txnBytes.sublist(txnOffset, txnOffset + currentChunkSize);
      txnOffset += currentChunkSize;
      final remainingBytes = txnBytes.length - txnOffset;

      final hostBytesLeftWriterNext = ByteDataWriter(endian: Endian.little);
      hostBytesLeftWriterNext.writeInt32(remainingBytes);
      final hostBytesLeftBytesNext = hostBytesLeftWriterNext.toBytes();

      final txnNSizeWriter = ByteDataWriter(endian: Endian.little);
      txnNSizeWriter.writeInt32(txnNBytes.length);
      final txnNSizeBytes = txnNSizeWriter.toBytes();

      final nextPayloadWriter = ByteDataWriter();
      nextPayloadWriter.write(hostBytesLeftBytesNext);
      nextPayloadWriter.write(txnNSizeBytes);
      nextPayloadWriter.write(txnNBytes);
      final nextPayload = nextPayloadWriter.toBytes();

      responseReader = await send(
        LedgerSimpleOperation(
          cla: CLA,
          ins: INS_SIGN_TXN,
          p1: P1_FIRST,
          p2: P2_FIRST,
          data: nextPayload,
          prependDataLength: true,
          debugName: 'Sign Zilliqa Txn Chunk N',
        ),
      );
    }

    if (responseReader.remainingLength < SIG_BYTE_LEN) {
      throw LedgerDeviceException(
        message:
            'Signature response too short. Expected $SIG_BYTE_LEN bytes, got ${responseReader.remainingLength}',
        connectionType: connectionType,
      );
    }

    final signatureBytes = responseReader.read(SIG_BYTE_LEN);
    return signatureBytes;
  }
}

```

`lib/main.dart`:

```dart
import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:flutter/material.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/src/rust/models/background.dart';

import 'services/auth_guard.dart';
import 'state/app_state.dart';

import 'package:zilpay/src/rust/frb_generated.dart';
import 'app.dart';

Future<String> getStoragePath() async {
  final appDocDir = await getApplicationSupportDirectory();
  return appDocDir.path;
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await RustLib.init();

  BackgroundState state;

  try {
    String appDocPath = await getStoragePath();
    final tempDir = await getTemporaryDirectory();

    final directory = Directory(tempDir.path);

    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }

    state = await loadService(path: "$appDocPath/storage");

    final appState = AppState(
      state: state,
      cahceDir: tempDir.path,
    );

    final authGuard = AuthGuard(state: appState);

    runApp(ZilPayApp(authGuard: authGuard, appState: appState));
  } catch (e) {
    debugPrint("try start, Error: $e");
  }
}

```

`lib/mixins/adaptive_size.dart`:

```dart
import 'package:flutter/material.dart';

class AdaptiveSize {
  static double getAdaptivePadding(
      BuildContext context, double defaultPadding) {
    final size = MediaQuery.of(context).size;

    if (size.width <= 375) {
      return defaultPadding / 2;
    }

    return defaultPadding;
  }
}

```

`lib/mixins/addr.dart`:

```dart
String shortenAddress(String address, {int leftSize = 6, int rightSize = 3}) {
  if (address.length < (leftSize + rightSize)) {
    return address;
  }

  final left = address.substring(0, leftSize);
  final right = address.substring(address.length - rightSize);

  return '$left..$right';
}

```

`lib/mixins/amount.dart`:

```dart
import 'package:flutter/rendering.dart';
import 'package:zilpay/config/ftokens.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/state/app_state.dart';

BigInt toDecimalsWei(String amount, int decimals) {
  try {
    final (value, dec) = toWei(value: amount, decimals: decimals);

    return BigInt.parse(value);
  } catch (e) {
    debugPrint("fail to parse number ${amount}");

    return BigInt.zero;
  }
}

(String, String) formatingAmount({
  required BigInt amount,
  required String symbol,
  required int decimals,
  required double rate,
  required AppState appState,
  double? threshold,
  bool? compact,
}) {
  String? convertedSymbolStr = appState.wallet?.settings.currencyConvert;
  double converted = 0;

  if (appState.account != null &&
      appState.wallet?.settings.ratesApiOptions != 0) {
    final account = appState.account;
    final chain = appState.getChain(account!.chainHash);

    converted = chain?.testnet == true ? 0 : rate;
  }

  return intlNumberFormating(
    value: amount.toString(),
    decimals: decimals,
    localeStr: appState.state.locale ?? "",
    nativeSymbolStr: symbol,
    convertedSymbolStr: convertedSymbolStr ?? '',
    threshold: threshold ?? baseThreshold,
    compact: compact ?? appState.state.abbreviatedNumber,
    converted: converted,
  );
}

```

`lib/mixins/colors.dart`:

```dart
import 'dart:ui';

String hexStrToColor(Color color) {
  return '#${color.toARGB32().toRadixString(16).padLeft(8, '0').substring(2)}';
}

```

`lib/mixins/eip712.dart`:

```dart
import 'dart:convert';

class EIP712Type {
  final String name;
  final String type;

  EIP712Type({required this.name, required this.type});

  factory EIP712Type.fromJson(Map<String, dynamic> json) {
    return EIP712Type(
      name: json['name'] as String,
      type: json['type'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'type': type,
    };
  }
}

class EIP712Domain {
  final String name;
  final String? version;
  final dynamic chainId;
  final String verifyingContract;

  EIP712Domain({
    required this.name,
    this.version,
    required this.chainId,
    required this.verifyingContract,
  });

  factory EIP712Domain.fromJson(Map<String, dynamic> json) {
    return EIP712Domain(
      name: json['name'] as String,
      version: json['version'] as String?,
      chainId: json['chainId'],
      verifyingContract: json['verifyingContract'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> result = {
      'name': name,
      'chainId': chainId,
      'verifyingContract': verifyingContract,
    };
    if (version != null) {
      result['version'] = version;
    }
    return result;
  }
}

class TypedDataEip712 {
  final Map<String, List<EIP712Type>> types;
  final String primaryType;
  final EIP712Domain domain;
  final Map<String, dynamic> message;

  TypedDataEip712({
    required this.types,
    required this.primaryType,
    required this.domain,
    required this.message,
  });

  factory TypedDataEip712.fromJson(Map<String, dynamic> json) {
    final typesJson = json['types'] as Map<String, dynamic>;
    final types = typesJson.map((key, value) => MapEntry(
          key,
          (value as List)
              .map((e) => EIP712Type.fromJson(e as Map<String, dynamic>))
              .toList(),
        ));

    return TypedDataEip712(
      types: types,
      primaryType: json['primaryType'] as String,
      domain: EIP712Domain.fromJson(json['domain'] as Map<String, dynamic>),
      message: json['message'] as Map<String, dynamic>,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'types': types.map((key, value) => MapEntry(
            key,
            value.map((type) => type.toJson()).toList(),
          )),
      'primaryType': primaryType,
      'domain': domain.toJson(),
      'message': message,
    };
  }

  String toJsonString() {
    return jsonEncode(toJson());
  }

  static TypedDataEip712 fromJsonString(String jsonStr) {
    return TypedDataEip712.fromJson(
        jsonDecode(jsonStr) as Map<String, dynamic>);
  }
}

```

`lib/mixins/gas_eip1559.dart`:

```dart
import 'package:zilpay/src/rust/models/ftoken.dart';

enum GasFeeOption { low, market, aggressive }

BigInt calculateMaxPriorityFee(GasFeeOption option, BigInt priorityFee) {
  switch (option) {
    case GasFeeOption.low:
      return BigInt.zero;
    case GasFeeOption.market:
      final multiplied = priorityFee * BigInt.from(150);

      return multiplied ~/ BigInt.from(100);
    case GasFeeOption.aggressive:
      final multiplied = priorityFee * BigInt.from(300);

      return multiplied ~/ BigInt.from(100);
  }
}

BigInt calculateGasPrice(GasFeeOption option, BigInt gasPrice) {
  switch (option) {
    case GasFeeOption.low:
      return gasPrice;

    case GasFeeOption.market:
      final increase = gasPrice * BigInt.from(20);

      final increasedAmount = increase ~/ BigInt.from(100);
      return gasPrice + increasedAmount;

    case GasFeeOption.aggressive:
      final increase = gasPrice * BigInt.from(50);

      final increasedAmount = increase ~/ BigInt.from(100);
      return gasPrice + increasedAmount;
  }
}

BigInt calculateMaxFeePerGas(
  GasFeeOption option,
  BigInt baseFee,
  BigInt priorityFee,
) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);
  switch (option) {
    case GasFeeOption.low:
      return baseFee + maxPriorityFee;
    case GasFeeOption.market:
      return baseFee +
          maxPriorityFee +
          (baseFee * BigInt.from(20) ~/ BigInt.from(100));
    case GasFeeOption.aggressive:
      return baseFee +
          maxPriorityFee +
          (baseFee * BigInt.from(50) ~/ BigInt.from(100));
  }
}

BigInt calculateFeeForOption(
    GasFeeOption option, BigInt baseFee, BigInt priorityFee) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);
  final maxFeePerGas = calculateMaxFeePerGas(option, baseFee, priorityFee);
  final minRequired = baseFee + maxPriorityFee;

  if (maxFeePerGas < minRequired) {
    return minRequired;
  }

  return maxFeePerGas;
}

BigInt calculateEffectiveGasPrice(
  GasFeeOption option,
  BigInt baseFee,
  BigInt priorityFee,
) {
  final maxPriorityFee = calculateMaxPriorityFee(option, priorityFee);

  return maxPriorityFee + baseFee;
}

BigInt calculateTotalGasCost(
  GasFeeOption option,
  BigInt baseFee,
  BigInt priorityFee,
  BigInt gasLimit,
  BigInt gasPrice,
) {
  if (baseFee != BigInt.zero) {
    final effectiveGasPrice =
        calculateEffectiveGasPrice(option, baseFee, priorityFee);
    return effectiveGasPrice * gasLimit;
  } else {
    return calculateGasPrice(option, gasPrice) * gasLimit;
  }
}

String formatGasPriceDetail(BigInt price, FTokenInfo token) {
  final gwei = price / BigInt.from(10).pow(9);

  if (gwei < 0.1) {
    return '${price.toString()} Wei';
  } else if (gwei < 1000000) {
    return '${gwei.toStringAsFixed(2)} Gwei';
  } else {
    final eth = price / BigInt.from(10).pow(18);
    return '${eth.toStringAsFixed(6)} ${token.symbol}';
  }
}

```

`lib/mixins/jazzicon.dart`:

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';
import 'package:zilpay/theme/app_theme.dart';

class Jazzicon extends StatefulWidget {
  final double diameter;
  final String seed;
  final int shapeCount;
  final AppTheme theme;

  const Jazzicon({
    super.key,
    required this.diameter,
    required this.seed,
    required this.theme,
    this.shapeCount = 4,
  });

  @override
  State<Jazzicon> createState() => _JazziconState();
}

class _JazziconState extends State<Jazzicon> {
  late JazziconPainter _painter;
  String? _previousSeed;
  double? _previousDiameter;
  int? _previousShapeCount;
  AppTheme? _previousTheme;

  @override
  void initState() {
    super.initState();
    _updatePainter();
  }

  @override
  void didUpdateWidget(Jazzicon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.seed != _previousSeed ||
        widget.diameter != _previousDiameter ||
        widget.shapeCount != _previousShapeCount ||
        widget.theme != _previousTheme) {
      _updatePainter();
    }
  }

  void _updatePainter() {
    _painter = JazziconPainter(
      seed: widget.seed,
      diameter: widget.diameter,
      theme: widget.theme,
      shapeCount: widget.shapeCount,
    );

    _previousSeed = widget.seed;
    _previousDiameter = widget.diameter;
    _previousShapeCount = widget.shapeCount;
    _previousTheme = widget.theme;
  }

  @override
  Widget build(BuildContext context) {
    return ClipOval(
      child: RepaintBoundary(
        child: CustomPaint(
          size: Size(widget.diameter, widget.diameter),
          painter: _painter,
          isComplex: true, // Указывает Flutter, что отрисовка сложная
        ),
      ),
    );
  }
}

class JazziconPainter extends CustomPainter {
  final String seed;
  final double diameter;
  final int shapeCount;
  late final Random _random;
  final AppTheme theme;
  late final List<Color> _colors;
  late final List<_ShapeConfig> _shapes;

  JazziconPainter({
    required this.seed,
    required this.diameter,
    required this.shapeCount,
    required this.theme,
  }) {
    if (seed.isEmpty) {
      throw ArgumentError('Seed cannot be empty');
    }

    _random = Random(_generateSeedFromString(seed));

    List<Color> colors = [
      theme.primaryPurple,
      theme.secondaryPurple,
      theme.background,
      theme.cardBackground,
      theme.textPrimary,
      theme.textSecondary,
      theme.buttonBackground,
      theme.success,
      theme.danger,
      theme.warning
    ];

    _colors = _hueShift(List<Color>.from(colors));
    _shapes = _generateShapes();
  }

  int _generateSeedFromString(String str) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
      var chr = str.codeUnitAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0;
    }
    return hash.abs();
  }

  List<_ShapeConfig> _generateShapes() {
    final shapes = <_ShapeConfig>[];
    final List<Color> remainingColors = List<Color>.from(_colors);

    // Фоновый цвет
    final backgroundColor = _genColor(remainingColors);
    shapes.add(_ShapeConfig(
      color: backgroundColor,
      transform: Matrix4.identity(),
    ));

    // Генерация остальных фигур
    for (var i = 0; i < shapeCount - 1; i++) {
      final shapeConfig = _genShape(i, shapeCount - 1, remainingColors);
      shapes.add(shapeConfig);
    }

    return shapes;
  }

  _ShapeConfig _genShape(int i, int total, List<Color> remainingColors) {
    final center = diameter / 2;

    final firstRot = _random.nextDouble();
    final angle = 2 * pi * firstRot;
    final velocity =
        (diameter / total * _random.nextDouble()) + (i * diameter / total);

    final tx = cos(angle) * velocity;
    final ty = sin(angle) * velocity;

    final secondRot = _random.nextDouble();
    final rot = (firstRot * 360) + secondRot * 180;

    final transform = Matrix4.identity()
      ..translate(tx, ty)
      ..translate(center, center)
      ..rotateZ(rot * pi / 180)
      ..translate(-center, -center);

    return _ShapeConfig(
      color: _genColor(remainingColors),
      transform: transform,
    );
  }

  Color _genColor(List<Color> remainingColors) {
    if (remainingColors.isEmpty) return const Color(0xFF000000);
    final idx = (_random.nextDouble() * remainingColors.length).floor();
    return remainingColors.removeAt(idx);
  }

  List<Color> _hueShift(List<Color> colors) {
    const wobble = 30;
    final amount = (_random.nextDouble() * 30) - (wobble / 2);
    return colors.map((color) => _colorRotate(color, amount)).toList();
  }

  Color _colorRotate(Color color, double degrees) {
    final hsl = HSLColor.fromColor(color);
    var hue = hsl.hue;
    hue = (hue + degrees) % 360;
    hue = hue < 0 ? 360 + hue : hue;
    return hsl.withHue(hue).toColor();
  }

  @override
  void paint(Canvas canvas, Size size) {
    for (final shape in _shapes) {
      canvas.save();
      canvas.transform(shape.transform.storage);

      final rect = Rect.fromLTWH(0, 0, size.width, size.height);
      final rrect = RRect.fromRectAndRadius(
        rect,
        const Radius.circular(4.0),
      );

      final paint = Paint()
        ..isAntiAlias = true
        ..style = PaintingStyle.fill
        ..color = shape.color;

      canvas.drawRRect(rrect, paint);
      canvas.restore();
    }
  }

  @override
  bool shouldRepaint(JazziconPainter oldDelegate) {
    return seed != oldDelegate.seed ||
        diameter != oldDelegate.diameter ||
        shapeCount != oldDelegate.shapeCount ||
        theme != oldDelegate.theme;
  }
}

class _ShapeConfig {
  final Color color;
  final Matrix4 transform;

  const _ShapeConfig({
    required this.color,
    required this.transform,
  });
}

```

`lib/mixins/preprocess_url.dart`:

```dart
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';

String selectVariant(String? theme, List<String> options) {
  if (options.isEmpty) return '';
  if (theme == 'Light') return options[0];
  if (theme == 'Dark' && options.length >= 2) return options[1];
  return options[0];
}

String processUrl(String template, String? theme) {
  final regex = RegExp(r'%\{(\w+)\(([^)]+)\)\}%');
  return template.replaceAllMapped(regex, (match) {
    String optionsStr = match.group(2)!;
    List<String> options = optionsStr.split(',').map((s) => s.trim()).toList();
    return selectVariant(theme, options);
  });
}

String processUrlTemplate({
  required String template,
  required String theme,
  Map<String, String> replacements = const {},
}) {
  if (!template.contains('%{')) return template;

  String processed = template;

  final funcRegex = RegExp(r'%\{(\w+)\(([^)]+)\)\}%');
  processed = processed.replaceAllMapped(funcRegex, (match) {
    String optionsStr = match.group(2)!;
    List<String> options = optionsStr.split(',').map((s) => s.trim()).toList();

    if (options.isEmpty) return '';
    if (theme == 'Light') return options[0];
    if (theme == 'Dark' && options.length >= 2) return options[1];
    return options[0];
  });

  if (processed.contains('%{dark,light}%')) {
    processed = processed.replaceAll(
        '%{dark,light}%', theme == 'Dark' ? 'light' : 'dark');
  }

  for (final entry in replacements.entries) {
    processed = processed.replaceAll('%{${entry.key}}%', entry.value);
  }

  return processed;
}

String processTokenLogo({
  required FTokenInfo token,
  required String shortName,
  required String theme,
}) {
  if (token.logo == null) return 'assets/icons/warning.svg';

  final replacements = <String, String>{
    'symbol': token.symbol.toLowerCase(),
    'contract_address': token.addr.toLowerCase(),
    'name': token.name,
    'shortName': shortName,
  };

  return processUrlTemplate(
    template: token.logo!,
    theme: theme,
    replacements: replacements,
  );
}

String formExplorerUrl(ExplorerInfo explorer, String transactionHash) {
  final baseUrl = explorer.url.endsWith('/')
      ? explorer.url.substring(0, explorer.url.length - 1)
      : explorer.url;

  return "$baseUrl/tx/$transactionHash";
}

String viewChain({
  required NetworkConfigInfo network,
  required String theme,
}) {
  const defaultIcon = 'assets/icons/default_chain.svg';

  if (network.logo.isEmpty) return defaultIcon;

  final replacements = <String, String>{
    'shortName': network.shortName.toLowerCase(),
  };

  return processUrlTemplate(
    template: network.logo,
    theme: theme,
    replacements: replacements,
  );
}

```

`lib/mixins/qrcode.dart`:

```dart
import 'package:zilpay/config/ftokens.dart';

String generateCryptoUrl({
  required String address,
  required String chain,
  String? token,
  String? amount,
}) {
  final buffer = StringBuffer('$chain:$address');

  if (token != null && token != zeroZIL && token != zeroEVM) {
    buffer.write('?token=$token');

    if (amount != null && amount.isNotEmpty && amount != "0") {
      buffer.write('&amount=$amount');
    }
  } else if (amount != null && amount.isNotEmpty && amount != "0") {
    buffer.write('?amount=$amount');
  }

  return buffer.toString();
}

String generateQRSecretData({
  required String chain,
  String? seedPhrase,
  String? privateKey,
}) {
  final params = <String>[];

  if (seedPhrase != null) {
    params.add('seed=$seedPhrase');
  }

  if (privateKey != null) {
    params.add('key=$privateKey');
  }

  return '$chain:?${params.join('&')}';
}

Map<String, String> parseQRSecretData(String qrData) {
  final result = <String, String>{};

  final parts = qrData.split(':?');
  if (parts.length != 2) return result;

  result['chain'] = parts[0];

  final params = parts[1].split('&');
  for (final param in params) {
    final keyValue = param.split('=');
    if (keyValue.length == 2) {
      if (keyValue[0] == 'seed') result['seed'] = keyValue[1];
      if (keyValue[0] == 'key') result['key'] = keyValue[1];
    }
  }

  return result;
}

```

`lib/mixins/wallet_type.dart`:

```dart
enum WalletType {
  ledger,
  // ignore: constant_identifier_names
  SecretPhrase,
  // ignore: constant_identifier_names
  SecretKey,
}

```

`lib/pages/about.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';
import '../state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class AboutPage extends StatefulWidget {
  const AboutPage({super.key});

  @override
  State<AboutPage> createState() => _AboutPageState();
}

class _AboutPageState extends State<AboutPage> {
  PackageInfo _packageInfo = PackageInfo(
    appName: 'ZilPay',
    packageName: '',
    version: '',
    buildNumber: '',
  );

  @override
  void initState() {
    super.initState();
    _initPackageInfo();
  }

  Future<void> _initPackageInfo() async {
    final info = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _packageInfo = info;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: l10n.aboutPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding: EdgeInsets.all(adaptivePadding),
                      child: Column(
                        children: [
                          _buildLogoSection(theme, l10n),
                          SizedBox(height: adaptivePadding * 2),
                          _buildAppInfoSection(theme, l10n),
                          SizedBox(height: adaptivePadding * 1.5),
                          _buildDeveloperSection(theme, l10n),
                          SizedBox(height: adaptivePadding * 1.5),
                          _buildLegalSection(theme, l10n),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLogoSection(AppTheme theme, AppLocalizations l10n) {
    return Column(
      children: [
        Container(
          width: 120,
          height: 120,
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(24),
          ),
          child: Center(
            child: SvgPicture.asset(
              'assets/imgs/zilpay.svg',
              width: 80,
              height: 80,
            ),
          ),
        ),
        const SizedBox(height: 16),
        Text(
          l10n.aboutPageAppName,
          style: TextStyle(
            color: theme.textPrimary,
            fontSize: 28,
            fontWeight: FontWeight.bold,
            overflow: TextOverflow.ellipsis,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          l10n.aboutPageAppDescription,
          style: TextStyle(
            color: theme.textSecondary,
            fontSize: 16,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildAppInfoSection(AppTheme theme, AppLocalizations l10n) {
    return _buildSectionContainer(
      theme,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle(theme, l10n.aboutPageAppInfoTitle),
          const SizedBox(height: 16),
          _buildInfoRow(
            theme,
            l10n.aboutPageVersionLabel,
            '${_packageInfo.version} (${_packageInfo.buildNumber})',
          ),
          _buildInfoRow(
            theme,
            l10n.aboutPageBuildDateLabel,
            l10n.aboutPageBuildDateValue,
          ),
          _buildInfoRow(
            theme,
            l10n.aboutPagePlatformLabel,
            Theme.of(context).platform.toString().split('.').last,
          ),
        ],
      ),
    );
  }

  Widget _buildDeveloperSection(AppTheme theme, AppLocalizations l10n) {
    return _buildSectionContainer(
      theme,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle(theme, l10n.aboutPageDeveloperTitle),
          const SizedBox(height: 16),
          _buildInfoRow(
            theme,
            l10n.aboutPageAuthorLabel,
            l10n.aboutPageAuthorValue,
          ),
          _buildInfoRow(
            theme,
            l10n.aboutPageWebsiteLabel,
            l10n.aboutPageWebsiteValue,
          ),
        ],
      ),
    );
  }

  Widget _buildLegalSection(AppTheme theme, AppLocalizations l10n) {
    return _buildSectionContainer(
      theme,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSectionTitle(theme, l10n.aboutPageLegalTitle),
          const SizedBox(height: 16),
          _buildActionRow(
            theme,
            l10n.aboutPagePrivacyPolicy,
            'assets/icons/shield.svg',
            false,
            () => _launchUrl('https://zilpay.io/policy'),
          ),
          _buildActionRow(
            theme,
            l10n.aboutPageTermsOfService,
            'assets/icons/document.svg',
            false,
            () => _launchUrl('https://zilpay.io/terms'),
          ),
          _buildActionRow(
            theme,
            l10n.aboutPageLicenses,
            'assets/icons/licenses.svg',
            true,
            () => _showLicensePage(context, l10n),
          ),
        ],
      ),
    );
  }

  Future<void> _showLicensePage(
    BuildContext context,
    AppLocalizations l10n,
  ) async {
    return showLicensePage(
      context: context,
      applicationName: _packageInfo.appName,
      applicationVersion: _packageInfo.version,
      applicationIcon: SvgPicture.asset(
        'assets/imgs/zilpay.svg',
        width: 48,
        height: 48,
      ),
      applicationLegalese: l10n.aboutPageLegalese,
    );
  }

  Widget _buildSectionContainer(AppTheme theme, {required Widget child}) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      padding: const EdgeInsets.all(16),
      child: child,
    );
  }

  Widget _buildSectionTitle(AppTheme theme, String title) {
    return Text(
      title,
      style: TextStyle(
        color: theme.textPrimary,
        fontSize: 18,
        fontWeight: FontWeight.bold,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }

  Widget _buildInfoRow(AppTheme theme, String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Expanded(
            flex: 3,
            child: Text(
              label,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 16,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ),
          Expanded(
            flex: 4,
            child: Text(
              value,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
                overflow: TextOverflow.ellipsis,
              ),
              textAlign: TextAlign.end,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildActionRow(
    AppTheme theme,
    String title,
    String iconPath,
    bool last,
    VoidCallback onTap,
  ) {
    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.opaque,
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12),
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color: last
                  ? Colors.transparent
                  : theme.textSecondary.withValues(alpha: 0.1),
              width: 1,
            ),
          ),
        ),
        child: Row(
          children: [
            SvgPicture.asset(
              iconPath,
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(
                theme.textPrimary,
                BlendMode.srcIn,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                title,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
            SvgPicture.asset(
              'assets/icons/right_arrow.svg',
              width: 16,
              height: 16,
              colorFilter: ColorFilter.mode(
                theme.textSecondary,
                BlendMode.srcIn,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _launchUrl(String urlString) async {
    final Uri url = Uri.parse(urlString);
    try {
      if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
        throw Exception('Could not launch $url');
      }
    } catch (e) {
      debugPrint('Error launching URL: $e');
    }
  }
}

```

`lib/pages/add_account.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/components/counter.dart';
import 'package:zilpay/components/smart_input.dart';
import 'dart:async';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class AddAccount extends StatefulWidget {
  const AddAccount({super.key});

  @override
  State<AddAccount> createState() => _AddAccountState();
}

class _AddAccountState extends State<AddAccount> {
  final TextEditingController _accountNameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _accountNameInputKey = GlobalKey<SmartInputState>();
  final AuthService _authService = AuthService();

  bool _isCreating = false;
  bool _zilliqaLegacy = false;
  String? _errorMessage;
  int _bip39Index = 0;
  bool _obscurePassword = true;
  bool _useBiometrics = false;
  bool _initialized = false;

  late AuthGuard _authGuard;

  @override
  void initState() {
    super.initState();
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    AppState appState = Provider.of<AppState>(context, listen: false);
    _bip39Index = appState.wallet!.accounts.length;
    _checkBiometricAvailability(appState);

    if (appState.account?.addrType == 0) {
      _zilliqaLegacy = true;
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (!_initialized) {
      AppState appState = Provider.of<AppState>(context, listen: false);
      _setAutoAccountName(appState);
      _initialized = true;
    }
  }

  void _checkBiometricAvailability(AppState appState) {
    if (appState.wallet != null) {
      final authType = appState.wallet!.authType;
      setState(() {
        _useBiometrics = authType == AuthMethod.faceId.name ||
            authType == AuthMethod.fingerprint.name ||
            authType == AuthMethod.biometric.name ||
            authType == AuthMethod.pinCode.name;
      });
    }
  }

  @override
  void dispose() {
    _accountNameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _setAutoAccountName(AppState appState) {
    _accountNameController.text = AppLocalizations.of(
      context,
    )!
        .addAccountPageDefaultName(_bip39Index);
  }

  bool _exists(AppState appState) {
    return appState.wallet?.accounts.any(
          (account) => account.index.toInt() == _bip39Index,
        ) ??
        false;
  }

  bool _isZIL(AppState appState) {
    if (appState.wallet == null) {
      return false;
    }

    final defaultChain = appState.getChain(appState.wallet!.defaultChainHash);

    if (defaultChain == null) {
      return false;
    }

    return appState.chain?.slip44 == 313 &&
        appState.wallet != null &&
        defaultChain.slip44 == appState.chain?.slip44;
  }

  Future<bool> _authenticateWithBiometrics() async {
    try {
      return await _authService.authenticate(
        allowPinCode: true,
        reason: AppLocalizations.of(context)!.addAccountPageBiometricReason,
      );
    } catch (e) {
      debugPrint('Biometric authentication error: $e');
      setState(() {
        _errorMessage =
            AppLocalizations.of(context)!.addAccountPageBiometricError(e);
      });
      return false;
    }
  }

  Future<void> _createAccount(AppState appState) async {
    final l10n = AppLocalizations.of(context)!;
    BigInt walletIndex = BigInt.from(appState.selectedWallet);

    if (_exists(appState)) {
      setState(() {
        _errorMessage = l10n.addAccountPageIndexExists(_bip39Index);
      });
      return;
    }

    if (_accountNameController.text.isEmpty) {
      _accountNameInputKey.currentState?.shake();
      return;
    }

    if (_passwordController.text.isEmpty &&
        appState.wallet!.authType == AuthMethod.none.name &&
        !_useBiometrics) {
      _passwordInputKey.currentState?.shake();
      return;
    }

    setState(() {
      _isCreating = true;
      _errorMessage = null;
    });

    String? session;

    if (_useBiometrics && _passwordController.text.isEmpty) {
      bool authenticated = await _authenticateWithBiometrics();
      if (!authenticated) {
        setState(() {
          _isCreating = false;
          _errorMessage = l10n.addAccountPageBiometricFailed;
        });
        return;
      }
    }

    try {
      session = await _authGuard.getSession(
          sessionKey: appState.wallet!.walletAddress);
    } catch (e) {
      debugPrint("getting session error: $e");
    }

    try {
      DeviceInfoService device = DeviceInfoService();
      List<String> identifiers = await device.getDeviceIdentifiers();

      if (appState.wallet!.walletType.contains(WalletType.SecretPhrase.name)) {
        AddNextBip39AccountParams params = AddNextBip39AccountParams(
          walletIndex: walletIndex,
          accountIndex: BigInt.from(_bip39Index),
          name: _accountNameController.text,
          passphrase: "",
          identifiers: identifiers,
          password: _passwordController.text.isEmpty
              ? null
              : _passwordController.text,
          sessionCipher: session,
        );

        await addNextBip39Account(
          params: params,
        );
      }

      await appState.syncData();

      if (_zilliqaLegacy && _isZIL(appState) && appState.wallet != null) {
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: BigInt.from(appState.wallet!.accounts.length - 1),
        );
      }

      try {
        await syncBalances(walletIndex: BigInt.from(appState.selectedWallet));
      } catch (_) {}

      await appState.syncData();

      if (mounted) {
        Navigator.pop(context);
      }
    } catch (e) {
      setState(() {
        _errorMessage = l10n.addAccountPageCreateFailed(e);
        _isCreating = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final keyboardHeight = MediaQuery.of(context).viewInsets.bottom;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
              child: CustomAppBar(
                title: l10n.addAccountPageTitle,
                onBackPressed: () => Navigator.pop(context),
                actionIcon: _isCreating
                    ? SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            theme.textPrimary,
                          ),
                        ),
                      )
                    : SvgPicture.asset(
                        'assets/icons/plus.svg',
                        width: 24,
                        height: 24,
                        colorFilter: ColorFilter.mode(
                          theme.textPrimary,
                          BlendMode.srcIn,
                        ),
                      ),
                onActionPressed: () => _createAccount(appState),
              ),
            ),
            Expanded(
              child: SingleChildScrollView(
                physics: const BouncingScrollPhysics(),
                child: Padding(
                  padding: EdgeInsets.only(
                    left: adaptivePadding,
                    right: adaptivePadding,
                    top: adaptivePadding,
                    bottom: keyboardHeight + adaptivePadding,
                  ),
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 480),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        Text(
                          l10n.addAccountPageSubtitle,
                          style: TextStyle(
                            color: theme.textPrimary,
                            fontSize: 24,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        SizedBox(height: adaptivePadding),
                        SmartInput(
                          key: _accountNameInputKey,
                          controller: _accountNameController,
                          hint: l10n.addAccountPageNameHint,
                          fontSize: 18,
                          height: 56,
                          disabled: _isCreating,
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                          focusedBorderColor: theme.primaryPurple,
                        ),
                        SizedBox(height: adaptivePadding),
                        Container(
                          padding: EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: theme.cardBackground,
                            borderRadius: BorderRadius.circular(16),
                            border: Border.all(color: theme.secondaryPurple),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                l10n.addAccountPageBip39Index,
                                style: TextStyle(
                                  color: theme.textPrimary,
                                  fontSize: 16,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              SizedBox(height: 8),
                              Counter(
                                initialValue: _bip39Index,
                                minValue: 0,
                                maxValue: 2147483647,
                                disabled: _isCreating,
                                iconColor: theme.primaryPurple,
                                numberStyle: TextStyle(
                                  color: theme.textPrimary,
                                  fontSize: 16,
                                  fontWeight: FontWeight.w500,
                                ),
                                onChanged: (value) {
                                  setState(() {
                                    _bip39Index = value;
                                  });
                                  _setAutoAccountName(appState);
                                },
                              ),
                            ],
                          ),
                        ),
                        if (_useBiometrics) ...[
                          SizedBox(height: adaptivePadding),
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 12),
                            decoration: BoxDecoration(
                              color: theme.cardBackground,
                              borderRadius: BorderRadius.circular(16),
                              border: Border.all(color: theme.secondaryPurple),
                            ),
                            child: Row(
                              children: [
                                SvgPicture.asset(
                                  'assets/icons/biometric.svg',
                                  width: 24,
                                  height: 24,
                                  colorFilter: ColorFilter.mode(
                                    theme.textPrimary,
                                    BlendMode.srcIn,
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: Text(
                                    l10n.addAccountPageUseBiometrics,
                                    style: TextStyle(
                                      color: theme.textPrimary,
                                      fontSize: 16,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                        if (appState.wallet!.authType ==
                            AuthMethod.none.name) ...[
                          SizedBox(height: adaptivePadding),
                          SmartInput(
                            key: _passwordInputKey,
                            controller: _passwordController,
                            hint: l10n.addAccountPagePasswordHint,
                            fontSize: 18,
                            height: 56,
                            disabled: _isCreating,
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            focusedBorderColor: theme.primaryPurple,
                            obscureText: _obscurePassword,
                            rightIconPath: _obscurePassword
                                ? "assets/icons/close_eye.svg"
                                : "assets/icons/open_eye.svg",
                            onRightIconTap: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ],
                        SizedBox(height: adaptivePadding),
                        if (_isZIL(appState))
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 4),
                            child: Row(
                              children: [
                                SvgPicture.asset(
                                  'assets/icons/scilla.svg',
                                  width: 24,
                                  height: 24,
                                  colorFilter: ColorFilter.mode(
                                    theme.textPrimary,
                                    BlendMode.srcIn,
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: Text(
                                    l10n.addAccountPageZilliqaLegacy,
                                    style: TextStyle(
                                      color: theme.textPrimary,
                                      fontSize: 16,
                                    ),
                                  ),
                                ),
                                Switch(
                                  value: _zilliqaLegacy,
                                  onChanged: _isCreating
                                      ? null
                                      : (bool value) async {
                                          setState(() {
                                            _zilliqaLegacy = value;
                                          });
                                        },
                                  activeThumbColor: theme.primaryPurple,
                                  activeTrackColor: theme.primaryPurple
                                      .withValues(alpha: 0.5),
                                ),
                              ],
                            ),
                          ),
                        if (_errorMessage != null) ...[
                          SizedBox(height: adaptivePadding),
                          Text(
                            _errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/pages/add_ledger_account.dart`:

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:flutter_svg/svg.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/counter.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/enable_card.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/ledger_device_card.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/ledger/common.dart';
import 'package:zilpay/ledger/ethereum/ethereum_ledger_application.dart';
import 'package:zilpay/ledger/zilliqa/zilliqa_ledger_application.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/ledger.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/theme/app_theme.dart';

class AddLedgerAccountPage extends StatefulWidget {
  const AddLedgerAccountPage({super.key});

  @override
  State<AddLedgerAccountPage> createState() => _AddLedgerAccountPageState();
}

class _AddLedgerAccountPageState extends State<AddLedgerAccountPage> {
  final _walletNameController = TextEditingController();
  final _btnController = RoundedLoadingButtonController();
  final _createBtnController = RoundedLoadingButtonController();

  int _accountCount = 1;
  bool _loading = false;
  String _errorMessage = '';
  bool _createWallet = true;
  NetworkConfigInfo? _network;
  List<LedgerDevice> _ledgers = [];
  List<LedgerAccount> _accounts = [];
  Map<LedgerAccount, bool> _selectedAccounts = {};
  bool _accountsLoaded = false;
  LedgerDevice? _selectedDevice;
  bool _isScanning = false;
  StreamSubscription<LedgerDevice>? _scanSubscription;
  Timer? _scanTimeout;
  int _scanRetries = 0;
  static const _maxRetries = 2;

  late AuthGuard _authGuard;

  @override
  void initState() {
    super.initState();
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _walletNameController.text = "";
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkLedgerDevices();
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    if (args == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pop();
      });
      return;
    }

    final network = args['chain'] as NetworkConfigInfo?;
    final ledger = args['ledger'] as LedgerDevice?;
    final createWallet = args['createWallet'] as bool?;

    if (network == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pop();
      });
      return;
    }

    setState(() {
      _network = network;
      if (ledger != null) {
        if (!_ledgers.any((d) => d.id == ledger.id)) {
          _ledgers.add(ledger);
        }
        _selectedDevice = ledger;
        _stopLedgerScan();
      }
      _createWallet = createWallet ?? true;
      _walletNameController.text = _ledgers.isNotEmpty
          ? "${_ledgers.first.name} (${network.name})"
          : "Ledger (${network.name})";

      final appState = context.read<AppState>();
      final isLedgerWallet = appState.selectedWallet != -1 &&
          appState.wallets.isNotEmpty &&
          appState.wallets[appState.selectedWallet].walletType
              .contains(WalletType.ledger.name);

      if (isLedgerWallet && !_createWallet) {
        final existingAccounts = appState.wallet?.accounts ?? [];
        _accounts = existingAccounts
            .map((account) => LedgerAccount(
                  index: account.index.toInt(),
                  address: account.addr,
                  publicKey: account.pubKey,
                ))
            .toList()
          ..sort((a, b) => a.index.compareTo(b.index));
        _selectedAccounts = {for (var account in _accounts) account: true};
        _accountsLoaded = true;
      }
    });
  }

  @override
  void dispose() {
    _walletNameController.dispose();
    _btnController.dispose();
    _createBtnController.dispose();
    _scanSubscription?.cancel();
    _scanTimeout?.cancel();
    super.dispose();
  }

  Future<void> _checkLedgerDevices() async {
    final appState = context.read<AppState>();
    final isLedgerWallet = appState.selectedWallet != -1 &&
        appState.wallets.isNotEmpty &&
        appState.wallets[appState.selectedWallet].walletType
            .contains(WalletType.ledger.name);

    if (_selectedDevice != null) {
      return;
    }

    if (!_createWallet || isLedgerWallet) {
      _startLedgerScan();
    } else if (_ledgers.isNotEmpty) {
      setState(() {
        _selectedDevice = _ledgers.first;
        _stopLedgerScan();
      });
    }
  }

  Future<void> _startLedgerScan() async {
    if (_scanRetries >= _maxRetries) {
      setState(() {
        _isScanning = false;
        _errorMessage = AppLocalizations.of(context)!
            .addLedgerAccountPageFailedToScanError('Max retries reached');
      });
      return;
    }

    setState(() {
      _isScanning = true;
      _scanRetries++;
    });

    final ledgerBle = LedgerInterface.ble(
      onPermissionRequest: (status) async {
        if (status != AvailabilityState.poweredOn) {
          setState(() => _errorMessage = AppLocalizations.of(context)!
              .addLedgerAccountPageBluetoothOffError);
          return false;
        }
        return true;
      },
    );

    _scanSubscription = ledgerBle.scan().listen(
      (device) {
        if (mounted) {
          setState(() {
            if (!_ledgers.any((d) => d.id == device.id)) {
              _ledgers.add(device);
            }
            final appState = context.read<AppState>();
            final deviceId =
                appState.wallet?.walletType.split('.').last.replaceAll('"', '');
            if (deviceId != null &&
                device.id.contains(deviceId) &&
                _selectedDevice == null) {
              _selectedDevice = device;
              _stopLedgerScan();
            }
          });
        }
      },
      onError: (e) {
        if (mounted) {
          setState(() {
            _isScanning = false;
            _errorMessage = AppLocalizations.of(context)!
                .addLedgerAccountPageFailedToScanError(e.toString());
          });
          Future.delayed(const Duration(seconds: 2), () {
            if (mounted && _ledgers.isEmpty && _selectedDevice == null) {
              _startLedgerScan();
            }
          });
        }
      },
    );

    _scanTimeout = Timer(const Duration(seconds: 15), () {
      _stopLedgerScan();
      if (mounted && _ledgers.isEmpty && _selectedDevice == null) {
        setState(() => _errorMessage =
            AppLocalizations.of(context)!.addLedgerAccountPageNoDevicesMessage);
        Future.delayed(const Duration(seconds: 2), () {
          if (mounted && _selectedDevice == null) {
            _startLedgerScan();
          }
        });
      }
    });
  }

  void _stopLedgerScan() {
    _scanSubscription?.cancel();
    _scanTimeout?.cancel();
    setState(() => _isScanning = false);
  }

  Future<void> _onGetAccounts() async {
    final l10n = AppLocalizations.of(context)!;

    if (_walletNameController.text.trim().isEmpty && _createWallet) {
      setState(
          () => _errorMessage = l10n.addLedgerAccountPageEmptyWalletNameError);
      _btnController.reset();
      return;
    }

    if (_walletNameController.text.length > 100 && _createWallet) {
      setState(() =>
          _errorMessage = l10n.addLedgerAccountPageWalletNameTooLongError);
      _btnController.reset();
      return;
    }

    setState(() {
      _loading = true;
      _errorMessage = '';
    });
    _btnController.start();

    try {
      if (_network == null || _selectedDevice == null) {
        throw Exception(l10n.addLedgerAccountPageNetworkOrLedgerMissingError);
      }

      final ledgerInterface = LedgerInterface.ble(
        onPermissionRequest: (_) async => true,
      );

      final connection = await ledgerInterface.connect(_selectedDevice!);
      List<LedgerAccount> newAccounts = [];

      if (_network?.slip44 == 60) {
        final ethereumApp = EthereumLedgerApp(connection, transformer: null);
        newAccounts = await ethereumApp
            .getAccounts(List<int>.generate(_accountCount, (i) => i));
      } else if (_network?.slip44 == 313) {
        final zilliqaApp = ZilliqaLedgerApp(connection, transformer: null);
        newAccounts = await zilliqaApp
            .getPublicAddress(List<int>.generate(_accountCount, (i) => i));
      }

      setState(() {
        final existingPubKeys =
            _accounts.map((acc) => acc.publicKey.toLowerCase()).toSet();
        final uniqueNewAccounts = newAccounts
            .where(
                (acc) => !existingPubKeys.contains(acc.publicKey.toLowerCase()))
            .toList();

        if (_createWallet) {
          _accounts = uniqueNewAccounts
            ..sort((a, b) => a.index.compareTo(b.index));
          _selectedAccounts = {for (var account in _accounts) account: true};
        } else {
          _accounts.addAll(uniqueNewAccounts);
          _accounts.sort((a, b) => a.index.compareTo(b.index));
          for (var acc in uniqueNewAccounts) {
            _selectedAccounts[acc] = true;
          }
        }
        _accountsLoaded = true;
      });

      _btnController.success();
      Future.delayed(const Duration(seconds: 1),
          () => mounted ? _btnController.reset() : null);
    } on LedgerException catch (e) {
      _handleLedgerError(e);
    } catch (e) {
      debugPrint("$e");
      setState(() => _errorMessage = e.toString());
      _btnController.error();
      Future.delayed(const Duration(seconds: 2),
          () => mounted ? _btnController.reset() : null);
    } finally {
      if (mounted && _loading) {
        setState(() => _loading = false);
      }
    }
  }

  void _handleLedgerError(LedgerException e) {
    String displayError = e.toString();
    if (e is ConnectionLostException) {
      displayError = "Connection to Ledger lost. Please reconnect.";
    } else if (e is DeviceNotConnectedException) {
      displayError = "Ledger device is not connected.";
    } else if (e is LedgerDeviceException) {
      displayError = "Ledger Error ${e.errorCode}: ${e.message}";
    }
    setState(() => _errorMessage = displayError);
    _btnController.error();
    Future.delayed(const Duration(seconds: 2),
        () => mounted ? _btnController.reset() : null);
  }

  void _toggleAccount(LedgerAccount account, bool value) {
    if (_loading) return;
    setState(() {
      _selectedAccounts[account] = value;
    });
  }

  Future<void> _saveSelectedAccounts() async {
    setState(() {
      _loading = true;
      _errorMessage = '';
    });
    _createBtnController.start();

    try {
      final appState = Provider.of<AppState>(context, listen: false);
      final l10n = AppLocalizations.of(context)!;
      final BigInt? chainHash;

      List<NetworkConfigInfo> chains = await getProviders();
      final matches = chains
          .where((chain) => chain.chainHash == _network!.chainHash)
          .toList();

      if (matches.isEmpty) {
        chainHash = await addProvider(providerConfig: _network!);
      } else {
        chainHash = matches.first.chainHash;
      }

      WalletSettingsInfo settings = WalletSettingsInfo(
        cipherOrders: Uint8List.fromList([]),
        argonParams: WalletArgonParamsInfo(
          iterations: 0,
          memory: 0,
          threads: 0,
          secret: '',
        ),
        currencyConvert: "BTC",
        ipfsNode: "dweb.link",
        ensEnabled: true,
        tokensListFetcher: true,
        nodeRankingEnabled: true,
        maxConnections: 5,
        requestTimeoutSecs: 30,
        ratesApiOptions: 1,
      );
      final isLegacyZilliq = _network?.slip44 == 313 &&
          _selectedAccounts.entries
              .map((entry) => entry.key)
              .every((a) => a.address.startsWith("zil1"));

      List<FTokenInfo> ftokens = [];

      if (_createWallet) {
        final selectedAccounts = _selectedAccounts.entries
            .where((entry) => entry.value)
            .map((entry) => entry.key)
            .toList();

        if (selectedAccounts.isEmpty) {
          throw Exception(l10n.addLedgerAccountPageNoAccountsSelectedError);
        }

        final pubKeys =
            selectedAccounts.map((a) => (a.index, a.publicKey)).toList();
        final accountNames =
            selectedAccounts.map((a) => "ledger ${a.index + 1}").toList();

        DeviceInfoService device = DeviceInfoService();
        List<String> identifiers = await device.getDeviceIdentifiers();

        final (session, walletAddress) = await addLedgerWallet(
          params: LedgerParamsInput(
            pubKeys: pubKeys,
            walletIndex: BigInt.from(appState.wallets.length),
            walletName: _walletNameController.text,
            ledgerId: _selectedDevice!.id,
            accountNames: accountNames,
            biometricType: AuthMethod.none.name,
            identifiers: identifiers,
            chainHash: chainHash,
            zilliqaLegacy: isLegacyZilliq,
          ),
          walletSettings: settings,
          ftokens: ftokens,
        );

        await appState.syncData();
        int currentWalletIndex = appState.wallets.length - 1;
        await _authGuard.setSession(walletAddress, session);
        await appState.syncData();
        appState.setSelectedWallet(currentWalletIndex);
        await appState.startTrackHistoryWorker();
        _createBtnController.success();
        setState(() {
          _loading = false;
        });

        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) {
            Navigator.of(context).pushNamed("/");
          }
        });
      } else {
        final walletIndex = appState.selectedWallet;
        final wallet = appState.wallet;

        if (wallet == null) {
          throw Exception(l10n.addLedgerAccountPageNoWalletSelectedError);
        }

        final accountsToUpdate = _selectedAccounts.entries
            .where((entry) => entry.value)
            .map((entry) => (
                  entry.key.index,
                  entry.key.publicKey,
                  "ledger ${entry.key.index + 1}"
                ))
            .toList();

        await updateLedgerAccounts(
          walletIndex: BigInt.from(walletIndex),
          accounts: accountsToUpdate,
          zilliqaLegacy: isLegacyZilliq,
        );

        await appState.syncData();
        _createBtnController.success();

        setState(() {
          _loading = false;
        });

        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) {
            Navigator.of(context).pushNamed("/");
          }
        });
      }
    } catch (e) {
      _createBtnController.error();
      setState(() {
        _loading = false;
        _errorMessage = e.toString();
      });
      Future.delayed(const Duration(seconds: 2), () {
        if (mounted) {
          _createBtnController.reset();
        }
      });
    }
  }

  Widget _buildDeviceInfoCard(AppTheme theme, AppLocalizations l10n) {
    if (_selectedDevice == null) return const SizedBox();
    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: theme.primaryPurple.withValues(alpha: 0.3),
          width: 1.5,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          LedgerCard(
            device: _selectedDevice!,
            isConnected: true,
            isConnecting: false,
            onTap: () {},
          ),
          _buildNetworkInfoRow(theme, l10n),
        ],
      ),
    );
  }

  Widget _buildNetworkInfoRow(AppTheme theme, AppLocalizations l10n) {
    final isTestnet = _network!.testnet ?? false;
    return Padding(
      padding: const EdgeInsets.all(12),
      child: Row(
        children: [
          SizedBox(
            width: 32,
            height: 32,
            child: AsyncImage(
              url: viewChain(network: _network!, theme: theme.value),
              fit: BoxFit.contain,
              errorWidget: const Icon(Icons.error),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        _network!.name,
                        style: TextStyle(
                          color: theme.textPrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 8, vertical: 2),
                      decoration: BoxDecoration(
                        color: isTestnet
                            ? theme.warning.withValues(alpha: 0.2)
                            : theme.success.withValues(alpha: 0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        isTestnet
                            ? l10n.setupNetworkSettingsPageTestnetLabel
                            : l10n.setupNetworkSettingsPageMainnetLabel,
                        style: TextStyle(
                          color: isTestnet ? theme.warning : theme.success,
                          fontSize: 10,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  '${l10n.setupNetworkSettingsPageTokenLabel} ${_network!.chain} (Chain ID: ${_network!.chainId})',
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWalletInfoCard(AppTheme theme, AppLocalizations l10n) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.3),
          width: 1.5,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Center(
                child: Counter(
                  iconSize: 24,
                  iconColor: theme.textPrimary,
                  animationDuration: const Duration(milliseconds: 300),
                  numberStyle: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: theme.textPrimary,
                  ),
                  minValue: 1,
                  initialValue: _accountCount,
                  disabled: _loading,
                  onChanged: !_loading
                      ? (value) {
                          setState(() {
                            _accountCount = value;
                          });
                        }
                      : null,
                ),
              ),
              const SizedBox(height: 16),
              RoundedLoadingButton(
                color: theme.primaryPurple,
                valueColor: theme.buttonText,
                controller: _btnController,
                onPressed: _onGetAccounts,
                child: Text(
                  l10n.addLedgerAccountPageGetAccountsButton,
                  style: TextStyle(
                    color: theme.buttonText,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAccountsCard(AppTheme theme) {
    if (!_accountsLoaded || _accounts.isEmpty) return const SizedBox();
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.3),
          width: 1.5,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ..._accounts.map((account) {
            final shortAddress =
                "${account.address.substring(0, 6)}...${account.address.substring(account.address.length - 4)}";
            return EnableCard(
              title: "Account ${account.index + 1}",
              name: shortAddress,
              iconWidget: SvgPicture.asset(
                'assets/icons/ledger.svg',
                width: 20,
                height: 20,
                colorFilter: ColorFilter.mode(
                  theme.success,
                  BlendMode.srcIn,
                ),
              ),
              isDefault: false,
              isEnabled: _selectedAccounts[account] ?? false,
              onToggle: (value) => _toggleAccount(account, value),
            );
          }).toList(),
        ],
      ),
    );
  }

  Widget _buildErrorMessage(AppTheme theme) {
    if (_errorMessage.isEmpty) return const SizedBox();
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SvgPicture.asset(
            'assets/icons/warning.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(theme.danger, BlendMode.srcIn),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              _errorMessage,
              style: TextStyle(
                color: theme.danger,
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDeviceList(AppTheme theme, AppLocalizations l10n) {
    if (_isScanning) {
      return Column(
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                LinearProgressIndicator(
                  backgroundColor: theme.textSecondary.withValues(alpha: 0.3),
                  valueColor:
                      AlwaysStoppedAnimation<Color>(theme.primaryPurple),
                ),
                const SizedBox(height: 16),
                Text(
                  l10n.addLedgerAccountPageScanningMessage,
                  style: TextStyle(color: theme.textSecondary),
                ),
              ],
            ),
          ),
        ],
      );
    } else if (_ledgers.isEmpty) {
      return Column(
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              l10n.addLedgerAccountPageNoDevicesMessage,
              style: TextStyle(color: theme.textSecondary),
            ),
          ),
        ],
      );
    }
    return RefreshIndicator(
      onRefresh: () async {
        _stopLedgerScan();
        setState(() {
          _scanRetries = 0;
          _ledgers.clear();
          _selectedDevice = null;
        });
        await _startLedgerScan();
      },
      color: theme.primaryPurple,
      backgroundColor: theme.cardBackground,
      child: ListView.builder(
        physics: const AlwaysScrollableScrollPhysics(),
        itemCount: _ledgers.length,
        itemBuilder: (context, index) {
          final device = _ledgers[index];
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
            child: LedgerCard(
              device: device,
              isConnected: device.id == _selectedDevice?.id,
              isConnecting: false,
              onTap: () {
                setState(() {
                  _selectedDevice = device;
                  _stopLedgerScan();
                });
              },
            ),
          );
        },
      ),
    );
  }

  @override
  Widget build(context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Stack(
              children: [
                Column(
                  children: [
                    CustomAppBar(
                      title: l10n.addLedgerAccountPageAppBarTitle,
                      onBackPressed: () => Navigator.pop(context),
                    ),
                    if (_network == null)
                      Expanded(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.start,
                          children: [
                            Padding(
                              padding: const EdgeInsets.all(16),
                              child: LinearProgressIndicator(
                                backgroundColor:
                                    theme.textSecondary.withValues(alpha: 0.3),
                                valueColor: AlwaysStoppedAnimation<Color>(
                                    theme.primaryPurple),
                              ),
                            ),
                          ],
                        ),
                      )
                    else if (_selectedDevice == null &&
                        (!_createWallet ||
                            (Provider.of<AppState>(context).selectedWallet !=
                                    -1 &&
                                Provider.of<AppState>(context)
                                    .wallets
                                    .isNotEmpty &&
                                Provider.of<AppState>(context)
                                    .wallets[Provider.of<AppState>(context)
                                        .selectedWallet]
                                    .walletType
                                    .contains(WalletType.ledger.name))))
                      Expanded(
                        child: _buildDeviceList(theme, l10n),
                      )
                    else
                      Expanded(
                        child: RefreshIndicator(
                          onRefresh: () async {
                            _stopLedgerScan();
                            setState(() {
                              _scanRetries = 0;
                              _ledgers.clear();
                              _selectedDevice = null;
                            });
                            await _startLedgerScan();
                          },
                          color: theme.primaryPurple,
                          backgroundColor: theme.cardBackground,
                          child: SingleChildScrollView(
                            physics: const AlwaysScrollableScrollPhysics(),
                            child: Padding(
                              padding: EdgeInsets.all(adaptivePadding),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  _buildDeviceInfoCard(theme, l10n),
                                  if (_errorMessage.isNotEmpty) ...[
                                    const SizedBox(height: 16),
                                    _buildErrorMessage(theme),
                                  ],
                                  const SizedBox(height: 16),
                                  _buildWalletInfoCard(theme, l10n),
                                  if (_accountsLoaded &&
                                      _accounts.isNotEmpty) ...[
                                    const SizedBox(height: 16),
                                    _buildAccountsCard(theme),
                                  ],
                                  const SizedBox(height: 80),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
                if (_accountsLoaded && _accounts.isNotEmpty && !_isScanning)
                  Positioned(
                    bottom: 0,
                    left: 0,
                    right: 0,
                    child: Container(
                      padding: EdgeInsets.all(adaptivePadding),
                      child: RoundedLoadingButton(
                        controller: _createBtnController,
                        color: theme.primaryPurple,
                        valueColor: theme.buttonText,
                        onPressed: _saveSelectedAccounts,
                        successIcon: "assets/icons/ok.svg",
                        child: Text(
                          _createWallet
                              ? l10n.addLedgerAccountPageCreateButton
                              : l10n.addLedgerAccountPageAddButton,
                          style: TextStyle(
                            color: theme.buttonText,
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/address_book.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/addr.dart';
import 'package:zilpay/modals/add_contect.dart';
import 'package:zilpay/src/rust/api/book.dart';
import 'package:zilpay/src/rust/models/book.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';
import '../components/switch_setting_item.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class AddressBookPage extends StatefulWidget {
  const AddressBookPage({super.key});

  @override
  State<AddressBookPage> createState() => _AddressBookPageState();
}

class _AddressBookPageState extends State<AddressBookPage> {
  Future<void> _showDeleteConfirmationDialog(BuildContext context,
      AppState state, AddressBookEntryInfo address) async {
    final l10n = AppLocalizations.of(context)!;
    final theme = state.currentTheme;

    return showDialog<void>(
      context: context,
      barrierDismissible: true,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          backgroundColor: theme.background,
          title: Text(
            l10n.addressBookPageDeleteConfirmationTitle,
            style: TextStyle(color: theme.textPrimary),
          ),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                Text(
                  l10n.addressBookPageDeleteConfirmationMessage(address.name),
                  style: TextStyle(color: theme.textSecondary),
                ),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: Text(
                l10n.cancel,
                style: TextStyle(color: theme.textSecondary),
              ),
              onPressed: () {
                Navigator.of(dialogContext).pop();
              },
            ),
            TextButton(
              child: Text(
                l10n.delete,
                style: TextStyle(color: theme.danger),
              ),
              onPressed: () async {
                try {
                  await removeFromAddressBook(addr: address.addr);
                  await state.syncData();
                } catch (_) {
                } finally {}
                Navigator.of(dialogContext).pop();
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _handleTransactionHistoryChange(bool value) async {
    final stateProvider = Provider.of<AppState>(context, listen: false);
    await stateProvider.setShowAddressesThroughTransactionHistory(value);
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: CustomAppBar(
                    title: l10n.addressBookPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                    actionIcon: SvgPicture.asset(
                      'assets/icons/plus.svg',
                      width: 24,
                      height: 24,
                      colorFilter: ColorFilter.mode(
                        theme.textPrimary,
                        BlendMode.srcIn,
                      ),
                    ),
                    onActionPressed: () => showAddContactModal(
                      context: context,
                      state: state,
                    ),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: SwitchSettingItem(
                    backgroundColor: theme.cardBackground,
                    iconPath: "assets/icons/history.svg",
                    title: l10n.transactionHistoryTitle,
                    description: l10n.transactionHistoryDescription,
                    value: state.showAddressesThroughTransactionHistory,
                    onChanged: _handleTransactionHistoryChange,
                  ),
                ),
                const SizedBox(height: 16),
                Expanded(
                  child: state.book.isEmpty
                      ? _buildEmptyState(theme, l10n)
                      : _buildAddressList(state, theme, l10n),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(AppTheme theme, AppLocalizations l10n) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SvgPicture.asset(
              'assets/icons/book.svg',
              width: 120,
              height: 120,
              colorFilter: ColorFilter.mode(
                theme.textSecondary.withValues(alpha: 0.4),
                BlendMode.srcIn,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              l10n.addressBookPageEmptyMessage,
              textAlign: TextAlign.center,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 16,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAddressList(
      AppState state, AppTheme theme, AppLocalizations l10n) {
    return ListView.builder(
      itemCount: state.book.length,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      physics: const BouncingScrollPhysics(),
      itemBuilder: (context, index) {
        final address = state.book[index];
        final isLastItem = index == state.book.length - 1;

        return GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: () {
            // print('Tapped on ${address.name}');
          },
          child: Container(
            height: 72,
            decoration: BoxDecoration(
              border: !isLastItem
                  ? Border(
                      bottom: BorderSide(
                        color: theme.textSecondary.withValues(alpha: 0.1),
                        width: 1,
                      ),
                    )
                  : null,
            ),
            child: Row(
              children: [
                ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: SizedBox(
                    width: 40,
                    height: 40,
                    child: Blockies(
                      seed: address.addr.toLowerCase(),
                      size: 8,
                      color: theme.primaryPurple,
                      bgColor: theme.background,
                      spotColor: theme.textSecondary,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        address.name,
                        style: TextStyle(
                          color: theme.textPrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                      const SizedBox(height: 4),
                      Text(
                        shortenAddress(address.addr,
                            leftSize: 12, rightSize: 12),
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 14,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ],
                  ),
                ),
                SizedBox(
                  width: 48,
                  height: double.infinity,
                  child: IconButton(
                    padding: EdgeInsets.zero,
                    iconSize: 24,
                    icon: SvgPicture.asset(
                      'assets/icons/close.svg',
                      width: 24,
                      height: 24,
                      colorFilter: ColorFilter.mode(
                        theme.danger,
                        BlendMode.srcIn,
                      ),
                    ),
                    tooltip: l10n.addressBookPageDeleteTooltip(address.name),
                    onPressed: () {
                      _showDeleteConfirmationDialog(context, state, address);
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

```

`lib/pages/appearance.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/components/switch_setting_item.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class AppearanceSettingsPage extends StatefulWidget {
  const AppearanceSettingsPage({super.key});

  @override
  State<AppearanceSettingsPage> createState() => _AppearanceSettingsPageState();
}

class _AppearanceSettingsPageState extends State<AppearanceSettingsPage> {
  int selectedThemeIndex = 0;
  bool compactNumbers = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final themeProvider = Provider.of<AppState>(context, listen: false);
    setState(() {
      selectedThemeIndex = themeProvider.state.appearances;
      compactNumbers = themeProvider.state.abbreviatedNumber;
    });
  }

  Future<void> _handleThemeSelection(int index) async {
    final stateProvider = Provider.of<AppState>(context, listen: false);
    await stateProvider.setAppearancesCode(index, compactNumbers);
    setState(() {
      selectedThemeIndex = index;
    });
    await stateProvider.syncData();
  }

  Future<void> _handleCompactNumbersChange(bool value) async {
    final stateProvider = Provider.of<AppState>(context, listen: false);
    await stateProvider.setAppearancesCode(selectedThemeIndex, value);
    setState(() {
      compactNumbers = value;
    });
    await stateProvider.syncData();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    final Color effectiveBgColor = Theme.of(context).scaffoldBackgroundColor;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      extendBody: true,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        toolbarHeight: 0,
        systemOverlayStyle: overlayStyle,
      ),
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: l10n.appearanceSettingsPageTitle,
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SwitchSettingItem(
                            backgroundColor: theme.cardBackground,
                            iconPath: "assets/icons/pin.svg",
                            title:
                                l10n.appearanceSettingsPageCompactNumbersTitle,
                            description: l10n
                                .appearanceSettingsPageCompactNumbersDescription,
                            value: compactNumbers,
                            onChanged: _handleCompactNumbersChange,
                          ),
                          const SizedBox(height: 24),
                          OptionsList(
                            options: [
                              OptionItem(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      l10n.appearanceSettingsPageDeviceSettingsTitle,
                                      style: TextStyle(
                                        color: theme.textPrimary,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      l10n.appearanceSettingsPageDeviceSettingsSubtitle,
                                      style: TextStyle(
                                        color: theme.primaryPurple,
                                        fontSize: 14,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      l10n.appearanceSettingsPageDeviceSettingsDescription,
                                      style: TextStyle(
                                        color: theme.textSecondary,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ],
                                ),
                                isSelected: selectedThemeIndex == 0,
                                onSelect: () => _handleThemeSelection(0),
                              ),
                              OptionItem(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      l10n.appearanceSettingsPageDarkModeTitle,
                                      style: TextStyle(
                                        color: theme.textPrimary,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      l10n.appearanceSettingsPageDarkModeSubtitle,
                                      style: TextStyle(
                                        color: theme.primaryPurple,
                                        fontSize: 14,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      l10n.appearanceSettingsPageDarkModeDescription,
                                      style: TextStyle(
                                        color: theme.textSecondary,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ],
                                ),
                                isSelected: selectedThemeIndex == 1,
                                onSelect: () => _handleThemeSelection(1),
                              ),
                              OptionItem(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      l10n.appearanceSettingsPageLightModeTitle,
                                      style: TextStyle(
                                        color: theme.textPrimary,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      l10n.appearanceSettingsPageLightModeSubtitle,
                                      style: TextStyle(
                                        color: theme.primaryPurple,
                                        fontSize: 14,
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      l10n.appearanceSettingsPageLightModeDescription,
                                      style: TextStyle(
                                        color: theme.textSecondary,
                                        fontSize: 14,
                                      ),
                                    ),
                                  ],
                                ),
                                isSelected: selectedThemeIndex == 2,
                                onSelect: () => _handleThemeSelection(2),
                              ),
                            ],
                            unselectedOpacity: 0.5,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/browser_page.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/config/search_engines.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/pages/web_view.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class BrowserPage extends StatefulWidget {
  const BrowserPage({super.key});

  @override
  State<BrowserPage> createState() => _BrowserPageState();
}

class _BrowserPageState extends State<BrowserPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    final appState = Provider.of<AppState>(context, listen: false);
    appState.syncConnections();
  }

  @override
  void dispose() {
    _tabController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  void _handleSearch(String value) {
    if (value.isEmpty) return;

    final appState = Provider.of<AppState>(context, listen: false);
    final browserSettings = appState.state.browserSettings;
    final searchEngineIndex = browserSettings.searchEngineIndex;
    final searchEngine = baseSearchEngines[searchEngineIndex];

    String query = value.trim();
    String url;

    final uri = Uri.tryParse(query);
    if (uri != null) {
      if (uri.hasScheme && uri.hasAuthority) {
        url = query;
      } else if (uri.hasAuthority && uri.port != 0) {
        url = 'http://$query';
      } else if (isDomainName(query)) {
        url = 'https://$query';
      } else {
        url = '${searchEngine.url}${Uri.encodeQueryComponent(query)}';
      }
    } else {
      if (isDomainName(query)) {
        url = 'https://$query';
      } else {
        url = '${searchEngine.url}${Uri.encodeQueryComponent(query)}';
      }
    }

    _openWebView(url);
  }

  void _openWebView(String url) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => WebViewPage(
          initialUrl: url,
        ),
      ),
    );
  }

  bool isDomainName(String input) {
    final domainPart = input.split(':')[0];
    final domainRegex = RegExp(
        r'^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$');
    return domainRegex.hasMatch(domainPart);
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final padding = EdgeInsets.symmetric(
        horizontal: AdaptiveSize.getAdaptivePadding(context, 16));
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final connections = appState.connections;
    final l10n = AppLocalizations.of(context)!;

    return SafeArea(
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 480),
          child: Scaffold(
            backgroundColor: theme.background,
            body: Column(
              children: [
                TabBar(
                  controller: _tabController,
                  tabs: [
                    Tab(text: l10n.browserPageConnectedTab),
                    Tab(text: l10n.browserPageExploreTab),
                  ],
                  labelStyle: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 18,
                      fontWeight: FontWeight.w600),
                  unselectedLabelStyle: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 18,
                      fontWeight: FontWeight.w600),
                  indicatorColor: theme.primaryPurple,
                  labelColor: theme.textPrimary,
                  unselectedLabelColor: theme.textSecondary,
                  indicatorSize: TabBarIndicatorSize.label,
                  splashFactory: NoSplash.splashFactory,
                  dividerColor: Colors.transparent,
                ),
                Expanded(
                  child: TabBarView(
                    controller: _tabController,
                    children: [
                      _buildConnectedTab(connections, theme, padding),
                      Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Text(l10n.browserPageNoExploreApps,
                                style: TextStyle(
                                    color: theme.textSecondary,
                                    fontSize: 16,
                                    fontWeight: FontWeight.w500)),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: _buildSearchBar(theme),
                ),
                const SizedBox(height: 4),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSearchBar(AppTheme theme) {
    final appState = Provider.of<AppState>(context);
    final searchEngineIndex = appState.state.browserSettings.searchEngineIndex;
    final searchEngine = baseSearchEngines[searchEngineIndex];
    final l10n = AppLocalizations.of(context)!;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SmartInput(
          controller: _searchController,
          hint: l10n.browserPageSearchHint(searchEngine.name),
          leftIconPath: 'assets/icons/search.svg',
          rightIconPath: "assets/icons/close.svg",
          onChanged: (value) {},
          onSubmitted: _handleSearch,
          onRightIconTap: () {
            _searchController.text = "";
          },
          borderColor: theme.textPrimary,
          focusedBorderColor: theme.primaryPurple,
          height: 48,
          fontSize: 16,
          padding: const EdgeInsets.symmetric(horizontal: 16),
          autofocus: false,
          keyboardType: TextInputType.url,
        ),
      ],
    );
  }

  Widget _buildConnectedTab(
      List<ConnectionInfo> connections, AppTheme theme, EdgeInsets padding) {
    final l10n = AppLocalizations.of(context)!;

    if (connections.isEmpty) {
      return Center(
        child: Text(
          l10n.browserPageNoConnectedApps,
          style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
              fontWeight: FontWeight.w500),
        ),
      );
    }

    return GridView.builder(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        mainAxisSpacing: 16,
        crossAxisSpacing: 16,
        childAspectRatio: 0.9,
      ),
      padding: padding.copyWith(top: 32, bottom: 16),
      itemCount: connections.length,
      itemBuilder: (context, index) {
        final connection = connections[index];
        final url = 'https://${connection.domain}';
        return _buildConnectedTile(
          connection.title,
          connection.favicon ?? 'https://${connection.domain}/favicon.ico',
          url,
          theme,
        );
      },
    );
  }

  Widget _buildConnectedTile(
      String label, String iconUrl, String url, AppTheme theme) {
    return TileButton(
      title: label,
      icon: AsyncImage(
        url: iconUrl,
        width: 24,
        height: 24,
        fit: BoxFit.contain,
        errorWidget: HoverSvgIcon(
          assetName: 'assets/icons/default.svg',
          width: 24,
          height: 24,
          onTap: () {},
          color: theme.textPrimary,
        ),
      ),
      onPressed: () => _openWebView(url),
      backgroundColor: theme.cardBackground,
      textColor: theme.primaryPurple,
    );
  }
}

```

`lib/pages/browser_settings.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/components/button_item.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/switch_setting_item.dart';
import 'package:zilpay/config/search_engines.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/list_selector.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class BrowserSettingsPage extends StatefulWidget {
  const BrowserSettingsPage({super.key});

  @override
  State<BrowserSettingsPage> createState() => _BrowserSettingsPageState();
}

class _BrowserSettingsPageState extends State<BrowserSettingsPage> {
  final List<ListItem> searchEngines = baseSearchEngines
      .map((s) => ListItem(title: s.name, subtitle: s.description))
      .toList();

  final List<ListItem> contentBlockingOptions = [
    ListItem(title: 'Off', subtitle: 'No content blocking'),
    ListItem(title: 'Moderate', subtitle: 'Blocks some trackers and ads'),
    ListItem(title: 'Strict', subtitle: 'Blocks most trackers and ads'),
  ];

  // Track which clear operations are currently loading
  final Set<String> _loading = {};

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  // Helper method to set loading state
  void _setLoading(String operation, bool isLoading) {
    setState(() {
      if (isLoading) {
        _loading.add(operation);
      } else {
        _loading.remove(operation);
      }
    });
  }

  Future<void> _toggleCache(AppState appState, bool enabled) async {
    try {
      BrowserSettingsInfo newSettings =
          appState.state.browserSettings.copyWith(cacheEnabled: enabled);
      await setBrowserSettings(browserSettings: newSettings);
      await appState.syncData();
    } catch (e) {
      debugPrint("Error toggling cache: $e");
    }
  }

  Future<void> _toggleCookies(AppState appState, bool enabled) async {
    try {
      BrowserSettingsInfo newSettings =
          appState.state.browserSettings.copyWith(cookiesEnabled: enabled);
      await setBrowserSettings(browserSettings: newSettings);
      await appState.syncData();
    } catch (e) {
      debugPrint("Error toggling cookies: $e");
    }
  }

  Future<void> _toggleDoNotTrack(AppState appState, bool enabled) async {
    try {
      BrowserSettingsInfo newSettings =
          appState.state.browserSettings.copyWith(doNotTrack: enabled);
      await setBrowserSettings(browserSettings: newSettings);
      await appState.syncData();
    } catch (e) {
      debugPrint("Error toggling do not track: $e");
    }
  }

  Future<void> _toggleIncognitoMode(AppState appState, bool enabled) async {
    try {
      BrowserSettingsInfo newSettings =
          appState.state.browserSettings.copyWith(incognitoMode: enabled);
      await setBrowserSettings(browserSettings: newSettings);
      await appState.syncData();
    } catch (e) {
      debugPrint("Error toggling incognito mode: $e");
    }
  }

  Future<void> _clearCookies(AppState appState) async {
    final String operation = 'cookies';
    try {
      _setLoading(operation, true);
      await CookieManager.instance().deleteAllCookies();
      await CookieManager.instance().removeSessionCookies();
      await appState.syncData();
    } catch (e) {
      debugPrint("Error clearing cookies: $e");
    } finally {
      _setLoading(operation, false);
    }
  }

  Future<void> _clearCache(AppState appState) async {
    final String operation = 'cache';
    try {
      _setLoading(operation, true);
      await InAppWebViewController.clearAllCache();
      await appState.syncData();
    } catch (e) {
      debugPrint("Error clearing cache: $e");
    } finally {
      _setLoading(operation, false);
    }
  }

  Future<void> _clearLocalStorage(AppState appState) async {
    final String operation = 'localStorage';
    try {
      _setLoading(operation, true);
      final headlessWebView = HeadlessInAppWebView(
        initialUrlRequest: URLRequest(url: WebUri("about:blank")),
        onLoadStop: (controller, url) async {
          try {
            await controller.evaluateJavascript(
                source: "localStorage.clear();");
            await controller.evaluateJavascript(
                source: "sessionStorage.clear();");
            await controller.evaluateJavascript(source: """
            if (window.indexedDB) {
              window.indexedDB.deleteDatabase('all');
            }
          """);

            await controller.clearHistory();
          } catch (e) {
            debugPrint("Error in JavaScript execution: $e");
          }
        },
      );

      await headlessWebView.run();
      await Future<void>.delayed(const Duration(milliseconds: 800));
      await appState.syncData();
    } catch (e) {
      debugPrint("Error clearing localStorage: $e");
    } finally {
      _setLoading(operation, false);
    }
  }

  void _showSearchEngineModal(AppState appState) {
    showListSelectorModal(
      context: context,
      title: AppLocalizations.of(context)!.browserSettingsSearchEngineTitle,
      items: searchEngines,
      selectedIndex: appState.state.browserSettings.searchEngineIndex,
      onItemSelected: (index) async {
        final appState = Provider.of<AppState>(context, listen: false);
        try {
          BrowserSettingsInfo newSettings =
              appState.state.browserSettings.copyWith(searchEngineIndex: index);
          await setBrowserSettings(browserSettings: newSettings);
          await appState.syncData();
        } catch (e) {
          debugPrint("Error setting search engine: $e");
        }
      },
    );
  }

  void _showContentBlockingModal(AppState appState) {
    showListSelectorModal(
      context: context,
      title: AppLocalizations.of(context)!.browserSettingsContentBlockingTitle,
      items: contentBlockingOptions,
      selectedIndex: appState.state.browserSettings.contentBlocking,
      onItemSelected: (index) async {
        final appState = Provider.of<AppState>(context, listen: false);
        try {
          BrowserSettingsInfo newSettings =
              appState.state.browserSettings.copyWith(contentBlocking: index);
          await setBrowserSettings(browserSettings: newSettings);
          await appState.syncData();
        } catch (e) {
          debugPrint("Error setting content blocking: $e");
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: AppLocalizations.of(context)!.browserSettingsTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _buildButtonSection(theme, appState),
                          const SizedBox(height: 24),
                          _buildPrivacySection(theme, appState),
                          const SizedBox(height: 24),
                          _buildPerformanceSection(theme, appState),
                          const SizedBox(height: 24),
                          _buildClearDataSection(theme, appState),
                          const SizedBox(height: 24),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildButtonSection(AppTheme theme, AppState appState) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            AppLocalizations.of(context)!.browserSettingsBrowserOptions,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              ButtonItem(
                theme: theme,
                title:
                    AppLocalizations.of(context)!.browserSettingsSearchEngine,
                iconPath: 'assets/icons/search.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsSearchEngineDescription,
                onTap: () => _showSearchEngineModal(appState),
                subtitleText: searchEngines[
                        appState.state.browserSettings.searchEngineIndex]
                    .title,
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              ButtonItem(
                theme: theme,
                title: AppLocalizations.of(context)!
                    .browserSettingsContentBlocking,
                iconPath: 'assets/icons/shield.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsContentBlockingDescription,
                onTap: () => _showContentBlockingModal(appState),
                subtitleText: contentBlockingOptions[
                        appState.state.browserSettings.contentBlocking]
                    .title,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPrivacySection(AppTheme theme, AppState appState) {
    final settings = appState.state.browserSettings;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            AppLocalizations.of(context)!.browserSettingsPrivacySecurity,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              SwitchSettingItem(
                title: AppLocalizations.of(context)!.browserSettingsCookies,
                iconPath: 'assets/icons/cookie.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsCookiesDescription,
                value: settings.cookiesEnabled,
                onChanged: (value) => _toggleCookies(appState, value),
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              SwitchSettingItem(
                title: AppLocalizations.of(context)!.browserSettingsDoNotTrack,
                iconPath: 'assets/icons/shield.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsDoNotTrackDescription,
                value: settings.doNotTrack,
                onChanged: (value) => _toggleDoNotTrack(appState, value),
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              SwitchSettingItem(
                title:
                    AppLocalizations.of(context)!.browserSettingsIncognitoMode,
                iconPath: 'assets/icons/incognito.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsIncognitoModeDescription,
                value: settings.incognitoMode,
                onChanged: (value) => _toggleIncognitoMode(appState, value),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPerformanceSection(AppTheme theme, AppState appState) {
    final settings = appState.state.browserSettings;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            AppLocalizations.of(context)!.browserSettingsPerformance,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              SwitchSettingItem(
                title: AppLocalizations.of(context)!.browserSettingsCache,
                iconPath: 'assets/icons/cache.svg',
                description: AppLocalizations.of(context)!
                    .browserSettingsCacheDescription,
                value: settings.cacheEnabled,
                onChanged: (value) => _toggleCache(appState, value),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildClearDataSection(AppTheme theme, AppState appState) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            AppLocalizations.of(context)!.browserSettingsClearData,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              _buildClearDataItem(
                theme,
                AppLocalizations.of(context)!.browserSettingsClearCookies,
                'assets/icons/cookie.svg',
                AppLocalizations.of(context)!
                    .browserSettingsClearCookiesDescription,
                () => _clearCookies(appState),
                _loading.contains('cookies'),
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildClearDataItem(
                theme,
                AppLocalizations.of(context)!.browserSettingsClearCache,
                'assets/icons/cache.svg',
                AppLocalizations.of(context)!
                    .browserSettingsClearCacheDescription,
                () => _clearCache(appState),
                _loading.contains('cache'),
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildClearDataItem(
                theme,
                AppLocalizations.of(context)!.browserSettingsClearLocalStorage,
                'assets/icons/data.svg',
                AppLocalizations.of(context)!
                    .browserSettingsClearLocalStorageDescription,
                () => _clearLocalStorage(appState),
                _loading.contains('localStorage'),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildClearDataItem(
    AppTheme theme,
    String title,
    String iconPath,
    String description,
    VoidCallback onTap,
    bool isLoading,
  ) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SvgPicture.asset(
            iconPath,
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.textPrimary,
              BlendMode.srcIn,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  description,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 8),
          TextButton(
            onPressed: isLoading ? null : onTap,
            style: TextButton.styleFrom(
              foregroundColor: theme.primaryPurple,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            child: isLoading
                ? SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryPurple),
                    ),
                  )
                : Text(AppLocalizations.of(context)!.browserSettingsClear),
          ),
        ],
      ),
    );
  }
}

```

`lib/pages/currency_conversion.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button_item.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/modals/list_selector.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';

class CurrencyConversionPage extends StatefulWidget {
  const CurrencyConversionPage({super.key});

  @override
  State<CurrencyConversionPage> createState() => _CurrencyConversionPageState();
}

class _CurrencyConversionPageState extends State<CurrencyConversionPage> {
  late List<Currency> _currencies = [];
  late List<Currency> _filteredCurrencies = [];
  final TextEditingController _searchController = TextEditingController();
  String selectedCurrency = 'btc';
  int selectedEngine = 0;

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final state = Provider.of<AppState>(context, listen: false);
      final currenciesTickets = await getCurrenciesTickets();

      final currenciesList = currenciesTickets
          .map((pair) =>
              Currency(pair.$1, "${_getCurrencyName(pair.$1)} ${pair.$2}"))
          .toList();

      setState(() {
        _currencies = currenciesList;
        _filteredCurrencies = currenciesList;
      });

      if (state.wallet?.settings.currencyConvert != null) {
        setState(() {
          selectedCurrency = state.wallet!.settings.currencyConvert;
        });
      }

      setState(() {
        selectedEngine = state.wallet?.settings.ratesApiOptions ?? 0;
      });
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _filterCurrencies(String query) {
    setState(() {
      if (query.isEmpty) {
        _filteredCurrencies = _currencies;
      } else {
        _filteredCurrencies = _currencies.where((currency) {
          return currency.name.toLowerCase().contains(query.toLowerCase()) ||
              currency.code.toLowerCase().contains(query.toLowerCase());
        }).toList();
      }
    });
  }

  String _getCurrencyName(String symbol) {
    final Map<String, String> currencyNames = {
      "BTC": "Bitcoin",
      "BRL": "Brazilian Real",
      "RUB": "Russian Ruble",
      "INR": "Indian Rupee",
      "CNY": "Chinese Yuan",
      "ZAR": "South African Rand",
      "EGP": "Egyptian Pound",
      "ETB": "Ethiopian Birr",
      "IRR": "Iranian Rial",
      "SAR": "Saudi Riyal",
      "AED": "United Arab Emirates Dirham",
      "USD": "United States Dollar",
      "EUR": "Euro",
      "JPY": "Japanese Yen",
      "GBP": "British Pound",
      "KRW": "South Korean Won",
      "CHF": "Swiss Franc",
      "AUD": "Australian Dollar",
      "CAD": "Canadian Dollar",
      "MXN": "Mexican Peso",
      "ETH": "Ethereum",
      "LTC": "Litecoin",
      "XRP": "Ripple",
      "BCH": "Bitcoin Cash",
      "ADA": "Cardano",
      "DOT": "Polkadot",
      "SOL": "Solana",
      "USDT": "Tether",
      "DOGE": "Dogecoin",
      "GOLD": "Gold",
      "SILVER": "Silver"
    };

    return currencyNames[symbol] ?? symbol;
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final bool isRateFetchEnabled =
        appState.wallet!.settings.ratesApiOptions != 0;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: AppLocalizations.of(context)!.currencyConversionTitle,
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: Column(
                      children: [
                        _buildEngineBlock(theme, appState),
                        const SizedBox(height: 16),
                        _buildCurrenciesBlock(
                            theme, appState, isRateFetchEnabled),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEngineBlock(AppTheme theme, AppState appState) {
    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: _buildEngineInfo(theme, appState),
    );
  }

  Widget _buildCurrenciesBlock(
      AppTheme theme, AppState appState, bool isRateFetchEnabled) {
    return Expanded(
      child: Container(
        decoration: BoxDecoration(
          color: theme.cardBackground,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Opacity(
          opacity: isRateFetchEnabled ? 1.0 : 0.5,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: AbsorbPointer(
              absorbing: !isRateFetchEnabled,
              child: Column(
                children: [
                  SmartInput(
                    controller: _searchController,
                    hint: AppLocalizations.of(context)!
                        .currencyConversionSearchHint,
                    leftIconPath: 'assets/icons/search.svg',
                    rightIconPath: "assets/icons/close.svg",
                    onChanged: (value) {
                      _filterCurrencies(value);
                    },
                    onRightIconTap: () {
                      _searchController.text = "";
                      _filterCurrencies("");
                    },
                    onSubmitted: (value) {},
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    autofocus: false,
                    keyboardType: TextInputType.text,
                  ),
                  const SizedBox(height: 16),
                  Expanded(
                    child: ListView.builder(
                      physics: const BouncingScrollPhysics(),
                      itemCount: _filteredCurrencies.length,
                      itemBuilder: (context, index) {
                        final currency = _filteredCurrencies[index];
                        final isSelected = currency.code.toLowerCase() ==
                            selectedCurrency.toLowerCase();

                        return _buildCurrencyItem(
                          theme,
                          currency,
                          isSelected,
                          onTap: () async {
                            setState(() {
                              selectedCurrency = currency.code;
                            });

                            await setRateFetcher(
                              walletIndex: BigInt.from(appState.selectedWallet),
                              currency: selectedCurrency,
                            );

                            await appState.syncRates(force: true);
                            await appState.syncData();
                          },
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEngineInfo(AppTheme theme, AppState appState) {
    final engineText = selectedEngine == 0 ? 'None' : 'Coingecko';

    return ButtonItem(
      theme: theme,
      title: AppLocalizations.of(context)!.currencyConversionEngineTitle,
      iconPath: 'assets/icons/currency.svg',
      description:
          AppLocalizations.of(context)!.currencyConversionEngineDescription,
      subtitleText: engineText,
      onTap: () {
        _showEngineSelector(appState);
      },
    );
  }

  void _showEngineSelector(AppState appState) {
    final engines = [
      ListItem(
          title: AppLocalizations.of(context)!.currencyConversionEngineNone,
          subtitle: AppLocalizations.of(context)!
              .currencyConversionEngineNoneSubtitle),
      ListItem(
          title:
              AppLocalizations.of(context)!.currencyConversionEngineCoingecko,
          subtitle: AppLocalizations.of(context)!
              .currencyConversionEngineCoingeckoSubtitle),
    ];

    showListSelectorModal(
      context: context,
      title:
          AppLocalizations.of(context)!.currencyConversionEngineSelectorTitle,
      items: engines,
      selectedIndex: selectedEngine,
      onItemSelected: (index) async {
        BigInt walletIndex = BigInt.from(appState.selectedWallet);

        setState(() {
          selectedEngine = index;
        });

        await setRateEngine(
          walletIndex: walletIndex,
          engineCode: index,
        );

        await appState.syncRates(force: true);
        await appState.syncData();
      },
    );
  }

  Widget _buildCurrencyItem(
    AppTheme theme,
    Currency currency,
    bool isSelected, {
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 56,
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color: theme.textSecondary.withValues(alpha: 0.1),
              width: 1,
            ),
          ),
        ),
        child: Row(
          children: [
            SizedBox(
              width: 60,
              child: Text(
                currency.code.toUpperCase(),
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            Expanded(
              child: Text(
                currency.name,
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: 16,
                ),
              ),
            ),
            SizedBox(
              width: 24,
              height: 24,
              child: isSelected
                  ? SvgPicture.asset(
                      'assets/icons/ok.svg',
                      colorFilter: ColorFilter.mode(
                        theme.primaryPurple,
                        BlendMode.srcIn,
                      ),
                    )
                  : null,
            ),
          ],
        ),
      ),
    );
  }
}

class Currency {
  final String code;
  final String name;

  Currency(this.code, this.name);
}

```

`lib/pages/gen_bip39.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/wor_count_selector.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/backup_confirmation_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SecretPhraseGeneratorPage extends StatefulWidget {
  const SecretPhraseGeneratorPage({
    super.key,
  });

  @override
  State<SecretPhraseGeneratorPage> createState() => _CreateAccountPageState();
}

class _CreateAccountPageState extends State<SecretPhraseGeneratorPage> {
  List<String> _mnemonicWords = [];
  var _count = 12;
  bool _hasBackupWords = false;
  bool _isCopied = false;
  // final String _selectedLanguage = 'English';

  @override
  void initState() {
    super.initState();
    _regenerateMnemonicWords();
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: l10n.secretPhraseGeneratorPageTitle,
                  onBackPressed: () => Navigator.pop(context),
                  actionIcon: SvgPicture.asset(
                    'assets/icons/reload.svg',
                    width: 30,
                    height: 30,
                    colorFilter: ColorFilter.mode(
                      theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  ),
                  onActionPressed: _regenerateMnemonicWords,
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        WordCountSelector(
                          wordCounts: const [12, 15, 18, 21, 24],
                          selectedCount: _count,
                          onCountChanged: (newCount) {
                            setState(() {
                              _count = newCount;
                              _regenerateMnemonicWords();
                            });
                          },
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: ListView.builder(
                            physics: const BouncingScrollPhysics(),
                            itemCount: _mnemonicWords.length,
                            itemBuilder: (context, index) {
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 8.0),
                                child: MnemonicWordInput(
                                  index: index + 1,
                                  word: _mnemonicWords[index],
                                  isEditable: false,
                                  opacity: 0.5,
                                ),
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 8),
                        Row(
                          children: [
                            Expanded(
                              child: Theme(
                                data: Theme.of(context).copyWith(
                                  splashFactory: NoSplash.splashFactory,
                                  highlightColor: Colors.transparent,
                                ),
                                child: CheckboxListTile(
                                  title: Text(
                                    l10n.secretPhraseGeneratorPageBackupCheckbox,
                                    style:
                                        TextStyle(color: theme.textSecondary),
                                  ),
                                  value: _hasBackupWords,
                                  onChanged: (_) {
                                    if (!_hasBackupWords) {
                                      showBackupConfirmationModal(
                                        context: context,
                                        onConfirmed: (confirmed) {
                                          setState(() {
                                            _hasBackupWords = confirmed;
                                          });
                                        },
                                      );
                                    }
                                  },
                                  controlAffinity:
                                      ListTileControlAffinity.leading,
                                  activeColor: theme.primaryPurple,
                                ),
                              ),
                            ),
                            TileButton(
                              icon: SvgPicture.asset(
                                _isCopied
                                    ? "assets/icons/check.svg"
                                    : "assets/icons/copy.svg",
                                width: 24,
                                height: 24,
                                colorFilter: ColorFilter.mode(
                                  theme.primaryPurple,
                                  BlendMode.srcIn,
                                ),
                              ),
                              disabled: false,
                              onPressed: () async {
                                await _handleCopy(_mnemonicWords.join(" "));
                              },
                              backgroundColor: theme.cardBackground,
                              textColor: theme.primaryPurple,
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16),
                          child: CustomButton(
                            textColor: theme.buttonText,
                            backgroundColor: theme.primaryPurple,
                            text: l10n.secretPhraseGeneratorPageNextButton,
                            onPressed: () {
                              Navigator.of(context).pushNamed('/verify_bip39',
                                  arguments: {'bip39': _mnemonicWords});
                            },
                            borderRadius: 30.0,
                            height: 56.0,
                            disabled: !_hasBackupWords,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _handleCopy(String text) async {
    await Clipboard.setData(ClipboardData(text: text));
    setState(() {
      _isCopied = true;
    });

    Future.delayed(const Duration(seconds: 2), () {
      if (mounted) {
        setState(() {
          _isCopied = false;
        });
      }
    });
  }

  void _regenerateMnemonicWords() async {
    String words = await genBip39Words(count: _count);

    setState(() {
      _mnemonicWords = words.split(" ");
      _hasBackupWords = false;
      _isCopied = false;
    });
  }
}

```

`lib/pages/gen_wallet_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class GenWalletOptionsPage extends StatelessWidget {
  const GenWalletOptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: SvgPicture.asset(
            'assets/icons/back.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.secondaryPurple,
              BlendMode.srcIn,
            ),
          ),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Text(AppLocalizations.of(context)!.genWalletOptionsTitle,
            style: TextStyle(color: theme.textPrimary)),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              WalletListItem(
                title: AppLocalizations.of(context)!.genWalletOptionsBIP39Title,
                subtitle:
                    AppLocalizations.of(context)!.genWalletOptionsBIP39Subtitle,
                icon: SvgPicture.asset(
                  'assets/icons/document.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_bip39');
                },
              ),
              WalletListItem(
                disabled: true,
                title:
                    AppLocalizations.of(context)!.genWalletOptionsSLIP0039Title,
                subtitle: AppLocalizations.of(context)!
                    .genWalletOptionsSLIP0039Subtitle,
                icon: SvgPicture.asset(
                  'assets/icons/puzzle.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {},
              ),
              WalletListItem(
                title: AppLocalizations.of(context)!
                    .genWalletOptionsPrivateKeyTitle,
                subtitle: AppLocalizations.of(context)!
                    .genWalletOptionsPrivateKeySubtitle,
                icon: SvgPicture.asset(
                  'assets/icons/bincode.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_sk');
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/history_page.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show defaultTargetPlatform;
import 'package:provider/provider.dart';
import 'package:zilpay/components/linear_refresh_indicator.dart';
import 'package:zilpay/components/transaction_item.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/transaction_details_modal.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/models/transactions/history.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

enum SortType { date, status }

class HistoryPage extends StatefulWidget {
  const HistoryPage({super.key});

  @override
  State<HistoryPage> createState() => _HistoryPageState();
}

class _HistoryPageState extends State<HistoryPage> {
  List<HistoricalTransactionInfo> _history = [];
  bool _isLoading = true;
  SortType _sortType = SortType.date;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadInitialHistory();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadInitialHistory() async {
    final appState = Provider.of<AppState>(context, listen: false);
    if (appState.wallet == null || appState.account == null) {
      if (mounted) Navigator.of(context).pop();
      return;
    }
    try {
      final history = await getHistory(
        walletIndex: BigInt.from(appState.selectedWallet),
      );
      if (mounted) {
        setState(() {
          _history = history;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint("Error syncing history: $e");
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _checkPendingTransactions(AppState appState) async {
    try {
      final history = await checkPendingTranasctions(
        walletIndex: BigInt.from(appState.selectedWallet),
      );
      if (mounted) {
        setState(() {
          _history = history;
        });
      }
    } catch (e) {
      debugPrint("Error syncing pending transactions: $e");
    }
  }

  Future<void> _clearAllTransactions(AppState appState) async {
    try {
      await clearHistory(
        walletIndex: BigInt.from(appState.selectedWallet),
      );
      if (mounted) {
        setState(() {
          _history = [];
        });
      }
    } catch (e) {
      debugPrint("Error clearing transactions: $e");
    }
  }

  List<HistoricalTransactionInfo> _getSortedAndFilteredHistory() {
    List<HistoricalTransactionInfo> filteredHistory =
        _history.where((transaction) {
      final searchText = _searchController.text.toLowerCase();
      return [
        transaction.transactionHash,
        transaction.amount,
        transaction.sender,
        transaction.recipient,
        transaction.contractAddress ?? '',
        transaction.title ?? '',
        transaction.error ?? '',
        transaction.tokenInfo?.symbol ?? '',
        transaction.chainType,
      ].any((field) => field.toLowerCase().contains(searchText));
    }).toList();
    if (_sortType == SortType.date) {
      filteredHistory.sort((a, b) => b.timestamp.compareTo(a.timestamp));
    } else {
      filteredHistory.sort((a, b) => a.status.index.compareTo(b.status.index));
    }
    return filteredHistory;
  }

  Widget _buildHeader(AppState appState, double adaptivePadding) {
    return Padding(
      padding: EdgeInsets.all(adaptivePadding),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            AppLocalizations.of(context)!.historyPageTitle,
            style: TextStyle(
              color: appState.currentTheme.textPrimary,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          Row(
            children: [
              HoverSvgIcon(
                assetName: 'assets/icons/down_arrow.svg',
                width: 24,
                height: 24,
                onTap: () {
                  setState(() {
                    _sortType = _sortType == SortType.date
                        ? SortType.status
                        : SortType.date;
                  });
                },
                color: appState.currentTheme.textPrimary,
              ),
              HoverSvgIcon(
                assetName: 'assets/icons/minus.svg',
                width: 24,
                height: 24,
                onTap: () {
                  _clearAllTransactions(appState);
                },
                color: appState.currentTheme.danger,
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildContent(AppState appState, double adaptivePadding) {
    if (_isLoading) {
      return Center(
        child: CircularProgressIndicator(
          color: appState.currentTheme.primaryPurple,
        ),
      );
    }
    final sortedHistory = _getSortedAndFilteredHistory();
    if (sortedHistory.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              AppLocalizations.of(context)!.historyPageNoTransactions,
              style: TextStyle(
                color: appState.currentTheme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      );
    }
    return Padding(
      padding: EdgeInsets.all(adaptivePadding),
      child: Column(
        children: sortedHistory.asMap().entries.map((entry) {
          final transaction = entry.value;
          final isLast = entry.key == sortedHistory.length - 1;
          return HistoryItem(
            transaction: transaction,
            showDivider: !isLast,
            onTap: () {
              showTransactionDetailsModal(
                context: context,
                transaction: transaction,
              );
            },
          );
        }).toList(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;

    final slivers = [
      if (isIOS)
        CupertinoSliverRefreshControl(
          onRefresh: () => _checkPendingTransactions(appState),
          builder: (
            BuildContext context,
            RefreshIndicatorMode refreshState,
            double pulledExtent,
            double refreshTriggerPullDistance,
            double refreshIndicatorExtent,
          ) {
            return LinearRefreshIndicator(
              pulledExtent: pulledExtent,
              refreshTriggerPullDistance: refreshTriggerPullDistance,
              refreshIndicatorExtent: refreshIndicatorExtent,
            );
          },
        ),
      SliverToBoxAdapter(
        child: Column(
          children: [
            _buildHeader(appState, adaptivePadding),
            _buildContent(appState, adaptivePadding),
          ],
        ),
      ),
    ];

    Widget scrollView = CustomScrollView(
      physics: const AlwaysScrollableScrollPhysics(),
      slivers: slivers,
    );

    if (!isIOS) {
      scrollView = RefreshIndicator(
        onRefresh: () => _checkPendingTransactions(appState),
        child: scrollView,
      );
    }

    return Scaffold(
      backgroundColor: appState.currentTheme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Expanded(child: scrollView),
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: SmartInput(
                    controller: _searchController,
                    hint: AppLocalizations.of(context)!.historyPageSearchHint,
                    leftIconPath: 'assets/icons/search.svg',
                    rightIconPath: "assets/icons/close.svg",
                    onChanged: (value) {
                      setState(() {});
                    },
                    onRightIconTap: () {
                      _searchController.text = "";
                    },
                    onSubmitted: (value) {},
                    borderColor: appState.currentTheme.textPrimary,
                    focusedBorderColor: appState.currentTheme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    autofocus: false,
                    keyboardType: TextInputType.text,
                  ),
                ),
                const SizedBox(height: 4),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/home_page.dart`:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart' show defaultTargetPlatform;
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/components/linear_refresh_indicator.dart';
import 'package:zilpay/components/net_btn.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/token_card.dart';
import 'package:zilpay/components/wallet_header.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/l10n/app_localizations.dart';

const double ICON_SIZE_SMALL = 24.0;
const double ICON_SIZE_MEDIUM = 32.0;
const double ICON_SIZE_TILE_BUTTON = 25.0;

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> with TickerProviderStateMixin {
  bool _isFirstLoad = true;
  String? _errorMessage;
  late AnimationController _animationController;
  late Animation<double> _heightAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 400),
    );

    _heightAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutCubic,
    );

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.3, 1.0, curve: Curves.easeOut),
      ),
    );

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_isFirstLoad) {
        _isFirstLoad = false;
        final appState = Provider.of<AppState>(context, listen: false);
        _refreshData(appState);
      }
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  Future<void> _refreshData(AppState appState) async {
    BigInt index = BigInt.from(appState.selectedWallet);

    try {
      await syncBalances(walletIndex: index);
      if (_errorMessage != null) {
        setState(() {
          _errorMessage = null;
        });
        _animationController.reverse();
      }
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
      });
      _animationController.forward();
    }

    await appState.syncRates();
    await appState.syncData();
  }

  void _dismissError() {
    _animationController.reverse().then((_) {
      setState(() {
        _errorMessage = null;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final adaptivePaddingCard = AdaptiveSize.getAdaptivePadding(context, 12);
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;
    final l10n = AppLocalizations.of(context)!;

    final filteredTokens = appState.wallet!.tokens
        .where((t) => t.addrType == appState.account?.addrType)
        .toList();

    final slivers = [
      if (isIOS)
        CupertinoSliverRefreshControl(
          onRefresh: () => _refreshData(appState),
          builder: (
            BuildContext context,
            RefreshIndicatorMode refreshState,
            double pulledExtent,
            double refreshTriggerPullDistance,
            double refreshIndicatorExtent,
          ) {
            return LinearRefreshIndicator(
              pulledExtent: pulledExtent,
              refreshTriggerPullDistance: refreshTriggerPullDistance,
              refreshIndicatorExtent: refreshIndicatorExtent,
            );
          },
        ),
      if (_errorMessage != null)
        SliverToBoxAdapter(
          child: SizeTransition(
            axisAlignment: -1,
            sizeFactor: _heightAnimation,
            child: FadeTransition(
              opacity: _opacityAnimation,
              child: Container(
                margin: const EdgeInsets.fromLTRB(16, 16, 16, 0),
                padding:
                    const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
                decoration: BoxDecoration(
                  color: theme.danger,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(l10n.homePageErrorTitle,
                              style: theme.subtitle1.copyWith(
                                color: theme.buttonText,
                              )),
                          const SizedBox(height: 4),
                          Text(
                            _errorMessage!,
                            style: TextStyle(
                              color: theme.buttonText,
                              fontSize: 16,
                            ),
                          ),
                        ],
                      ),
                    ),
                    IconButton(
                      icon: SvgPicture.asset(
                        'assets/icons/close.svg',
                        width: ICON_SIZE_SMALL,
                        height: ICON_SIZE_SMALL,
                        colorFilter: ColorFilter.mode(
                          theme.buttonText,
                          BlendMode.srcIn,
                        ),
                      ),
                      onPressed: _dismissError,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      SliverToBoxAdapter(
        child: Padding(
          padding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 12,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (appState.account != null)
                Expanded(
                  child: WalletHeader(
                    account: appState.account!,
                    onSettings: () {
                      Navigator.pushNamed(context, '/settings');
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
      SliverToBoxAdapter(
        child: SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
          child: Row(
            children: [
              TileButton(
                icon: SvgPicture.asset(
                  "assets/icons/send.svg",
                  width: ICON_SIZE_TILE_BUTTON,
                  height: ICON_SIZE_TILE_BUTTON,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                title: l10n.homePageSendButton,
                onPressed: () {
                  Navigator.pushNamed(context, '/send');
                },
                backgroundColor: theme.cardBackground,
                textColor: theme.primaryPurple,
              ),
              SizedBox(width: adaptivePaddingCard),
              TileButton(
                icon: SvgPicture.asset(
                  "assets/icons/receive.svg",
                  width: ICON_SIZE_TILE_BUTTON,
                  height: ICON_SIZE_TILE_BUTTON,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                title: l10n.homePageReceiveButton,
                onPressed: () {
                  Navigator.pushNamed(context, '/receive');
                },
                backgroundColor: theme.cardBackground,
                textColor: theme.primaryPurple,
              ),
              if (appState.account != null &&
                  appState.chain?.slip44 == 313) ...[
                SizedBox(width: adaptivePaddingCard),
                TileButton(
                  icon: SvgPicture.asset(
                    "assets/icons/anchor.svg",
                    width: ICON_SIZE_TILE_BUTTON,
                    height: ICON_SIZE_TILE_BUTTON,
                    colorFilter:
                        ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
                  ),
                  title: "Stake",
                  onPressed: () async {
                    Navigator.pushNamed(context, '/zil_stake');
                  },
                  backgroundColor: theme.cardBackground,
                  textColor: theme.primaryPurple,
                ),
              ],
              if (appState.account != null &&
                  appState.chain?.slip44 == 313 &&
                  !appState.wallet!.walletType
                      .contains(WalletType.ledger.name)) ...[
                SizedBox(width: adaptivePaddingCard),
                TileButton(
                  icon: SvgPicture.asset(
                    appState.account?.addrType == 0
                        ? "assets/icons/scilla.svg"
                        : "assets/icons/solidity.svg",
                    width: ICON_SIZE_TILE_BUTTON,
                    height: ICON_SIZE_TILE_BUTTON,
                    colorFilter:
                        ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
                  ),
                  title: appState.account?.addrType == 0 ? "Scilla" : "EVM",
                  onPressed: () async {
                    BigInt walletIndex = BigInt.from(appState.selectedWallet);
                    await zilliqaSwapChain(
                      walletIndex: walletIndex,
                      accountIndex: appState.wallet!.selectedAccount,
                    );
                    await appState.syncData();

                    try {
                      await syncBalances(
                        walletIndex: walletIndex,
                      );
                      await appState.syncData();
                    } catch (_) {}
                  },
                  backgroundColor: theme.cardBackground,
                  textColor: theme.primaryPurple,
                ),
              ]
            ],
          ),
        ),
      ),
      SliverToBoxAdapter(
        child: Padding(
          padding:
              EdgeInsets.symmetric(horizontal: adaptivePadding, vertical: 4),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Row(
                children: [
                  NetworkDownButton(
                    onPressed: () {
                      Navigator.pushNamed(context, '/networks');
                    },
                    chain: appState.chain!,
                  ),
                  SizedBox(width: adaptivePadding),
                  HoverSvgIcon(
                    assetName: appState.hideBalance
                        ? 'assets/icons/close_eye.svg'
                        : 'assets/icons/open_eye.svg',
                    width: ICON_SIZE_MEDIUM,
                    height: ICON_SIZE_MEDIUM,
                    padding: EdgeInsets.fromLTRB(
                        0, adaptivePadding, 0, adaptivePadding),
                    color: theme.textSecondary,
                    onTap: () {
                      setState(() {
                        appState.setHideBalance(!appState.hideBalance);
                      });
                    },
                  ),
                ],
              ),
              HoverSvgIcon(
                assetName: 'assets/icons/manage.svg',
                width: ICON_SIZE_MEDIUM,
                height: ICON_SIZE_MEDIUM,
                padding: EdgeInsets.fromLTRB(
                    30, adaptivePadding, 0, adaptivePadding),
                color: theme.textSecondary,
                onTap: () {
                  Navigator.pushNamed(context, '/manage_tokens');
                },
              ),
            ],
          ),
        ),
      ),
      SliverList(
        delegate: SliverChildBuilderDelegate(
          (context, index) {
            final token = filteredTokens[index];
            final isLast = index == filteredTokens.length - 1;
            final tokenAmountValue = token.balances.isNotEmpty &&
                    token.balances.keys
                        .contains(appState.wallet!.selectedAccount)
                ? BigInt.tryParse(token
                        .balances[appState.wallet!.selectedAccount]
                        .toString()) ??
                    BigInt.zero
                : BigInt.zero;

            return TokenCard(
              ftoken: token,
              hideBalance: appState.hideBalance,
              tokenAmount: tokenAmountValue,
              showDivider: !isLast,
              onTap: () {
                final originalIndex = appState.wallet!.tokens.indexOf(token);
                Navigator.of(context).pushNamed(
                  '/send',
                  arguments: {'token_index': originalIndex},
                );
              },
            );
          },
          childCount: filteredTokens.length,
        ),
      ),
    ];

    Widget scrollView = CustomScrollView(
      physics: const AlwaysScrollableScrollPhysics(),
      slivers: slivers,
    );

    if (!isIOS) {
      scrollView = RefreshIndicator(
        onRefresh: () => _refreshData(appState),
        child: scrollView,
      );
    }

    return SafeArea(
      child: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 480),
          child: scrollView,
        ),
      ),
    );
  }
}

```

`lib/pages/initial_page.dart`:

```dart
import 'dart:io' show Platform;
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

class InitialPage extends StatefulWidget {
  const InitialPage({super.key});

  @override
  State<InitialPage> createState() => _InitialPageState();
}

class _InitialPageState extends State<InitialPage> {
  bool _isLoading = true;
  bool _isRestoreAvailable = false;
  String? _vaultJson;
  String? _accountsJson;

  @override
  void initState() {
    super.initState();
    _loadingOldStorage();
  }

  void _loadingOldStorage() async {
    try {
      if (Platform.isAndroid) {
        final (vaultJson, accountsJson) = await loadOldDatabaseAndroid();
        setState(() {
          _vaultJson = vaultJson;
          _accountsJson = accountsJson;
          _isRestoreAvailable = true;
        });
      } else if (Platform.isIOS) {
        final appDocDir = await getApplicationSupportDirectory();
        final (vaultJson, accountsJson) =
            await loadOldDatabaseIos(baseDir: appDocDir.path);
        setState(() {
          _vaultJson = vaultJson;
          _accountsJson = accountsJson;
          _isRestoreAvailable = true;
        });
      }
    } catch (_) {
      setState(() {
        _isRestoreAvailable = false;
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Widget _buildButton(AppTheme theme) {
    if (_isLoading) {
      return const CircularProgressIndicator(
        valueColor: AlwaysStoppedAnimation<Color>(Colors.purple),
      );
    } else if (_isRestoreAvailable) {
      return CustomButton(
        textColor: theme.buttonText,
        backgroundColor: theme.primaryPurple,
        text: AppLocalizations.of(context)!.initialPagerestoreZilPay,
        onPressed: () {
          Navigator.of(context).pushNamed(
            '/rk_restore',
            arguments: {
              'vaultJson': _vaultJson,
              'accountsJson': _accountsJson,
            },
          );
        },
      );
    } else {
      return CustomButton(
        textColor: theme.buttonText,
        backgroundColor: theme.primaryPurple,
        text: AppLocalizations.of(context)?.initialPagegetStarted ?? "",
        onPressed: () {
          Navigator.of(context).pushNamed('/new_wallet_options');
        },
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    final Color effectiveBgColor = theme.background;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      extendBody: true,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        toolbarHeight: 0,
        systemOverlayStyle: overlayStyle,
      ),
      backgroundColor: theme.background,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  IconButton(
                    icon: SvgPicture.asset(
                      'assets/icons/moon_sun.svg',
                      colorFilter: ColorFilter.mode(
                        theme.textPrimary,
                        BlendMode.srcIn,
                      ),
                      width: 30.0,
                      height: 30.0,
                    ),
                    onPressed: () async {
                      final appState =
                          Provider.of<AppState>(context, listen: false);

                      switch (appState.state.appearances) {
                        case 0:
                          final Brightness systemBrightness =
                              PlatformDispatcher.instance.platformBrightness;
                          if (systemBrightness == Brightness.dark) {
                            await appState.setAppearancesCode(
                              2,
                              appState.state.abbreviatedNumber,
                            );
                          } else {
                            await appState.setAppearancesCode(
                              1,
                              appState.state.abbreviatedNumber,
                            );
                          }
                          break;
                        case 1:
                          await appState.setAppearancesCode(
                            2,
                            appState.state.abbreviatedNumber,
                          );
                          break;
                        case 2:
                          await appState.setAppearancesCode(
                            1,
                            appState.state.abbreviatedNumber,
                          );
                          break;
                      }
                    },
                  ),
                  IconButton(
                    icon: SvgPicture.asset(
                      'assets/icons/language.svg',
                      colorFilter:
                          ColorFilter.mode(theme.textPrimary, BlendMode.srcIn),
                      width: 34.0,
                      height: 34.0,
                    ),
                    onPressed: () {
                      Navigator.pushNamed(context, '/language');
                    },
                  ),
                ],
              ),
            ),
            Expanded(
              child: Center(
                child: SvgPicture.asset(
                  'assets/icons/little_dragons.svg',
                  width: 400.0,
                  height: 400.0,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.only(left: 16.0, right: 16.0, bottom: 32.0),
              child: _buildButton(theme),
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/pages/keystore_backup.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_common.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:file_picker/file_picker.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';

class KeystoreBackup extends StatefulWidget {
  const KeystoreBackup({super.key});

  @override
  State<KeystoreBackup> createState() => _KeystoreBackupState();
}

class _KeystoreBackupState extends State<KeystoreBackup> {
  bool isProcessing = false;
  bool hasError = false;
  String? errorMessage;
  bool _obscureConfirmPassword = true;
  bool isBackupCreated = false;
  String? backupFilePath;
  Uint8List? keystoreBytes;

  final _confirmPasswordController = TextEditingController();
  final _confirmPasswordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  @override
  void initState() {
    _secureScreen();
    super.initState();
  }

  @override
  void dispose() {
    _confirmPasswordController.dispose();
    ScreenProtector.preventScreenshotOff();
    ScreenProtector.protectDataLeakageOff();
    ScreenProtector.protectDataLeakageWithBlurOff();
    super.dispose();
  }

  Future<void> _secureScreen() async {
    await ScreenProtector.preventScreenshotOn();
    await ScreenProtector.protectDataLeakageOn();
    await ScreenProtector.protectDataLeakageWithBlur();
  }

  void _onCreateBackup(BigInt walletIndex, String name) async {
    final l10n = AppLocalizations.of(context)!;

    if (_confirmPasswordController.text.isEmpty) {
      setState(() {
        hasError = true;
        errorMessage = l10n.keystoreBackupPasswordTooShort;
      });
      return;
    }

    _btnController.start();
    setState(() {
      isProcessing = true;
      hasError = false;
      errorMessage = null;
    });

    try {
      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      keystoreBytes = await makeKeystoreFile(
        walletIndex: walletIndex,
        password: _confirmPasswordController.text,
        deviceIndicators: identifiers,
      );

      final docPath = await _saveKeystoreToDocumentsDir(
        keystoreBytes!,
        name,
      );

      setState(() {
        isBackupCreated = true;
        backupFilePath = docPath;
        isProcessing = false;
      });

      _btnController.success();
    } catch (e) {
      setState(() {
        isProcessing = false;
        hasError = true;
        errorMessage = "${l10n.keystoreBackupError} $e";
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  Future<String> _saveKeystoreToDocumentsDir(
    Uint8List keystoreBytes,
    String name,
  ) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final filePath =
          '${directory.path}/${name}_zilpay_keystore_$timestamp.zp';

      final file = File(filePath);
      await file.writeAsBytes(keystoreBytes);

      return filePath;
    } catch (e) {
      throw Exception('Failed to save keystore file: $e');
    }
  }

  Future<void> _saveKeystoreWithPicker(String name) async {
    final l10n = AppLocalizations.of(context)!;

    if (keystoreBytes == null) {
      setState(() {
        hasError = true;
        errorMessage = l10n.keystoreBackupError;
      });
      return;
    }

    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = '${name}_zilpay_keystore_$timestamp.zp';

      if (Platform.isIOS) {
        final directory = await getApplicationDocumentsDirectory();
        final outputPath = '${directory.path}/$fileName';

        final file = File(outputPath);
        await file.writeAsBytes(keystoreBytes!);

        setState(() {
          backupFilePath = outputPath;
        });

        await SharePlus.instance.share(
          ShareParams(
            files: [XFile(outputPath)],
          ),
        );
      } else {
        String? outputDirectory = await FilePicker.platform.getDirectoryPath(
          dialogTitle: l10n.keystoreBackupSaveDialogTitle,
        );

        if (outputDirectory != null) {
          final outputPath = '$outputDirectory/$fileName';

          final file = File(outputPath);
          await file.writeAsBytes(keystoreBytes!);

          setState(() {
            backupFilePath = outputPath;
          });

          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(l10n.keystoreBackupSavedSuccess),
                backgroundColor: Provider.of<AppState>(context, listen: false)
                    .currentTheme
                    .success,
              ),
            );
          }
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          hasError = true;
          errorMessage = '${l10n.keystoreBackupSaveFailed}: $e';
        });
      }
    }
  }

  Future<void> _shareKeystoreFile() async {
    if (backupFilePath == null || !File(backupFilePath!).existsSync()) {
      final l10n = AppLocalizations.of(context)!;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(l10n.keystoreBackupSaveFailed),
          backgroundColor:
              Provider.of<AppState>(context, listen: false).currentTheme.danger,
        ),
      );
      return;
    }

    await SharePlus.instance.share(
      ShareParams(
        files: [XFile(backupFilePath!)],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = state.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: l10n.keystoreBackupTitle,
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    _buildWarningAlert(theme),
                    if (!isBackupCreated) ...[
                      SmartInput(
                        key: _confirmPasswordInputKey,
                        controller: _confirmPasswordController,
                        hint: l10n.keystoreBackupConfirmPasswordHint,
                        fontSize: 18,
                        height: 50,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        obscureText: _obscureConfirmPassword,
                        onSubmitted: (_) => _onCreateBackup(
                          BigInt.from(
                            state.selectedWallet,
                          ),
                          state.wallet?.walletName ?? "",
                        ),
                        rightIconPath: _obscureConfirmPassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: () => setState(() =>
                            _obscureConfirmPassword = !_obscureConfirmPassword),
                      ),
                      if (hasError && errorMessage != null)
                        Container(
                          margin: const EdgeInsets.only(top: 8),
                          child: Text(
                            errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: RoundedLoadingButton(
                          color: theme.primaryPurple,
                          valueColor: theme.buttonText,
                          controller: _btnController,
                          onPressed: () => _onCreateBackup(
                            BigInt.from(state.selectedWallet),
                            state.wallet?.walletName ?? "",
                          ),
                          child: Text(
                            l10n.keystoreBackupCreateButton,
                            style: TextStyle(
                              color: theme.buttonText,
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    ],
                    if (isBackupCreated) ...[
                      _buildSuccessMessage(theme),
                      SizedBox(height: adaptivePadding),
                      if (!Platform.isIOS) ...[
                        Container(
                          constraints: const BoxConstraints(maxWidth: 480),
                          child: CustomButton(
                            textColor: theme.buttonText,
                            backgroundColor: theme.primaryPurple,
                            text: l10n.keystoreBackupSaveAsButton,
                            onPressed: () => _saveKeystoreWithPicker(
                              state.wallet?.walletName ?? "",
                            ),
                            borderRadius: 30.0,
                            height: 56.0,
                          ),
                        ),
                        SizedBox(height: adaptivePadding),
                      ],
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: CustomButton(
                          textColor: theme.buttonText,
                          backgroundColor: theme.primaryPurple,
                          text: l10n.keystoreBackupShareButton,
                          onPressed: _shareKeystoreFile,
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                      SizedBox(height: adaptivePadding),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: CustomButton(
                          textColor: theme.buttonText,
                          backgroundColor: theme.secondaryPurple,
                          text: l10n.keystoreBackupDoneButton,
                          onPressed: () => Navigator.pop(context),
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildWarningAlert(AppTheme theme) {
    final l10n = AppLocalizations.of(context)!;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.warning.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.warning),
      ),
      child: Column(
        children: [
          Row(
            children: [
              SvgPicture.asset(
                "assets/icons/warning.svg",
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.warning,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 8),
              Text(
                l10n.keystoreBackupWarningTitle,
                style: TextStyle(
                  color: theme.warning,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            l10n.keystoreBackupWarningMessage,
            style: TextStyle(
              color: theme.warning,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSuccessMessage(AppTheme theme) {
    final l10n = AppLocalizations.of(context)!;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.success.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.success),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Text(
                l10n.keystoreBackupSuccessTitle,
                style: TextStyle(
                  color: theme.success,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            l10n.keystoreBackupSuccessMessage,
            style: TextStyle(
              color: theme.success,
              fontSize: 14,
            ),
          ),
          if (backupFilePath != null) ...[
            const SizedBox(height: 8),
            Text(
              '${l10n.keystoreBackupTempLocation}:\n$backupFilePath',
              style: TextStyle(
                color: theme.success,
                fontSize: 12,
                fontStyle: FontStyle.italic,
              ),
            ),
          ],
        ],
      ),
    );
  }
}

```

`lib/pages/keystore_file_restore.dart`:

```dart
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:file_picker/file_picker.dart';
import 'package:zilpay/components/biometric_switch.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/device.dart';
import 'package:path_provider/path_provider.dart';
import 'package:zilpay/theme/app_theme.dart';

class RestoreKeystoreFilePage extends StatefulWidget {
  const RestoreKeystoreFilePage({super.key});

  @override
  State<RestoreKeystoreFilePage> createState() =>
      _RestoreKeystoreFilePageState();
}

class _RestoreKeystoreFilePageState extends State<RestoreKeystoreFilePage> {
  static const List<int> SIGNATURE = [
    90,
    73,
    76,
    80,
    65,
    89,
    95,
    66,
    65,
    67,
    75,
    85,
    80
  ];

  String _password = '';
  bool _disabled = false;
  String _errorMessage = '';
  bool _isLoading = true;
  List<KeystoreFile> _backupFiles = [];
  KeystoreFile? _selectedFile;

  final AuthService _authService = AuthService();
  late AuthGuard _authGuard;
  late AppState _appState;
  List<AuthMethod> _authMethods = [AuthMethod.none];
  bool _useDeviceAuth = true;

  final TextEditingController _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();
  bool _obscurePassword = true;

  @override
  void initState() {
    super.initState();
    _loadBackupFiles();

    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);
    _checkAuthMethods();
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _btnController.dispose();
    super.dispose();
  }

  Future<void> _checkAuthMethods() async {
    final methods = await _authService.getAvailableAuthMethods();
    setState(() {
      _authMethods = methods;
    });
  }

  Future<void> _loadBackupFiles() async {
    setState(() {
      _isLoading = true;
      _backupFiles = [];
      _errorMessage = '';
    });

    try {
      final List<KeystoreFile> files = [];

      final tempDir = await getTemporaryDirectory();
      await _loadFilesFromDirectory(tempDir.path, files);

      final docDir = await getApplicationDocumentsDirectory();
      await _loadFilesFromDirectory(docDir.path, files);

      if (Platform.isAndroid) {
        await _loadFilesFromDirectory('/storage/emulated/0/Download', files);
      }

      setState(() {
        _backupFiles = files;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = e.toString();
      });
    }
  }

  Future<void> _loadFilesFromDirectory(
      String dirPath, List<KeystoreFile> files) async {
    try {
      final dir = Directory(dirPath);
      if (await dir.exists()) {
        final dirFiles = dir
            .listSync()
            .where((entity) => entity is File && entity.path.endsWith('.zp'))
            .map((entity) => entity as File);

        for (final file in dirFiles) {
          try {
            final keystoreFile = await _parseKeystoreFile(file);
            if (keystoreFile != null) {
              files.add(keystoreFile);
            }
          } catch (_) {}
        }
      }
    } catch (_) {}
  }

  Future<KeystoreFile?> _parseKeystoreFile(File file) async {
    try {
      final bytes = await file.readAsBytes();
      if (bytes.length < SIGNATURE.length + 1) {
        return KeystoreFile(
          file: file,
          fileName: file.path.split('/').last,
          filePath: file.path,
          lastModified: file.lastModifiedSync(),
          isValid: false,
        );
      }

      final signatureBytes = bytes.sublist(0, SIGNATURE.length);
      final signatureMatches =
          _compareByteList(signatureBytes, Uint8List.fromList(SIGNATURE));

      int? version;
      if (signatureMatches && bytes.length > SIGNATURE.length) {
        version = bytes[SIGNATURE.length];
      }

      return KeystoreFile(
        file: file,
        fileName: file.path.split('/').last,
        filePath: file.path,
        lastModified: file.lastModifiedSync(),
        isValid: signatureMatches,
        version: version,
      );
    } catch (e) {
      return null;
    }
  }

  bool _compareByteList(Uint8List a, Uint8List b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  void _selectBackupFile(KeystoreFile file) {
    if (_disabled) return;

    setState(() {
      _selectedFile = file;
      _errorMessage = '';
    });
  }

  Future<void> _openFilePicker() async {
    if (_disabled) return;

    try {
      final l10n = AppLocalizations.of(context)!;
      final result = await FilePicker.platform.pickFiles(type: FileType.any);

      if (result != null &&
          result.files.isNotEmpty &&
          result.files.first.path != null) {
        final path = result.files.first.path!;
        if (path.toLowerCase().endsWith('.zp')) {
          try {
            final file = File(path);
            final keystoreFile = await _parseKeystoreFile(file);

            if (keystoreFile != null) {
              setState(() {
                if (!_backupFiles
                    .any((f) => f.filePath == keystoreFile.filePath)) {
                  _backupFiles.add(keystoreFile);
                }
                _selectedFile = keystoreFile;
                _errorMessage = '';
              });
            }
          } catch (e) {
            setState(() => _errorMessage = e.toString());
          }
        } else {
          setState(() => _errorMessage = l10n.keystoreRestoreExtError);
        }
      }
    } catch (e) {
      setState(() => _errorMessage = e.toString());
    }
  }

  Future<void> _restoreFromKeystore() async {
    setState(() {
      _disabled = true;
      _errorMessage = '';
    });

    if (_passwordController.text.isEmpty) {
      setState(() {
        _errorMessage =
            AppLocalizations.of(context)!.passwordSetupPageShortPasswordError;
        _disabled = false;
      });
      _passwordInputKey.currentState?.shake();
      _btnController.reset();
      return;
    }

    try {
      _btnController.start();

      if (_useDeviceAuth) {
        final authenticated = await _authService.authenticate(
          allowPinCode: true,
          reason: AppLocalizations.of(context)!.passwordSetupPageAuthReason,
        );
        setState(() => _useDeviceAuth = authenticated);
        if (!authenticated) {
          setState(() {
            _disabled = false;
          });
          _btnController.reset();
          return;
        }
      }

      DeviceInfoService device = DeviceInfoService();
      List<String> identifiers = await device.getDeviceIdentifiers();

      AuthMethod biometricType = AuthMethod.none;
      if (_useDeviceAuth) {
        biometricType = _authMethods[0];
      }

      final fileBytes = await _selectedFile!.file.readAsBytes();
      final (String, String) session = await restoreFromKeystore(
        keystoreBytes: fileBytes,
        deviceIndicators: identifiers,
        password: _passwordController.text,
        biometricType: biometricType.name,
      );

      if (_useDeviceAuth) {
        await _authGuard.setSession(session.$2, session.$1);
      }

      await _appState.syncData();
      await _appState.startTrackHistoryWorker();

      _appState.setSelectedWallet(_appState.wallets.length - 1);

      _btnController.success();

      if (mounted) {
        Navigator.of(context).pushReplacementNamed('/');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = e.toString();
          _disabled = false;
        });
        _btnController.error();
        await Future.delayed(const Duration(seconds: 1));
        _btnController.reset();
      }
    }
  }

  String _getFormattedDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year} ${date.hour}:${date.minute.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: l10n.restoreWalletOptionsKeyStoreTitle,
              onBackPressed: _disabled ? () {} : () => Navigator.pop(context),
              actionIcon: SvgPicture.asset(
                'assets/icons/reload.svg',
                width: 24,
                height: 24,
                colorFilter:
                    ColorFilter.mode(theme.textPrimary, BlendMode.srcIn),
              ),
              onActionPressed: _disabled ? null : _loadBackupFiles,
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(top: 16, bottom: 8),
                      child: SmartInput(
                        key: _passwordInputKey,
                        controller: _passwordController,
                        hint: l10n.keystorePasswordHint,
                        height: 50.0,
                        fontSize: 18,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        disabled: _disabled || _selectedFile == null,
                        obscureText: _obscurePassword,
                        rightIconPath: _obscurePassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: _disabled
                            ? null
                            : () {
                                setState(
                                    () => _obscurePassword = !_obscurePassword);
                              },
                        onChanged: _disabled
                            ? null
                            : (value) {
                                setState(() {
                                  _password = value;
                                  if (_errorMessage.isNotEmpty) {
                                    _errorMessage = '';
                                  }
                                });
                              },
                      ),
                    ),
                    BiometricSwitch(
                      biometricType: _authMethods.first,
                      value: _useDeviceAuth,
                      disabled: _disabled,
                      onChanged: (value) async {
                        setState(() => _useDeviceAuth = value);
                      },
                    ),
                    Padding(
                      padding: const EdgeInsets.only(top: 8, bottom: 16),
                      child: RoundedLoadingButton(
                        color: theme.primaryPurple,
                        valueColor: theme.buttonText,
                        controller: _btnController,
                        onPressed: (_password.isNotEmpty &&
                                _selectedFile != null &&
                                !_disabled)
                            ? _restoreFromKeystore
                            : () {},
                        child: Text(
                          l10n.keystoreRestoreButton,
                          style: const TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                    if (_errorMessage.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16),
                        child: Text(
                          _errorMessage,
                          style: TextStyle(
                            color: theme.danger,
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    _buildFileListHeader(theme),
                    _buildFileList(theme),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFileListHeader(AppTheme theme) {
    final l10n = AppLocalizations.of(context)!;

    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            l10n.keystoreRestoreFilesTitle,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: theme.textPrimary,
            ),
          ),
          IconButton(
            onPressed: _disabled ? null : _openFilePicker,
            icon: SvgPicture.asset(
              'assets/icons/plus.svg',
              width: 24,
              height: 24,
              colorFilter: ColorFilter.mode(
                  _disabled ? theme.textSecondary : theme.textPrimary,
                  BlendMode.srcIn),
            ),
            splashRadius: 20,
          ),
        ],
      ),
    );
  }

  Widget _buildFileList(AppTheme theme) {
    if (_isLoading) {
      return Expanded(
        child: Center(
          child: CircularProgressIndicator(color: theme.primaryPurple),
        ),
      );
    }

    final l10n = AppLocalizations.of(context)!;

    return Expanded(
      child: _backupFiles.isEmpty
          ? Center(
              child: Text(
                l10n.keystoreRestoreNoFile,
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: 16,
                ),
              ),
            )
          : ListView.builder(
              itemCount: _backupFiles.length,
              itemBuilder: (context, index) {
                final file = _backupFiles[index];
                final isSelected = _selectedFile?.filePath == file.filePath;
                final formattedDate = _getFormattedDate(file.lastModified);

                return Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: KeystoreFileCard(
                    file: file,
                    isSelected: isSelected,
                    formattedDate: formattedDate,
                    theme: theme,
                    disabled: _disabled,
                    onPressed: () => _selectBackupFile(file),
                  ),
                );
              },
            ),
    );
  }
}

class KeystoreFile {
  final File file;
  final String fileName;
  final String filePath;
  final DateTime lastModified;
  final bool isValid;
  final int? version;
  final int fileSize;

  KeystoreFile({
    required this.file,
    required this.fileName,
    required this.filePath,
    required this.lastModified,
    required this.isValid,
    this.version,
  }) : fileSize = file.lengthSync();
}

class KeystoreFileCard extends StatelessWidget {
  final KeystoreFile file;
  final bool isSelected;
  final String formattedDate;
  final AppTheme theme;
  final bool disabled;
  final VoidCallback onPressed;

  const KeystoreFileCard({
    Key? key,
    required this.file,
    required this.isSelected,
    required this.formattedDate,
    required this.theme,
    required this.onPressed,
    this.disabled = false,
  }) : super(key: key);

  String _formatFileSize() {
    final sizeInKB = (file.fileSize / 1024).toStringAsFixed(1);
    return '$sizeInKB KB';
  }

  @override
  Widget build(BuildContext context) {
    return PressableCard(
      onPressed: disabled ? () {} : onPressed,
      backgroundColor: isSelected
          ? theme.primaryPurple.withValues(alpha: 0.1)
          : theme.cardBackground,
      borderColor: isSelected
          ? theme.primaryPurple
          : theme.secondaryPurple.withValues(alpha: 0.3),
      disabled: disabled,
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                SvgPicture.asset(
                  'assets/icons/document.svg',
                  width: 32,
                  height: 32,
                  colorFilter: ColorFilter.mode(
                    file.isValid
                        ? (disabled ? theme.textSecondary : theme.primaryPurple)
                        : theme.textSecondary,
                    BlendMode.srcIn,
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        file.fileName,
                        style: TextStyle(
                          color: disabled
                              ? theme.textSecondary
                              : theme.textPrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Text(
                            formattedDate,
                            style: TextStyle(
                              color: theme.textSecondary,
                              fontSize: 12,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Text(
                            _formatFileSize(),
                            style: TextStyle(
                              color: theme.textSecondary,
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                if (file.isValid)
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: theme.primaryPurple
                          .withValues(alpha: disabled ? 0.1 : 0.2),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'v${file.version ?? "?"}',
                      style: TextStyle(
                        color: disabled
                            ? theme.textSecondary
                            : theme.primaryPurple,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              file.filePath,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }
}

class PressableCard extends StatefulWidget {
  final Widget child;
  final VoidCallback onPressed;
  final Color backgroundColor;
  final Color borderColor;
  final bool disabled;

  const PressableCard({
    Key? key,
    required this.child,
    required this.onPressed,
    required this.backgroundColor,
    required this.borderColor,
    this.disabled = false,
  }) : super(key: key);

  @override
  State<PressableCard> createState() => _PressableCardState();
}

class _PressableCardState extends State<PressableCard> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown:
          widget.disabled ? null : (_) => setState(() => _isPressed = true),
      onTapUp: widget.disabled
          ? null
          : (_) {
              setState(() => _isPressed = false);
              widget.onPressed();
            },
      onTapCancel:
          widget.disabled ? null : () => setState(() => _isPressed = false),
      child: AnimatedScale(
        scale: (_isPressed && !widget.disabled) ? 0.97 : 1.0,
        duration: const Duration(milliseconds: 100),
        child: Card(
          margin: EdgeInsets.zero,
          color: widget.backgroundColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: widget.disabled
                  ? widget.borderColor.withValues(alpha: 0.5)
                  : widget.borderColor,
              width: 1,
            ),
          ),
          child: widget.child,
        ),
      ),
    );
  }
}

```

`lib/pages/ledger_connect.dart`:

```dart
import 'dart:async';
import 'dart:io' show Platform;
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/ledger_device_card.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:async/async.dart';

class LedgerConnectPage extends StatefulWidget {
  const LedgerConnectPage({super.key});
  @override
  State<LedgerConnectPage> createState() => _LedgerConnectPageState();
}

class _LedgerConnectPageState extends State<LedgerConnectPage> {
  LedgerInterface? _ledgerBle;
  LedgerInterface? _ledgerUsb;
  final Set<LedgerDevice> _discoveredDevices = {};
  StreamSubscription? _scanSubscription;
  bool _isScanning = false;
  bool _isConnecting = false;
  LedgerDevice? _connectingDevice;
  LedgerConnection? _ledgerConnection;
  String _statusText = 'Initializing...';
  StreamSubscription? _disconnectionSubscription;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initLedger();
      Future.delayed(const Duration(milliseconds: 500), _startScanning);
    });
  }

  @override
  void dispose() {
    _scanSubscription?.cancel();
    _disconnectionSubscription?.cancel();
    _ledgerConnection
        ?.disconnect()
        .catchError((e) => debugPrint('Error disconnecting on dispose: $e'));
    _ledgerBle
        ?.dispose()
        .catchError((e) => debugPrint('Error disposing BLE: $e'));
    _ledgerUsb
        ?.dispose()
        .catchError((e) => debugPrint('Error disposing USB: $e'));
    super.dispose();
  }

  void _initLedger() {
    if (!mounted) return;
    try {
      _ledgerBle = LedgerInterface.ble(
        onPermissionRequest: _handlePermissionRequest,
        bleOptions: BluetoothOptions(
          maxScanDuration: const Duration(seconds: 15),
        ),
      );
      _ledgerUsb = Platform.isAndroid ? LedgerInterface.usb() : null;
      setState(() {
        _statusText = 'Ready to scan. Press refresh button.';
      });
    } catch (e) {
      debugPrint('Error initializing Ledger: $e');
      if (!mounted) return;
      setState(() {
        _statusText = 'Error initializing Ledger: $e';
      });
      _showErrorDialog(
          'Initialization Error', 'Failed to initialize Ledger interfaces: $e');
    }
  }

  Future<bool> _handlePermissionRequest(AvailabilityState status) async {
    if (!mounted) return false;

    if (status == AvailabilityState.poweredOff) {
      setState(() {
        _statusText =
            'Bluetooth is turned off. Please enable Bluetooth on your device.';
      });
      _showErrorDialog('Bluetooth Off',
          'Please turn on Bluetooth in your device settings and try again.');
      return false;
    }

    if (status == AvailabilityState.unauthorized) {
      setState(() {
        _statusText = 'Bluetooth permission denied. Please enable in settings.';
      });

      if (Platform.isIOS) {
        _showErrorDialog('Permission Required',
            'This app requires Bluetooth permission to scan for Ledger devices. Please enable Bluetooth permission in your device settings.',
            showSettingsButton: true);
      } else {
        final statuses = await [
          Permission.bluetoothScan,
          Permission.bluetoothConnect,
          Permission.locationWhenInUse,
        ].request();

        final allGranted = statuses.values.every((s) => s.isGranted);
        if (!allGranted && mounted) {
          _showErrorDialog('Permission Denied',
              'Bluetooth permissions are required to scan for Ledger devices. Please grant permissions in settings.',
              showSettingsButton: true);
          return false;
        }
      }
      return false;
    }

    if (status == AvailabilityState.unsupported) {
      setState(() {
        _statusText = 'Bluetooth LE is not supported on this device.';
      });
      _showErrorDialog('Unsupported Device',
          'This device does not support Bluetooth Low Energy, which is required to connect to Ledger devices wirelessly.');
      return false;
    }

    if (Platform.isIOS) {
      return true;
    }

    final statuses = await [
      Permission.bluetoothScan,
      Permission.bluetoothConnect,
      Permission.locationWhenInUse,
    ].request();

    final allGranted = statuses.values.every((s) => s.isGranted);

    if (!allGranted && mounted) {
      setState(() {
        _statusText = 'Permissions denied. Cannot scan via BLE.';
      });

      _showErrorDialog('Permission Denied',
          'Bluetooth permissions are required to scan for Ledger devices via BLE. Please grant permissions in settings.',
          showSettingsButton: true);
      return false;
    }

    return true;
  }

  Future<void> _startScanning() async {
    if (_isScanning || _isConnecting || _ledgerBle == null) return;

    await _disconnectDevice();
    if (!mounted) return;

    setState(() {
      _isScanning = true;
      _discoveredDevices.clear();
      _statusText = 'Scanning for Ledger devices...';
    });

    await _scanSubscription?.cancel();
    _scanSubscription = null;

    try {
      final bleStatus = await _ledgerBle!.status;
      debugPrint('[Scan] Current BLE status: $bleStatus');

      if (bleStatus != AvailabilityState.poweredOn) {
        debugPrint('[Scan] BLE not powered on, current state: $bleStatus');
        final granted = await _handlePermissionRequest(bleStatus);
        if (!granted) {
          setState(() => _isScanning = false);
          return;
        }
      }

      await Future.delayed(const Duration(milliseconds: 500));

      final bleStream = _ledgerBle!.scan();
      final usbStream = Platform.isAndroid ? _ledgerUsb?.scan() : null;

      final combinedStream = StreamGroup.merge([
        bleStream,
        if (usbStream != null) usbStream,
      ]);

      _scanSubscription = combinedStream.listen(
        (device) {
          if (!mounted) return;
          setState(() {
            _discoveredDevices.add(device);
            _statusText = 'Found ${_discoveredDevices.length} device(s)...';
          });
        },
        onError: (error) {
          if (!mounted) return;
          debugPrint('[Scan] Scan Error: $error');
          setState(() {
            _isScanning = false;
            _statusText = 'Scan Error: $error';
          });
          _showErrorDialog('Scan Error', 'Scan Error: $error');
        },
        onDone: () {
          if (!mounted) return;
          setState(() {
            _isScanning = false;
            _statusText = _discoveredDevices.isEmpty
                ? 'Scan finished. No devices found.'
                : 'Scan finished. Found ${_discoveredDevices.length} device(s). Select one to connect.';
          });
        },
      );

      Future.delayed(const Duration(seconds: 16), () {
        if (mounted && _isScanning) {
          _stopScan();
        }
      });
    } catch (e, s) {
      debugPrint('[Scan] Error starting scan: $e\n$s');
      if (!mounted) return;
      setState(() {
        _isScanning = false;
        _statusText = 'Failed to start scan: $e';
      });
      _showErrorDialog('Scan Error', 'Failed to start scan: $e');
    }
  }

  Future<void> _stopScan() async {
    debugPrint("[Scan] Stopping scan...");
    await _scanSubscription?.cancel();
    _scanSubscription = null;
    if (mounted && _isScanning) {
      setState(() {
        _isScanning = false;
        if (!_isConnecting && _ledgerConnection == null) {
          _statusText = _discoveredDevices.isEmpty
              ? 'Scan stopped.'
              : 'Scan stopped. Found ${_discoveredDevices.length} device(s).';
        }
      });
      debugPrint("[Scan] Scan stopped and state updated.");
    }
  }

  Future<void> _connectToDevice(LedgerDevice device, {int retries = 2}) async {
    if (_isConnecting || _ledgerConnection != null) {
      debugPrint('[Connect] Attempt aborted: Already connecting or connected.');
      return;
    }
    if (_isScanning) {
      await _stopScan();
    }
    if (!mounted) return;
    debugPrint(
        '[Connect] Attempting connection to ${device.name} (${device.id}) via ${device.connectionType.name}');
    setState(() {
      _isConnecting = true;
      _connectingDevice = device;
      _statusText =
          'Connecting to ${device.name} (${device.connectionType.name.toUpperCase()})...';
    });
    LedgerConnection? tempConnection;
    const connectionTimeout = Duration(seconds: 30);
    int attempt = 0;

    while (attempt < retries) {
      try {
        debugPrint(
            '[Connect] Calling ${device.connectionType.name}.connect() with ${connectionTimeout.inSeconds}s timeout... (Attempt ${attempt + 1} of $retries)');
        if (device.connectionType == ConnectionType.ble && _ledgerBle != null) {
          tempConnection = await _ledgerBle!.connect(device).timeout(
            connectionTimeout,
            onTimeout: () {
              debugPrint('[Connect] BLE connection timed out.');
              throw TimeoutException(
                  'Connection timed out after ${connectionTimeout.inSeconds} seconds');
            },
          );
        } else if (device.connectionType == ConnectionType.usb &&
            _ledgerUsb != null) {
          tempConnection = await _ledgerUsb!.connect(device).timeout(
            connectionTimeout,
            onTimeout: () {
              debugPrint('[Connect] USB connection timed out.');
              throw TimeoutException(
                  'Connection timed out after ${connectionTimeout.inSeconds} seconds');
            },
          );
        } else {
          throw Exception('Appropriate Ledger interface not available.');
        }
        debugPrint(
            '[Connect] Connection call successful for ${device.id}. Connection object present:');
        if (!mounted) {
          debugPrint(
              '[Connect] Widget unmounted after connection success, disconnecting.');
          await tempConnection.disconnect().catchError((e) => debugPrint(
              '[Connect] Error disconnecting after widget disposed: $e'));
          return;
        }
        _ledgerConnection = tempConnection;
        setState(() {
          debugPrint('[Connect] Setting state to connected.');
          _statusText = 'Successfully connected to ${device.name}!';
        });
        Navigator.of(context).pushNamed(
          '/net_setup',
          arguments: {
            'ledger': device,
          },
        );
        debugPrint('[Connect] Setting up disconnect listener for ${device.id}');
        _listenForDisconnection(device.id);
        debugPrint('[Connect] Disconnect listener setup initiated.');
        return;
      } on TimeoutException catch (e) {
        debugPrint('[Connect] TimeoutException caught: ${e.message}');
        attempt++;
        if (attempt >= retries) {
          if (!mounted) return;
          setState(() {
            _statusText =
                'Connection Failed: Timed out after $attempt attempts';
            _ledgerConnection = null;
          });
          _showErrorDialog('Connection Failed',
              'Connection timed out after $attempt attempts. Please ensure the device is unlocked and try again.');
        } else {
          debugPrint(
              '[Connect] Retrying connection (attempt ${attempt + 1} of $retries)');
          await Future.delayed(const Duration(milliseconds: 500));
        }
      } on LedgerException catch (e) {
        debugPrint('[Connect] LedgerException caught: $e');
        if (!mounted) return;
        setState(() {
          _statusText = 'Connection Failed: $e';
          _ledgerConnection = null;
        });
        _showErrorDialog('Connection Failed', 'Ledger Error: $e');
        return;
      } catch (e, s) {
        debugPrint('[Connect] Generic Exception caught: $e\n$s');
        if (!mounted) return;
        setState(() {
          _statusText = 'Connection Failed: $e';
          _ledgerConnection = null;
        });
        _showErrorDialog('Connection Failed',
            'Could not connect to ${device.name}.\nError: $e');
        return;
      } finally {
        if (mounted && attempt >= retries) {
          setState(() {
            _isConnecting = false;
            _connectingDevice = null;
          });
        }
      }
    }
  }

  void _listenForDisconnection(String deviceId) {
    _disconnectionSubscription?.cancel();
    _disconnectionSubscription = null;
    final manager = (_ledgerConnection?.connectionType == ConnectionType.ble)
        ? _ledgerBle
        : _ledgerUsb;
    if (manager == null || _ledgerConnection == null) {
      debugPrint(
          "[Disconnect Listener] Cannot listen: Manager or connection is null.");
      return;
    }
    debugPrint("[Disconnect Listener] Setting up listener for $deviceId");
    try {
      _disconnectionSubscription =
          manager.deviceStateChanges(deviceId).listen((state) {
        debugPrint("[Disconnect Listener] State changed for $deviceId: $state");
        bool isDisconnected = false;
        if (manager == _ledgerBle) {
          isDisconnected = state == BleConnectionState.disconnected;
        }
        if (isDisconnected &&
            mounted &&
            _ledgerConnection?.device.id == deviceId) {
          debugPrint(
              '[Disconnect Listener] Device $deviceId disconnected externally.');
          _handleDisconnectionUI('Device disconnected.');
        }
      }, onError: (e) {
        debugPrint('[Disconnect Listener] Error in stream for $deviceId: $e');
        if (mounted) {}
      }, onDone: () {
        debugPrint('[Disconnect Listener] Stream done for $deviceId.');
        if (mounted && _ledgerConnection?.device.id == deviceId) {
          _handleDisconnectionUI('Listener stopped.');
        }
      });
    } catch (e) {
      debugPrint(
          "[Disconnect Listener] Error setting up listener for $deviceId: $e");
      if (mounted) {
        setState(() {
          if (_ledgerConnection != null) {
            _statusText = 'Failed to monitor disconnects.';
          }
        });
      }
    }
  }

  Future<void> _disconnectDevice() async {
    debugPrint("[Disconnect] Initiating disconnection...");
    await _disconnectionSubscription?.cancel();
    _disconnectionSubscription = null;
    if (_ledgerConnection == null) {
      debugPrint("[Disconnect] No active connection to disconnect.");
      return;
    }
    final deviceName = _ledgerConnection?.device.name ?? 'Ledger';
    final deviceId = _ledgerConnection?.device.id ?? 'unknown';
    debugPrint("[Disconnect] Disconnecting from $deviceName ($deviceId)");
    final connectionToClose = _ledgerConnection;
    _ledgerConnection = null;
    if (mounted) {
      _handleDisconnectionUI('Disconnecting from $deviceName...');
    }
    try {
      await connectionToClose!.disconnect();
      debugPrint('[Disconnect] Successfully disconnected from $deviceName.');
      if (mounted) {
        _handleDisconnectionUI('Disconnected from $deviceName.');
      }
    } catch (e) {
      debugPrint('[Disconnect] Error during disconnect: $e');
      if (mounted) {
        _handleDisconnectionUI('Error disconnecting from $deviceName.');
      }
    }
  }

  void _handleDisconnectionUI(String statusMsg) {
    debugPrint(
        "[Disconnect Handler] Handling disconnection UI update. Message: $statusMsg");
    if (!mounted) return;
    _disconnectionSubscription?.cancel();
    _disconnectionSubscription = null;
    setState(() {
      _ledgerConnection = null;
      _isConnecting = false;
      _connectingDevice = null;
      _statusText = statusMsg;
    });
  }

  void _showErrorDialog(String title, String content,
      {bool showSettingsButton = false}) {
    if (!mounted) return;
    final theme = Provider.of<AppState>(context, listen: false).currentTheme;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: theme.cardBackground,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
        title: Text(title, style: TextStyle(color: theme.textPrimary)),
        content: Text(content, style: TextStyle(color: theme.textSecondary)),
        actions: [
          TextButton(
            onPressed: Navigator.of(context).pop,
            child: Text('Cancel', style: TextStyle(color: theme.primaryPurple)),
          ),
          if (showSettingsButton)
            TextButton(
              onPressed: () async {
                Navigator.of(context).pop();
                await openAppSettings();
              },
              child: Text('Go to Settings',
                  style: TextStyle(color: theme.primaryPurple)),
            ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 20);
    final theme = Provider.of<AppState>(context).currentTheme;
    final bool isConnected = _ledgerConnection != null;
    final String pageTitle = "Connect Ledger";

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Column(
              children: [
                CustomAppBar(
                  title: pageTitle,
                  onBackPressed: () => Navigator.pop(context),
                  actionIcon: SvgPicture.asset(
                    'assets/icons/reload.svg',
                    width: 28,
                    height: 28,
                    colorFilter: ColorFilter.mode(
                      (_isScanning || _isConnecting)
                          ? theme.textSecondary.withAlpha(128)
                          : theme.textPrimary,
                      BlendMode.srcIn,
                    ),
                  ),
                  onActionPressed:
                      (_isScanning || _isConnecting) ? null : _startScanning,
                ),
                Padding(
                  padding: EdgeInsets.symmetric(
                      horizontal: adaptivePadding, vertical: 16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Text(
                        _statusText,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 15,
                          height: 1.4,
                        ),
                      ),
                      const SizedBox(height: 12),
                      AnimatedOpacity(
                        opacity: (_isScanning || _isConnecting) ? 1.0 : 0.0,
                        duration: const Duration(milliseconds: 300),
                        child: SizedBox(
                          height: 4,
                          child: (_isScanning || _isConnecting)
                              ? LinearProgressIndicator(
                                  backgroundColor:
                                      theme.primaryPurple.withAlpha(51),
                                  valueColor: AlwaysStoppedAnimation<Color>(
                                      theme.primaryPurple),
                                )
                              : Container(),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 10),
                Expanded(
                  child: RefreshIndicator(
                    onRefresh: _startScanning,
                    color: theme.primaryPurple,
                    backgroundColor: theme.cardBackground,
                    child: _discoveredDevices.isEmpty &&
                            !_isScanning &&
                            !_isConnecting &&
                            !isConnected
                        ? LayoutBuilder(
                            builder: (context, constraints) =>
                                SingleChildScrollView(
                              physics: const AlwaysScrollableScrollPhysics(),
                              child: ConstrainedBox(
                                constraints: BoxConstraints(
                                    minHeight: constraints.maxHeight),
                                child: Center(
                                  child: Padding(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 30.0),
                                    child: Text(
                                      'No devices found. Ensure Ledger is powered on, unlocked, and Bluetooth/USB is enabled.\nPull down or use refresh icon to scan again.',
                                      textAlign: TextAlign.center,
                                      style: TextStyle(
                                          color: theme.textSecondary,
                                          fontSize: 16,
                                          height: 1.5),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          )
                        : ListView.builder(
                            physics: const AlwaysScrollableScrollPhysics(),
                            padding: EdgeInsets.symmetric(
                                horizontal: adaptivePadding - 4),
                            itemCount: _discoveredDevices.length,
                            itemBuilder: (context, index) {
                              final device =
                                  _discoveredDevices.elementAt(index);
                              final bool isCurrentlyConnected = isConnected &&
                                  _ledgerConnection!.device.id == device.id;
                              final bool isCurrentlyConnecting =
                                  _isConnecting &&
                                      _connectingDevice?.id == device.id;
                              return Padding(
                                padding: const EdgeInsets.symmetric(
                                    vertical: 6, horizontal: 4),
                                child: LedgerCard(
                                  key: ValueKey(device.id),
                                  device: device,
                                  isConnected: isCurrentlyConnected,
                                  isConnecting: isCurrentlyConnecting,
                                  onTap: () => _connectToDevice(device),
                                ),
                              );
                            },
                          ),
                  ),
                ),
                if (isConnected)
                  Padding(
                    padding: EdgeInsets.all(adaptivePadding),
                    child: ElevatedButton.icon(
                      icon: SvgPicture.asset(
                        'assets/icons/disconnect.svg',
                        width: 20,
                        height: 20,
                        colorFilter:
                            ColorFilter.mode(theme.buttonText, BlendMode.srcIn),
                      ),
                      label: Text(
                          'Disconnect from ${_ledgerConnection?.device.name ?? 'Unknown'}',
                          style: TextStyle(color: theme.buttonText)),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: theme.danger,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 24, vertical: 12),
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(30.0)),
                        elevation: 3.0,
                      ),
                      onPressed: _disconnectDevice,
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/locale.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import '../components/custom_app_bar.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class Language {
  final String code;
  final String name;
  final String localName;

  Language(this.code, this.name, this.localName);
}

class LanguagePage extends StatefulWidget {
  const LanguagePage({super.key});

  @override
  State<LanguagePage> createState() => _LanguagePageState();
}

class _LanguagePageState extends State<LanguagePage> {
  final List<Language> languages = [];

  String selectedLanguage = 'system';
  bool vibrateEnabled = true;

  @override
  void initState() {
    super.initState();
    final _appState = Provider.of<AppState>(context, listen: false);

    if (_appState.state.locale != null) {
      setState(() {
        selectedLanguage = _appState.state.locale!;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    languages.clear();
    languages.addAll([
      Language('system', 'System', ""),
      Language('ru', 'Russian', "Русский"),
      Language('en', 'English', "English"),
      Language('ja', 'Japanese', "日本語"),
      Language('zh', 'Chinese', "中文"),
    ]);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: CustomAppBar(
                    title: l10n.languagePageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ListView.builder(
                    physics: const BouncingScrollPhysics(),
                    itemCount: languages.length,
                    itemBuilder: (context, index) {
                      final language = languages[index];
                      final isSelected = language.code == selectedLanguage;
                      final isLastItem = index == languages.length - 1;

                      return _buildLanguageItem(
                        theme,
                        language,
                        isSelected,
                        isLastItem,
                        onTap: () async {
                          await setDefaultLocale(locale: language.code);
                          setState(() {
                            selectedLanguage = language.code;
                          });

                          await appState.syncData();
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLanguageItem(
    AppTheme theme,
    Language language,
    bool isSelected,
    bool isLastItem, {
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: !isLastItem
              ? Border(
                  bottom: BorderSide(
                    color: theme.textSecondary.withValues(alpha: 0.1),
                    width: 1,
                  ),
                )
              : null,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              language.name,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    language.localName,
                    style: TextStyle(
                      color: theme.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ),
                SizedBox(
                  width: 24,
                  height: 24,
                  child: isSelected
                      ? SvgPicture.asset(
                          'assets/icons/ok.svg',
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        )
                      : null,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/pages/login_page.dart`:

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/svg.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/l10n/app_localizations.dart';

import '../components/load_button.dart';
import '../components/smart_input.dart';
import '../components/wallet_option.dart';
import '../mixins/adaptive_size.dart';
import '../mixins/wallet_type.dart';
import '../services/auth_guard.dart';
import '../services/biometric_service.dart';
import '../services/device.dart';
import '../state/app_state.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();
  final AuthService _authService = AuthService();

  late final AuthGuard _authGuard;
  late final AppState _appState;

  bool _obscurePassword = true;
  bool _obscureButton = true;
  int _selectedWallet = -1;

  @override
  void initState() {
    super.initState();
    _initializeServices();
  }

  void _initializeServices() {
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (_appState.wallets.isEmpty) {
      setState(() => _selectedWallet = -1);
      Navigator.of(context).pushNamed('/initial');
    }
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _btnController.dispose();
    super.dispose();
  }

  void _navigateToHome() {
    _appState.setSelectedWallet(_selectedWallet);
    Navigator.of(context).pushNamed('/');
  }

  void _navigateToNewWallet() {
    Navigator.pushNamed(context, '/new_wallet_options');
  }

  Future<bool> _authenticateWithSession(
    String session,
    int walletIndex,
    List<String> identifiers,
  ) async {
    try {
      bool unlocked = await tryUnlockWithSession(
        sessionCipher: session,
        walletIndex: BigInt.from(walletIndex),
        identifiers: identifiers,
      );

      if (unlocked) {
        await _appState.syncData();
        _authGuard.setEnabled(true);
        return true;
      }
    } catch (e) {
      debugPrint('Session authentication error: $e');
    }
    return false;
  }

  Future<bool> _authenticateWithPassword(
    String password,
    int walletIndex,
    List<String> identifiers,
  ) async {
    try {
      bool unlocked = await tryUnlockWithPassword(
        password: password,
        walletIndex: BigInt.from(walletIndex),
        identifiers: identifiers,
      );

      if (unlocked) {
        await _appState.syncData();
        _authGuard.setEnabled(true);
        return true;
      }
    } catch (e) {
      debugPrint('Password authentication error: $e');
    }
    return false;
  }

  Future<bool> _authenticateWithBiometrics() async {
    try {
      return await _authService.authenticate(
        allowPinCode: true,
        reason: AppLocalizations.of(context)!.loginPageBiometricReason,
      );
    } catch (e) {
      debugPrint('Biometric authentication error: $e');
      return false;
    }
  }

  Future<void> _handleAuthentication() async {
    if (_selectedWallet == -1 || _appState.wallets.isEmpty) return;

    final wallet = _appState.wallets[_selectedWallet];
    final device = DeviceInfoService();
    final identifiers = await device.getDeviceIdentifiers();

    _btnController.start();

    try {
      bool isAuthenticated = false;

      if (wallet.walletType.contains(WalletType.ledger.name)) {
        final session =
            await _authGuard.getSession(sessionKey: wallet.walletAddress);
        isAuthenticated = await _authenticateWithSession(
          session ?? "",
          _selectedWallet,
          identifiers,
        );
      } else if (wallet.authType != AuthMethod.none.name &&
          _passwordController.text.isEmpty) {
        final biometricAuth = await _authenticateWithBiometrics();
        if (biometricAuth) {
          final session =
              await _authGuard.getSession(sessionKey: wallet.walletAddress);
          isAuthenticated = await _authenticateWithSession(
            session ?? "",
            _selectedWallet,
            identifiers,
          );
        }
      } else if (_passwordController.text.isNotEmpty) {
        isAuthenticated = await _authenticateWithPassword(
          _passwordController.text,
          _selectedWallet,
          identifiers,
        );
      } else {
        if (mounted) {
          _btnController.reset();
        }
        return;
      }

      if (isAuthenticated) {
        if (mounted) {
          _btnController.reset();
        }
        _navigateToHome();
      } else {
        if (mounted) {
          _handleAuthenticationError();
        }
      }

      await _appState.startTrackHistoryWorker();
    } catch (e) {
      debugPrint("unlock $e");
      if (mounted) {
        _handleAuthenticationError();
      }
    }
  }

  void _handleAuthenticationError() {
    if (mounted) {
      _btnController.error();
      if (_passwordController.text.isNotEmpty) {
        _passwordInputKey.currentState?.shake();
      }
      Timer(const Duration(seconds: 1), () {
        if (mounted) {
          _btnController.reset();
        }
      });
    }
  }

  Widget _buildBackground(Size screenSize) {
    return Positioned(
      child: SizedBox(
        height: screenSize.height * 0.6,
        child: Transform.scale(
          scale: 1.4,
          child: SvgPicture.asset(
            'assets/imgs/zilpay.svg',
            fit: BoxFit.cover,
            width: screenSize.width,
            height: screenSize.height * 0.6,
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(AppState theme) {
    return Padding(
      padding: EdgeInsets.all(AdaptiveSize.getAdaptivePadding(context, 16)),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Spacer(),
          IconButton(
            onPressed: _navigateToNewWallet,
            icon: SvgPicture.asset(
              'assets/icons/plus.svg',
              width: 32,
              height: 32,
              colorFilter: ColorFilter.mode(
                theme.currentTheme.textPrimary,
                BlendMode.srcIn,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildWalletList(AppState theme) {
    return Expanded(
      child: ListView.builder(
        physics: const BouncingScrollPhysics(),
        padding: EdgeInsets.symmetric(
          horizontal: AdaptiveSize.getAdaptivePadding(context, 16),
        ),
        itemCount: _appState.wallets.length,
        itemBuilder: (context, index) => _buildWalletItem(index, theme),
      ),
    );
  }

  Widget _buildWalletItem(int index, AppState theme) {
    if (index >= _appState.wallets.length) return const SizedBox.shrink();

    final wallet = _appState.wallets[index];
    final l10n = AppLocalizations.of(context)!;

    if (!_obscureButton && _selectedWallet != index) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: EdgeInsets.only(top: index > 0 ? 4 : 0),
      child: WalletOption(
        title: wallet.walletName.isEmpty
            ? l10n.loginPageWalletTitle(index + 1)
            : wallet.walletName,
        walletIndex: index,
        address: wallet.walletAddress,
        isSelected: _selectedWallet == index,
        padding: const EdgeInsets.all(16),
        onTap: () {
          setState(() => _selectedWallet = index);
          _handleAuthentication();
        },
        icons: _getWalletIcons(wallet),
      ),
    );
  }

  List<String> _getWalletIcons(WalletInfo wallet) {
    return [
      if (wallet.walletType.contains(WalletType.ledger.name))
        'assets/icons/ledger.svg',
      if (wallet.walletType.contains(WalletType.SecretPhrase.name))
        'assets/icons/document.svg',
      if (wallet.walletType.contains(WalletType.SecretKey.name))
        'assets/icons/bincode.svg',
      if (wallet.authType == AuthMethod.faceId.name) 'assets/icons/face_id.svg',
      if (wallet.authType == AuthMethod.fingerprint.name)
        'assets/icons/fingerprint.svg',
      if (wallet.authType == AuthMethod.biometric.name)
        'assets/icons/biometric.svg',
      if (wallet.authType == AuthMethod.pinCode.name) 'assets/icons/pin.svg',
    ];
  }

  Widget _buildLoginForm(AppState theme) {
    final isLedgerWallet = _selectedWallet != -1 &&
        _appState.wallets.isNotEmpty &&
        _appState.wallets[_selectedWallet].walletType
            .contains(WalletType.ledger.name);
    final l10n = AppLocalizations.of(context)!;

    return Padding(
      padding: EdgeInsets.all(AdaptiveSize.getAdaptivePadding(context, 16)),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SmartInput(
            key: _passwordInputKey,
            controller: _passwordController,
            hint: l10n.loginPagePasswordHint,
            fontSize: 18,
            height: 50,
            disabled: _selectedWallet == -1 || isLedgerWallet,
            padding: const EdgeInsets.symmetric(horizontal: 20),
            focusedBorderColor: theme.currentTheme.primaryPurple,
            obscureText: _obscurePassword,
            onFocusChanged: (isFocused) =>
                setState(() => _obscureButton = !isFocused),
            rightIconPath: _obscurePassword
                ? "assets/icons/close_eye.svg"
                : "assets/icons/open_eye.svg",
            onRightIconTap: () =>
                setState(() => _obscurePassword = !_obscurePassword),
          ),
          const SizedBox(height: 8),
          if (_obscureButton) _buildUnlockButton(theme),
        ],
      ),
    );
  }

  Widget _buildUnlockButton(AppState appState) {
    final theme = appState.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return SizedBox(
      width: double.infinity,
      child: RoundedLoadingButton(
        color: theme.primaryPurple,
        valueColor: theme.buttonText,
        controller: _btnController,
        onPressed: _handleAuthentication,
        child: Text(
          l10n.loginPageUnlockButton,
          style: TextStyle(
            color: theme.buttonText,
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final screenSize = MediaQuery.of(context).size;
    final l10n = AppLocalizations.of(context)!;

    if (appState.wallets.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    return Scaffold(
      backgroundColor: appState.currentTheme.background,
      body: Stack(
        children: [
          _buildBackground(screenSize),
          SafeArea(
            child: Center(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 480),
                child: Column(
                  children: [
                    _buildHeader(appState),
                    Text(
                      l10n.loginPageWelcomeBack,
                      style: TextStyle(
                        color: appState.currentTheme.textPrimary,
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 16),
                    _buildWalletList(appState),
                    _buildLoginForm(appState),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

`lib/pages/main_page.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../components/bottom_nav_bar.dart';
import './home_page.dart';
import './history_page.dart';
import './browser_page.dart';

class MainPage extends StatefulWidget {
  const MainPage({super.key});

  @override
  State<MainPage> createState() => MainPageState();
}

class MainPageState extends State<MainPage> {
  int _selectedIndex = 0;

  static final List<Widget> _pages = <Widget>[
    const HomePage(),
    const HistoryPage(),
    // const ChatPage(),
    const BrowserPage()
  ];

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final selectedIndex = args?['selectedIndex'] as int?;

    if (selectedIndex != null) {
      _selectedIndex = selectedIndex;
    }
  }

  void _onItemTapped(int index) {
    if (index == _selectedIndex) {
      return;
    }

    Navigator.push(
      context,
      PageRouteBuilder<MainPage>(
        settings: RouteSettings(
          name: '/',
          arguments: {'selectedIndex': index},
        ),
        pageBuilder: (_, __, ___) => const MainPage(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final Color effectiveBgColor = Theme.of(context).scaffoldBackgroundColor;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      extendBody: true,
      body: SafeArea(
          top: true, bottom: false, child: _pages.elementAt(_selectedIndex)),
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        toolbarHeight: 0,
        systemOverlayStyle: overlayStyle,
      ),
      bottomNavigationBar: SafeArea(
        child: CustomBottomNavigationBar(
          items: [
            CustomBottomNavigationBarItem(iconPath: 'assets/icons/wallet.svg'),
            CustomBottomNavigationBarItem(iconPath: 'assets/icons/history.svg'),
            CustomBottomNavigationBarItem(iconPath: 'assets/icons/nav.svg'),
          ],
          currentIndex: _selectedIndex,
          onTap: _onItemTapped,
        ),
      ),
    );
  }
}

```

`lib/pages/manage_tokens.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/enable_card.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'dart:convert';
import 'dart:async';

extension FTokenInfoJsonExtension on FTokenInfo {
  static FTokenInfo fromJson(Map<String, dynamic> json) {
    return FTokenInfo(
      name: json['name'] as String,
      symbol: json['symbol'] as String,
      decimals: json['decimals'] as int,
      addr: json['addr'] as String,
      addrType: json['addrType'] as int,
      logo: json['logo'] as String?,
      balances: const {},
      rate: json['rate'] as double,
      default_: json['default_'] as bool,
      native: json['native'] as bool,
      chainHash: BigInt.parse(json['chainHash'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'symbol': symbol,
      'decimals': decimals,
      'addr': addr,
      'addrType': addrType,
      'logo': logo,
      'balances': {},
      'rate': rate,
      'default_': default_,
      'native': native,
      'chainHash': chainHash.toString(),
    };
  }
}

class ManageTokensPage extends StatefulWidget {
  const ManageTokensPage({super.key});

  @override
  State<ManageTokensPage> createState() => _ManageTokensPageState();
}

class _ManageTokensPageState extends State<ManageTokensPage> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  List<FTokenInfo> _allTokens = [];
  String _searchQuery = '';
  bool _isLoading = false;
  Timer? _debounce;
  BigInt? _currentChainHash;
  int? _currentAddrType;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final appState = Provider.of<AppState>(context, listen: false);
      if (mounted) {
        setState(() {
          _currentChainHash = appState.chain?.chainHash;
          _currentAddrType = appState.account?.addrType;
        });
        _refreshTokens();
      }
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final appState = Provider.of<AppState>(context);
    if ((appState.chain?.chainHash != _currentChainHash ||
            appState.account?.addrType != _currentAddrType) &&
        mounted) {
      setState(() {
        _currentChainHash = appState.chain?.chainHash;
        _currentAddrType = appState.account?.addrType;
        _allTokens = [];
        _searchController.clear();
        _searchQuery = '';
        _isLoading = false;
        _debounce?.cancel();
      });
      _refreshTokens();
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    _debounce?.cancel();
    super.dispose();
  }

  bool _canFetchApiTokens(AppState appState) {
    final chain = appState.chain;
    return chain != null &&
        chain.testnet != true &&
        appState.wallet?.settings.tokensListFetcher == true;
  }

  String _getCacheKey(NetworkConfigInfo chain, AccountInfo account) {
    return '${chain.shortName}_${account.addrType}_tokens_cache';
  }

  Future<void> _refreshTokens({bool force = false}) async {
    if (_isLoading) return;
    if (!mounted) return;

    setState(() => _isLoading = true);

    try {
      final appState = Provider.of<AppState>(context, listen: false);
      final chain = appState.chain;
      final account = appState.account;
      if (chain == null || account == null) {
        if (mounted) setState(() => _isLoading = false);
        return;
      }

      final walletTokens = appState.wallet?.tokens
              .where((t) =>
                  t.chainHash == chain.chainHash &&
                  t.addrType == account.addrType)
              .toList() ??
          [];
      List<FTokenInfo> remoteTokens = [];
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = _getCacheKey(chain, account);

      if (!force) {
        final cachedData = prefs.getString(cacheKey);
        if (cachedData != null) {
          final List<dynamic> decoded = jsonDecode(cachedData);
          remoteTokens = decoded
              .map((item) => FTokenInfoJsonExtension.fromJson(item))
              .toList();
        }
      }

      if ((remoteTokens.isEmpty || force) && _canFetchApiTokens(appState)) {
        List<FTokenInfo> apiTokens = [];
        String logo =
            "https://raw.githubusercontent.com/zilpay/tokens_meta/refs/heads/master/ft/${chain.shortName}/%{contract_address}%/%{dark,light}%.webp";

        if (chain.slip44 == 313 && appState.account?.addrType == 0) {
          apiTokens = await fetchTokensListZilliqaLegacy(limit: 200, offset: 0);
        } else if (chain.slip44 == 60 && appState.account?.addrType == 1) {
          apiTokens = await fetchTokensEvmList(
            chainName: chain.shortName,
            chainId: chain.chainId.toInt(),
          );
        }

        remoteTokens = apiTokens.map((token) {
          return FTokenInfo(
            name: token.name,
            symbol: token.symbol,
            decimals: token.decimals,
            addr: token.addr,
            addrType: token.addrType,
            logo: logo,
            balances: token.balances,
            rate: 0,
            default_: false,
            native: false,
            chainHash: chain.chainHash,
          );
        }).toList();

        await prefs.setString(cacheKey,
            jsonEncode(remoteTokens.map((token) => token.toJson()).toList()));
      }

      _mergeAndSetTokens(walletTokens, remoteTokens);
    } catch (e) {
      debugPrint("Refresh tokens error: $e");
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  void _mergeAndSetTokens(
      List<FTokenInfo> walletTokens, List<FTokenInfo> remoteTokens) {
    final uniqueTokens = <String, FTokenInfo>{};

    for (var token in remoteTokens) {
      uniqueTokens[token.addr.toLowerCase()] = token;
    }
    for (var token in walletTokens) {
      uniqueTokens[token.addr.toLowerCase()] = token;
    }

    if (mounted) {
      setState(() {
        _allTokens = uniqueTokens.values.toList();
      });
    }
  }

  void _onSearchChanged(String query) {
    if (!mounted) return;

    setState(() {
      _searchQuery = query;
    });

    if (_debounce?.isActive ?? false) _debounce!.cancel();
    _debounce = Timer(const Duration(milliseconds: 500), () {
      if (query.length > 30 && mounted) {
        _fetchTokenByAddress(query);
      }
    });
  }

  Future<void> _fetchTokenByAddress(String address) async {
    if (!mounted) return;
    if (_allTokens
        .any((token) => token.addr.toLowerCase() == address.toLowerCase())) {
      return;
    }

    setState(() => _isLoading = true);
    try {
      final appState = Provider.of<AppState>(context, listen: false);
      final meta = await fetchTokenMeta(
        addr: address,
        walletIndex: BigInt.from(appState.selectedWallet),
      );
      final exists = _allTokens
          .any((t) => t.addr.toLowerCase() == meta.addr.toLowerCase());
      if (!exists && mounted) {
        setState(() {
          _allTokens.add(meta);
        });
      }
    } catch (e) {
      debugPrint("Fetch token meta error: $e");
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  Future<void> _onToggleToken(FTokenInfo token, bool isEnabled) async {
    if (!mounted) return;
    final appState = Provider.of<AppState>(context, listen: false);

    try {
      if (isEnabled) {
        await addFtoken(
          meta: token,
          walletIndex: BigInt.from(appState.selectedWallet),
        );
      } else {
        await rmFtoken(
          walletIndex: BigInt.from(appState.selectedWallet),
          tokenAddress: token.addr,
        );
      }
      await appState.syncData();
    } catch (e) {
      debugPrint("Toggle token error: $e");
      await appState.syncData();
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    final filteredTokens = _allTokens.where((token) {
      final query = _searchQuery.toLowerCase();
      return token.name.toLowerCase().contains(query) ||
          token.symbol.toLowerCase().contains(query) ||
          token.addr.toLowerCase().contains(query);
    }).toList();

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: "Tokens",
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.symmetric(
                      horizontal: adaptivePadding, vertical: 16),
                  child: SmartInput(
                    controller: _searchController,
                    hint: "Search tokens or paste address",
                    leftIconPath: 'assets/icons/search.svg',
                    rightIconPath: 'assets/icons/close.svg',
                    onChanged: _onSearchChanged,
                    onRightIconTap: () {
                      _searchController.clear();
                      _onSearchChanged('');
                    },
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    autofocus: false,
                  ),
                ),
                Container(
                  width: 36,
                  height: 4,
                  margin: const EdgeInsets.symmetric(vertical: 8),
                  decoration: BoxDecoration(
                    color: theme.modalBorder,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                Expanded(
                  child: RefreshIndicator(
                    onRefresh: () => _refreshTokens(force: true),
                    child: Stack(
                      children: [
                        if (filteredTokens.isEmpty && !_isLoading)
                          const Center(child: Text("No tokens found")),
                        CustomScrollView(
                          controller: _scrollController,
                          physics: const AlwaysScrollableScrollPhysics(),
                          slivers: [
                            SliverPadding(
                              padding: EdgeInsets.symmetric(
                                  horizontal: adaptivePadding),
                              sliver: SliverList(
                                delegate: SliverChildBuilderDelegate(
                                  (context, index) {
                                    final token = filteredTokens[index];
                                    final isEnabled = appState.wallet?.tokens
                                            .any((t) =>
                                                t.addr.toLowerCase() ==
                                                token.addr.toLowerCase()) ??
                                        false;
                                    return EnableCard(
                                      title: token.symbol,
                                      name: token.name,
                                      iconWidget: AsyncImage(
                                        url: processTokenLogo(
                                          token: token,
                                          shortName:
                                              appState.chain?.shortName ?? "",
                                          theme: theme.value,
                                        ),
                                        width: 32.0,
                                        height: 32.0,
                                        fit: BoxFit.contain,
                                        errorWidget: SvgPicture.asset(
                                          "assets/icons/warning.svg",
                                          width: 32.0,
                                          height: 32.0,
                                          colorFilter: ColorFilter.mode(
                                            theme.warning,
                                            BlendMode.srcIn,
                                          ),
                                        ),
                                        loadingWidget: const Center(
                                          child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                          ),
                                        ),
                                      ),
                                      isDefault: token.native,
                                      isEnabled: isEnabled,
                                      onToggle: (value) =>
                                          _onToggleToken(token, value),
                                    );
                                  },
                                  childCount: filteredTokens.length,
                                ),
                              ),
                            ),
                          ],
                        ),
                        if (_isLoading)
                          const Positioned(
                            top: 0,
                            left: 0,
                            right: 0,
                            child: LinearProgressIndicator(),
                          ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/network.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/network_card.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/modals/chain_config_edit.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/theme/app_theme.dart';
import '../components/custom_app_bar.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class NetworkPage extends StatefulWidget {
  const NetworkPage({super.key});

  @override
  State<NetworkPage> createState() => _NetworkPageState();
}

class _NetworkPageState extends State<NetworkPage> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  List<NetworkItem> addedNetworks = [];
  List<NetworkItem> potentialNetworks = [];
  bool isLoading = true;
  String? errorMessage;
  String? _shortName;
  bool isTestnet = false;

  @override
  void initState() {
    super.initState();
    _loadNetworks();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final AppState appState = Provider.of<AppState>(context, listen: false);
    if (appState.chain != null && (appState.chain?.testnet ?? false)) {
      setState(() {
        isTestnet = true;
      });
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  String _createNetworkIdentifier(NetworkConfigInfo network) {
    final chainId = network.chainId.toString();
    final slip44 = network.slip44.toString();
    final name = network.name.toLowerCase();
    return '$slip44|$chainId|$name';
  }

  Future<void> _loadNetworks() async {
    setState(() {
      isLoading = true;
      errorMessage = null;
    });

    try {
      final storedProviders = await getProviders();
      final String mainnetJsonData =
          await rootBundle.loadString('assets/chains/mainnet-chains.json');
      final String testnetJsonData =
          await rootBundle.loadString('assets/chains/testnet-chains.json');
      final List<NetworkConfigInfo> mainnetChains =
          await getChainsProvidersFromJson(jsonStr: mainnetJsonData);
      final List<NetworkConfigInfo> testnetChains =
          await getChainsProvidersFromJson(jsonStr: testnetJsonData);

      setState(() {
        addedNetworks.clear();
        potentialNetworks.clear();

        addedNetworks.addAll(storedProviders.map(
            (provider) => NetworkItem(configInfo: provider, isAdded: true)));

        final Set<String> addedNetworkIds = {};
        final Set<String> addedNetworkNamesLower = {};

        for (final network in addedNetworks) {
          addedNetworkIds.add(_createNetworkIdentifier(network.configInfo));
          addedNetworkNamesLower.add(network.configInfo.name.toLowerCase());
        }

        final List<NetworkItem> potentialMainnetItems = [];
        for (final chain in mainnetChains) {
          final networkId = _createNetworkIdentifier(chain);
          final nameLower = chain.name.toLowerCase();

          if (!addedNetworkIds.contains(networkId) &&
              !addedNetworkNamesLower.contains(nameLower)) {
            potentialMainnetItems
                .add(NetworkItem(configInfo: chain, isAdded: false));
          }
        }

        final List<NetworkItem> potentialTestnetItems = [];
        for (final chain in testnetChains) {
          final networkId = _createNetworkIdentifier(chain);
          final nameLower = chain.name.toLowerCase();

          if (!addedNetworkIds.contains(networkId) &&
              !addedNetworkNamesLower.contains(nameLower)) {
            potentialTestnetItems
                .add(NetworkItem(configInfo: chain, isAdded: false));
          }
        }

        potentialNetworks.clear();
        potentialNetworks
            .addAll([...potentialMainnetItems, ...potentialTestnetItems]);

        isLoading = false;
        if (_shortName != null) _trySelectNetworkByShortName();
      });
    } catch (e) {
      setState(() {
        isLoading = false;
        errorMessage =
            AppLocalizations.of(context)!.networkPageLoadError + '$e';
      });
    }
  }

  void _trySelectNetworkByShortName() {
    if (_shortName == null) return;

    int addedIndex = addedNetworks
        .indexWhere((network) => network.configInfo.name == _shortName);
    if (addedIndex >= 0) {
      _handleNetworkSelect(addedNetworks[addedIndex].configInfo);
      return;
    }

    int potentialIndex = potentialNetworks
        .indexWhere((network) => network.configInfo.name == _shortName);
    if (potentialIndex >= 0) {
      _handleNetworkSelect(potentialNetworks[potentialIndex].configInfo);
    }
  }

  List<NetworkItem> _getFilteredNetworks(List<NetworkItem> networks) {
    if (_searchQuery.isEmpty) return networks;
    return networks
        .where((network) => network.configInfo.name
            .toLowerCase()
            .contains(_searchQuery.toLowerCase()))
        .toList();
  }

  void _handleNetworkSelect(NetworkConfigInfo network) async {
    final appState = Provider.of<AppState>(context, listen: false);

    try {
      await selectAccountsChain(
        walletIndex: BigInt.from(appState.selectedWallet),
        chainHash: network.chainHash,
      );
    } catch (_) {}

    await appState.syncData();
  }

  Future<void> _handleAddNetwork(
      NetworkConfigInfo config, AppState state) async {
    try {
      await addProvider(providerConfig: config);
      await state.syncData();
      await _loadNetworks();
    } catch (e) {
      setState(() {
        errorMessage = AppLocalizations.of(context)!.networkPageAddError + '$e';
      });
    }
  }

  void _handleEditNetwork(NetworkConfigInfo config) {
    showChainInfoModal(
      context: context,
      networkConfig: config,
      onRemoved: () async {
        Navigator.of(context).pop();
        await _loadNetworks();
      },
    );
  }

  Widget _buildNetworkSection(
      String title,
      List<NetworkItem> networks,
      AppTheme theme,
      NetworkConfigInfo? chain,
      WalletInfo? wallet,
      bool isAvailableSection) {
    if (networks.isEmpty) return const SizedBox.shrink();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title,
            style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w500,
                color: theme.textSecondary.withValues(alpha: 0.7))),
        const SizedBox(height: 16),
        ...networks.map((network) => NetworkCard(
              configInfo: network.configInfo,
              isAdded: network.isAdded,
              isDefault:
                  wallet?.defaultChainHash == network.configInfo.chainHash,
              isSelected: chain?.chainId == network.configInfo.chainId &&
                  chain?.slip44 == network.configInfo.slip44,
              // disabled: chain?.slip44 != network.configInfo.slip44,
              isTestnet: network.configInfo.testnet ?? false,
              iconUrl:
                  viewChain(network: network.configInfo, theme: theme.value),
              onNetworkSelect: _handleNetworkSelect,
              onNetworkEdit: _handleEditNetwork,
              onNetworkAdd: (config) => _handleAddNetwork(
                  config, Provider.of<AppState>(context, listen: false)),
            )),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final chain = appState.chain;
    final wallet = appState.wallet;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final filteredAddedNetworks = _getFilteredNetworks(addedNetworks);
    final filteredPotentialNetworks = _getFilteredNetworks(potentialNetworks)
        .where((network) => isTestnet || !(network.configInfo.testnet ?? false))
        .toList();
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(
                    horizontal: adaptivePadding,
                  ),
                  child: CustomAppBar(
                    title: l10n.networkPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                    actionWidget: Row(
                      children: [
                        Text(l10n.networkPageShowTestnet,
                            style: TextStyle(
                                color: theme.textSecondary, fontSize: 14)),
                        const SizedBox(width: 8),
                        Switch(
                            value: isTestnet,
                            onChanged: (value) => setState(() {
                                  isTestnet = value;
                                  _loadNetworks();
                                }),
                            activeThumbColor: theme.primaryPurple),
                      ],
                    ),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: SmartInput(
                    controller: _searchController,
                    hint: l10n.networkPageSearchHint,
                    leftIconPath: 'assets/icons/search.svg',
                    onChanged: (value) => setState(() => _searchQuery = value),
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                  ),
                ),
                if (errorMessage != null)
                  Padding(
                      padding: const EdgeInsets.all(16),
                      child: Text(errorMessage!,
                          style: TextStyle(color: theme.danger, fontSize: 14))),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    padding: EdgeInsets.symmetric(
                        horizontal: adaptivePadding, vertical: 24),
                    child: Align(
                      alignment: Alignment.topLeft,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _buildNetworkSection(
                              l10n.networkPageAddedNetworks,
                              filteredAddedNetworks,
                              theme,
                              chain,
                              wallet,
                              false),
                          if (filteredAddedNetworks.isNotEmpty &&
                              filteredPotentialNetworks.isNotEmpty)
                            const SizedBox(height: 24),
                          _buildNetworkSection(
                              l10n.networkPageAvailableNetworks,
                              filteredPotentialNetworks,
                              theme,
                              chain,
                              wallet,
                              true),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class NetworkItem {
  final NetworkConfigInfo configInfo;
  final bool isAdded;

  NetworkItem({required this.configInfo, required this.isAdded});
}

```

`lib/pages/new_wallet_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class AddWalletOptionsPage extends StatelessWidget {
  const AddWalletOptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    final Color effectiveBgColor = Theme.of(context).scaffoldBackgroundColor;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: SvgPicture.asset(
            'assets/icons/back.svg',
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(
              theme.secondaryPurple,
              BlendMode.srcIn,
            ),
          ),
          onPressed: () => Navigator.of(context).pop(),
        ),
        systemOverlayStyle: overlayStyle,
        title: Text(AppLocalizations.of(context)!.addWalletOptionsTitle,
            style: TextStyle(color: theme.textPrimary)),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              WalletListItem(
                title: AppLocalizations.of(context)!
                    .addWalletOptionsNewWalletTitle,
                subtitle: AppLocalizations.of(context)!
                    .addWalletOptionsNewWalletSubtitle,
                icon: SvgPicture.asset(
                  'assets/icons/add.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/gen_options');
                },
              ),
              WalletListItem(
                title: AppLocalizations.of(context)!
                    .addWalletOptionsExistingWalletTitle,
                subtitle: AppLocalizations.of(context)!
                    .addWalletOptionsExistingWalletSubtitle,
                icon: SvgPicture.asset(
                  'assets/icons/import.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/restore_options');
                },
              ),
              WalletListItem(
                title: AppLocalizations.of(context)!
                    .addWalletOptionsPairWithLedgerTitle,
                subtitle: AppLocalizations.of(context)!
                    .addWalletOptionsPairWithLedgerSubtitle,
                icon: SvgPicture.asset(
                  'assets/icons/ledger.svg',
                  width: 25,
                  height: 25,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {
                  Navigator.of(context).pushNamed('/ledger_connect');
                },
              ),
              const SizedBox(height: 24),
              Padding(
                padding: const EdgeInsets.only(left: 16.0),
                child: Text(
                  AppLocalizations.of(context)!.addWalletOptionsOtherOptions,
                  style: theme.caption.copyWith(
                    color: theme.textSecondary,
                  ),
                ),
              ),
              const SizedBox(height: 16),
              WalletListItem(
                disabled: true,
                title: AppLocalizations.of(context)!
                    .addWalletOptionsWatchAccountTitle,
                subtitle: AppLocalizations.of(context)!
                    .addWalletOptionsWatchAccountSubtitle,
                icon: SvgPicture.asset(
                  'assets/icons/looking.svg',
                  width: 35,
                  height: 35,
                  colorFilter: ColorFilter.mode(
                    theme.primaryPurple,
                    BlendMode.srcIn,
                  ),
                ),
                onTap: () {},
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/notification.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:blockies/blockies.dart';
import 'package:zilpay/components/switch_setting_item.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/models/notification.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import '../components/custom_app_bar.dart';
import '../state/app_state.dart';

class NotificationsSettingsPage extends StatefulWidget {
  const NotificationsSettingsPage({super.key});

  @override
  State<NotificationsSettingsPage> createState() =>
      _NotificationsSettingsPageState();
}

class _NotificationsSettingsPageState extends State<NotificationsSettingsPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _initializeServices();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _initializeServices() {}

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final theme = state.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: AppLocalizations.of(context)!
                        .notificationsSettingsPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          SwitchSettingItem(
                            iconPath: "assets/icons/manage.svg",
                            title: AppLocalizations.of(context)!
                                .notificationsSettingsPagePushTitle,
                            backgroundColor: theme.cardBackground,
                            description: AppLocalizations.of(context)!
                                .notificationsSettingsPagePushDescription,
                            value: state.state.notificationsGlobalEnabled,
                            onChanged: (value) async {
                              await setGlobalNotifications(
                                  globalEnabled: value);
                              await state.syncData();
                            },
                          ),
                          SizedBox(height: adaptivePadding),
                          _buildWalletsSection(theme, adaptivePadding),
                          SizedBox(height: adaptivePadding),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildWalletsSection(AppTheme theme, double adaptivePadding) {
    return Consumer<AppState>(
      builder: (context, appState, _) {
        final isGlobalEnabled = appState.state.notificationsGlobalEnabled;

        return Opacity(
          opacity: isGlobalEnabled ? 1.0 : 0.5,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                AppLocalizations.of(context)!
                    .notificationsSettingsPageWalletsTitle,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                AppLocalizations.of(context)!
                    .notificationsSettingsPageWalletsDescription,
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: 16,
                ),
              ),
              SizedBox(height: adaptivePadding),
              Container(
                decoration: BoxDecoration(
                  color: theme.cardBackground,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: AbsorbPointer(
                  absorbing: !isGlobalEnabled,
                  child: ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: appState.wallets.length,
                    itemBuilder: (context, index) => _buildWalletItem(
                      appState,
                      appState.wallets[index],
                      index,
                      isLastItem: index == appState.wallets.length - 1,
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildWalletItem(
    AppState state,
    WalletInfo wallet,
    int index, {
    bool isLastItem = false,
  }) {
    final theme = state.currentTheme;
    final BackgroundNotificationState? walletNotify =
        state.state.notificationsWalletStates[BigInt.from(index)];
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Container(
      padding: EdgeInsets.symmetric(horizontal: adaptivePadding, vertical: 12),
      decoration: BoxDecoration(
        border: !isLastItem
            ? Border(
                bottom: BorderSide(
                  color: theme.textSecondary.withValues(alpha: 0.1),
                  width: 1,
                ),
              )
            : null,
      ),
      child: Row(
        children: [
          SizedBox(
            width: 40,
            height: 40,
            child: Padding(
              padding: const EdgeInsets.all(4),
              child: Blockies(
                seed: wallet.walletAddress,
                color: theme.secondaryPurple,
                bgColor: theme.primaryPurple,
                spotColor: theme.background,
                size: 8,
              ),
            ),
          ),
          SizedBox(width: 12),
          Expanded(
            child: Text(
              wallet.walletName.isEmpty
                  ? "${AppLocalizations.of(context)!.notificationsSettingsPageWalletPrefix} ${index + 1}"
                  : wallet.walletName,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Switch(
            value: walletNotify != null ? walletNotify.transactions : false,
            onChanged: (value) async {
              await setWalletNotifications(
                walletIndex: BigInt.from(index),
                transactions: value,
                price: false,
                security: false,
                balance: false,
              );
              await state.syncData();
            },
            activeThumbColor: theme.primaryPurple,
            activeTrackColor: theme.primaryPurple.withValues(alpha: 0.5),
          ),
        ],
      ),
    );
  }
}

```

`lib/pages/password_setup.dart`:

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/components/biometric_switch.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart' show AppState;
import 'package:zilpay/l10n/app_localizations.dart';

class PasswordSetupPage extends StatefulWidget {
  const PasswordSetupPage({super.key});

  @override
  State<PasswordSetupPage> createState() => _PasswordSetupPageState();
}

class _PasswordSetupPageState extends State<PasswordSetupPage> {
  List<String>? _bip39List;
  NetworkConfigInfo? _chain;
  WalletArgonParamsInfo? _argon2;
  Uint8List? _cipher;
  KeyPairInfo? _keys;

  final AuthService _authService = AuthService();
  late AuthGuard _authGuard;
  late AppState _appState;

  List<AuthMethod> _authMethods = [AuthMethod.none];
  bool _useDeviceAuth = true;
  bool _zilLegacy = false;
  bool _bypassChecksumValidation = false;

  String _errorMessage = '';
  bool _disabled = false;
  bool _walletNameInitialized = false;
  bool _updatedArgs = false;

  final _btnController = RoundedLoadingButtonController();

  final _walletNameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _confirmPasswordInputKey = GlobalKey<SmartInputState>();

  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (_updatedArgs) return;

    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final bip39 = args?['bip39'] as List<String>?;
    final chain = args?['chain'] as NetworkConfigInfo?;
    final keys = args?['keys'] as KeyPairInfo?;
    final cipher = args?['cipher'] as Uint8List?;
    final argon2 = args?['argon2'] as WalletArgonParamsInfo?;
    final bypassChecksumValidation = args?['ignore_checksum'] as bool?;

    if (bip39 == null && chain == null && cipher == null && keys == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = bip39;
        _chain = chain;
        _keys = keys;
        _cipher = cipher;
        _argon2 = argon2;
        _bypassChecksumValidation = bypassChecksumValidation ?? false;

        if (_chain?.slip44 == 313) {
          _zilLegacy = true;
        }

        _updatedArgs = true;
      });
    }

    if (!_walletNameInitialized) {
      _walletNameController.text = _generateWalletName();
      _walletNameInitialized = true;
    }
  }

  @override
  void initState() {
    super.initState();

    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    _appState = Provider.of<AppState>(context, listen: false);
    _walletNameController.text = '';

    _checkAuthMethods();
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    _walletNameController.dispose();
    _btnController.dispose();
    super.dispose();
  }

  String _generateWalletName() {
    String type;
    if (_bip39List != null) {
      type = AppLocalizations.of(context)!.passwordSetupPageSeedType;
    } else if (_keys != null) {
      type = AppLocalizations.of(context)!.passwordSetupPageKeyType;
    } else {
      type = "";
    }

    String networkName = _chain?.name ??
        AppLocalizations.of(context)!.passwordSetupPageUniversalNetwork;
    int walletNumber = _appState.wallets.length + 1;
    return "$networkName #$walletNumber ($type)";
  }

  bool _validatePasswords() {
    if (_walletNameController.text.trim().isEmpty) {
      setState(() {
        _errorMessage =
            AppLocalizations.of(context)!.passwordSetupPageEmptyWalletNameError;
        _disabled = false;
      });
      return false;
    }

    if (_walletNameController.text.length > 32) {
      setState(() {
        _errorMessage =
            AppLocalizations.of(context)!.passwordSetupPageLongWalletNameError;
        _disabled = false;
      });
      return false;
    }

    if (_passwordController.text.length < 6) {
      _passwordInputKey.currentState?.shake();
      setState(() {
        _errorMessage =
            AppLocalizations.of(context)!.passwordSetupPageShortPasswordError;
        _disabled = false;
      });
      return false;
    }

    if (_passwordController.text != _confirmPasswordController.text) {
      _confirmPasswordInputKey.currentState?.shake();
      setState(() {
        _disabled = false;
        _errorMessage = AppLocalizations.of(context)!
            .passwordSetupPageMismatchPasswordError;
      });
      return false;
    }
    return true;
  }

  void _createWallet() async {
    setState(() {
      _errorMessage = '';
      _disabled = true;
    });

    if (!_validatePasswords()) {
      _btnController.reset();
      return;
    }

    try {
      final l10n = AppLocalizations.of(context)!;
      final BigInt? chainHash;
      List<NetworkConfigInfo> chains = await getProviders();
      final matches = chains
          .where((chain) => chain.chainHash == _chain!.chainHash)
          .toList();

      if (matches.isEmpty) {
        chainHash = await addProvider(providerConfig: _chain!);
      } else {
        chainHash = matches.first.chainHash;
      }

      if (_useDeviceAuth) {
        final authenticated = await _authService.authenticate(
          allowPinCode: true,
          reason: AppLocalizations.of(context)!.passwordSetupPageAuthReason,
        );
        setState(() => _useDeviceAuth = authenticated);
        if (!authenticated) {
          setState(() {
            _disabled = true;
          });
          return;
        }
      }

      _btnController.start();

      DeviceInfoService device = DeviceInfoService();
      List<String> identifiers = await device.getDeviceIdentifiers();

      AuthMethod biometricType = AuthMethod.none;
      if (_useDeviceAuth) {
        biometricType = _authMethods[0];
      }

      (String, String) session;

      WalletSettingsInfo settings = WalletSettingsInfo(
        cipherOrders: _cipher!,
        argonParams: _argon2!,
        currencyConvert: "BTC",
        ipfsNode: "dweb.link",
        ensEnabled: true,
        tokensListFetcher: true,
        nodeRankingEnabled: true,
        maxConnections: 5,
        requestTimeoutSecs: 30,
        ratesApiOptions: 1, // CoinGecko
      );

      List<FTokenInfo> ftokens = [];

      if (_bip39List != null) {
        Bip39AddWalletParams params = Bip39AddWalletParams(
          password: _passwordController.text,
          mnemonicStr: _bip39List!.join(' '),
          accounts: [(BigInt.zero, l10n.addAccountPageDefaultName(0))],
          passphrase: "",
          walletName: _walletNameController.text,
          biometricType: biometricType.name,
          identifiers: identifiers,
          chainHash: chainHash,
          mnemonicCheck: !_bypassChecksumValidation,
        );

        session = await addBip39Wallet(
          params: params,
          walletSettings: settings,
          ftokens: ftokens,
        );
      } else if (_keys != null) {
        AddSKWalletParams params = AddSKWalletParams(
          sk: _keys!.sk,
          password: _passwordController.text,
          walletName: _walletNameController.text,
          biometricType: biometricType.name,
          identifiers: identifiers,
          chainHash: chainHash,
        );

        session = await addSkWallet(
          params: params,
          walletSettings: settings,
          ftokens: ftokens,
        );
      } else {
        throw "";
      }

      await _appState.syncData();

      _appState.setSelectedWallet(_appState.wallets.length - 1);

      if (_useDeviceAuth) {
        await _authGuard.setSession(session.$2, session.$1);
      }

      await _appState.syncData();

      if (_zilLegacy && _chain?.slip44 == 313) {
        BigInt walletIndex = BigInt.from(_appState.selectedWallet);
        await zilliqaSwapChain(
          walletIndex: walletIndex,
          accountIndex: _appState.wallet!.selectedAccount,
        );
        await _appState.syncData();
      }

      await _appState.startTrackHistoryWorker();

      _appState.setSelectedWallet(_appState.wallets.length - 1);
      _btnController.success();

      if (!mounted) return;
      Navigator.of(context).pushNamed('/');
    } catch (e) {
      setState(() {
        _disabled = false;
        _errorMessage = e.toString();
      });
      _btnController.error();
      Timer(const Duration(seconds: 1), () {
        _btnController.reset();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    const inputHeight = 50.0;

    return Scaffold(
      resizeToAvoidBottomInset: true,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
              child: Column(
                children: [
                  CustomAppBar(
                    title: AppLocalizations.of(context)!.passwordSetupPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                  Expanded(
                    child: SingleChildScrollView(
                      physics: const BouncingScrollPhysics(),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          const SizedBox(height: 16),
                          Text(
                            AppLocalizations.of(context)!
                                .passwordSetupPageSubtitle,
                            style: TextStyle(
                              color: theme.textPrimary,
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          SizedBox(height: adaptivePadding),
                          SmartInput(
                            controller: _walletNameController,
                            hint: AppLocalizations.of(context)!
                                .passwordSetupPageWalletNameHint,
                            fontSize: 18,
                            height: inputHeight,
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            focusedBorderColor: theme.primaryPurple,
                            disabled: _disabled,
                            onChanged: (value) {
                              if (_errorMessage != '') {
                                setState(() {
                                  _errorMessage = '';
                                });
                              }
                            },
                          ),
                          SizedBox(height: adaptivePadding),
                          SmartInput(
                            key: _passwordInputKey,
                            controller: _passwordController,
                            hint: AppLocalizations.of(context)!
                                .passwordSetupPagePasswordHint,
                            fontSize: 18,
                            height: inputHeight,
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            focusedBorderColor: theme.primaryPurple,
                            disabled: _disabled,
                            obscureText: _obscurePassword,
                            rightIconPath: _obscurePassword
                                ? "assets/icons/close_eye.svg"
                                : "assets/icons/open_eye.svg",
                            onChanged: (value) {
                              if (_errorMessage != '') {
                                setState(() {
                                  _errorMessage = '';
                                });
                              }
                            },
                            onRightIconTap: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                          SizedBox(height: adaptivePadding),
                          SmartInput(
                            key: _confirmPasswordInputKey,
                            controller: _confirmPasswordController,
                            hint: AppLocalizations.of(context)!
                                .passwordSetupPageConfirmPasswordHint,
                            height: inputHeight,
                            fontSize: 18,
                            disabled: _disabled,
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                            obscureText: _obscureConfirmPassword,
                            rightIconPath: _obscureConfirmPassword
                                ? "assets/icons/close_eye.svg"
                                : "assets/icons/open_eye.svg",
                            onRightIconTap: () {
                              setState(() {
                                _obscureConfirmPassword =
                                    !_obscureConfirmPassword;
                              });
                            },
                            onChanged: (value) {
                              if (_errorMessage != '') {
                                setState(() {
                                  _errorMessage = '';
                                });
                              }
                            },
                          ),
                          const SizedBox(height: 8),
                          Text(
                            _errorMessage,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          if (_chain?.slip44 == 313)
                            Padding(
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 4),
                              child: Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  Row(
                                    children: [
                                      SvgPicture.asset(
                                        "assets/icons/scilla.svg",
                                        width: 24,
                                        height: 24,
                                        colorFilter: ColorFilter.mode(
                                          theme.textPrimary,
                                          BlendMode.srcIn,
                                        ),
                                      ),
                                      const SizedBox(width: 4),
                                      Text(
                                        AppLocalizations.of(context)!
                                            .passwordSetupPageLegacyLabel,
                                        style: TextStyle(
                                          color: theme.textPrimary,
                                          fontSize: 16,
                                        ),
                                      ),
                                    ],
                                  ),
                                  Switch(
                                    value: _zilLegacy,
                                    onChanged: _disabled
                                        ? null
                                        : (value) {
                                            setState(() {
                                              _zilLegacy = value;
                                            });
                                          },
                                    activeThumbColor: theme.primaryPurple,
                                    activeTrackColor: theme.primaryPurple
                                        .withValues(alpha: 0.4),
                                  ),
                                ],
                              ),
                            ),
                          BiometricSwitch(
                            biometricType: _authMethods.first,
                            value: _useDeviceAuth,
                            disabled: _disabled,
                            onChanged: (value) async {
                              setState(() => _useDeviceAuth = value);
                            },
                          ),
                          SizedBox(height: 80),
                        ],
                      ),
                    ),
                  ),
                  Container(
                    width: double.infinity,
                    padding: EdgeInsets.only(bottom: adaptivePadding),
                    child: RoundedLoadingButton(
                      color: theme.primaryPurple,
                      valueColor: theme.buttonText,
                      controller: _btnController,
                      onPressed: _createWallet,
                      child: Text(
                        AppLocalizations.of(context)!
                            .passwordSetupPageCreateButton,
                        style: TextStyle(
                          color: theme.buttonText,
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _checkAuthMethods() async {
    final methods = await _authService.getAvailableAuthMethods();
    setState(() {
      _authMethods = methods;
      if (_authMethods.length == 0 || _authMethods.first == AuthMethod.none) {
        _useDeviceAuth = false;
      }
    });
  }
}

```

`lib/pages/receive.dart`:

```dart
import 'dart:io';

import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/modals/select_token.dart';
import 'package:zilpay/src/rust/api/qrcode.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class ReceivePage extends StatefulWidget {
  const ReceivePage({super.key});

  @override
  State<ReceivePage> createState() => _ReceivePageState();
}

class _ReceivePageState extends State<ReceivePage> {
  bool isCopied = false;
  bool isPressedToken = false;
  int selectedToken = 0;
  String amount = "0";
  Key _imageKey = UniqueKey();
  String? legacyAddress;
  bool useLegacyAddress = false;

  final TextEditingController _accountNameController = TextEditingController();
  final TextEditingController _amountController = TextEditingController();

  @override
  void initState() {
    super.initState();
    final appState = Provider.of<AppState>(context, listen: false);
    final chain = appState.chain!;

    _amountController.text = amount;
    _accountNameController.text = appState.account?.name ?? "";

    if (chain.slip44 == 313) {
      zilliqaGetNFormat(
        walletIndex: BigInt.from(appState.selectedWallet),
        accountIndex: appState.wallet!.selectedAccount,
      ).then((addr) {
        setState(() {
          legacyAddress = addr;
        });
      });
    }
  }

  @override
  void dispose() {
    _amountController.dispose();
    _accountNameController.dispose();
    super.dispose();
  }

  Future<void> handleCopy(String address) async {
    await Clipboard.setData(ClipboardData(text: address));
    setState(() {
      isCopied = true;
    });
    await Future.delayed(const Duration(seconds: 2));
    setState(() {
      isCopied = false;
    });
  }

  void handlePressedChanged(bool pressed) {
    setState(() {
      isPressedToken = pressed;
    });
  }

  void handleSelectToken() {
    showTokenSelectModal(
      context: context,
      onTokenSelected: (index) {
        setState(() {
          selectedToken = index;
          _imageKey = UniqueKey();
        });
      },
    );
  }

  Future<void> handleShare(
    FTokenInfo token,
    String addr,
    AppTheme theme,
    NetworkConfigInfo chain,
  ) async {
    QrConfigInfo config = QrConfigInfo(
      size: 600,
      gapless: false,
      color: theme.primaryPurple.toARGB32(),
      eyeShape: EyeShape.circle.value,
      dataModuleShape: DataModuleShape.circle.value,
    );
    String data = generateCryptoUrl(
      address: addr,
      chain: chain.shortName,
      token: token.addr,
      amount: amount,
    );

    try {
      final pngBytes = await genPngQrcode(data: data, config: config);
      final tempDir = await getTemporaryDirectory();
      final tempFile = File('${tempDir.path}/qrcode.png');
      await tempFile.writeAsBytes(pngBytes);
      final xFile = XFile(tempFile.path, mimeType: 'image/png');
      await SharePlus.instance.share(
        ShareParams(
          files: [xFile],
          text: '$addr, amount: $amount',
        ),
      );
      await tempFile.delete();
    } catch (e) {
      debugPrint("error share: $e");
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = appState.chain!;
    final token = appState.wallet!.tokens[selectedToken];
    final currentAddress = useLegacyAddress && legacyAddress != null
        ? legacyAddress!
        : appState.account!.addr;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: l10n.receivePageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    child: Padding(
                      padding:
                          EdgeInsets.symmetric(horizontal: adaptivePadding),
                      child: Column(
                        children: [
                          Container(
                            width: double.infinity,
                            constraints: const BoxConstraints(maxWidth: 400),
                            child: Column(
                              children: [
                                Container(
                                  margin: EdgeInsets.symmetric(
                                      vertical: adaptivePadding),
                                  padding: const EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: theme.warning.withValues(alpha: 0.1),
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  child: Row(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      SvgPicture.asset(
                                        "assets/icons/warning.svg",
                                        width: 24,
                                        height: 24,
                                        colorFilter: ColorFilter.mode(
                                          theme.warning,
                                          BlendMode.srcIn,
                                        ),
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Text(
                                          l10n.receivePageWarning(
                                              chain.name, token.symbol),
                                          style: TextStyle(
                                            color: theme.warning,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                Container(
                                  width: double.infinity,
                                  padding: EdgeInsets.all(adaptivePadding),
                                  decoration: BoxDecoration(
                                    color: theme.cardBackground,
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      _buildTokenSelector(appState, token),
                                      const SizedBox(height: 24),
                                      if (appState.account != null)
                                        SizedBox(
                                          width: 220,
                                          height: 220,
                                          child: AsyncQRcode(
                                            data: generateCryptoUrl(
                                              address: currentAddress,
                                              chain: chain.shortName,
                                              token: token.addr,
                                              amount: amount,
                                            ),
                                            color: theme.primaryPurple,
                                            size: 220,
                                            fit: BoxFit.contain,
                                          ),
                                        ),
                                      const SizedBox(height: 16),
                                      Text(
                                        currentAddress,
                                        style: TextStyle(
                                          color: theme.textSecondary,
                                          fontSize: 12,
                                        ),
                                        textAlign: TextAlign.center,
                                      ),
                                    ],
                                  ),
                                ),
                                const SizedBox(height: 16),
                                SmartInput(
                                  controller: _accountNameController,
                                  hint: l10n.receivePageAccountNameHint,
                                  onSubmitted: (_) async {
                                    if (_accountNameController
                                        .text.isNotEmpty) {
                                      await changeAccountName(
                                        walletIndex: BigInt.from(
                                            appState.selectedWallet),
                                        accountIndex:
                                            appState.wallet!.selectedAccount,
                                        newName: _accountNameController.text,
                                      );
                                      await appState.syncData();
                                    }
                                  },
                                  height: 50,
                                  rightIconPath: "assets/icons/edit.svg",
                                  borderColor: theme.cardBackground,
                                  focusedBorderColor: theme.primaryPurple,
                                  fontSize: 14,
                                ),
                                const SizedBox(height: 16),
                                _buildActionButtons(
                                    theme, chain, context, currentAddress),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTokenSelector(AppState appState, FTokenInfo token) {
    final theme = appState.currentTheme;

    return GestureDetector(
      onTapDown: (_) => handlePressedChanged(true),
      onTapUp: (_) => handlePressedChanged(false),
      onTapCancel: () => handlePressedChanged(false),
      onTap: handleSelectToken,
      child: AnimatedOpacity(
        duration: const Duration(milliseconds: 150),
        opacity: isPressedToken ? 0.6 : 1.0,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 32,
              height: 32,
              decoration: const BoxDecoration(shape: BoxShape.circle),
              child: Center(
                child: AsyncImage(
                  key: _imageKey,
                  url: processTokenLogo(
                    token: token,
                    shortName: appState.chain?.shortName ?? "",
                    theme: theme.value,
                  ),
                  width: 32,
                  height: 32,
                  fit: BoxFit.contain,
                  errorWidget: Blockies(
                    seed: token.addr,
                    color: theme.secondaryPurple,
                    bgColor: theme.primaryPurple,
                    spotColor: theme.background,
                    size: 8,
                  ),
                  loadingWidget: const Center(
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
            Text(
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
              token.name,
              style: TextStyle(
                color: theme.textPrimary,
                fontSize: 12,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 2),
            Text(
              "(${token.symbol})",
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 18,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButtons(
    AppTheme theme,
    NetworkConfigInfo chain,
    BuildContext context,
    String currentAddress,
  ) {
    final appState = Provider.of<AppState>(context);
    final token = appState.wallet!.tokens[selectedToken];
    final account = appState.account;

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        TileButton(
          icon: SvgPicture.asset(
            isCopied ? "assets/icons/check.svg" : "assets/icons/copy.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
          ),
          disabled: false,
          onPressed: () async {
            await handleCopy(currentAddress);
          },
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
        TileButton(
          icon: SvgPicture.asset(
            "assets/icons/hash.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
          ),
          disabled: false,
          onPressed: _handleAmountDialog,
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
        if (account != null && chain.slip44 == 313)
          TileButton(
            icon: SvgPicture.asset(
              useLegacyAddress
                  ? "assets/icons/scilla.svg"
                  : "assets/icons/solidity.svg",
              width: 24,
              height: 24,
              colorFilter:
                  ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
            ),
            disabled: legacyAddress == null || account.addrType == 0,
            onPressed: () {
              if (legacyAddress != null) {
                setState(() {
                  useLegacyAddress = !useLegacyAddress;
                });
              }
            },
            backgroundColor: theme.cardBackground,
            textColor: theme.primaryPurple,
          ),
        TileButton(
          icon: SvgPicture.asset(
            "assets/icons/share.svg",
            width: 24,
            height: 24,
            colorFilter: ColorFilter.mode(theme.primaryPurple, BlendMode.srcIn),
          ),
          disabled: false,
          onPressed: () async {
            await handleShare(token, currentAddress, theme, chain);
          },
          backgroundColor: theme.cardBackground,
          textColor: theme.primaryPurple,
        ),
      ],
    );
  }

  Future<void> _handleAmountDialog() async {
    _amountController.text = amount;
    final l10n = AppLocalizations.of(context)!;

    final result = await showDialog<String>(
      context: context,
      builder: (BuildContext context) {
        final theme = Provider.of<AppState>(context).currentTheme;

        return AlertDialog(
          backgroundColor: theme.cardBackground,
          title: Text(
            l10n.receivePageAmountDialogTitle,
            style: TextStyle(
              color: theme.textPrimary,
              fontWeight: FontWeight.bold,
            ),
          ),
          content: TextField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9\,\.]')),
              TextInputFormatter.withFunction((oldValue, newValue) {
                return TextEditingValue(
                  text: newValue.text.replaceAll(',', '.'),
                  selection: newValue.selection,
                );
              }),
              TextInputFormatter.withFunction((oldValue, newValue) {
                if (newValue.text.isEmpty) return newValue;
                if (newValue.text.split('.').length > 2) return oldValue;
                return newValue;
              }),
            ],
            decoration: InputDecoration(
              hintText: l10n.receivePageAmountDialogHint,
              hintStyle: TextStyle(color: theme.textSecondary),
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: theme.primaryPurple),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: theme.primaryPurple, width: 2),
              ),
            ),
            style: TextStyle(
              color: theme.textPrimary,
              fontSize: 16,
            ),
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(
                l10n.receivePageAmountDialogCancel,
                style: TextStyle(color: theme.textSecondary),
              ),
            ),
            TextButton(
              onPressed: () {
                if (_amountController.text.isEmpty) {
                  _amountController.text = '0';
                }
                Navigator.pop(context, _amountController.text);
              },
              child: Text(
                l10n.receivePageAmountDialogConfirm,
                style: TextStyle(
                  color: theme.primaryPurple,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        );
      },
    );

    if (result != null) {
      setState(() {
        amount = result;
      });
    }
  }
}

```

`lib/pages/restore_bip39.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:math' as math;
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/components/wor_count_selector.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class RestoreSecretPhrasePage extends StatefulWidget {
  const RestoreSecretPhrasePage({super.key});

  @override
  State<RestoreSecretPhrasePage> createState() =>
      _RestoreSecretPhrasePageState();
}

class _RestoreSecretPhrasePageState extends State<RestoreSecretPhrasePage> {
  late List<String> _words;
  List<int> _wordsErrorIndexes = [];
  int _count = 12;
  final List<int> _allowedCounts = const [12, 15, 18, 21, 24];
  bool _isChecksumValid = true;
  bool _bypassChecksumValidation = false;
  bool _showChecksumWarning = false;
  bool _allWordsEntered = false;

  @override
  void initState() {
    super.initState();
    _words = List.filled(_count, '');
  }

  Future<void> _handleCheckWords() async {
    try {
      final nonEmptyWords = _words.where((word) => word.isNotEmpty).toList();
      if (nonEmptyWords.isEmpty) return;

      List<int> errorIndexes = (await checkNotExistsBip39Words(
        words: nonEmptyWords,
        lang: 'english',
      ))
          .map((e) => e.toInt())
          .toList();

      final List<int> adjustedIndexes = [];
      var currentIndex = 0;

      for (int i = 0; i < _words.length; i++) {
        if (_words[i].isNotEmpty) {
          if (errorIndexes.contains(currentIndex)) {
            adjustedIndexes.add(i);
          }
          currentIndex++;
        }
      }

      if (mounted) {
        setState(() {
          _wordsErrorIndexes = adjustedIndexes;
          _validateForm();
        });
      }
    } catch (e) {
      debugPrint('Error checking words: $e');
    }
  }

  Future<void> _validateForm() async {
    bool areAllWordsValid =
        _words.every((word) => word.isNotEmpty) && _wordsErrorIndexes.isEmpty;

    setState(() {
      _allWordsEntered = areAllWordsValid;
    });

    if (areAllWordsValid) {
      if (!_showChecksumWarning) {
        String phrase = _words.join(' ');
        bool checksumValid = await bip39ChecksumValid(words: phrase);

        if (mounted) {
          setState(() {
            _isChecksumValid = checksumValid;
            _showChecksumWarning = !checksumValid;
          });
        }
      }
    } else {
      if (mounted) {
        setState(() {
          _showChecksumWarning = false;
          _bypassChecksumValidation = false;
        });
      }
    }
  }

  void _handleWordChange(int index, String word) {
    if (word.trim().contains(' ')) {
      _handlePhrasePaste(word);
      return;
    }

    final trimmedWord =
        word.trim().toLowerCase().replaceAll(RegExp(r'[^a-z]'), '');
    final currentIndex = index - 1;

    _words[currentIndex] = trimmedWord;
    if (_wordsErrorIndexes.contains(currentIndex)) {
      _wordsErrorIndexes.remove(currentIndex);
    }

    if (_showChecksumWarning) {
      setState(() {
        _showChecksumWarning = false;
        _bypassChecksumValidation = false;
      });
    }

    _validateForm();

    if (trimmedWord.isNotEmpty) {
      Future.microtask(() => _handleCheckWords());
    }
  }

  void _handlePhrasePaste(String phrase) {
    final words = phrase
        .trim()
        .split(RegExp(r'\s+'))
        .where((word) => word.isNotEmpty)
        .toList();

    int targetCount = _allowedCounts.firstWhere(
      (count) => count >= words.length,
      orElse: () => _allowedCounts.last,
    );

    if (targetCount != _count) {
      _handleCountChanged(targetCount, autoAdjust: true);
    }

    for (var i = 0; i < words.length && i < targetCount; i++) {
      _words[i] = words[i].toLowerCase();
    }

    setState(() {
      _showChecksumWarning = false;
      _bypassChecksumValidation = false;
    });

    _validateForm();

    if (words.isNotEmpty) {
      Future.microtask(() => _handleCheckWords());
    }
  }

  void _handleCountChanged(int newCount, {bool autoAdjust = false}) {
    if (mounted) {
      setState(() {
        _count = newCount;
        final newWords = List<String>.filled(newCount, '');
        for (var i = 0; i < math.min(_words.length, newCount); i++) {
          newWords[i] = _words[i];
        }
        _words = newWords;
        _wordsErrorIndexes = [];
        _showChecksumWarning = false;
        _bypassChecksumValidation = false;
        _allWordsEntered = false;
      });

      _validateForm();
    }
  }

  Widget _buildChecksumWarning() {
    if (!_showChecksumWarning) return const SizedBox.shrink();

    final theme = Provider.of<AppState>(context).currentTheme;

    return Container(
      padding: const EdgeInsets.all(8),
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: theme.danger),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            AppLocalizations.of(context)!.checksumValidationFailed,
            style: TextStyle(color: theme.danger, fontWeight: FontWeight.bold),
          ),
          Row(
            children: [
              Checkbox(
                value: _bypassChecksumValidation,
                onChanged: (value) {
                  setState(() {
                    _bypassChecksumValidation = value ?? false;
                  });
                },
                activeColor: theme.primaryPurple,
              ),
              Expanded(
                child: Text(
                  AppLocalizations.of(context)!.proceedDespiteInvalidChecksum,
                  style: TextStyle(color: theme.textPrimary),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  bool get _isButtonEnabled {
    if (!_allWordsEntered) return false;
    if (_isChecksumValid) return true;
    return _bypassChecksumValidation;
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: AppLocalizations.of(context)!
                      .restoreSecretPhrasePageTitle,
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const SizedBox(height: 16),
                        WordCountSelector(
                          wordCounts: _allowedCounts,
                          selectedCount: _count,
                          onCountChanged: (count) => _handleCountChanged(count),
                        ),
                        const SizedBox(height: 16),
                        Expanded(
                          child: ListView.builder(
                            physics: const BouncingScrollPhysics(),
                            itemCount: _count,
                            itemBuilder: (context, index) {
                              return Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 8.0),
                                child: MnemonicWordInput(
                                  key: ValueKey('word_$index'),
                                  index: index + 1,
                                  word: _words[index],
                                  isEditable: true,
                                  onChanged: _handleWordChange,
                                  borderColor: theme.buttonText,
                                  hasError: _wordsErrorIndexes.contains(index),
                                  errorBorderColor: theme.danger,
                                ),
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        _buildChecksumWarning(),
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16),
                          child: CustomButton(
                            textColor: theme.buttonText,
                            backgroundColor: theme.primaryPurple,
                            text: AppLocalizations.of(context)!
                                .restoreSecretPhrasePageRestoreButton,
                            onPressed: () {
                              Navigator.of(context)
                                  .pushNamed('/net_setup', arguments: {
                                'bip39': _words,
                                'ignore_checksum': _bypassChecksumValidation,
                              });
                            },
                            borderRadius: 30.0,
                            height: 56.0,
                            disabled: !_isButtonEnabled,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/restore_rkstorage.dart`:

```dart
import 'dart:convert';
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class Account {
  final String name;
  final String address;
  final String? balance;
  final int type;
  final int index;

  Account({
    required this.name,
    required this.address,
    required this.type,
    required this.index,
    this.balance,
  });
}

class RestoreRKStorage extends StatefulWidget {
  const RestoreRKStorage({super.key});

  @override
  State<RestoreRKStorage> createState() => _RestoreRKStorageState();
}

class _RestoreRKStorageState extends State<RestoreRKStorage> {
  List<Account> accounts = [];
  final TextEditingController _passwordController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;
  bool _obscurePassword = true;
  String? _vaultJson;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final appState = Provider.of<AppState>(context);

    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, String?>?;
    if (args == null || args['vaultJson'] == null) {
      Navigator.pop(context);
      return;
    }
    _vaultJson = args['vaultJson'];
    try {
      final accountsJson = jsonDecode(args['accountsJson'] ?? '{}');
      final identities = (accountsJson['identities'] as List<dynamic>?) ?? [];

      setState(() {
        accounts = identities.map((identity) {
          final balanceMap = identity['balance'] as Map<String, dynamic>?;
          final mainnetBalance =
              balanceMap?['mainnet'] as Map<String, dynamic>?;
          final (balance, _) = formatingAmount(
            amount: mainnetBalance?['ZIL'] ?? "0",
            symbol: "ZIL",
            decimals: 12,
            rate: 0,
            appState: appState,
          );

          return Account(
            name: identity['name'] as String? ?? 'Unnamed',
            address: identity['bech32'] as String? ?? '',
            type: identity['type'] as int? ?? 0,
            index: identity['index'] as int? ?? 0,
            balance: balance,
          );
        }).toList();
      });
    } catch (e) {
      debugPrint("Error parsing accounts JSON: $e");
      setState(() {
        accounts = [];
      });
    }
  }

  @override
  void dispose() {
    _passwordController.dispose();
    super.dispose();
  }

  void _handleRestore() async {
    if (_passwordController.text.isEmpty) {
      setState(() => _errorMessage =
          AppLocalizations.of(context)!.restoreRKStorageEnterPassword);
      return;
    }
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    try {
      String words = await tryRestoreRkstorage(
        vaultJson: _vaultJson!,
        password: _passwordController.text,
      );
      if (mounted) {
        Navigator.of(context).pushNamed('/net_setup', arguments: {
          'bip39': words.split(" "),
          'zilLegacy': true,
          'ignore_checksum': true,
        });
      }
    } catch (e) {
      setState(() => _errorMessage =
          '${AppLocalizations.of(context)!.restoreRKStorageErrorPrefix} ${e.toString()}');
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;
    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: CustomScrollView(
              slivers: [
                SliverToBoxAdapter(
                  child: CustomAppBar(
                    title: l10n.restoreRKStorageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                SliverToBoxAdapter(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (accounts.isNotEmpty) ...[
                          Text(l10n.restoreRKStorageAccountsPrompt,
                              style: TextStyle(
                                  color: theme.textSecondary, fontSize: 14)),
                          const SizedBox(height: 16),
                          Container(
                            padding: const EdgeInsets.all(16.0),
                            decoration: BoxDecoration(
                              color: theme.cardBackground,
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(
                                  color: theme.secondaryPurple
                                      .withValues(alpha: 0.2)),
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: accounts
                                  .map((account) =>
                                      AccountItem(account: account))
                                  .toList(),
                            ),
                          ),
                          const SizedBox(height: 16),
                        ],
                        SmartInput(
                          controller: _passwordController,
                          hint: l10n.restoreRKStoragePasswordHint,
                          obscureText: _obscurePassword,
                          rightIconPath: _obscurePassword
                              ? 'assets/icons/close_eye.svg'
                              : 'assets/icons/open_eye.svg',
                          onRightIconTap: () => setState(
                              () => _obscurePassword = !_obscurePassword),
                          disabled: _isLoading,
                          focusedBorderColor: theme.primaryPurple,
                          height: 56,
                          padding: const EdgeInsets.symmetric(horizontal: 20),
                        ),
                        if (_errorMessage != null)
                          Padding(
                            padding: const EdgeInsets.only(top: 8.0),
                            child: Text(_errorMessage!,
                                style: TextStyle(
                                    color: theme.danger, fontSize: 14)),
                          ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: double.infinity,
                          child: CustomButton(
                            textColor: theme.buttonText,
                            backgroundColor: theme.primaryPurple,
                            text: l10n.restoreRKStorageRestoreButton,
                            disabled: _isLoading,
                            onPressed: _handleRestore,
                            borderRadius: 30.0,
                            height: 56.0,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Center(
                          child: SizedBox(
                            width: 100,
                            child: TextButton(
                              onPressed: () => Navigator.of(context)
                                  .pushNamed('/new_wallet_options'),
                              child: Text(l10n.restoreRKStorageSkipButton,
                                  style: TextStyle(
                                      color: theme.textSecondary,
                                      fontSize: 14)),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class AccountItem extends StatelessWidget {
  final Account account;

  const AccountItem({super.key, required this.account});

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SizedBox(
            width: 40,
            height: 40,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(20),
              child: Blockies(
                seed: account.address.toLowerCase(),
                size: 8,
                color: theme.secondaryPurple,
                bgColor: theme.primaryPurple,
                spotColor: theme.background,
              ),
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(account.name,
                    style: TextStyle(
                        color: theme.textPrimary,
                        fontWeight: FontWeight.bold,
                        fontSize: 16)),
                Text(account.address,
                    style: TextStyle(color: theme.textSecondary, fontSize: 14),
                    overflow: TextOverflow.ellipsis),
                Text(
                    '${l10n.accountItemBalanceLabel} ${account.balance ?? '0'} ZIL',
                    style: TextStyle(color: theme.textSecondary, fontSize: 14)),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

```

`lib/pages/restore_sk.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/hex_key.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/backup_confirmation_modal.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SecretKeyRestorePage extends StatefulWidget {
  const SecretKeyRestorePage({super.key});

  @override
  State<SecretKeyRestorePage> createState() => _SecretKeyRestorePageState();
}

class _SecretKeyRestorePageState extends State<SecretKeyRestorePage> {
  final TextEditingController _privateKeyController = TextEditingController();
  String? _errorMessage;
  bool _hasBackup = false;
  bool _isValidating = false;
  KeyPairInfo _keyPair = KeyPairInfo(sk: "", pk: "");

  @override
  void dispose() {
    _privateKeyController.dispose();
    super.dispose();
  }

  void _validatePrivateKey(String input) async {
    final l10n = AppLocalizations.of(context)!;
    setState(() {
      _isValidating = true;
      _errorMessage = null;
      _keyPair = KeyPairInfo(sk: "", pk: "");
    });

    if (input.isEmpty) {
      setState(() => _isValidating = false);
      return;
    }

    try {
      if (input.length != 64 || !RegExp(r'^[a-fA-F0-9]+$').hasMatch(input)) {
        throw Exception('Invalid format');
      }
      setState(() {
        _keyPair = KeyPairInfo(sk: input, pk: "");
        _errorMessage = null;
      });
    } catch (e) {
      setState(() {
        _errorMessage = l10n.secretKeyRestorePageInvalidFormat;
        _keyPair = KeyPairInfo(sk: "", pk: "");
      });
    } finally {
      setState(() => _isValidating = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: l10n.secretKeyRestorePageTitle,
              onBackPressed: () => Navigator.pop(context),
              actionIcon: SvgPicture.asset(
                'assets/icons/paste.svg',
                width: 30,
                height: 30,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    Expanded(
                      flex: 4,
                      child: SingleChildScrollView(
                        child: Column(
                          children: [
                            SmartInput(
                              controller: _privateKeyController,
                              hint: l10n.secretKeyRestorePageHint,
                              onChanged: _validatePrivateKey,
                              keyboardType: TextInputType.text,
                              leftIconPath: 'assets/icons/key.svg',
                              rightIconPath: _isValidating
                                  ? 'assets/icons/loading.svg'
                                  : null,
                              secondaryColor: theme.textSecondary,
                              backgroundColor: theme.cardBackground,
                              textColor: theme.textPrimary,
                              focusedBorderColor: theme.primaryPurple,
                              height: 64,
                              fontSize: 16,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 16),
                              iconPadding:
                                  const EdgeInsets.symmetric(horizontal: 12),
                            ),
                            if (_errorMessage != null)
                              Padding(
                                padding: const EdgeInsets.only(top: 8),
                                child: Text(
                                  _errorMessage!,
                                  style: TextStyle(
                                    color: theme.danger,
                                    fontSize: 14,
                                  ),
                                ),
                              ),
                            Padding(
                              padding: const EdgeInsets.only(top: 16),
                              child: HexKeyDisplay(
                                hexKey: _keyPair.sk.isNotEmpty
                                    ? _keyPair.sk
                                    : '0000000000000000000000000000000000000000000000000000000000000000',
                                title: l10n.secretKeyRestorePageKeyTitle,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Theme(
                              data: Theme.of(context).copyWith(
                                splashFactory: NoSplash.splashFactory,
                                highlightColor: Colors.transparent,
                              ),
                              child: CheckboxListTile(
                                title: Text(
                                  l10n.secretKeyRestorePageBackupLabel,
                                  style: TextStyle(color: theme.textSecondary),
                                ),
                                value: _hasBackup,
                                onChanged: (value) {
                                  if (!_hasBackup) {
                                    showBackupConfirmationModal(
                                      context: context,
                                      onConfirmed: (confirmed) {
                                        setState(() {
                                          _hasBackup = confirmed;
                                        });
                                      },
                                    );
                                  }
                                },
                                controlAffinity:
                                    ListTileControlAffinity.leading,
                                activeColor: theme.primaryPurple,
                              ),
                            ),
                            CustomButton(
                              textColor: theme.buttonText,
                              backgroundColor: theme.primaryPurple,
                              text: l10n.secretKeyRestorePageNextButton,
                              onPressed: _keyPair.sk.isNotEmpty && _hasBackup
                                  ? () {
                                      Navigator.of(context).pushNamed(
                                        '/net_setup',
                                        arguments: {'keys': _keyPair},
                                      );
                                    }
                                  : null,
                              borderRadius: 30.0,
                              height: 56.0,
                              disabled: !(_keyPair.sk.isNotEmpty && _hasBackup),
                            ),
                          ],
                        ),
                      ],
                    ),
                    const SizedBox(
                      height: 16,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/pages/reveal_bip39.dart`:

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class RevealSecretPhrase extends StatefulWidget {
  const RevealSecretPhrase({super.key});

  @override
  State<RevealSecretPhrase> createState() => _RevealSecretPhraseState();
}

class _RevealSecretPhraseState extends State<RevealSecretPhrase> {
  bool isCopied = false;
  bool isAuthenticated = false;
  bool hasError = false;
  bool isTimerActive = false;
  bool canShowPhrase = false;
  String? errorMessage;
  bool _obscurePassword = true;
  String? seedPhrase;
  Timer? _countdownTimer;
  int _remainingTime = 3600;

  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  @override
  void initState() {
    _secureScreen();
    super.initState();
  }

  @override
  void dispose() {
    _countdownTimer?.cancel();
    ScreenProtector.preventScreenshotOff();
    ScreenProtector.protectDataLeakageOff();
    ScreenProtector.protectDataLeakageWithBlurOff();
    super.dispose();
  }

  Future<void> _secureScreen() async {
    await ScreenProtector.preventScreenshotOn();
    await ScreenProtector.protectDataLeakageOn();
    await ScreenProtector.protectDataLeakageWithBlur();
  }

  void _startCountdown() {
    setState(() {
      isTimerActive = true;
      _remainingTime = 3600;
    });

    _countdownTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      setState(() {
        if (_remainingTime > 0) {
          _remainingTime--;
        } else {
          canShowPhrase = true;
          isTimerActive = false;
          timer.cancel();
        }
      });
    });
  }

  String _formatTime(int seconds) {
    final hours = seconds ~/ 3600;
    final minutes = (seconds % 3600) ~/ 60;
    final secs = seconds % 60;
    return '${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
  }

  void _onPasswordSubmit(BigInt walletIndex) async {
    _btnController.start();
    try {
      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      await tryUnlockWithPassword(
        password: _passwordController.text,
        walletIndex: walletIndex,
        identifiers: identifiers,
      );

      String phrase = await revealBip39Phrase(
        walletIndex: walletIndex,
        identifiers: identifiers,
        password: _passwordController.text,
      );

      setState(() {
        seedPhrase = phrase;
        isAuthenticated = true;
        hasError = false;
        errorMessage = null;
      });

      _btnController.success();
      _startCountdown();
    } catch (e) {
      setState(() {
        isAuthenticated = false;
        hasError = true;
        errorMessage =
            "${AppLocalizations.of(context)!.revealSecretPhraseInvalidPassword} $e";
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = state.currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: AppLocalizations.of(context)!.revealSecretPhraseTitle,
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    _buildScamAlert(theme),
                    if (!isAuthenticated) ...[
                      SmartInput(
                        key: _passwordInputKey,
                        controller: _passwordController,
                        hint: AppLocalizations.of(context)!
                            .revealSecretPhrasePasswordHint,
                        fontSize: 18,
                        height: 50,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        obscureText: _obscurePassword,
                        onSubmitted: (_) => _onPasswordSubmit(
                          BigInt.from(state.selectedWallet),
                        ),
                        rightIconPath: _obscurePassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: () => setState(
                            () => _obscurePassword = !_obscurePassword),
                      ),
                      if (hasError && errorMessage != null)
                        Container(
                          margin: const EdgeInsets.only(top: 8),
                          child: Text(
                            errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: RoundedLoadingButton(
                          color: theme.primaryPurple,
                          valueColor: theme.buttonText,
                          controller: _btnController,
                          onPressed: () => _onPasswordSubmit(
                            BigInt.from(state.selectedWallet),
                          ),
                          child: Text(
                            AppLocalizations.of(context)!
                                .revealSecretPhraseSubmitButton,
                            style: TextStyle(
                              color: theme.buttonText,
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    ],
                    if (isAuthenticated && isTimerActive && !canShowPhrase) ...[
                      _buildTimerDisplay(theme),
                    ],
                    if (isAuthenticated &&
                        canShowPhrase &&
                        seedPhrase != null) ...[
                      _buildQrCode(theme),
                      _buildPhraseDisplay(theme),
                      SizedBox(height: adaptivePadding),
                      TileButton(
                        icon: SvgPicture.asset(
                          isCopied
                              ? "assets/icons/check.svg"
                              : "assets/icons/copy.svg",
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        ),
                        onPressed: () => _handleCopy(seedPhrase ?? ""),
                        backgroundColor: theme.cardBackground,
                        textColor: theme.primaryPurple,
                      ),
                      SizedBox(height: adaptivePadding),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        padding: EdgeInsets.only(bottom: adaptivePadding),
                        child: CustomButton(
                          textColor: theme.buttonText,
                          backgroundColor: theme.primaryPurple,
                          text: AppLocalizations.of(context)!
                              .revealSecretPhraseDoneButton,
                          onPressed: () => Navigator.pop(context),
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTimerDisplay(AppTheme theme) {
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 32),
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: theme.secondaryPurple),
      ),
      child: Column(
        children: [
          SvgPicture.asset(
            "assets/icons/time.svg",
            width: 48,
            height: 48,
            colorFilter: ColorFilter.mode(
              theme.primaryPurple,
              BlendMode.srcIn,
            ),
          ),
          const SizedBox(height: 16),
          Text(
            "Security Timer",
            style: TextStyle(
              color: theme.textPrimary,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            AppLocalizations.of(context)!.revealSecretPhraseRevealAfter,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 14,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            _formatTime(_remainingTime),
            style: TextStyle(
              color: theme.primaryPurple,
              fontSize: 32,
              fontWeight: FontWeight.bold,
              fontFamily: 'monospace',
            ),
          ),
          const SizedBox(height: 16),
          LinearProgressIndicator(
            value: 1 - (_remainingTime / 3600),
            backgroundColor: theme.background,
            valueColor: AlwaysStoppedAnimation(theme.primaryPurple),
            borderRadius: BorderRadius.circular(4),
          ),
        ],
      ),
    );
  }

  Widget _buildScamAlert(AppTheme theme) {
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.danger),
      ),
      child: Column(
        children: [
          Row(
            children: [
              SvgPicture.asset(
                "assets/icons/warning.svg",
                width: 24,
                height: 24,
                colorFilter: ColorFilter.mode(
                  theme.danger,
                  BlendMode.srcIn,
                ),
              ),
              const SizedBox(width: 8),
              Text(
                AppLocalizations.of(context)!.revealSecretPhraseScamAlertTitle,
                style: TextStyle(
                  color: theme.danger,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            AppLocalizations.of(context)!
                .revealSecretPhraseScamAlertDescription,
            style: TextStyle(
              color: theme.danger,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPhraseDisplay(AppTheme theme) {
    final List<String> words = seedPhrase?.split(' ') ?? [];
    final int itemsPerRow = 3;
    final int rowCount = (words.length / itemsPerRow).ceil();

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: theme.secondaryPurple),
      ),
      child: Column(
        children: List.generate(rowCount, (rowIndex) {
          final startIndex = rowIndex * itemsPerRow;
          final endIndex = (startIndex + itemsPerRow).clamp(0, words.length);

          return Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Row(
              children: List.generate(
                endIndex - startIndex,
                (index) => Expanded(
                  child: Container(
                    margin: EdgeInsets.only(
                      right: index != itemsPerRow - 1 ? 8 : 0,
                    ),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    decoration: BoxDecoration(
                      color: theme.background,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      '${startIndex + index + 1}. ${words[startIndex + index]}',
                      style: TextStyle(
                        color: theme.textPrimary,
                        fontSize: 10,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildQrCode(AppTheme theme) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = state.chain!;

    return Container(
      margin: EdgeInsets.symmetric(vertical: adaptivePadding),
      child: Center(
        child: AsyncQRcode(
          data: generateQRSecretData(
            chain: chain.shortName,
            seedPhrase: seedPhrase,
          ),
          size: 160,
          color: theme.danger,
          eyeShape: EyeShape.circle,
          dataModuleShape: DataModuleShape.circle,
          loadingWidget: CircularProgressIndicator(
            color: theme.danger,
          ),
        ),
      ),
    );
  }

  Future<void> _handleCopy(String phrase) async {
    await Clipboard.setData(ClipboardData(text: phrase));
    setState(() {
      isCopied = true;
    });

    await Future<void>.delayed(const Duration(seconds: 1));

    setState(() {
      isCopied = false;
    });
  }
}

```

`lib/pages/reveal_sk.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:zilpay/components/async_qrcode.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/hex_key.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/components/load_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/auth.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class RevealSecretKey extends StatefulWidget {
  const RevealSecretKey({super.key});

  @override
  State<RevealSecretKey> createState() => _RevealSecretKeyState();
}

class _RevealSecretKeyState extends State<RevealSecretKey> {
  bool isCopied = false;
  bool isAuthenticated = false;
  bool hasError = false;
  String? errorMessage;
  bool _obscurePassword = true;
  KeyPairInfo? keys;

  final _passwordController = TextEditingController();
  final _passwordInputKey = GlobalKey<SmartInputState>();
  final _btnController = RoundedLoadingButtonController();

  @override
  void initState() {
    _secureScreen();
    super.initState();
  }

  @override
  void dispose() {
    ScreenProtector.preventScreenshotOff();
    ScreenProtector.protectDataLeakageOff();
    ScreenProtector.protectDataLeakageWithBlurOff();
    super.dispose();
  }

  Future<void> _secureScreen() async {
    await ScreenProtector.preventScreenshotOn();
    await ScreenProtector.protectDataLeakageOn();
    await ScreenProtector.protectDataLeakageWithBlur();
  }

  void _onPasswordSubmit(BigInt walletIndex, BigInt accountIndex) async {
    final l10n = AppLocalizations.of(context)!;

    _btnController.start();
    try {
      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      await tryUnlockWithPassword(
        password: _passwordController.text,
        walletIndex: walletIndex,
        identifiers: identifiers,
      );
      KeyPairInfo keypair = await revealKeypair(
        walletIndex: walletIndex,
        accountIndex: accountIndex,
        identifiers: identifiers,
        password: _passwordController.text,
      );

      setState(() {
        keys = keypair;
        isAuthenticated = true;
        hasError = false;
        errorMessage = null;
      });
      _btnController.success();
    } catch (e) {
      setState(() {
        isAuthenticated = false;
        hasError = true;
        errorMessage = "${l10n.revealSecretKeyInvalidPassword} $e";
      });
      _btnController.error();
      await Future.delayed(const Duration(seconds: 1));
      _btnController.reset();
    }
  }

  @override
  Widget build(BuildContext context) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = state.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: l10n.revealSecretKeyTitle,
              onBackPressed: () => Navigator.pop(context),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    _buildScamAlert(theme),
                    if (!isAuthenticated) ...[
                      SmartInput(
                        key: _passwordInputKey,
                        controller: _passwordController,
                        hint: l10n.revealSecretKeyPasswordHint,
                        fontSize: 18,
                        height: 50,
                        padding: const EdgeInsets.symmetric(horizontal: 20),
                        focusedBorderColor: theme.primaryPurple,
                        obscureText: _obscurePassword,
                        onSubmitted: (_) => _onPasswordSubmit(
                          BigInt.from(state.selectedWallet),
                          state.wallet!.selectedAccount,
                        ),
                        rightIconPath: _obscurePassword
                            ? "assets/icons/close_eye.svg"
                            : "assets/icons/open_eye.svg",
                        onRightIconTap: () => setState(
                            () => _obscurePassword = !_obscurePassword),
                      ),
                      if (hasError && errorMessage != null)
                        Container(
                          margin: const EdgeInsets.only(top: 8),
                          child: Text(
                            errorMessage!,
                            style: TextStyle(
                              color: theme.danger,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        child: RoundedLoadingButton(
                          color: theme.primaryPurple,
                          valueColor: theme.buttonText,
                          controller: _btnController,
                          onPressed: () => _onPasswordSubmit(
                            BigInt.from(state.selectedWallet),
                            state.wallet!.selectedAccount,
                          ),
                          child: Text(
                            l10n.revealSecretKeySubmitButton,
                            style: TextStyle(
                              color: theme.buttonText,
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ),
                    ],
                    if (isAuthenticated) ...[
                      if (keys != null) ...[
                        _buildQrCode(theme),
                        HexKeyDisplay(
                          hexKey: keys!.sk,
                          title: "",
                        )
                      ],
                      SizedBox(height: adaptivePadding),
                      TileButton(
                        icon: SvgPicture.asset(
                          isCopied
                              ? "assets/icons/check.svg"
                              : "assets/icons/copy.svg",
                          width: 24,
                          height: 24,
                          colorFilter: ColorFilter.mode(
                            theme.primaryPurple,
                            BlendMode.srcIn,
                          ),
                        ),
                        onPressed: () => _handleCopy(keys?.sk ?? ""),
                        backgroundColor: theme.cardBackground,
                        textColor: theme.primaryPurple,
                      ),
                      SizedBox(height: adaptivePadding),
                      Container(
                        constraints: const BoxConstraints(maxWidth: 480),
                        padding: EdgeInsets.only(bottom: adaptivePadding),
                        child: CustomButton(
                          textColor: theme.buttonText,
                          backgroundColor: theme.primaryPurple,
                          text: l10n.revealSecretKeyDoneButton,
                          onPressed: () => Navigator.pop(context),
                          borderRadius: 30.0,
                          height: 56.0,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildScamAlert(AppTheme theme) {
    final l10n = AppLocalizations.of(context)!;

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.danger.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.danger),
      ),
      child: Column(
        children: [
          Row(
            children: [
              Icon(
                Icons.warning_amber_rounded,
                color: theme.danger,
                size: 24,
              ),
              const SizedBox(width: 8),
              Text(
                l10n.revealSecretKeyScamAlertTitle,
                style: TextStyle(
                  color: theme.danger,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            l10n.revealSecretKeyScamAlertMessage,
            style: TextStyle(
              color: theme.danger,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildQrCode(AppTheme theme) {
    final state = Provider.of<AppState>(context);
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final chain = state.chain!;

    return Container(
      margin: EdgeInsets.symmetric(vertical: adaptivePadding),
      child: Center(
        child: AsyncQRcode(
          data: generateQRSecretData(
            chain: chain.shortName,
            privateKey: keys?.sk,
          ),
          size: 160,
          color: theme.danger,
          eyeShape: EyeShape.circle,
          dataModuleShape: DataModuleShape.circle,
          loadingWidget: CircularProgressIndicator(
            color: theme.danger,
          ),
        ),
      ),
    );
  }

  Future<void> _handleCopy(String key) async {
    await Clipboard.setData(ClipboardData(text: key));
    setState(() {
      isCopied = true;
    });

    await Future<void>.delayed(const Duration(seconds: 1));

    setState(() {
      isCopied = false;
    });
  }
}

```

`lib/pages/security.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/custom_app_bar.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SecurityPage extends StatefulWidget {
  const SecurityPage({super.key});

  @override
  State<SecurityPage> createState() => _SecurityPageState();
}

class _SecurityPageState extends State<SecurityPage> {
  final TextEditingController _ipfsController = TextEditingController(text: '');

  @override
  void dispose() {
    _ipfsController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final state = Provider.of<AppState>(context, listen: false);

      if (state.wallet != null && state.wallet!.settings.ipfsNode != null) {
        _ipfsController.text = state.wallet!.settings.ipfsNode!;
      } else {
        _ipfsController.text = "dweb.link";
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: l10n.securityPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: CustomScrollView(
                    physics: const BouncingScrollPhysics(),
                    slivers: [
                      SliverPadding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        sliver: SliverList(
                          delegate: SliverChildListDelegate([
                            _buildNetworkSection(appState),
                            const SizedBox(height: 32),
                            if (!appState.wallet!.walletType
                                .contains(WalletType.ledger.name)) ...[
                              // const SizedBox(height: 32)
                            ],
                            _buildEncryptionSection(appState),
                            const SizedBox(height: 32),
                          ]),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildNetworkSection(AppState state) {
    final theme = state.currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            l10n.securityPageNetworkPrivacy,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            children: [
              _buildPreferenceItem(
                state,
                l10n.securityPageTokensFetcherTitle,
                'assets/icons/globe.svg',
                l10n.securityPageTokensFetcherDescription,
                true,
                state.wallet!.settings.tokensListFetcher,
                (value) async {
                  await setTokensListFetcher(
                    walletIndex: BigInt.from(state.selectedWallet),
                    enabled: value,
                  );
                  await state.syncData();
                },
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                l10n.securityPageEnsDomains,
                'assets/icons/graph.svg',
                l10n.securityPageEnsDescription,
                true,
                state.wallet!.settings.ensEnabled,
                (value) async {
                  await setWalletEns(
                    walletIndex: BigInt.from(state.selectedWallet),
                    ensEnabled: value,
                  );
                  await state.syncData();
                },
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                l10n.securityPageIpfsGateway,
                'assets/icons/ipfs.svg',
                l10n.securityPageIpfsDescription,
                true,
                state.wallet!.settings.ipfsNode != null,
                (value) async {
                  await setWalletIpfsNode(
                    walletIndex: BigInt.from(state.selectedWallet),
                    node: value ? _ipfsController.text : null,
                  );
                  await state.syncData();
                },
                showInput: true,
                controller: _ipfsController,
              ),
              Divider(
                  height: 1, color: theme.textSecondary.withValues(alpha: 0.1)),
              _buildPreferenceItem(
                state,
                l10n.securityPageNodeRanking,
                'assets/icons/server.svg',
                l10n.securityPageNodeDescription,
                true,
                state.wallet!.settings.nodeRankingEnabled,
                (value) async {
                  await setWalletNodeRanking(
                    walletIndex: BigInt.from(state.selectedWallet),
                    enabled: value,
                  );
                  await state.syncData();
                },
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildPreferenceItem(
    AppState state,
    String title,
    String iconPath,
    String description,
    bool hasSwitch,
    bool value,
    Function(bool)? onChanged, {
    VoidCallback? onTap,
    bool showInput = false,
    TextEditingController? controller,
  }) {
    final theme = state.currentTheme;

    return GestureDetector(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                SvgPicture.asset(
                  iconPath,
                  width: 24,
                  height: 24,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Text(
                    title,
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 16,
                    ),
                  ),
                ),
                if (hasSwitch)
                  Switch(
                    value: value,
                    onChanged: onChanged,
                    activeThumbColor: theme.primaryPurple,
                  )
              ],
            ),
            if (description.isNotEmpty) ...[
              const SizedBox(height: 4),
              Padding(
                padding: const EdgeInsets.only(left: 40),
                child: Text(
                  description,
                  style: TextStyle(
                    color: theme.textSecondary,
                    fontSize: 14,
                  ),
                ),
              ),
            ],
            if (showInput) ...[
              const SizedBox(height: 12),
              Padding(
                padding: const EdgeInsets.only(left: 40),
                child: TextField(
                  controller: controller,
                  readOnly: !value,
                  style: TextStyle(
                    color: value
                        ? theme.textPrimary
                        : theme.textSecondary.withValues(alpha: 0.5),
                    fontSize: 14,
                  ),
                  decoration: InputDecoration(
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                      borderSide: BorderSide(
                        color: theme.textSecondary.withValues(alpha: 0.2),
                      ),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                      borderSide: BorderSide(
                        color: theme.primaryPurple,
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildEncryptionSection(AppState state) {
    final theme = state.currentTheme;
    final algorithms = generateAlgorithms(state.wallet!.settings.cipherOrders);
    final l10n = AppLocalizations.of(context)!;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            l10n.securityPageEncryptionLevel,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: 16,
            ),
          ),
        ),
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          physics: const BouncingScrollPhysics(),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Row(
              children: [
                for (int i = 0; i < algorithms.length; i++) ...[
                  if (i > 0)
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                      child: SvgPicture.asset(
                        'assets/icons/chevron_right.svg',
                        width: 16,
                        height: 16,
                        colorFilter: ColorFilter.mode(
                          theme.textSecondary,
                          BlendMode.srcIn,
                        ),
                      ),
                    ),
                  SizedBox(
                    width: 250,
                    child: _buildEncryptionCard(
                      state,
                      algorithms[i],
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildEncryptionCard(
    AppState state,
    Algorithm algorithm,
  ) {
    final theme = state.currentTheme;
    final cardWidth = MediaQuery.of(context).size.width > 480
        ? 320.0
        : MediaQuery.of(context).size.width * 0.7;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      width: cardWidth,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: theme.background,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: SvgPicture.asset(
                  algorithm.icon,
                  width: 24,
                  height: 24,
                  colorFilter: ColorFilter.mode(
                    theme.textPrimary,
                    BlendMode.srcIn,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Text(
                algorithm.name,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const Spacer(),
            ],
          ),
          const SizedBox(height: 16),
          _buildProgressBar(
            state,
            l10n.securityPageProtection,
            algorithm.protection,
            theme.primaryPurple,
          ),
          const SizedBox(height: 12),
          _buildProgressBar(
            state,
            l10n.securityPageCpuLoad,
            algorithm.cpuLoad,
            theme.warning,
          ),
        ],
      ),
    );
  }

  Widget _buildProgressBar(
    AppState state,
    String label,
    double value,
    Color color,
  ) {
    final theme = state.currentTheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
            ),
            Text(
              '${(value * 100).toInt()}%',
              style: TextStyle(
                color: theme.textSecondary,
                fontSize: 12,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        Container(
          height: 4,
          decoration: BoxDecoration(
            color: theme.background,
            borderRadius: BorderRadius.circular(2),
          ),
          child: FractionallySizedBox(
            widthFactor: value,
            child: Container(
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
        ),
      ],
    );
  }

  List<Algorithm> generateAlgorithms(List<int> algorithms) {
    final l10n = AppLocalizations.of(context)!;
    final Map<int, Algorithm> algorithmData = {
      0: Algorithm(
        name: l10n.securityPageAes256,
        protection: 0.60,
        cpuLoad: 0.3,
        icon: 'assets/icons/lock.svg',
      ),
      1: Algorithm(
        name: l10n.securityPageKuznechikGost,
        protection: 0.70,
        cpuLoad: 0.2,
        icon: 'assets/icons/grasshopper.svg',
      ),
      2: Algorithm(
        name: l10n.securityPageNtruPrime,
        protection: 0.92,
        cpuLoad: 0.9,
        icon: 'assets/icons/atom.svg',
      ),
      3: Algorithm(
        name: l10n.securityPageCyber,
        protection: 0.70,
        cpuLoad: 0.5,
        icon: 'assets/icons/atom.svg',
      ),
    };

    return algorithms.map((algo) {
      return algorithmData[algo] ??
          Algorithm(
            name: l10n.securityPageUnknown,
            protection: 0.0,
            cpuLoad: 0.0,
            icon: 'assets/icons/lock.svg',
          );
    }).toList();
  }
}

class Algorithm {
  final String name;
  final double protection;
  final double cpuLoad;
  final String icon;

  const Algorithm({
    required this.name,
    required this.protection,
    required this.cpuLoad,
    required this.icon,
  });
}

```

`lib/pages/send.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/input_amount.dart';
import 'package:zilpay/components/number_keyboard.dart';
import 'package:zilpay/components/wallet_selector_card.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/amount.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/modals/transfer.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/qrcode.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SendTokenPage extends StatefulWidget {
  const SendTokenPage({super.key});

  @override
  State<SendTokenPage> createState() => _SendTokenPageState();
}

class _SendTokenPageState extends State<SendTokenPage> {
  bool _initialized = false;
  int _tokenIndex = 0;
  String _amount = "0";
  bool _hasDecimalPoint = false;
  String? _address;
  String? _walletName;

  late final AppState _appState;

  bool get _isFormValid => _isValidAmount && _isValidAddress;

  bool get _isValidAddress {
    if (_address == null || _address!.isEmpty) {
      return false;
    }

    return true;
  }

  bool get _isValidAmount {
    if (_amount.endsWith('.')) {
      return false;
    }

    try {
      final numAmount = double.parse(_amount);
      final token = _appState.wallet!.tokens[_tokenIndex];
      final bigBalance = BigInt.parse(
          token.balances[_appState.wallet!.selectedAccount] ?? '0');
      final balance =
          fromWei(value: bigBalance.toString(), decimals: token.decimals);

      return numAmount >= 0 && numAmount <= double.parse(balance);
    } catch (e) {
      debugPrint("amount is not valid $e");
      return false;
    }
  }

  void _updateValue(String value) {
    setState(() {
      _amount = value;
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: l10n.sendTokenPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ScrollConfiguration(
                    behavior: const ScrollBehavior().copyWith(
                      physics: const BouncingScrollPhysics(),
                      overscroll: true,
                    ),
                    child: SingleChildScrollView(
                      physics: const AlwaysScrollableScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          children: [
                            const SizedBox(height: 16),
                            TokenAmountCard(
                              amount: _amount,
                              tokenIndex: _tokenIndex,
                              onMaxTap: _updateValue,
                              onTokenSelected: (int value) {
                                setState(() {
                                  _tokenIndex = value;
                                  _amount = '0';
                                });
                              },
                            ),
                            SvgPicture.asset(
                              "assets/icons/down_arrow.svg",
                              width: 20,
                              height: 20,
                              colorFilter: ColorFilter.mode(
                                theme.textSecondary.withValues(alpha: 0.1),
                                BlendMode.srcIn,
                              ),
                            ),
                            WalletSelectionCard(
                              address: _address,
                              walletName: _walletName,
                              onChange: updateAddress,
                            ),
                            NumberKeyboard(
                              onKeyPressed: (value) {
                                handleKeyPress(value.toString());
                              },
                              onBackspace: handleBackspace,
                              onDotPress: () => handleKeyPress("."),
                            ),
                            CustomButton(
                              textColor: theme.buttonText,
                              backgroundColor: theme.primaryPurple,
                              text: l10n.sendTokenPageSubmitButton,
                              onPressed: () => handleSubmit(appState),
                              disabled: !_isFormValid,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (!_initialized) {
      final args =
          ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
      final int? argTokenIndex = args?['token_index'];

      if (argTokenIndex != null) {
        setState(() {
          _tokenIndex = argTokenIndex;
        });
      }
      _initialized = true;
    }
  }

  void handleBackspace() {
    setState(() {
      if (_amount.length > 1) {
        if (_amount[_amount.length - 1] == '.') {
          _hasDecimalPoint = false;
        }
        _amount = _amount.substring(0, _amount.length - 1);
      } else {
        _amount = "0";
        _hasDecimalPoint = false;
      }
    });
  }

  void handleKeyPress(String value) {
    if (value == ".") {
      if (!_hasDecimalPoint) {
        setState(() {
          _hasDecimalPoint = true;
          if (_amount == "0") {
            _amount = "0.";
          } else {
            _amount += value;
          }
        });
      }
      return;
    }

    setState(() {
      if (_hasDecimalPoint) {
        _amount += value;
      } else {
        if (_amount == "0") {
          _amount = value;
        } else {
          _amount += value;
        }
      }
    });
  }

  void handleSubmit(AppState appState) async {
    if (!_isFormValid) {
      return;
    }

    try {
      BigInt accountIndex = appState.wallet!.selectedAccount;
      FTokenInfo token = appState.wallet!.tokens[_tokenIndex];
      TokenTransferParamsInfo params = TokenTransferParamsInfo(
        walletIndex: BigInt.from(appState.selectedWallet),
        accountIndex: accountIndex,
        token: token,
        amount: toDecimalsWei(_amount, token.decimals).toString(),
        recipient: _address ?? "",
        icon: processTokenLogo(
          token: token,
          shortName: appState.chain?.shortName ?? '',
          theme: appState.currentTheme.value,
        ),
      );

      TransactionRequestInfo tx = await createTokenTransfer(params: params);
      if (!mounted) return;
      showConfirmTransactionModal(
        context: context,
        tx: tx,
        to: _address!,
        token: token,
        amount: _amount,
        onConfirm: (_) {
          Navigator.of(context).pushNamed('/', arguments: {
            'selectedIndex': 1,
          });
        },
      );
    } catch (e) {
      if (!mounted) return;

      String errorMessage = e.toString();

      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          backgroundColor: appState.currentTheme.cardBackground,
          title: Text(
            "Error",
            style: TextStyle(color: appState.currentTheme.textPrimary),
          ),
          content: Text(
            errorMessage,
            style: TextStyle(color: appState.currentTheme.danger),
          ),
          actions: [],
        ),
      );
    }
  }

  @override
  void initState() {
    super.initState();
    _appState = Provider.of<AppState>(context, listen: false);
  }

  void updateAddress(QRcodeScanResultInfo params, String name) {
    setState(() {
      if (params.recipient.isNotEmpty) {
        _address = params.recipient;
      }

      if (params.amount != null && params.amount!.isNotEmpty) {
        _amount = params.amount!;
      }

      _walletName = name;
    });

    Navigator.pop(context);
  }

  void updateAmount(String value) {
    setState(() {
      if (_amount == "0" && value != ".") {
        _amount = value;
      } else {
        _amount += value;
      }
    });
  }
}

```

`lib/pages/settings_page.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/settings_item.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/services/social_media.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import '../theme/app_theme.dart';

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final SocialMediaService socialMediaService = SocialMediaService();
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    final Color effectiveBgColor = Theme.of(context).scaffoldBackgroundColor;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        toolbarHeight: 0,
        systemOverlayStyle: overlayStyle,
      ),
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  child: CustomAppBar(
                    title: AppLocalizations.of(context)!.settingsPageTitle,
                    onBackPressed: () => Navigator.pop(context),
                  ),
                ),
                Expanded(
                  child: ScrollConfiguration(
                    behavior: const ScrollBehavior().copyWith(
                      physics: const BouncingScrollPhysics(),
                      overscroll: true,
                    ),
                    child: SingleChildScrollView(
                      physics: const AlwaysScrollableScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          children: [
                            _buildWalletSection(theme, appState),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              if (appState.chain?.slip44 == 313 &&
                                  appState.wallet != null &&
                                  !appState.wallet!.walletType.contains(WalletType
                                      .ledger
                                      .name)) // 313 this is officially  zilliqa slip44 number.
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 16, vertical: 4),
                                  child: Row(
                                    children: [
                                      SvgPicture.asset(
                                        'assets/icons/scilla.svg',
                                        width: 24,
                                        height: 24,
                                        colorFilter: ColorFilter.mode(
                                          theme.textPrimary,
                                          BlendMode.srcIn,
                                        ),
                                      ),
                                      const SizedBox(width: 12),
                                      Expanded(
                                        child: Text(
                                          AppLocalizations.of(context)!
                                              .settingsPageZilliqaLegacy,
                                          style: TextStyle(
                                            color: theme.textPrimary,
                                            fontSize: 16,
                                          ),
                                        ),
                                      ),
                                      Switch(
                                        padding: EdgeInsets.all(0),
                                        value: appState.account?.addrType == 0,
                                        onChanged: (bool value) async {
                                          BigInt walletIndex = BigInt.from(
                                              appState.selectedWallet);
                                          await zilliqaSwapChain(
                                            walletIndex: walletIndex,
                                            accountIndex: appState
                                                .wallet!.selectedAccount,
                                          );
                                          await appState.syncData();

                                          try {
                                            await syncBalances(
                                              walletIndex: walletIndex,
                                            );
                                            await appState.syncData();
                                          } catch (_) {}
                                        },
                                        activeThumbColor: theme.primaryPurple,
                                        activeTrackColor: theme.primaryPurple
                                            .withValues(alpha: 0.5),
                                      ),
                                    ],
                                  ),
                                ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageCurrency,
                                trailingSvgPath: 'assets/icons/currency.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/currency'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageAppearance,
                                trailingSvgPath: 'assets/icons/appearance.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/appearance'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageNotifications,
                                trailingSvgPath: 'assets/icons/bell.svg',
                                onTap: () => Navigator.pushNamed(
                                    context, '/notifications'),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: true,
                                title: AppLocalizations.of(context)!
                                    .settingsPageAddressBook,
                                trailingSvgPath: 'assets/icons/book.svg',
                                onTap: () => Navigator.pushNamed(
                                    context, '/address-book'),
                              ),
                            ]),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              SettingsItem(
                                isFirst: true,
                                isLast: false,
                                title: AppLocalizations.of(context)!
                                    .settingsPageSecurityPrivacy,
                                trailingSvgPath: 'assets/icons/shield.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/security'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageNetworks,
                                trailingSvgPath: 'assets/icons/globe.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/networks'),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: false,
                                title: AppLocalizations.of(context)!
                                    .settingsPageLanguage,
                                trailingSvgPath: 'assets/icons/language.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/language'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageBrowser,
                                trailingSvgPath: 'assets/icons/browser.svg',
                                onTap: () => Navigator.pushNamed(
                                    context, '/browser_settings'),
                              ),
                            ]),
                            const SizedBox(height: 24),
                            _buildSettingsGroup(theme, [
                              SettingsItem(
                                isFirst: true,
                                isLast: false,
                                title: AppLocalizations.of(context)!
                                    .settingsPageTelegram,
                                trailingSvgPath: 'assets/icons/telegram.svg',
                                onTap: () => socialMediaService.openTelegram(
                                    username: 'zilpaychat'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageTwitter,
                                trailingSvgPath: 'assets/icons/x.svg',
                                onTap: () => socialMediaService.openX(
                                    username: 'pay_zil'),
                              ),
                              SettingsItem(
                                title: AppLocalizations.of(context)!
                                    .settingsPageGitHub,
                                trailingSvgPath: 'assets/icons/github.svg',
                                onTap: () => socialMediaService.openGitHub(
                                  username: 'zilpay',
                                  repository: 'zilpay-mobile',
                                ),
                              ),
                              SettingsItem(
                                isFirst: false,
                                isLast: true,
                                title: AppLocalizations.of(context)!
                                    .settingsPageAbout,
                                trailingSvgPath: 'assets/icons/info.svg',
                                onTap: () =>
                                    Navigator.pushNamed(context, '/about'),
                              ),
                            ]),
                            SizedBox(height: adaptivePadding),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildWalletSection(AppTheme theme, AppState appState) {
    final chain = appState.chain!;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => Navigator.pushNamed(context, '/wallet'),
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: theme.cardBackground,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: theme.background,
                borderRadius: BorderRadius.circular(20),
              ),
              child: AsyncImage(
                url: viewChain(network: chain, theme: theme.value),
                width: 32,
                height: 32,
                fit: BoxFit.contain,
                errorWidget: Blockies(
                  seed: appState.wallet!.walletAddress,
                  color: theme.secondaryPurple,
                  bgColor: theme.primaryPurple,
                  spotColor: theme.background,
                  size: 8,
                ),
                loadingWidget: const Center(
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 16),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(appState.wallet!.walletName,
                    style: theme.caption.copyWith(
                      color: theme.textSecondary,
                    )),
                Text(
                  appState.chain?.name ?? "",
                  style: theme.headline2.copyWith(
                    color: theme.textPrimary,
                    fontSize: 21,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSettingsGroup(AppTheme theme, List<Widget> items) {
    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        children: List.generate(items.length, (index) {
          final item = items[index];
          final isLast = index == items.length - 1;
          return Column(
            children: [
              item,
              if (!isLast)
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  child: Divider(
                    height: 1,
                    color: theme.textSecondary.withValues(alpha: 0.1),
                  ),
                ),
            ],
          );
        }),
      ),
    );
  }
}

```

`lib/pages/setup_cipher.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/config/argon.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/argon2.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/settings.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class CipherSettingsPage extends StatefulWidget {
  const CipherSettingsPage({super.key});

  @override
  State<CipherSettingsPage> createState() => _CipherSettingsPageState();
}

class _CipherSettingsPageState extends State<CipherSettingsPage> {
  List<String>? _bip39List;
  NetworkConfigInfo? _chain;
  KeyPairInfo? _keys;
  bool _bypassChecksumValidation = false;
  WalletArgonParamsInfo _argonParams = Argon2DefaultParams.owaspDefault();
  int selectedCipherIndex = 2;

  final List<Map<String, String>> cipherDescriptions = [
    {
      'title': '',
      'subtitle': '',
      'description': '',
    },
    {
      'title': '',
      'subtitle': '',
      'description': '',
    },
    {
      'title': '',
      'subtitle': '',
      'description': '',
    },
  ];

  void _onAdvancedPressed() {
    showArgonSettingsModal(
      context: context,
      onParamsSelected: (params) => setState(() => _argonParams = params),
      argonParams: _argonParams,
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    if (args == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
      return;
    }
    setState(() {
      _bip39List = args['bip39'] as List<String>?;
      _chain = args['chain'] as NetworkConfigInfo?;
      _keys = args['keys'] as KeyPairInfo?;
      _bypassChecksumValidation = args['ignore_checksum'] as bool? ?? false;
    });

    cipherDescriptions[0]['title'] =
        AppLocalizations.of(context)!.cipherSettingsPageStandardTitle;
    cipherDescriptions[0]['subtitle'] =
        AppLocalizations.of(context)!.cipherSettingsPageStandardSubtitle;
    cipherDescriptions[0]['description'] =
        AppLocalizations.of(context)!.cipherSettingsPageStandardDescription;
    cipherDescriptions[1]['title'] =
        AppLocalizations.of(context)!.cipherSettingsPageHybridTitle;
    cipherDescriptions[1]['subtitle'] =
        AppLocalizations.of(context)!.cipherSettingsPageHybridSubtitle;
    cipherDescriptions[1]['description'] =
        AppLocalizations.of(context)!.cipherSettingsPageHybridDescription;
    cipherDescriptions[2]['title'] =
        AppLocalizations.of(context)!.cipherSettingsPageQuantumTitle;
    cipherDescriptions[2]['subtitle'] =
        AppLocalizations.of(context)!.cipherSettingsPageQuantumSubtitle;
    cipherDescriptions[2]['description'] =
        AppLocalizations.of(context)!.cipherSettingsPageQuantumDescription;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final padding = AdaptiveSize.getAdaptivePadding(context, 16);

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title: AppLocalizations.of(context)!.cipherSettingsPageTitle,
                  onBackPressed: () => Navigator.pop(context),
                ),
                Expanded(
                  child: SingleChildScrollView(
                    physics: const BouncingScrollPhysics(),
                    padding: EdgeInsets.symmetric(horizontal: padding),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: _onAdvancedPressed,
                          style: ButtonStyle(
                            overlayColor: const WidgetStatePropertyAll(
                                Colors.transparent),
                            foregroundColor: WidgetStateProperty.resolveWith(
                              (states) => states.contains(WidgetState.pressed)
                                  ? theme.primaryPurple.withValues(alpha: 0.7)
                                  : theme.primaryPurple,
                            ),
                          ),
                          child: Text(
                            AppLocalizations.of(context)!
                                .cipherSettingsPageAdvancedButton,
                            style: const TextStyle(
                                fontSize: 16, fontWeight: FontWeight.w500),
                          ),
                        ),
                        OptionsList(
                          options: List.generate(
                            cipherDescriptions.length,
                            (index) => OptionItem(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    cipherDescriptions[index]['title']!,
                                    style: TextStyle(
                                      color: theme.textPrimary,
                                      fontSize: 16,
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                  Text(
                                    cipherDescriptions[index]['subtitle']!,
                                    style: TextStyle(
                                      color: theme.primaryPurple,
                                      fontSize: 14,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                  Text(
                                    cipherDescriptions[index]['description']!,
                                    style: TextStyle(
                                      color: theme.textSecondary,
                                      fontSize: 14,
                                    ),
                                  ),
                                ],
                              ),
                              isSelected: selectedCipherIndex == index,
                              onSelect: () =>
                                  setState(() => selectedCipherIndex = index),
                            ),
                          ),
                          unselectedOpacity: 0.5,
                        ),
                      ],
                    ),
                  ),
                ),
                Padding(
                  padding: EdgeInsets.all(padding),
                  child: Column(
                    children: [
                      if (selectedCipherIndex == 2)
                        Text(
                          AppLocalizations.of(context)!
                              .cipherSettingsPageQuantumWarning,
                          style: TextStyle(
                            color: theme.textSecondary,
                            fontSize: 14,
                            fontStyle: FontStyle.italic,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      CustomButton(
                        textColor: theme.buttonText,
                        backgroundColor: theme.primaryPurple,
                        text: AppLocalizations.of(context)!
                            .cipherSettingsPageConfirmButton,
                        onPressed: () => Navigator.of(context).pushNamed(
                          '/pass_setup',
                          arguments: {
                            'bip39': _bip39List,
                            'chain': _chain,
                            'keys': _keys,
                            'cipher': _getCipherOrders(),
                            'argon2': _argonParams,
                            'ignore_checksum': _bypassChecksumValidation,
                          },
                        ),
                        borderRadius: 30.0,
                        height: 50.0,
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Uint8List _getCipherOrders() {
    switch (selectedCipherIndex) {
      case 0:
        return Uint8List.fromList([0, 1]); // AES-256 + KUZNECHIK-GOST
      case 1:
        return Uint8List.fromList([1, 3]); // CYBER + KUZNECHIK-GOST
      case 2:
        return Uint8List.fromList([3, 2, 1]); // CYBER + KUZNECHIK + NTRUP1277
      default:
        return Uint8List.fromList([3, 2, 1]); // CYBER + KUZNECHIK + NTRUP1277
    }
  }
}

```

`lib/pages/setup_net.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:ledger_flutter_plus/ledger_flutter_plus.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/option_list.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SetupNetworkSettingsPage extends StatefulWidget {
  const SetupNetworkSettingsPage({super.key});

  @override
  State<SetupNetworkSettingsPage> createState() =>
      _SetupNetworkSettingsPageState();
}

class _SetupNetworkSettingsPageState extends State<SetupNetworkSettingsPage> {
  List<String>? _bip39List;
  KeyPairInfo? _keys;
  LedgerDevice? _ledger;
  String? _errorMessage;
  String? _shortName;
  bool _bypassChecksumValidation = false;
  bool _isTestnet = false;

  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  int selectedNetworkIndex = 0;
  bool optionsDisabled = false;
  List<NetworkConfigInfo> mainnetNetworks = [];
  List<NetworkConfigInfo> testnetNetworks = [];

  @override
  void initState() {
    super.initState();
    _loadChains();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args =
        ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
    final bip39 = args?['bip39'] as List<String>?;
    final keys = args?['keys'] as KeyPairInfo?;
    final shortName = args?['shortName'] as String?;
    final ledger = args?['ledger'] as LedgerDevice?;
    final bypassChecksumValidation = args?['ignore_checksum'] as bool?;

    if (bip39 == null && keys == null && ledger == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = bip39;
        _ledger = ledger;
        _keys = keys;
        _shortName = shortName;
        _bypassChecksumValidation = bypassChecksumValidation ?? false;
      });
    }
  }

  List<NetworkConfigInfo> get filteredNetworks {
    final networks = _isTestnet ? testnetNetworks : mainnetNetworks;
    if (_searchQuery.isEmpty) {
      return networks;
    }
    return networks.where((network) {
      final searchLower = _searchQuery.toLowerCase();
      return network.name.toLowerCase().contains(searchLower) ||
          network.chain.toLowerCase().contains(searchLower) ||
          network.chainId.toString().contains(searchLower);
    }).toList();
  }

  Future<void> _loadChains() async {
    try {
      final appState = Provider.of<AppState>(context, listen: false);
      final storedProviders = appState.state.providers;

      final String mainnetJsonData =
          await rootBundle.loadString('assets/chains/mainnet-chains.json');
      final String testnetJsonData =
          await rootBundle.loadString('assets/chains/testnet-chains.json');
      final List<NetworkConfigInfo> mainnetChains =
          await getChainsProvidersFromJson(jsonStr: mainnetJsonData);
      final List<NetworkConfigInfo> testnetChains =
          await getChainsProvidersFromJson(jsonStr: testnetJsonData);

      setState(() {
        mainnetNetworks = mainnetChains;
        mainnetNetworks =
            _appendUniqueMainnetNetworks(storedProviders, mainnetNetworks);
        testnetNetworks = testnetChains;

        if (_shortName != null) {
          final networks = _isTestnet ? testnetNetworks : mainnetNetworks;
          int foundIndex =
              networks.indexWhere((network) => network.shortName == _shortName);
          if (foundIndex > 0) {
            selectedNetworkIndex = foundIndex;
          }
        }
      });
    } catch (e) {
      setState(() {
        _errorMessage = '$e';
      });
      debugPrint('Error loading chains: $e');
    }
  }

  List<NetworkConfigInfo> _appendUniqueMainnetNetworks(
      List<NetworkConfigInfo> storedProviders,
      List<NetworkConfigInfo> jsonChains) {
    final Set<String> jsonNetworkIds =
        jsonChains.map(_createNetworkIdentifier).toSet();
    final List<NetworkConfigInfo> uniqueStoredNetworks = [];

    for (final provider in storedProviders) {
      if (!(provider.testnet ?? false)) {
        final identifier = _createNetworkIdentifier(provider);
        if (!jsonNetworkIds.contains(identifier)) {
          uniqueStoredNetworks.add(provider);
        }
      }
    }

    return [...jsonChains, ...uniqueStoredNetworks];
  }

  String _createNetworkIdentifier(NetworkConfigInfo network) {
    return '${network.slip44}|${network.chainId}';
  }

  OptionItem _buildNetworkItem(
      NetworkConfigInfo chain, AppTheme theme, int index) {
    final l10n = AppLocalizations.of(context)!;

    return OptionItem(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              SizedBox(
                width: 40,
                height: 40,
                child: AsyncImage(
                  url: viewChain(network: chain, theme: theme.value),
                  fit: BoxFit.contain,
                  errorWidget: const Icon(Icons.error),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Expanded(
                          child: Text(
                            chain.name,
                            style: TextStyle(
                              color: theme.textPrimary,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: _isTestnet
                                ? theme.warning.withValues(alpha: 0.2)
                                : theme.success.withValues(alpha: 0.2),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text(
                            _isTestnet
                                ? l10n.setupNetworkSettingsPageTestnetLabel
                                : l10n.setupNetworkSettingsPageMainnetLabel,
                            style: TextStyle(
                              color: _isTestnet ? theme.warning : theme.success,
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${l10n.setupNetworkSettingsPageChainIdLabel} ${chain.chainIds.where((id) => id != BigInt.zero).toList().join(",")}',
                      style: TextStyle(
                        color: theme.primaryPurple,
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${l10n.setupNetworkSettingsPageTokenLabel} ${chain.chain}',
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 14,
                      ),
                    ),
                    if (chain.explorers.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        '${l10n.setupNetworkSettingsPageExplorerLabel} ${chain.explorers.first.name}',
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 12,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
      isSelected: selectedNetworkIndex == index,
      onSelect: () => setState(() => selectedNetworkIndex = index),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  actionWidget: Row(
                    children: [
                      Text(
                        l10n.setupNetworkSettingsPageTestnetSwitch,
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Switch(
                        value: _isTestnet,
                        onChanged: (value) {
                          setState(() {
                            _isTestnet = value;
                            selectedNetworkIndex = 0;
                          });
                        },
                        activeThumbColor: theme.primaryPurple,
                      ),
                    ],
                  ),
                  onBackPressed: () => Navigator.pop(context),
                ),
                Padding(
                  padding: EdgeInsets.all(adaptivePadding),
                  child: SmartInput(
                    controller: _searchController,
                    hint: l10n.setupNetworkSettingsPageSearchHint,
                    leftIconPath: 'assets/icons/search.svg',
                    onChanged: (value) => setState(() => _searchQuery = value),
                    borderColor: theme.textPrimary,
                    focusedBorderColor: theme.primaryPurple,
                    height: 48,
                    fontSize: 16,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                  ),
                ),
                if (_errorMessage != null)
                  Padding(
                    padding: EdgeInsets.all(adaptivePadding),
                    child: Text(
                      _errorMessage!,
                      style: TextStyle(
                        color: theme.danger,
                        fontSize: 14,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  )
                else if (filteredNetworks.isEmpty)
                  Expanded(
                    child: Center(
                      child: Text(
                        mainnetNetworks.isEmpty && testnetNetworks.isEmpty
                            ? l10n.setupNetworkSettingsPageNoNetworks
                            : l10n.setupNetworkSettingsPageNoResults(
                                _searchQuery),
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 16,
                        ),
                      ),
                    ),
                  )
                else
                  Expanded(
                    child: SingleChildScrollView(
                      physics: const BouncingScrollPhysics(),
                      child: Padding(
                        padding:
                            EdgeInsets.symmetric(horizontal: adaptivePadding),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            OptionsList(
                              disabled: optionsDisabled,
                              options: List.generate(
                                filteredNetworks.length,
                                (index) => _buildNetworkItem(
                                    filteredNetworks[index], theme, index),
                              ),
                              unselectedOpacity: 0.5,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                Padding(
                  padding: EdgeInsets.all(adaptivePadding),
                  child: CustomButton(
                    textColor: theme.buttonText,
                    backgroundColor: theme.primaryPurple,
                    text: l10n.setupNetworkSettingsPageNextButton,
                    onPressed: filteredNetworks.isEmpty
                        ? () {}
                        : () {
                            final chain = _isTestnet
                                ? testnetNetworks[selectedNetworkIndex]
                                : mainnetNetworks[selectedNetworkIndex];

                            if (_ledger != null) {
                              Navigator.of(context).pushNamed(
                                '/add_ledger_account',
                                arguments: {
                                  'chain': chain,
                                  'isTestnet': _isTestnet,
                                  'ledger': _ledger,
                                },
                              );
                              return;
                            } else {
                              Navigator.of(context).pushNamed(
                                '/cipher_setup',
                                arguments: {
                                  'bip39': _bip39List,
                                  'keys': _keys,
                                  'chain': chain,
                                  'isTestnet': _isTestnet,
                                  'ignore_checksum': _bypassChecksumValidation,
                                },
                              );
                            }
                          },
                    borderRadius: 30.0,
                    height: 56.0,
                  ),
                )
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

`lib/pages/sk_gen.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/hex_key.dart';
import 'package:zilpay/components/tile_button.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/modals/backup_confirmation_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class SecretKeyGeneratorPage extends StatefulWidget {
  const SecretKeyGeneratorPage({super.key});

  @override
  State<SecretKeyGeneratorPage> createState() => _CreateAccountPageState();
}

class _CreateAccountPageState extends State<SecretKeyGeneratorPage> {
  KeyPairInfo _keyPair = KeyPairInfo(sk: "", pk: "");
  bool _hasBackupWords = false;
  bool isCopied = false;

  @override
  void initState() {
    super.initState();
    _regenerateKeys();
  }

  Future<void> _regenerateKeys() async {
    KeyPairInfo keyPair = await genKeypair();
    setState(() {
      _hasBackupWords = false;
      _keyPair = keyPair;
    });
  }

  @override
  Widget build(BuildContext context) {
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            CustomAppBar(
              title: l10n.secretKeyGeneratorPageTitle,
              onBackPressed: () => Navigator.pop(context),
              actionIcon: SvgPicture.asset(
                'assets/icons/reload.svg',
                width: 30,
                height: 30,
                colorFilter: ColorFilter.mode(
                  theme.textPrimary,
                  BlendMode.srcIn,
                ),
              ),
              onActionPressed: _regenerateKeys,
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                child: Column(
                  children: [
                    Expanded(
                      flex: 4,
                      child: SingleChildScrollView(
                        child: Column(
                          children: [
                            HexKeyDisplay(
                              hexKey: _keyPair.sk,
                              title: l10n.secretKeyGeneratorPagePrivateKey,
                            ),
                            const SizedBox(height: 16),
                            HexKeyDisplay(
                              hexKey: _keyPair.pk,
                              title: l10n.secretKeyGeneratorPagePublicKey,
                            ),
                          ],
                        ),
                      ),
                    ),
                    SizedBox(
                      height: MediaQuery.of(context).size.height * 0.3,
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Container(
                            constraints: const BoxConstraints(maxWidth: 480),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Row(
                                  children: [
                                    Expanded(
                                      child: Theme(
                                        data: Theme.of(context).copyWith(
                                          splashFactory: NoSplash.splashFactory,
                                          highlightColor: Colors.transparent,
                                        ),
                                        child: CheckboxListTile(
                                          title: Text(
                                            l10n.secretKeyGeneratorPageBackupCheckbox,
                                            style: TextStyle(
                                              color: theme.textSecondary,
                                            ),
                                          ),
                                          value: _hasBackupWords,
                                          onChanged: (_) {
                                            if (!_hasBackupWords) {
                                              showBackupConfirmationModal(
                                                context: context,
                                                onConfirmed: (confirmed) {
                                                  setState(() {
                                                    _hasBackupWords = confirmed;
                                                  });
                                                },
                                              );
                                            }
                                          },
                                          controlAffinity:
                                              ListTileControlAffinity.leading,
                                          activeColor: theme.primaryPurple,
                                        ),
                                      ),
                                    ),
                                    TileButton(
                                      icon: SvgPicture.asset(
                                        isCopied
                                            ? "assets/icons/check.svg"
                                            : "assets/icons/copy.svg",
                                        width: 24,
                                        height: 24,
                                        colorFilter: ColorFilter.mode(
                                          theme.primaryPurple,
                                          BlendMode.srcIn,
                                        ),
                                      ),
                                      disabled: false,
                                      onPressed: () async {
                                        await _handleCopy(_keyPair.sk);
                                      },
                                      backgroundColor: theme.cardBackground,
                                      textColor: theme.primaryPurple,
                                    ),
                                  ],
                                ),
                                const SizedBox(
                                  height: 16,
                                ),
                                CustomButton(
                                  textColor: theme.buttonText,
                                  backgroundColor: theme.primaryPurple,
                                  text: l10n.secretKeyGeneratorPageNextButton,
                                  onPressed: () {
                                    Navigator.of(context).pushNamed(
                                      '/net_setup',
                                      arguments: {'keys': _keyPair},
                                    );
                                  },
                                  borderRadius: 30.0,
                                  height: 56.0,
                                  disabled: !_hasBackupWords,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _handleCopy(String address) async {
    await Clipboard.setData(ClipboardData(text: address));
    setState(() {
      isCopied = true;
    });
    await Future<void>.delayed(const Duration(seconds: 2));
    setState(() {
      isCopied = false;
    });
  }
}

```

`lib/pages/verify_bip39.dart`:

```dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:zilpay/components/button.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/mnemonic_word_input.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/l10n/app_localizations.dart';

List<int> getRandomNumbers(int min, int max, int count) {
  final random = Random();
  Set<int> numbers = {};

  while (numbers.length < count) {
    int randomNumber = min + random.nextInt(max - min);
    numbers.add(randomNumber);
  }

  return numbers.toList();
}

const maxNumbers = 4;

class SecretPhraseVerifyPage extends StatefulWidget {
  const SecretPhraseVerifyPage({
    super.key,
  });

  @override
  State<SecretPhraseVerifyPage> createState() => _VerifyBip39PageState();
}

class _VerifyBip39PageState extends State<SecretPhraseVerifyPage> {
  List<String>? _bip39List;
  List<int> _indexes = [];
  final List<String> _verifyWords =
      List<String>.filled(maxNumbers, '', growable: false);

  void _generateIndexes() {
    if (_bip39List != null && _bip39List!.isNotEmpty) {
      setState(() {
        _indexes = getRandomNumbers(0, _bip39List!.length, maxNumbers);
      });
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args = ModalRoute.of(context)?.settings.arguments
        as Map<String, List<String>>?;

    if (args == null || args['bip39'] == null || args['bip39']!.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacementNamed('/initial');
      });
    } else {
      setState(() {
        _bip39List = args['bip39'];
        _generateIndexes();
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Provider.of<AppState>(context).currentTheme;

    return Scaffold(
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: Column(
              children: [
                CustomAppBar(
                  title:
                      AppLocalizations.of(context)!.secretPhraseVerifyPageTitle,
                  onBackPressed: () => Navigator.pop(context),
                  // actionWidget: TextButton(
                  //   onPressed: () {
                  //     Navigator.of(context).pushNamed('/net_setup',
                  //         arguments: {'bip39': _bip39List});
                  //   },
                  //   child: Text(
                  //     AppLocalizations.of(context)!
                  //         .secretPhraseVerifyPageSkipButton,
                  //     style: TextStyle(
                  //       color: theme.textPrimary,
                  //       fontSize: 16,
                  //       fontWeight: FontWeight.w500,
                  //     ),
                  //   ),
                  // ),
                ),
                Expanded(
                  child: _bip39List == null
                      ? const Center(child: CircularProgressIndicator())
                      : Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                AppLocalizations.of(context)!
                                    .secretPhraseVerifyPageSubtitle,
                                style: TextStyle(
                                  fontSize: 24,
                                  fontWeight: FontWeight.bold,
                                  color: theme.textPrimary,
                                ),
                              ),
                              const SizedBox(height: 16),
                              Expanded(
                                child: ListView.builder(
                                  physics: const BouncingScrollPhysics(),
                                  itemCount: maxNumbers,
                                  itemBuilder: (context, index) {
                                    final wordIndex = _indexes[index];
                                    final displayIndex = wordIndex + 1;

                                    return Padding(
                                      padding: const EdgeInsets.symmetric(
                                          vertical: 8.0),
                                      child: MnemonicWordInput(
                                        index: displayIndex,
                                        word: _verifyWords[index],
                                        isEditable: true,
                                        borderColor: _verifyWords[index] == ''
                                            ? theme.textSecondary
                                            : _bip39List![wordIndex] ==
                                                    _verifyWords[index]
                                                ? Colors.green
                                                : Colors.red,
                                        onChanged: (_, newWord) {
                                          setState(() {
                                            _verifyWords[index] = newWord;
                                          });
                                        },
                                      ),
                                    );
                                  },
                                ),
                              ),
                              Padding(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 16.0),
                                child: CustomButton(
                                  textColor: theme.buttonText,
                                  backgroundColor: theme.primaryPurple,
                                  text: AppLocalizations.of(context)!
                                      .secretPhraseVerifyPageNextButton,
                                  onPressed: () {
                                    Navigator.of(context).pushNamed(
                                        '/net_setup',
                                        arguments: {'bip39': _bip39List});
                                  },
                                  borderRadius: 30.0,
                                  height: 56.0,
                                  disabled: !isVerified,
                                ),
                              ),
                            ],
                          ),
                        ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  bool get isVerified {
    if (_bip39List == null ||
        _indexes.length != maxNumbers ||
        _verifyWords.length != maxNumbers) {
      return false;
    }

    for (int i = 0; i < maxNumbers; i++) {
      int bip39Index = _indexes[i];

      if (bip39Index < 0 || bip39Index >= _bip39List!.length) {
        return false;
      }

      if (_bip39List![bip39Index].trim().toLowerCase() !=
          _verifyWords[i].trim().toLowerCase()) {
        return false;
      }
    }

    return true;
  }
}

```

`lib/pages/wallet.dart`:

```dart
import 'package:blockies/blockies.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/image_cache.dart';
import 'package:zilpay/components/smart_input.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/biometric_switch.dart';
import 'package:zilpay/mixins/preprocess_url.dart';
import 'package:zilpay/mixins/wallet_type.dart';
import 'package:zilpay/modals/confirm_password.dart';
import 'package:zilpay/modals/delete_wallet.dart';
import 'package:zilpay/modals/manage_connections.dart';
import 'package:zilpay/modals/secret_recovery_modal.dart';
import 'package:zilpay/services/auth_guard.dart';
import 'package:zilpay/services/biometric_service.dart';
import 'package:zilpay/services/device.dart';
import 'package:zilpay/src/rust/api/connections.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/state/app_state.dart';
import '../theme/app_theme.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class WalletPreferenceItem {
  final String title;
  final String iconPath;
  final bool hasSwitch;
  final bool switchValue;
  final bool switchEnabled;
  final Function(bool)? onChanged;
  final VoidCallback? onTap;

  WalletPreferenceItem({
    required this.title,
    required this.iconPath,
    this.hasSwitch = false,
    this.switchValue = false,
    this.switchEnabled = true,
    this.onChanged,
    this.onTap,
  });
}

class WalletPage extends StatefulWidget {
  const WalletPage({super.key});

  @override
  State<WalletPage> createState() => _WalletPageState();
}

class _WalletPageState extends State<WalletPage> {
  late final AuthGuard _authGuard;
  final AuthService _authService = AuthService();
  final TextEditingController _walletNameController = TextEditingController();
  static const double _avatarSize = 80.0;
  static const double _borderRadius = 12.0;
  static const double _iconSize = 24.0;
  static const double _fontSize = 16.0;

  List<AuthMethod> _authMethods = [AuthMethod.none];
  bool _biometricsAvailable = false;
  bool _isBiometricLoading = false;

  @override
  void initState() {
    super.initState();
    _authGuard = Provider.of<AuthGuard>(context, listen: false);
    final appState = Provider.of<AppState>(context, listen: false);
    _walletNameController.text = appState.wallet!.walletName;
    appState.syncConnections();
    _checkAuthMethods();
  }

  @override
  void dispose() {
    _walletNameController.dispose();
    super.dispose();
  }

  Future<void> _checkAuthMethods() async {
    try {
      final methods = await _authService.getAvailableAuthMethods();

      setState(() {
        _authMethods = methods;
        _biometricsAvailable =
            methods.isNotEmpty && methods.first != AuthMethod.none;
      });
    } catch (e) {
      debugPrint("Error checking auth methods: $e");
      setState(() {
        _authMethods = [AuthMethod.none];
        _biometricsAvailable = false;
      });
    }
  }

  void _handleDappDisconnect(String url) async {
    AppState appState = Provider.of<AppState>(context, listen: false);
    await removeConnections(
      walletIndex: BigInt.from(appState.selectedWallet),
      domain: url,
    );
    await appState.syncConnections();
  }

  Future<void> _handleToggleBiometric(bool enable, AppState appState) async {
    if (_isBiometricLoading) return;

    setState(() {
      _isBiometricLoading = true;
    });

    try {
      final wallet = appState.wallet;
      if (wallet == null) {
        setState(() {
          _isBiometricLoading = false;
        });
        return;
      }

      final device = DeviceInfoService();
      final identifiers = await device.getDeviceIdentifiers();

      if (enable && mounted) {
        showConfirmPasswordModal(
          context: context,
          theme: appState.currentTheme,
          onDismiss: () {
            if (mounted) {
              setState(() {
                _isBiometricLoading = false;
              });
            }
          },
          onConfirm: (password) async {
            try {
              final authenticated = await _authService.authenticate(
                allowPinCode: true,
                reason: AppLocalizations.of(context)!.walletPageBiometricReason,
              );

              if (!authenticated) {
                return "Authorization declined for biometrics";
              }

              final biometricType = _authMethods.first.name;

              final session = await setBiometric(
                walletIndex: BigInt.from(appState.selectedWallet),
                identifiers: identifiers,
                password: password,
                newBiometricType: biometricType,
              );

              if (session != null) {
                await _authGuard.setSession(wallet.walletAddress, session);
              }

              await appState.syncData();

              if (mounted) {
                setState(() {
                  _isBiometricLoading = false;
                });
              }

              return null;
            } catch (e) {
              return e.toString();
            }
          },
        );
      } else {
        String? sessionCipher;

        try {
          sessionCipher = await _authGuard.getSession(
            sessionKey: wallet.walletAddress,
            requireAuth: false,
          );
        } catch (e) {
          debugPrint("No session available for disabling biometrics: $e");
        }

        await setBiometric(
          walletIndex: BigInt.from(appState.selectedWallet),
          identifiers: identifiers,
          password: "",
          sessionCipher: sessionCipher,
          newBiometricType: AuthMethod.none.name,
        );
        await _authGuard.setSession(wallet.walletAddress, "");

        if (mounted) {
          setState(() {
            _isBiometricLoading = false;
          });
        }
      }
    } catch (e) {
      debugPrint("Error changing biometric: $e");
      if (mounted) {
        setState(() {
          _isBiometricLoading = false;
        });
      }
    } finally {
      await appState.syncData();
    }
  }

  List<WalletPreferenceItem> _getPreferenceItems(AppState appState) {
    final l10n = AppLocalizations.of(context)!;
    final List<WalletPreferenceItem> items = [];

    items.add(
      WalletPreferenceItem(
        title: l10n.walletPageManageConnections,
        iconPath: 'assets/icons/globe.svg',
        onTap: () {
          if (appState.connections.isNotEmpty) {
            showConnectedDappsModal(
              context: context,
              onDappDisconnect: _handleDappDisconnect,
            );
          }
        },
      ),
    );

    if (!appState.wallet!.walletType.contains(WalletType.ledger.name)) {
      items.add(
        WalletPreferenceItem(
          title: l10n.walletPageBackup,
          iconPath: 'assets/icons/key.svg',
          onTap: () {
            if (!appState.wallet!.walletType.contains(WalletType.ledger.name)) {
              _handleBackup(appState.currentTheme);
            }
          },
        ),
      );
    }

    return items;
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    final Color effectiveBgColor = Theme.of(context).scaffoldBackgroundColor;
    final Brightness backgroundBrightness =
        ThemeData.estimateBrightnessForColor(effectiveBgColor);
    final Brightness statusBarIconBrightness =
        backgroundBrightness == Brightness.light
            ? Brightness.dark
            : Brightness.light;
    final Brightness statusBarBrightness = backgroundBrightness;

    final SystemUiOverlayStyle overlayStyle = SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: statusBarIconBrightness,
      statusBarBrightness: statusBarBrightness,
    );

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        toolbarHeight: 0,
        systemOverlayStyle: overlayStyle,
      ),
      body: SafeArea(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 480),
            child: CustomScrollView(
              slivers: [
                SliverToBoxAdapter(
                  child: Padding(
                    padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                    child: CustomAppBar(
                      title: "",
                      onBackPressed: () => Navigator.pop(context),
                    ),
                  ),
                ),
                SliverPadding(
                  padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
                  sliver: SliverList(
                    delegate: SliverChildListDelegate([
                      Center(child: _buildWalletHeader(theme, appState)),
                      const SizedBox(height: 16),
                      _buildWalletNameInput(theme, appState),
                      const SizedBox(height: 32),
                      _buildPreferencesSection(appState),
                    ]),
                  ),
                ),
                SliverFillRemaining(
                  hasScrollBody: false,
                  fillOverscroll: true,
                  child: Padding(
                    padding: EdgeInsets.only(
                      left: adaptivePadding,
                      right: adaptivePadding,
                      bottom: 24 + MediaQuery.of(context).viewInsets.bottom,
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        _buildRemoveWalletButton(appState),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
      resizeToAvoidBottomInset: true,
    );
  }

  Widget _buildWalletHeader(AppTheme theme, AppState appState) {
    return SizedBox(
      width: _avatarSize,
      height: _avatarSize,
      child: Container(
        decoration: BoxDecoration(
          color: theme.background,
          borderRadius: BorderRadius.circular(_avatarSize / 2),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(_avatarSize / 2),
          child: Transform.scale(
            scale: 1.0,
            child: AsyncImage(
              url: viewChain(network: appState.chain!, theme: theme.value),
              width: 32,
              height: 32,
              fit: BoxFit.contain,
              errorWidget: Blockies(
                seed: appState.wallet!.walletAddress,
                color: theme.secondaryPurple,
                bgColor: theme.primaryPurple,
                spotColor: theme.background,
                size: 8,
              ),
              loadingWidget: const Center(
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildWalletNameInput(AppTheme theme, AppState state) {
    return SmartInput(
      controller: _walletNameController,
      hint: AppLocalizations.of(context)!.walletPageWalletNameHint,
      onSubmitted: (_) async {
        if (_walletNameController.text.isNotEmpty) {
          await changeWalletName(
            walletIndex: BigInt.from(state.selectedWallet),
            newName: _walletNameController.text,
          );
          await state.syncData();
        }
      },
      height: 50,
      rightIconPath: "assets/icons/edit.svg",
      borderColor: theme.cardBackground,
      focusedBorderColor: theme.primaryPurple,
      fontSize: _fontSize,
    );
  }

  Widget _buildPreferencesSection(AppState appState) {
    final theme = appState.currentTheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.only(left: 16, bottom: 16),
          child: Text(
            AppLocalizations.of(context)!.walletPagePreferencesTitle,
            style: TextStyle(
              color: theme.textSecondary,
              fontSize: _fontSize,
            ),
          ),
        ),
        Container(
          decoration: BoxDecoration(
            color: theme.cardBackground,
            borderRadius: BorderRadius.circular(_borderRadius),
          ),
          child: Column(
            children: _buildPreferenceItems(appState),
          ),
        ),
      ],
    );
  }

  List<Widget> _buildPreferenceItems(AppState appState) {
    final theme = appState.currentTheme;
    final items = _getPreferenceItems(appState);
    final List<Widget> widgets = [];

    if (_biometricsAvailable && _authMethods.first != AuthMethod.none) {
      widgets.add(
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: BiometricSwitch(
            biometricType: _authMethods.first,
            value: AuthMethod.none.name != appState.wallet?.authType,
            disabled: false,
            isLoading: _isBiometricLoading,
            onChanged: (value) => _handleToggleBiometric(value, appState),
          ),
        ),
      );

      if (items.isNotEmpty) {
        widgets.add(Divider(
          height: 1,
          color: theme.textSecondary.withValues(alpha: 0.1),
        ));
      }
    }

    for (var i = 0; i < items.length; i++) {
      widgets.add(_buildPreferenceItem(theme, items[i], appState));
      if (i < items.length - 1) {
        widgets.add(Divider(
          height: 1,
          color: theme.textSecondary.withValues(alpha: 0.1),
        ));
      }
    }

    return widgets;
  }

  Widget _buildPreferenceItem(
      AppTheme theme, WalletPreferenceItem item, AppState appState) {
    return GestureDetector(
      onTap: item.onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            SvgPicture.asset(
              item.iconPath,
              width: _iconSize,
              height: _iconSize,
              colorFilter: ColorFilter.mode(
                theme.textPrimary,
                BlendMode.srcIn,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                item.title,
                style: TextStyle(
                  color: theme.textPrimary,
                  fontSize: _fontSize,
                ),
              ),
            ),
            if (item.hasSwitch)
              Switch(
                value: item.switchValue,
                onChanged: item.switchEnabled ? item.onChanged : null,
                activeThumbColor: theme.primaryPurple,
              )
            else if (item.title ==
                AppLocalizations.of(context)!.walletPageManageConnections)
              Text(
                '${appState.connections.length}',
                style: TextStyle(
                  color: theme.textSecondary,
                  fontSize: _fontSize,
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildRemoveWalletButton(AppState appState) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () async {
        showDeleteWalletModal(context: context, state: appState);
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: Colors.red.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(_borderRadius),
        ),
        child: Row(
          children: [
            const SizedBox(width: 16),
            Expanded(
              child: Text(
                AppLocalizations.of(context)!.walletPageDeleteWallet,
                style: const TextStyle(
                  color: Colors.red,
                  fontSize: _fontSize,
                ),
              ),
            ),
            SvgPicture.asset(
              'assets/icons/logout.svg',
              colorFilter: const ColorFilter.mode(
                Colors.red,
                BlendMode.srcIn,
              ),
              width: _iconSize,
              height: _iconSize,
            ),
          ],
        ),
      ),
    );
  }

  void _handleBackup(AppTheme theme) {
    showSecretRecoveryModal(context: context, theme: theme);
  }
}

```

`lib/pages/wallet_restore_options.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/qrcode.dart';
import 'package:zilpay/modals/qr_scanner_modal.dart';
import 'package:zilpay/src/rust/api/methods.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/keypair.dart';
import 'package:zilpay/state/app_state.dart';
import '../components/view_item.dart';

class RestoreWalletOptionsPage extends StatelessWidget {
  const RestoreWalletOptionsPage({super.key});

  void _handleBip39Restore(BuildContext context) {
    Navigator.of(context).pushNamed('/restore_bip39');
  }

  void _handlePrivateKeyRestore(BuildContext context) {
    Navigator.of(context).pushNamed('/restore_sk');
  }

  void _handleKeystoreResotre(BuildContext context) {
    Navigator.of(context).pushNamed('/keystore_file_restore');
  }

  void _handleQRCodeScanning(BuildContext context) {
    showQRScannerModal(
      context: context,
      onScanned: (String qrData) async {
        try {
          final values = parseQRSecretData(qrData);
          final String? shortName = values['chain'];
          final String? seed = values['seed'];
          final String? key = values['key'];

          if (shortName != null && context.mounted) {
            final mainnetJsonData = await rootBundle
                .loadString('assets/chains/mainnet-chains.json');
            final mainnetChains =
                await getChainsProvidersFromJson(jsonStr: mainnetJsonData);

            if (mainnetChains.any((chain) => chain.shortName == shortName) &&
                context.mounted) {
              if (seed != null && context.mounted) {
                await _processSeedFromQR(context, seed, shortName);
                return;
              } else if (key != null && context.mounted) {
                await _processKeyFromQR(context, key, shortName);
                return;
              }
            }
          }

          final words =
              qrData.split(' ').where((word) => word.isNotEmpty).toList();
          final wordCount = words.length;

          if ([12, 15, 18, 21, 24].contains(wordCount) && context.mounted) {
            final errorIndexes =
                (await checkNotExistsBip39Words(words: words, lang: 'english'))
                    .map((e) => e.toInt())
                    .toList();

            if (errorIndexes.isEmpty && context.mounted) {
              Navigator.of(context).pushNamed('/net_setup',
                  arguments: {'bip39': words, 'shortName': null});
              return;
            }
          }

          if (context.mounted) {
            Navigator.pop(context);
          }
        } catch (e) {
          debugPrint("QR scanning error: $e");
          if (context.mounted) Navigator.pop(context);
        }
      },
    );
  }

  Future<void> _processSeedFromQR(
      BuildContext context, String seed, String shortName) async {
    final nonEmptyWords =
        seed.split(" ").where((word) => word.isNotEmpty).toList();

    if (nonEmptyWords.isEmpty) {
      if (context.mounted) Navigator.pop(context);
      return;
    }

    final List<int> errorIndexes = (await checkNotExistsBip39Words(
      words: nonEmptyWords,
      lang: 'english',
    ))
        .map((e) => e.toInt())
        .toList();

    if (!context.mounted) return;

    if (errorIndexes.isEmpty) {
      Navigator.of(context).pushNamed(
        '/net_setup',
        arguments: {'bip39': nonEmptyWords, 'shortName': shortName},
      );
    } else {
      Navigator.pop<void>(context);
    }
  }

  Future<void> _processKeyFromQR(
      BuildContext context, String key, String shortName) async {
    try {
      final KeyPairInfo keys = await keypairFromSk(sk: key);

      if (!context.mounted) return;

      Navigator.of(context).pushNamed(
        '/net_setup',
        arguments: {'keys': keys, 'shortName': shortName},
      );
    } catch (e) {
      debugPrint("Private key processing error: $e");
      if (context.mounted) Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;

    final backIcon = SvgPicture.asset(
      'assets/icons/back.svg',
      width: 24,
      height: 24,
      colorFilter: ColorFilter.mode(
        theme.secondaryPurple,
        BlendMode.srcIn,
      ),
    );

    final documentIcon = SvgPicture.asset(
      'assets/icons/document.svg',
      width: 35,
      height: 35,
      colorFilter: ColorFilter.mode(
        theme.primaryPurple,
        BlendMode.srcIn,
      ),
    );

    final puzzleIcon = SvgPicture.asset(
      'assets/icons/puzzle.svg',
      width: 35,
      height: 35,
      colorFilter: ColorFilter.mode(
        theme.primaryPurple,
        BlendMode.srcIn,
      ),
    );

    final bincodeIcon = SvgPicture.asset(
      'assets/icons/bincode.svg',
      width: 35,
      height: 35,
      colorFilter: ColorFilter.mode(
        theme.primaryPurple,
        BlendMode.srcIn,
      ),
    );

    final fileIcon = SvgPicture.asset(
      'assets/icons/file.svg',
      width: 35,
      height: 35,
      colorFilter: ColorFilter.mode(
        theme.primaryPurple,
        BlendMode.srcIn,
      ),
    );

    final qrcodeIcon = SvgPicture.asset(
      'assets/icons/qrcode.svg',
      width: 35,
      height: 35,
      colorFilter: ColorFilter.mode(
        theme.primaryPurple,
        BlendMode.srcIn,
      ),
    );

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: backIcon,
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Text(
          AppLocalizations.of(context)!.restoreWalletOptionsTitle,
          style: TextStyle(color: theme.textPrimary),
        ),
      ),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            WalletListItem(
              title:
                  AppLocalizations.of(context)!.restoreWalletOptionsBIP39Title,
              subtitle: AppLocalizations.of(context)!
                  .restoreWalletOptionsBIP39Subtitle,
              icon: documentIcon,
              onTap: () => _handleBip39Restore(context),
            ),
            WalletListItem(
              disabled: true,
              title: AppLocalizations.of(context)!
                  .restoreWalletOptionsSLIP0039Title,
              subtitle: AppLocalizations.of(context)!
                  .restoreWalletOptionsSLIP0039Subtitle,
              icon: puzzleIcon,
              onTap: null,
            ),
            WalletListItem(
              title: AppLocalizations.of(context)!
                  .restoreWalletOptionsPrivateKeyTitle,
              subtitle: AppLocalizations.of(context)!
                  .restoreWalletOptionsPrivateKeySubtitle,
              icon: bincodeIcon,
              onTap: () => _handlePrivateKeyRestore(context),
            ),
            WalletListItem(
              title: AppLocalizations.of(context)!
                  .restoreWalletOptionsKeyStoreTitle,
              subtitle: AppLocalizations.of(context)!
                  .restoreWalletOptionsKeyStoreSubtitle,
              icon: fileIcon,
              onTap: () => _handleKeystoreResotre(context),
            ),
            WalletListItem(
              title:
                  AppLocalizations.of(context)!.restoreWalletOptionsQRCodeTitle,
              subtitle: AppLocalizations.of(context)!
                  .restoreWalletOptionsQRCodeSubtitle,
              icon: qrcodeIcon,
              onTap: () => _handleQRCodeScanning(context),
            ),
          ],
        ),
      ),
    );
  }
}

```

`lib/pages/web_view.dart`:

```dart
import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:share_plus/share_plus.dart';
import 'package:zilpay/components/browser_action_menu.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/components/hoverd_svg.dart';
import 'package:zilpay/web3/eip_1193.dart';
import 'package:zilpay/web3/message.dart';
import 'package:zilpay/web3/zilpay_legacy.dart';
import 'package:zilpay/l10n/app_localizations.dart';

class WebViewPage extends StatefulWidget {
  final String initialUrl;
  const WebViewPage({super.key, required this.initialUrl});
  @override
  State<WebViewPage> createState() => _WebViewPageState();
}

class _WebViewPageState extends State<WebViewPage> with WidgetsBindingObserver {
  InAppWebViewController? _webViewController;
  ZilPayLegacyHandler? _legacyHandler;
  Web3EIP1193Handler? _eip1193Handler;
  CookieManager? _cookieManager;
  bool _isLoading = false;
  bool _hasError = false;
  String _errorMessage = '';
  String _currentUrl = '';
  double _progress = 0;

  String get _baseUserAgent => Platform.isIOS
      ? 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1'
      : 'Mozilla/5.0 (Linux; Android 11; SM-G998U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Mobile Safari/537.36';

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _cookieManager = CookieManager.instance();
    _currentUrl = widget.initialUrl;
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _legacyHandler = null;
    _eip1193Handler = null;

    if (_legacyHandler != null) {
      _legacyHandler!.dispose();
    }

    // if (_eip1193Handler != null) {
    //   _eip1193Handler!.dispose();
    // }

    if (_webViewController != null) {
      _webViewController!.dispose();
    }

    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed &&
        _hasError &&
        _webViewController != null) {
      _refreshPage();
    }
  }

  void _setupJavaScriptHandlers() {
    if (_webViewController == null) return;

    _webViewController?.addJavaScriptHandler(
      handlerName: 'ZilPayLegacy',
      callback: (args) {
        if (!mounted) return;

        try {
          final jsonData = jsonDecode(args[0]) as Map<String, dynamic>;
          final zilPayMessage = ZilPayWeb3Message.fromJson(jsonData);
          _legacyHandler ??= ZilPayLegacyHandler(
            webViewController: _webViewController!,
          );
          _legacyHandler!.handleLegacyZilPayMessage(zilPayMessage, context);
        } catch (e) {
          debugPrint("$e");
        }
        return null;
      },
    );

    _webViewController?.addJavaScriptHandler(
      handlerName: 'EIP1193Channel',
      callback: (args) {
        if (!mounted) return;

        try {
          final jsonData = jsonDecode(args[0]) as Map<String, dynamic>;
          final zilPayMessage = ZilPayWeb3Message.fromJson(jsonData);
          _eip1193Handler ??= Web3EIP1193Handler(
            webViewController: _webViewController!,
            initialUrl: _currentUrl,
          );
          _eip1193Handler!.handleWeb3EIP1193Message(zilPayMessage, context);
        } catch (e) {
          debugPrint("$e");
        }
        return null;
      },
    );
  }

  Future<void> _applyTextScalingFactor(AppState appState) async {
    try {
      await _webViewController?.evaluateJavascript(
          source:
              'document.documentElement.style.fontSize = \'${(appState.state.browserSettings.textScalingFactor * 100).toInt()}%\';');
    } catch (e) {
      debugPrint("$e");
    }
  }

  Future<void> _applyEnhancedContentBlocking(AppState appState) async {
    final level = appState.state.browserSettings.contentBlocking;
    String jsCode = '';

    if (level >= 1) {
      jsCode = '''
        (function() {
          const adSelectors = [
            'iframe[src*="doubleclick.net"]',
            'iframe[src*="googleadservices"]',
            'div[id*="google_ads_"]',
            'div[class*="ad-container"]',
            'div[class*="advertisement"]',
            'div[class*="banner"]',
            'div[id*="banner-ad"]'
          ];
          adSelectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(el => el.style.display = 'none');
          });
          
          const blockAutoplay = function() {
            const videoElements = document.querySelectorAll('video');
            const audioElements = document.querySelectorAll('audio');
            
            for (const element of [...videoElements, ...audioElements]) {
              element.autoplay = false;
              element.pause();
              
              element.addEventListener('play', function(e) {
                if (!e.isTrusted) {
                  this.pause();
                }
              }, true);
            }
          };
          
          blockAutoplay();
          setInterval(blockAutoplay, 2000);
        })();
      ''';
    }

    if (level >= 2) {
      jsCode = '''
        (function() {
          const blockSelectors = [
            'iframe[src*="doubleclick.net"]',
            'iframe[src*="googleadservices"]',
            'iframe[src*="facebook"]',
            'iframe[src*="twitter"]',
            'iframe[src*="instagram"]',
            'div[id*="google_ads_"]',
            'div[class*="ad-"]',
            'div[id*="ad-"]',
            'div[class*="social-"]',
            'div[class*="tracking"]',
            'script[src*="analytics"]',
            'script[src*="tracker"]',
            'script[src*="pixel"]',
            'div[class*="popup"]',
            'div[id*="popup"]',
            'div[class*="overlay"][class*="ad"]'
          ];
          
          blockSelectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(el => {
              el.style.display = 'none';
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
            });
          });
          
          const blockAutoplay = function() {
            const mediaElements = [...document.querySelectorAll('video'), ...document.querySelectorAll('audio')];
            for (const element of mediaElements) {
              element.autoplay = false;
              element.pause();
              
              element.addEventListener('play', function(e) {
                if (!e.isTrusted) {
                  this.pause();
                }
              }, true);
            }
            
            const oldPlay = HTMLMediaElement.prototype.play;
            HTMLMediaElement.prototype.play = function() {
              if (document.userActivated) {
                return oldPlay.apply(this, arguments);
              }
              return Promise.reject('Autoplay blocked by ZilPay Browser');
            };
          };
          
          window.open = function() { return null; };
          window.showModalDialog = function() { return null; };
          
          window.ga = function() {};
          window.fbq = function() {};
          window._gaq = { push: function() {} };
          
          if (window.Notification) {
            window.Notification.requestPermission = function() {
              return Promise.resolve('denied');
            };
            Object.defineProperty(window.Notification, 'permission', {
              get: function() { return 'denied'; }
            });
          }
          
          blockAutoplay();
          setInterval(function() {
            blockSelectors.forEach(selector => {
              document.querySelectorAll(selector).forEach(el => {
                el.style.display = 'none';
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
              });
            });
            blockAutoplay();
          }, 2000);
          
          const observer = new MutationObserver(function(mutations) {
            let needsRecheck = false;
            for (const mutation of mutations) {
              if (mutation.addedNodes.length) {
                needsRecheck = true;
                break;
              }
            }
            
            if (needsRecheck) {
              blockSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(el => {
                  el.style.display = 'none';
                  if (el.parentNode) {
                    el.parentNode.removeChild(el);
                  }
                });
              });
              blockAutoplay();
            }
          });
          
          observer.observe(document.body, { 
            childList: true, 
            subtree: true 
          });
        })();
      ''';
    }

    if (jsCode.isNotEmpty) {
      try {
        await _webViewController?.evaluateJavascript(source: jsCode);
      } catch (e) {
        debugPrint("$e");
      }
    }
  }

  Future<void> _disableAutoplay(AppState appState) async {
    if (!appState.state.browserSettings.allowAutoPlay) {
      try {
        await _webViewController?.evaluateJavascript(source: '''
          (function() {
            const disableAutoplay = function() {
              const videoElements = document.querySelectorAll('video');
              const audioElements = document.querySelectorAll('audio');
              
              for (const element of [...videoElements, ...audioElements]) {
                element.autoplay = false;
                element.pause();
                
                element.addEventListener('play', function(e) {
                  if (!e.isTrusted) {
                    this.pause();
                  }
                }, true);
              }
              
              if (!window.oldPlayDefined) {
                window.oldPlayDefined = true;
                const oldPlay = HTMLMediaElement.prototype.play;
                HTMLMediaElement.prototype.play = function() {
                  if (document.userActivated) {
                    return oldPlay.apply(this, arguments);
                  }
                  return Promise.reject('Autoplay blocked by browser settings');
                };
              }
            };
            
            const frames = document.querySelectorAll('iframe');
            frames.forEach(frame => {
              try {
                if (frame.contentDocument) {
                  const videos = frame.contentDocument.querySelectorAll('video');
                  videos.forEach(video => {
                    video.autoplay = false;
                    video.pause();
                  });
                }
              } catch (e) {}
            });
            
            disableAutoplay();
            setInterval(disableAutoplay, 2000);
          })();
        ''');
      } catch (e) {
        debugPrint("$e");
      }
    }
  }

  Future<void> _initializeZilPayInjection(AppState appState) async {
    try {
      if (appState.chain?.slip44 == 60 || appState.chain?.slip44 == 313) {
        await _webViewController?.injectJavascriptFileFromAsset(
          assetFilePath: 'assets/evm_inject.js',
        );
      }
    } catch (e) {
      debugPrint("$e");
    }

    try {
      if (appState.chain?.slip44 == 313) {
        String scilla =
            await rootBundle.loadString('assets/zilpay_legacy_inject.js');
        await _webViewController?.evaluateJavascript(source: scilla);
        await _legacyHandler!.sendData(appState);
      }
    } catch (e) {
      debugPrint("$e");
    }
  }

  void _refreshPage() {
    _webViewController?.reload();
  }

  Map<String, String> _splitDomain(String url) {
    try {
      final uri = Uri.parse(url);
      final host = uri.host;
      final parts = host.split('.');
      if (parts.length <= 2) {
        return {'subdomain': '', 'domain': host};
      }
      final subdomain = parts[0];
      final domain = parts.sublist(1).join('.');
      return {'subdomain': subdomain, 'domain': domain};
    } catch (e) {
      return {'subdomain': '', 'domain': url};
    }
  }

  void _applyPrivacySettings(
      AppState appState, InAppWebViewController controller) {
    if (!appState.state.browserSettings.cookiesEnabled) {
      _cookieManager?.deleteAllCookies();
    }

    if (appState.state.browserSettings.incognitoMode) {
      InAppWebViewController.clearAllCache();
      controller.clearHistory();
      controller.clearFormData();
      controller.closeAllMediaPresentations();

      if (!appState.state.browserSettings.cookiesEnabled) {
        _cookieManager?.deleteAllCookies();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final domainParts =
        _splitDomain(_currentUrl.isEmpty ? widget.initialUrl : _currentUrl);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(50.0),
        child: AppBar(
          backgroundColor: theme.cardBackground,
          elevation: 0,
          leading: IconButton(
            icon: _isLoading
                ? SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      color: theme.primaryPurple,
                      strokeWidth: 2,
                    ),
                  )
                : HoverSvgIcon(
                    assetName: 'assets/icons/reload.svg',
                    width: 24,
                    height: 24,
                    onTap: _refreshPage,
                    color: theme.textPrimary,
                  ),
            onPressed: _refreshPage,
          ),
          title: Stack(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                mainAxisSize: MainAxisSize.min,
                children: [
                  HoverSvgIcon(
                    assetName: 'assets/icons/lock.svg',
                    width: 16,
                    height: 16,
                    onTap: () {},
                    color: _currentUrl.startsWith('https://')
                        ? theme.primaryPurple
                        : theme.textSecondary,
                  ),
                  const SizedBox(width: 4),
                  Expanded(
                    child: RichText(
                      text: TextSpan(
                        children: [
                          if (domainParts['subdomain']!.isNotEmpty)
                            TextSpan(
                              text: '${domainParts['subdomain']}.',
                              style: TextStyle(
                                color:
                                    theme.textSecondary.withValues(alpha: 0.7),
                                fontSize: 12,
                              ),
                            ),
                          TextSpan(
                            text: domainParts['domain'],
                            style: TextStyle(
                              color: theme.textPrimary,
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 1,
                    ),
                  ),
                  if (appState.state.browserSettings.doNotTrack)
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 4, vertical: 2),
                      margin: const EdgeInsets.only(left: 4),
                      decoration: BoxDecoration(
                        color: theme.primaryPurple.withValues(alpha: 0.2),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        l10n.webViewPageDntLabel,
                        style: TextStyle(
                          color: theme.primaryPurple,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  if (appState.state.browserSettings.incognitoMode)
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 4, vertical: 2),
                      margin: const EdgeInsets.only(left: 4),
                      decoration: BoxDecoration(
                        color: theme.textSecondary.withValues(alpha: 0.2),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        l10n.webViewPageIncognitoLabel,
                        style: TextStyle(
                          color: theme.textSecondary,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                ],
              ),
            ],
          ),
          actions: [
            BrowserActionMenu(
              parentContext: context,
              onShare: () {
                SharePlus.instance.share(
                  ShareParams(
                    text: _currentUrl,
                  ),
                );
              },
              onCopyLink: () {
                Clipboard.setData(ClipboardData(text: _currentUrl));
              },
              onClose: () {
                stopBlockWorker();
                Navigator.pop(context);
              },
              onBack: () {
                _webViewController?.goBack();
              },
              onForward: () {
                _webViewController?.goForward();
              },
            ),
          ],
        ),
      ),
      body: _hasError
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  HoverSvgIcon(
                    assetName: 'assets/icons/warning.svg',
                    width: 100,
                    height: 100,
                    onTap: () {},
                    color: theme.textSecondary,
                  ),
                  const SizedBox(height: 20),
                  Text(
                    l10n.webViewPageLoadError,
                    style: TextStyle(
                      color: theme.textPrimary,
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 10),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 20),
                    child: Text(
                      _errorMessage,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: theme.textSecondary,
                        fontSize: 16,
                      ),
                    ),
                  ),
                  const SizedBox(height: 20),
                  ElevatedButton(
                    onPressed: _refreshPage,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.primaryPurple,
                    ),
                    child: Text(
                      l10n.webViewPageTryAgain,
                      style: TextStyle(color: theme.background),
                    ),
                  ),
                ],
              ),
            )
          : Stack(
              children: [
                InAppWebView(
                  initialUrlRequest: URLRequest(url: WebUri(widget.initialUrl)),
                  initialSettings: InAppWebViewSettings(
                    javaScriptEnabled: true,
                    safeBrowsingEnabled: false,
                    userAgent: _baseUserAgent +
                        (appState.state.browserSettings.doNotTrack
                            ? ' DNT:1'
                            : ' ZilPay/1.0'),
                    useHybridComposition: true,
                    supportZoom: true,
                    useOnLoadResource: true,
                    verticalScrollBarEnabled: false,
                    horizontalScrollBarEnabled: false,
                    disableVerticalScroll: false,
                    disableHorizontalScroll: false,
                    transparentBackground: false,
                    javaScriptCanOpenWindowsAutomatically: false,
                    supportMultipleWindows: false,
                    cacheEnabled: appState.state.browserSettings.cacheEnabled,
                    clearCache: !appState.state.browserSettings.cacheEnabled,
                    mediaPlaybackRequiresUserGesture:
                        !appState.state.browserSettings.allowAutoPlay,
                    allowsInlineMediaPlayback:
                        appState.state.browserSettings.allowAutoPlay,
                    forceDark: appState.currentTheme.value == "Dark"
                        ? ForceDark.ON
                        : ForceDark.OFF,
                  ),
                  onWebViewCreated: (controller) {
                    _webViewController = controller;
                    _setupJavaScriptHandlers();

                    if (!appState.state.browserSettings.cookiesEnabled) {
                      _cookieManager?.deleteAllCookies();
                    }
                  },
                  onLoadStart: (controller, url) {
                    setState(() {
                      _isLoading = true;
                      _hasError = false;
                      _currentUrl = url.toString();
                    });

                    _applyPrivacySettings(appState, controller);
                  },
                  onLoadStop: (controller, url) async {
                    await _initializeZilPayInjection(appState);

                    setState(() {
                      _isLoading = false;
                      _currentUrl = url.toString();
                    });

                    await _applyEnhancedContentBlocking(appState);

                    if (!appState.state.browserSettings.allowAutoPlay) {
                      await _disableAutoplay(appState);
                    }

                    if (_legacyHandler != null) {
                      _legacyHandler!.handleStartBlockWorker(appState);
                    }

                    if (appState.state.browserSettings.textScalingFactor !=
                        1.0) {
                      await _applyTextScalingFactor(appState);
                    }
                  },
                  onProgressChanged: (controller, progress) async {
                    if (progress > 20) {
                      await _initializeZilPayInjection(appState);
                    }

                    setState(() {
                      _progress = progress / 100;
                    });
                  },
                  onConsoleMessage: (_, value) {
                    // print(value);
                  },
                  onReceivedError: (_, __, error) {
                    print("browser error: $error");
                  },
                  shouldOverrideUrlLoading:
                      (controller, navigationAction) async {
                    final url =
                        navigationAction.request.url.toString().toLowerCase();

                    if (appState.state.browserSettings.contentBlocking > 0) {
                      final adDomains = [
                        'doubleclick.net',
                        'googleadservices',
                        'googlesyndication',
                        'adform.net',
                        'adnxs.com',
                        'ad.doubleclick.net',
                        'analytics',
                        'facebook.com/tr',
                      ];

                      for (final domain in adDomains) {
                        if (url.contains(domain)) {
                          return NavigationActionPolicy.CANCEL;
                        }
                      }
                    }

                    return NavigationActionPolicy.ALLOW;
                  },
                ),
                if (_isLoading && _progress < 1.0)
                  LinearProgressIndicator(
                    value: _progress,
                    backgroundColor: Colors.transparent,
                    color: theme.primaryPurple,
                  ),
              ],
            ),
    );
  }
}

```

`lib/pages/zil_stake.dart`:

```dart
import 'dart:async';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/components/custom_app_bar.dart';
import 'package:zilpay/components/linear_refresh_indicator.dart';
import 'package:zilpay/components/stakeing_card.dart';
import 'package:zilpay/l10n/app_localizations.dart';
import 'package:zilpay/mixins/adaptive_size.dart';
import 'package:zilpay/src/rust/api/stake.dart';
import 'package:zilpay/src/rust/models/stake.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/theme/app_theme.dart';

enum SortType { apr, commission, tvl, votePower }

class ZilStakePage extends StatefulWidget {
  const ZilStakePage({super.key});

  @override
  State<ZilStakePage> createState() => _ZilStakePageState();
}

class _ZilStakePageState extends State<ZilStakePage> {
  List<FinalOutputInfo> _stakes = [];
  bool _isLoading = true;
  String? _errorMessage;
  SortType _sortType = SortType.apr;

  @override
  void initState() {
    super.initState();
    _fetchStakes();
  }

  Future<void> _fetchStakes({bool isRefresh = false}) async {
    if (!isRefresh && mounted) {
      setState(() {
        _isLoading = true;
        _errorMessage = null;
      });
    }

    try {
      final appState = Provider.of<AppState>(context, listen: false);
      List<FinalOutputInfo> list = [];

      if (appState.account?.addrType == 0) {
        list = await fetchScillaStake(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
      } else {
        list = await fetchEvmStake(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
      }

      if (mounted) {
        setState(() {
          _stakes = list;
          _errorMessage = null;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = e.toString();
        });
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final appState = Provider.of<AppState>(context);
    final theme = appState.currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.background,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: EdgeInsets.symmetric(horizontal: adaptivePadding),
              child: CustomAppBar(
                title: l10n.zilStakePageTitle,
                onBackPressed: () => Navigator.pop(context),
              ),
            ),
            Expanded(
              child: isIOS ? _buildIosBody() : _buildAndroidBody(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildIosBody() {
    return _buildContent();
  }

  Widget _buildAndroidBody() {
    final theme = Provider.of<AppState>(context, listen: false).currentTheme;
    return RefreshIndicator(
      onRefresh: () => _fetchStakes(isRefresh: true),
      color: theme.primaryPurple,
      backgroundColor: theme.cardBackground,
      child: _buildContent(),
    );
  }

  Widget _buildContent() {
    if (_isLoading) {
      return _buildSkeletonLoading();
    }

    if (_errorMessage != null) {
      return _buildErrorState();
    }

    if (_stakes.isEmpty) {
      return _buildEmptyState();
    }

    return _buildStakeList();
  }

  Widget _buildStakeList() {
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return CustomScrollView(
      physics: const AlwaysScrollableScrollPhysics(
        parent: BouncingScrollPhysics(),
      ),
      slivers: [
        if (isIOS)
          CupertinoSliverRefreshControl(
            onRefresh: () => _fetchStakes(isRefresh: true),
            builder: (
              BuildContext context,
              RefreshIndicatorMode refreshState,
              double pulledExtent,
              double refreshTriggerPullDistance,
              double refreshIndicatorExtent,
            ) {
              return LinearRefreshIndicator(
                pulledExtent: pulledExtent,
                refreshTriggerPullDistance: refreshTriggerPullDistance,
                refreshIndicatorExtent: refreshIndicatorExtent,
              );
            },
          ),
        SliverPadding(
          padding: EdgeInsets.symmetric(
            horizontal: adaptivePadding,
            vertical: 8,
          ),
          sliver: SliverToBoxAdapter(
            child: _buildSortButtons(theme, l10n),
          ),
        ),
        SliverPadding(
          padding: EdgeInsets.fromLTRB(
            adaptivePadding,
            8,
            adaptivePadding,
            adaptivePadding,
          ),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                return Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: StakingPoolCard(stake: _stakes[index]),
                );
              },
              childCount: _stakes.length,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildErrorState() {
    final theme = Provider.of<AppState>(context, listen: false).currentTheme;
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);

    return CustomScrollView(
      physics: const AlwaysScrollableScrollPhysics(
        parent: BouncingScrollPhysics(),
      ),
      slivers: [
        if (isIOS)
          CupertinoSliverRefreshControl(
            onRefresh: () => _fetchStakes(isRefresh: true),
            builder: (
              BuildContext context,
              RefreshIndicatorMode refreshState,
              double pulledExtent,
              double refreshTriggerPullDistance,
              double refreshIndicatorExtent,
            ) {
              return LinearRefreshIndicator(
                pulledExtent: pulledExtent,
                refreshTriggerPullDistance: refreshTriggerPullDistance,
                refreshIndicatorExtent: refreshIndicatorExtent,
              );
            },
          ),
        SliverFillRemaining(
          child: Center(
            child: Padding(
              padding: EdgeInsets.all(adaptivePadding),
              child: Text(
                'Error: $_errorMessage',
                style: TextStyle(color: theme.danger),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState() {
    final theme = Provider.of<AppState>(context).currentTheme;
    final l10n = AppLocalizations.of(context)!;
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;

    return CustomScrollView(
      physics: const AlwaysScrollableScrollPhysics(
        parent: BouncingScrollPhysics(),
      ),
      slivers: [
        if (isIOS)
          CupertinoSliverRefreshControl(
            onRefresh: () => _fetchStakes(isRefresh: true),
            builder: (
              BuildContext context,
              RefreshIndicatorMode refreshState,
              double pulledExtent,
              double refreshTriggerPullDistance,
              double refreshIndicatorExtent,
            ) {
              return LinearRefreshIndicator(
                pulledExtent: pulledExtent,
                refreshTriggerPullDistance: refreshTriggerPullDistance,
                refreshIndicatorExtent: refreshIndicatorExtent,
              );
            },
          ),
        SliverFillRemaining(
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                SvgPicture.asset(
                  'assets/icons/anchor.svg',
                  width: 80,
                  height: 80,
                  colorFilter: ColorFilter.mode(
                    theme.textSecondary.withValues(alpha: 0.3),
                    BlendMode.srcIn,
                  ),
                ),
                const SizedBox(height: 24),
                Text(
                  l10n.noStakingPoolsFound,
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: theme.textPrimary,
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildSkeletonLoading() {
    final theme = Provider.of<AppState>(context, listen: false).currentTheme;
    final adaptivePadding = AdaptiveSize.getAdaptivePadding(context, 16);
    final isIOS = defaultTargetPlatform == TargetPlatform.iOS;

    return CustomScrollView(
      physics: const NeverScrollableScrollPhysics(),
      slivers: [
        if (isIOS)
          CupertinoSliverRefreshControl(
            onRefresh: () => _fetchStakes(isRefresh: true),
          ),
        SliverPadding(
          padding: EdgeInsets.symmetric(
            horizontal: adaptivePadding,
            vertical: 8,
          ),
          sliver: SliverToBoxAdapter(
            child: _buildSkeletonSortButtons(theme),
          ),
        ),
        SliverPadding(
          padding: EdgeInsets.fromLTRB(
            adaptivePadding,
            8,
            adaptivePadding,
            adaptivePadding,
          ),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                return Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: _buildSkeletonStakingPoolCard(theme),
                );
              },
              childCount: 3,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildSkeletonSortButtons(AppTheme theme) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      physics: const BouncingScrollPhysics(),
      child: Row(
        children: List.generate(4, (index) {
          return Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: Container(
              width: 80,
              height: 32,
              decoration: BoxDecoration(
                color: theme.textSecondary.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(20),
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildSkeletonStakingPoolCard(AppTheme theme) {
    return Container(
      decoration: BoxDecoration(
        color: theme.cardBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: theme.textSecondary.withValues(alpha: 0.1),
        ),
      ),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                Row(
                  children: [
                    Container(
                      width: 48,
                      height: 48,
                      decoration: BoxDecoration(
                        color: theme.textSecondary.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Container(
                            width: 120,
                            height: 18,
                            decoration: BoxDecoration(
                              color: theme.textSecondary.withValues(alpha: 0.1),
                              borderRadius: BorderRadius.circular(4),
                            ),
                          ),
                          const SizedBox(height: 4),
                          Container(
                            width: 60,
                            height: 14,
                            decoration: BoxDecoration(
                              color: theme.textSecondary.withValues(alpha: 0.1),
                              borderRadius: BorderRadius.circular(4),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: List.generate(4, (index) {
                    return Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          width: 40,
                          height: 12,
                          decoration: BoxDecoration(
                            color: theme.textSecondary.withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(4),
                          ),
                        ),
                        const SizedBox(height: 4),
                        Container(
                          width: 60,
                          height: 16,
                          decoration: BoxDecoration(
                            color: theme.textSecondary.withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(4),
                          ),
                        ),
                      ],
                    );
                  }),
                ),
              ],
            ),
          ),
          Container(
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(
                  color: theme.textSecondary.withValues(alpha: 0.1),
                ),
              ),
            ),
            padding: const EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Container(
                    height: 44,
                    decoration: BoxDecoration(
                      color: theme.textSecondary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Container(
                    height: 44,
                    decoration: BoxDecoration(
                      color: theme.textSecondary.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSortButtons(AppTheme theme, AppLocalizations l10n) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      physics: const BouncingScrollPhysics(),
      child: Row(
        children: SortType.values.map((type) {
          final isSelected = _sortType == type;
          String label;
          switch (type) {
            case SortType.apr:
              label = l10n.aprSort;
              break;
            case SortType.commission:
              label = l10n.commissionSort;
              break;
            case SortType.tvl:
              label = l10n.tvlSort;
              break;
            case SortType.votePower:
              label = "VP";
              break;
          }
          return Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: GestureDetector(
              onTap: () {
                if (_sortType != type) {
                  setState(() => _sortType = type);
                }
              },
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                decoration: BoxDecoration(
                  color:
                      isSelected ? theme.primaryPurple : theme.cardBackground,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color: isSelected
                        ? Colors.transparent
                        : theme.textSecondary.withValues(alpha: 0.2),
                  ),
                ),
                child: Text(
                  label.toUpperCase(),
                  style: TextStyle(
                    color: isSelected ? theme.buttonText : theme.textPrimary,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}

```

`lib/router.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/pages/about.dart';
import 'package:zilpay/pages/add_account.dart';
import 'package:zilpay/pages/add_ledger_account.dart';
import 'package:zilpay/pages/address_book.dart';
import 'package:zilpay/pages/appearance.dart';
import 'package:zilpay/pages/browser_settings.dart';
import 'package:zilpay/pages/currency_conversion.dart';
import 'package:zilpay/pages/keystore_backup.dart';
import 'package:zilpay/pages/keystore_file_restore.dart';
import 'package:zilpay/pages/ledger_connect.dart';
import 'package:zilpay/pages/locale.dart';
import 'package:zilpay/pages/manage_tokens.dart';
import 'package:zilpay/pages/network.dart';
import 'package:zilpay/pages/notification.dart';
import 'package:zilpay/pages/password_setup.dart';
import 'package:zilpay/pages/receive.dart';
import 'package:zilpay/pages/restore_bip39.dart';
import 'package:zilpay/pages/restore_rkstorage.dart';
import 'package:zilpay/pages/restore_sk.dart';
import 'package:zilpay/pages/reveal_bip39.dart';
import 'package:zilpay/pages/reveal_sk.dart';
import 'package:zilpay/pages/security.dart';
import 'package:zilpay/pages/send.dart';
import 'package:zilpay/pages/setup_cipher.dart';
import 'package:zilpay/pages/setup_net.dart';
import 'package:zilpay/pages/sk_gen.dart';
import 'package:zilpay/pages/verify_bip39.dart';
import 'package:zilpay/pages/wallet.dart';
import 'package:zilpay/pages/web_view.dart';
import 'package:zilpay/pages/zil_stake.dart';

import 'services/auth_guard.dart';
import 'state/app_state.dart';

import 'pages/main_page.dart';
import 'pages/login_page.dart';
import 'pages/initial_page.dart';
import 'pages/browser_page.dart';
import 'pages/settings_page.dart';
import 'pages/new_wallet_options.dart';
import 'pages/gen_wallet_options.dart';
import 'pages/wallet_restore_options.dart';
import './pages/gen_bip39.dart';

class AppRouter {
  final AuthGuard authGuard;
  final AppState appState;

  AppRouter({required this.authGuard, required this.appState});

  Route<dynamic> onGenerateRoute(RouteSettings settings) {
    return MaterialPageRoute(
      settings: settings,
      builder: (context) => _buildRoute(context, settings),
    );
  }

  Widget _buildRoute(BuildContext context, RouteSettings settings) {
    Widget wrapWithProviders(Widget child) {
      return MultiProvider(
        providers: [
          ChangeNotifierProvider.value(value: authGuard),
          ChangeNotifierProvider.value(value: appState),
        ],
        child: child,
      );
    }

    final List<String> setupRoutes = [
      '/pass_setup',
      '/cipher_setup',
      '/net_setup',
      '/gen_bip39',
      '/gen_sk',
      '/verify_bip39',
      '/restore_options',
      '/gen_options',
      '/new_wallet_options',
      '/initial',
      '/ledger_connect',
      '/wallet',
      '/appearance',
      '/restore_bip39',
      '/currency',
      '/notifications',
      '/language',
      '/address-book',
      '/security',
      '/networks',
      '/send',
      '/receive',
      '/reveal_sk',
      '/reveal_bip39',
      '/add_account',
      '/web_view',
      '/rk_restore',
      '/browser_settings',
      '/restore_sk',
      '/about',
      '/keystore_backup',
      '/keystore_file_restore',
      '/add_ledger_account',
      '/zil_stake',
    ];

    if (settings.name == '/ledger_connect') {
      return wrapWithProviders(const LedgerConnectPage());
    }

    if (settings.name == '/' || settings.name == null) {
      if (!authGuard.ready) {
        return wrapWithProviders(const InitialPage());
      } else if (!authGuard.enabled) {
        return wrapWithProviders(const LoginPage());
      } else {
        return wrapWithProviders(const MainPage());
      }
    }

    if (!authGuard.ready) {
      if (setupRoutes.contains(settings.name)) {
        switch (settings.name) {
          case '/pass_setup':
            return wrapWithProviders(const PasswordSetupPage());
          case '/add_ledger_account':
            return wrapWithProviders(const AddLedgerAccountPage());
          case '/about':
            return wrapWithProviders(const AboutPage());
          case '/restore_sk':
            return wrapWithProviders(const SecretKeyRestorePage());
          case '/rk_restore':
            return wrapWithProviders(const RestoreRKStorage());
          case '/restore_bip39':
            return wrapWithProviders(const RestoreSecretPhrasePage());
          case '/cipher_setup':
            return wrapWithProviders(const CipherSettingsPage());
          case '/net_setup':
            return wrapWithProviders(const SetupNetworkSettingsPage());
          case '/gen_bip39':
            return wrapWithProviders(const SecretPhraseGeneratorPage());
          case '/gen_sk':
            return wrapWithProviders(const SecretKeyGeneratorPage());
          case '/verify_bip39':
            return wrapWithProviders(const SecretPhraseVerifyPage());
          case '/restore_options':
            return wrapWithProviders(const RestoreWalletOptionsPage());
          case '/gen_options':
            return wrapWithProviders(const GenWalletOptionsPage());
          case '/new_wallet_options':
            return wrapWithProviders(const AddWalletOptionsPage());
          case '/keystore_file_restore':
            return wrapWithProviders(const RestoreKeystoreFilePage());
          case '/initial':
            return wrapWithProviders(const InitialPage());
          case '/language':
            return wrapWithProviders(const LanguagePage());
          default:
            return wrapWithProviders(const InitialPage());
        }
      }
      return wrapWithProviders(const InitialPage());
    }

    if (!authGuard.enabled) {
      if (settings.name == '/login') {
        return wrapWithProviders(const LoginPage());
      }

      if (setupRoutes.contains(settings.name)) {
        switch (settings.name) {
          case '/about':
            return wrapWithProviders(const AboutPage());
          case '/restore_sk':
            return wrapWithProviders(const SecretKeyRestorePage());
          case '/pass_setup':
            return wrapWithProviders(const PasswordSetupPage());
          case '/rk_restore':
            return wrapWithProviders(const RestoreRKStorage());
          case '/cipher_setup':
            return wrapWithProviders(const CipherSettingsPage());
          case '/net_setup':
            return wrapWithProviders(const SetupNetworkSettingsPage());
          case '/gen_sk':
            return wrapWithProviders(const SecretKeyGeneratorPage());
          case '/keystore_file_restore':
            return wrapWithProviders(const RestoreKeystoreFilePage());
          case '/gen_bip39':
            return wrapWithProviders(const SecretPhraseGeneratorPage());
          case '/verify_bip39':
            return wrapWithProviders(const SecretPhraseVerifyPage());
          case '/restore_bip39':
            return wrapWithProviders(const RestoreSecretPhrasePage());
          case '/restore_options':
            return wrapWithProviders(const RestoreWalletOptionsPage());
          case '/gen_options':
            return wrapWithProviders(const GenWalletOptionsPage());
          case '/new_wallet_options':
            return wrapWithProviders(const AddWalletOptionsPage());
          case '/initial':
            return wrapWithProviders(const InitialPage());
          case '/web_view':
            return wrapWithProviders(const WebViewPage(initialUrl: ''));
          case '/add_ledger_account':
            return wrapWithProviders(const AddLedgerAccountPage());
          default:
            return wrapWithProviders(const LoginPage());
        }
      }
      return wrapWithProviders(const LoginPage());
    }

    switch (settings.name) {
      case '/about':
        return wrapWithProviders(const AboutPage());
      case '/login':
        return wrapWithProviders(const LoginPage());
      case '/':
        return wrapWithProviders(const MainPage());
      case '/receive':
        return wrapWithProviders(const ReceivePage());
      case '/add_account':
        return wrapWithProviders(const AddAccount());
      case '/manage_tokens':
        return wrapWithProviders(const ManageTokensPage());
      case '/send':
        return wrapWithProviders(const SendTokenPage());
      case '/reveal_sk':
        return wrapWithProviders(const RevealSecretKey());
      case '/reveal_bip39':
        return wrapWithProviders(const RevealSecretPhrase());
      case '/browser':
        return wrapWithProviders(const BrowserPage());
      case '/wallet':
        return wrapWithProviders(const WalletPage());
      case '/appearance':
        return wrapWithProviders(const AppearanceSettingsPage());
      case '/notifications':
        return wrapWithProviders(const NotificationsSettingsPage());
      case '/address-book':
        return wrapWithProviders(const AddressBookPage());
      case '/language':
        return wrapWithProviders(const LanguagePage());
      case '/networks':
        return wrapWithProviders(const NetworkPage());
      case '/security':
        return wrapWithProviders(const SecurityPage());
      case '/settings':
        return wrapWithProviders(const SettingsPage());
      case '/currency':
        return wrapWithProviders(const CurrencyConversionPage());
      case '/pass_setup':
        return wrapWithProviders(const PasswordSetupPage());
      case '/cipher_setup':
        return wrapWithProviders(const CipherSettingsPage());
      case '/rk_restore':
        return wrapWithProviders(const RestoreRKStorage());
      case '/net_setup':
        return wrapWithProviders(const SetupNetworkSettingsPage());
      case '/gen_sk':
        return wrapWithProviders(const SecretKeyGeneratorPage());
      case '/gen_bip39':
        return wrapWithProviders(const SecretPhraseGeneratorPage());
      case '/verify_bip39':
        return wrapWithProviders(const SecretPhraseVerifyPage());
      case '/browser_settings':
        return wrapWithProviders(const BrowserSettingsPage());
      case '/keystore_backup':
        return wrapWithProviders(const KeystoreBackup());
      case '/restore_options':
        return wrapWithProviders(const RestoreWalletOptionsPage());
      case '/gen_options':
        return wrapWithProviders(const GenWalletOptionsPage());
      case '/new_wallet_options':
        return wrapWithProviders(const AddWalletOptionsPage());
      case '/restore_bip39':
        return wrapWithProviders(const RestoreSecretPhrasePage());
      case '/restore_sk':
        return wrapWithProviders(const SecretKeyRestorePage());
      case '/keystore_file_restore':
        return wrapWithProviders(const RestoreKeystoreFilePage());
      case '/initial':
        return wrapWithProviders(const InitialPage());
      case '/add_ledger_account':
        return wrapWithProviders(const AddLedgerAccountPage());
      case '/zil_stake':
        return wrapWithProviders(const ZilStakePage());
      case '/web_view':
        final uri =
            Uri.tryParse(settings.name?.replaceFirst('/web_view?', '') ?? '') ??
                Uri();
        return wrapWithProviders(
            WebViewPage(initialUrl: uri.queryParameters['url'] ?? ''));
      default:
        return wrapWithProviders(const MainPage());
    }
  }
}

```

`lib/services/auth_guard.dart`:

```dart
import 'package:zilpay/services/biometric_service.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:zilpay/state/app_state.dart';

class AuthGuard extends ChangeNotifier {
  final FlutterSecureStorage _storage;
  final AppState _state;

  bool _enabled = false;

  bool get ready => _state.wallets.isNotEmpty;
  bool get enabled => _enabled;

  AuthGuard({required AppState state})
      : _storage = const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: true,
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock,
            synchronizable: true,
          ),
        ),
        _state = state;

  void setEnabled(bool value) {
    _enabled = value;
  }

  Future<void> setSession(String sessionKey, String sessionValue) async {
    final AuthService authService = AuthService();

    try {
      final authMethods = await authService.getAvailableAuthMethods();

      if (authMethods.contains(AuthMethod.none)) {
        throw 'Device does not support secure storage. Please enable device lock.';
      }

      await _storage.write(
        key: sessionKey,
        value: sessionValue,
      );

      _enabled = true;

      notifyListeners();
    } catch (e) {
      throw 'Failed to save session key: $e';
    }
  }

  Future<String?> getSession({
    required String sessionKey,
    bool requireAuth = true,
    String reason = 'Please authenticate to access your wallet',
  }) async {
    final value = await _storage.read(key: sessionKey);

    if (value == null) {
      return null;
    }

    _enabled = true;

    notifyListeners();

    return value;
  }
}

```

`lib/services/biometric_service.dart`:

```dart
import 'package:local_auth/local_auth.dart';
import 'package:flutter/services.dart';

enum AuthMethod { faceId, fingerprint, biometric, pinCode, none }

class AuthService {
  final LocalAuthentication _auth = LocalAuthentication();

  Future<List<AuthMethod>> getAvailableAuthMethods() async {
    try {
      List<AuthMethod> methods = [];

      final isSupported = await _auth.isDeviceSupported();
      final canCheckBiometrics = await _auth.canCheckBiometrics;

      if (isSupported && canCheckBiometrics) {
        final availableBiometrics = await _auth.getAvailableBiometrics();

        if (availableBiometrics.contains(BiometricType.face)) {
          methods.add(AuthMethod.faceId);
        } else if (availableBiometrics.contains(BiometricType.fingerprint)) {
          methods.add(AuthMethod.fingerprint);
        } else if (availableBiometrics.contains(BiometricType.strong) ||
            availableBiometrics.contains(BiometricType.weak)) {
          methods.add(AuthMethod.biometric);
        }
      }

      if (await _checkDevicePinCode()) {
        methods.add(AuthMethod.pinCode);
      }

      return methods.isEmpty ? [AuthMethod.none] : methods;
    } on PlatformException catch (_) {
      return [AuthMethod.none];
    }
  }

  Future<bool> _checkDevicePinCode() async {
    try {
      return await _auth.isDeviceSupported();
    } catch (_) {
      return false;
    }
  }

  Future<bool> authenticate({
    bool allowPinCode = true,
    String reason = 'Please authenticate to continue',
  }) async {
    return await _auth.authenticate(
      localizedReason: reason,
      options: AuthenticationOptions(
        stickyAuth: true,
        biometricOnly: !allowPinCode,
        useErrorDialogs: true,
      ),
    );
  }
}

```

`lib/services/device.dart`:

```dart
import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:package_info_plus/package_info_plus.dart';
import 'package:zilpay/services/biometric_service.dart';

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfo = DeviceInfoPlugin();

  Future<List<String>> getDeviceIdentifiers() async {
    final packageInfo = await PackageInfo.fromPlatform();
    final AuthService authService = AuthService();
    final methods =
        (await authService.getAvailableAuthMethods()).map((e) => e.name);

    if (Platform.isAndroid) {
      final info = await _deviceInfo.androidInfo;
      return [
        info.brand,
        info.manufacturer,
        info.hardware,
        info.model,
        info.product,
        info.device,
        info.board,
        info.isPhysicalDevice.toString(),
        packageInfo.packageName,
        packageInfo.buildSignature,
        ...methods
      ];
    }

    if (Platform.isIOS) {
      final info = await _deviceInfo.iosInfo;
      return [
        info.model,
        info.localizedModel,
        info.utsname.machine,
        info.isPhysicalDevice.toString(),
        packageInfo.packageName,
        packageInfo.buildSignature,
        ...methods
      ];
    }

    throw UnsupportedError('Unsupported platform');
  }

  Future<Map<String, String>> getDeviceInfo() async {
    final packageInfo = await PackageInfo.fromPlatform();

    if (Platform.isAndroid) {
      final info = await _deviceInfo.androidInfo;
      return {
        'brand': info.brand,
        'manufacturer': info.manufacturer,
        'hardware': info.hardware,
        'model': info.model,
        'product': info.product,
        'device': info.device,
        'board': info.board,
        'isPhysicalDevice': info.isPhysicalDevice.toString(),
        'appId': packageInfo.packageName,
        'buildSignature': packageInfo.buildSignature,
      };
    }

    if (Platform.isIOS) {
      final info = await _deviceInfo.iosInfo;
      return {
        'model': info.model,
        'localizedModel': info.localizedModel,
        'machine': info.utsname.machine,
        'isPhysicalDevice': info.isPhysicalDevice.toString(),
        'appId': packageInfo.packageName,
        'buildSignature': packageInfo.buildSignature,
      };
    }

    throw UnsupportedError('Unsupported platform');
  }
}

```

`lib/services/secure_storage.dart`:

```dart
import 'dart:convert';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:zilpay/services/biometric_service.dart';

class SecureStorage {
  static const String _keyPrefix = 'zilpay_';
  static const String _sessionKey = '${_keyPrefix}session';
  static const String _authMethodKey = '${_keyPrefix}auth_method';

  final FlutterSecureStorage _storage;
  final AuthService _authService;

  SecureStorage({AuthService? authService})
      : _storage = const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: true,
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock,
            synchronizable: true,
          ),
        ),
        _authService = authService ?? AuthService();

  Future<void> saveSessionKey(String sessionKey) async {
    try {
      final authMethods = await _authService.getAvailableAuthMethods();

      if (authMethods.contains(AuthMethod.none)) {
        throw SecurityException(
            'Device does not support secure storage. Please enable device lock.');
      }

      final encodedKey = base64.encode(utf8.encode(sessionKey));

      await _storage.write(
        key: _sessionKey,
        value: encodedKey,
      );

      await _storage.write(
        key: _authMethodKey,
        value: authMethods.first.toString(),
      );
    } catch (e) {
      throw StorageException('Failed to save session key: $e');
    }
  }

  Future<String?> getSessionKey({
    bool requireAuth = true,
    String reason = 'Please authenticate to access your wallet',
  }) async {
    try {
      final encodedKey = await _storage.read(key: _sessionKey);
      if (encodedKey == null) return null;

      if (requireAuth) {
        final isAuthenticated = await _authService.authenticate(
          reason: reason,
        );

        if (!isAuthenticated) {
          throw AuthenticationException('Authentication failed');
        }
      }

      return utf8.decode(base64.decode(encodedKey));
    } catch (e) {
      if (e is AuthenticationException) rethrow;
      throw StorageException('Failed to get session key: $e');
    }
  }

  Future<bool> hasSessionKey() async {
    try {
      final key = await _storage.read(key: _sessionKey);
      return key != null;
    } catch (e) {
      return false;
    }
  }

  Future<void> deleteSessionKey() async {
    try {
      await _storage.delete(key: _sessionKey);
      await _storage.delete(key: _authMethodKey);
    } catch (e) {
      throw StorageException('Failed to delete session key: $e');
    }
  }

  Future<void> clearStorage() async {
    try {
      await _storage.deleteAll();
    } catch (e) {
      throw StorageException('Failed to clear storage: $e');
    }
  }

  Future<AuthMethod> getCurrentAuthMethod() async {
    try {
      final method = await _storage.read(key: _authMethodKey);
      if (method == null) return AuthMethod.none;
      return AuthMethod.values.firstWhere(
        (e) => e.toString() == method,
        orElse: () => AuthMethod.none,
      );
    } catch (e) {
      return AuthMethod.none;
    }
  }
}

class SecurityException implements Exception {
  final String message;
  SecurityException(this.message);
  @override
  String toString() => message;
}

class StorageException implements Exception {
  final String message;
  StorageException(this.message);
  @override
  String toString() => message;
}

class AuthenticationException implements Exception {
  final String message;
  AuthenticationException(this.message);
  @override
  String toString() => message;
}

```

`lib/services/social_media.dart`:

```dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:url_launcher/url_launcher.dart';

class SocialMediaService {
  static const String _telegramScheme = 'tg://';
  static const String _telegramWebUrl = 'https://telegram.org';
  static const String _telegramAndroidStore =
      'market://details?id=org.telegram.messenger';
  static const String _telegramIosStore =
      'https://apps.apple.com/app/telegram-messenger/id686449807';

  static final String _xScheme =
      Platform.isIOS ? 'twitter://' : 'com.twitter.android';
  static const String _xWebUrl = 'https://x.com';
  static const String _xAndroidStore =
      'market://details?id=com.twitter.android';
  static const String _xIosStore =
      'https://apps.apple.com/app/twitter/id333903271';

  static final String _githubScheme =
      Platform.isIOS ? 'github://' : 'com.github.android';
  static const String _githubWebUrl = 'https://github.com';
  static const String _githubAndroidStore =
      'market://details?id=com.github.android';
  static const String _githubIosStore =
      'https://apps.apple.com/app/github/id1477376905';

  Future<void> openTelegram({String? username, String? message}) async {
    String url = _telegramScheme;

    if (username != null) {
      url = 'tg://resolve?domain=$username';
    } else if (message != null) {
      url = 'tg://msg?text=${Uri.encodeComponent(message)}';
    }

    try {
      final Uri uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(
          uri,
          mode: LaunchMode.externalApplication,
        );
      } else {
        await _handleAppNotInstalled(
          webUrl: _telegramWebUrl,
          androidStore: _telegramAndroidStore,
          iosStore: _telegramIosStore,
        );
      }
    } catch (e) {
      debugPrint('Error launching Telegram: $e');

      await _launchUrl(_telegramWebUrl);
    }
  }

  Future<void> openX({String? username, String? tweet}) async {
    String url = _xScheme;

    if (username != null) {
      url = Platform.isIOS
          ? 'twitter://user?screen_name=$username'
          : 'com.twitter.android://user?screen_name=$username';
    } else if (tweet != null) {
      url = Platform.isIOS
          ? 'twitter://post?message=${Uri.encodeComponent(tweet)}'
          : 'com.twitter.android://post?message=${Uri.encodeComponent(tweet)}';
    }

    try {
      final Uri uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(
          uri,
          mode: LaunchMode.externalApplication,
        );
      } else {
        await _handleAppNotInstalled(
          webUrl: _xWebUrl,
          androidStore: _xAndroidStore,
          iosStore: _xIosStore,
        );
      }
    } catch (e) {
      debugPrint('Error launching X: $e');

      await _launchUrl(_xWebUrl);
    }
  }

  Future<void> openGitHub({String? username, String? repository}) async {
    String url;

    if (username != null && repository != null) {
      url = Platform.isIOS
          ? 'github://repo/$username/$repository'
          : 'com.github.android://repo/$username/$repository';
    } else if (username != null) {
      url = Platform.isIOS
          ? 'github://user/$username'
          : 'com.github.android://user/$username';
    } else {
      url = _githubScheme;
    }

    String webUrl = _githubWebUrl;
    if (username != null && repository != null) {
      webUrl = '$_githubWebUrl/$username/$repository';
    } else if (username != null) {
      webUrl = '$_githubWebUrl/$username';
    }

    try {
      final Uri uri = Uri.parse(url);
      if (await canLaunchUrl(uri)) {
        await launchUrl(
          uri,
          mode: LaunchMode.externalApplication,
        );
      } else {
        await _handleAppNotInstalled(
          webUrl: webUrl,
          androidStore: _githubAndroidStore,
          iosStore: _githubIosStore,
        );
      }
    } catch (e) {
      debugPrint('Error launching GitHub: $e');

      await _launchUrl(webUrl);
    }
  }

  Future<void> _handleAppNotInstalled({
    required String webUrl,
    required String androidStore,
    required String iosStore,
  }) async {
    final Uri storeUri = Uri.parse(
      Platform.isAndroid ? androidStore : iosStore,
    );

    try {
      if (await canLaunchUrl(storeUri)) {
        await launchUrl(storeUri);
      } else {
        await _launchUrl(webUrl);
      }
    } catch (e) {
      debugPrint('Error opening store/web: $e');
      await _launchUrl(webUrl);
    }
  }

  Future<void> _launchUrl(String url) async {
    final Uri uri = Uri.parse(url);
    try {
      await launchUrl(
        uri,
        mode: LaunchMode.externalApplication,
      );
    } catch (e) {
      debugPrint('Error launching URL: $e');
    }
  }
}

```

`lib/state/app_state.dart`:

```dart
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:zilpay/mixins/gas_eip1559.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/src/rust/api/book.dart';
import 'package:zilpay/src/rust/api/connections.dart';
import 'package:zilpay/src/rust/api/settings.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/transaction.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/account.dart';
import 'package:zilpay/src/rust/models/background.dart';
import 'package:zilpay/src/rust/models/book.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/wallet.dart';
import 'package:zilpay/theme/app_theme.dart';

class AppState extends ChangeNotifier with WidgetsBindingObserver {
  List<AddressBookEntryInfo> _book = [];
  List<ConnectionInfo> _connections = [];
  DateTime _lastRateUpdateTime = DateTime.fromMillisecondsSinceEpoch(0);
  GasFeeOption _selectedGasOption = GasFeeOption.market;
  bool _showAddressesThroughTransactionHistory = false;

  static const Duration _rateUpdateCooldown = Duration(minutes: 1);
  static const String _hideBalanceStorageKey = "hide_balance_key";
  static const String _gasOptionStorageKey = "gas_option_key";
  static const String _showAddressesThroughTransactionHistoryKey =
      "show_addresses_transaction_history_key";

  late BackgroundState _state;
  late String _cahceDir;
  int _selectedWallet = 0;
  bool _hideBalance = false;

  final Brightness _systemBrightness =
      PlatformDispatcher.instance.platformBrightness;

  AppState({
    required BackgroundState state,
    required String cahceDir,
  }) {
    WidgetsBinding.instance.addObserver(this);
    _state = state;
    _cahceDir = cahceDir;
  }

  void setSelectedWallet(int index) {
    _selectedWallet = index;
    notifyListeners();
  }

  bool get showAddressesThroughTransactionHistory {
    return _showAddressesThroughTransactionHistory;
  }

  GasFeeOption get selectedGasOption {
    return _selectedGasOption;
  }

  String get cahceDir {
    return _cahceDir;
  }

  bool get hideBalance {
    return _hideBalance;
  }

  List<WalletInfo> get wallets {
    return _state.wallets;
  }

  Locale? get locale {
    return state.locale != null ? Locale(state.locale!) : null;
  }

  List<ConnectionInfo> get connections {
    return _connections;
  }

  List<AddressBookEntryInfo> get book {
    return _book;
  }

  BackgroundState get state {
    return _state;
  }

  AppTheme get currentTheme {
    switch (_state.appearances) {
      case 0:
        return _systemBrightness == Brightness.dark
            ? DarkTheme()
            : LightTheme();
      case 1:
        return DarkTheme();
      case 2:
        return LightTheme();
      default:
        return _systemBrightness == Brightness.dark
            ? DarkTheme()
            : LightTheme();
    }
  }

  WalletInfo? get wallet {
    return _state.wallets[_selectedWallet];
  }

  NetworkConfigInfo? get chain {
    BigInt? hash = account?.chainHash;

    if (hash == null) {
      return null;
    }

    return getChain(hash);
  }

  AccountInfo? get account {
    if (wallet == null) {
      return null;
    }

    int index = wallet!.selectedAccount.toInt();

    return wallet!.accounts[index];
  }

  int get selectedWallet {
    return _selectedWallet;
  }

  void setHideBalance(bool value) async {
    _hideBalance = value;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_hideBalanceStorageKey, value);
    notifyListeners();
  }

  Future<void> syncData() async {
    _state = await getData();
    await syncBook();
    await syncConnections();
    await loadSelectedGasOption();
    await loadHideBalance();
    await loadShowAddressesThroughTransactionHistory();
    notifyListeners();
  }

  Future<void> syncBook() async {
    _book = await getAddressBookList();

    notifyListeners();
  }

  Future<void> loadHideBalance() async {
    final prefs = await SharedPreferences.getInstance();
    _hideBalance = prefs.getBool(_hideBalanceStorageKey) ?? false;
    notifyListeners();
  }

  Future<void> syncConnections() async {
    _connections =
        await getConnectionsList(walletIndex: BigInt.from(_selectedWallet));

    notifyListeners();
  }

  Future<void> syncRates({bool force = false}) async {
    if (chain?.testnet == true || wallet?.settings.ratesApiOptions == 0) return;
    final now = DateTime.now();

    if (!force && now.difference(_lastRateUpdateTime) < _rateUpdateCooldown) {
      return;
    }

    try {
      await updateRates(walletIndex: BigInt.from(_selectedWallet));
      _lastRateUpdateTime = now;
    } catch (e) {
      debugPrint("error sync rates: $e");
    }

    notifyListeners();
  }

  Future<void> updateSelectedAccount(
    BigInt walletIndex,
    BigInt accountIndex,
  ) async {
    await selectAccount(walletIndex: walletIndex, accountIndex: accountIndex);
    await syncData();

    notifyListeners();
  }

  Future<void> setAppearancesCode(int code, bool compactNumbers) async {
    await setTheme(
      appearancesCode: code,
      compactNumbers: compactNumbers,
    );
    _state = await getData();

    notifyListeners();

    SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: currentTheme.brightness,
      statusBarBrightness: currentTheme.brightness == Brightness.light
          ? Brightness.dark
          : Brightness.light,
      systemNavigationBarColor: currentTheme.background,
      systemNavigationBarIconBrightness: currentTheme.brightness,
    ));
  }

  Future<void> setSelectedGasOption(GasFeeOption option) async {
    _selectedGasOption = option;
    final prefs = await SharedPreferences.getInstance();
    final key = "$_gasOptionStorageKey:$selectedWallet";
    await prefs.setString(key, option.name);
    notifyListeners();
  }

  Future<void> loadSelectedGasOption() async {
    final prefs = await SharedPreferences.getInstance();
    final key = "$_gasOptionStorageKey:$selectedWallet";
    final optionName = prefs.getString(key);

    if (optionName != null) {
      try {
        _selectedGasOption = GasFeeOption.values.firstWhere(
          (option) => option.name == optionName,
        );
      } catch (e) {
        _selectedGasOption = GasFeeOption.market;
      }
    }
    notifyListeners();
  }

  Future<void> setShowAddressesThroughTransactionHistory(bool value) async {
    _showAddressesThroughTransactionHistory = value;
    final prefs = await SharedPreferences.getInstance();
    final key = "$_showAddressesThroughTransactionHistoryKey:$selectedWallet";
    await prefs.setBool(key, value);
    notifyListeners();
  }

  Future<void> loadShowAddressesThroughTransactionHistory() async {
    final prefs = await SharedPreferences.getInstance();
    final key = "$_showAddressesThroughTransactionHistoryKey:$selectedWallet";
    _showAddressesThroughTransactionHistory = prefs.getBool(key) ?? false;
    notifyListeners();
  }

  Future<void> startTrackHistoryWorker() async {
    try {
      Stream<String> stream =
          startHistoryWorker(walletIndex: BigInt.from(selectedWallet));

      stream.listen((event) async {
        notifyListeners();
      });
    } catch (e) {
      debugPrint("start worker error: $e");
    }
  }

  NetworkConfigInfo? getChain(BigInt hash) {
    return state.providers.firstWhere((e) => e.chainHash == hash);
  }
}

```

`lib/theme/app_theme.dart`:

```dart
import 'package:flutter/material.dart';

class _TextStyles {
  static const String _fontFamily = 'SFRounded';

  static const TextStyle headline1 = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 28,
    fontWeight: FontWeight.bold,
  );
  static const TextStyle headline2 = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 22,
    fontWeight: FontWeight.w600,
  );
  static const TextStyle subtitle1 = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 20,
    fontWeight: FontWeight.w500,
  );
  static const TextStyle bodyText1 = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 15,
    fontWeight: FontWeight.w500,
  );
  static const TextStyle bodyText2 = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 14,
    fontWeight: FontWeight.w500,
  );
  static const TextStyle button = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 16,
    fontWeight: FontWeight.w600,
    letterSpacing: 1.25,
  );
  static const TextStyle caption = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 11,
    fontWeight: FontWeight.w400,
  );
  static const TextStyle overline = TextStyle(
    fontFamily: _fontFamily,
    fontSize: 10,
    fontWeight: FontWeight.w300,
    letterSpacing: 1.5,
  );
}

abstract class AppTheme {
  String value = "Dark";

  Color get primaryPurple;
  Color get secondaryPurple;
  Color get background;
  Color get cardBackground;
  Color get textPrimary;
  Color get textSecondary;
  Color get buttonBackground;
  Color get buttonText;
  Color get danger;
  Color get success;
  Color get warning;

  Color get gradientStart;
  Color get gradientMiddle;
  Color get gradientEnd;

  Color get modalBorder;

  Brightness get brightness;

  TextStyle get headline1;
  TextStyle get headline2;
  TextStyle get subtitle1;
  TextStyle get bodyText1;
  TextStyle get bodyText2;
  TextStyle get button;
  TextStyle get caption;
  TextStyle get overline;
}

class DarkTheme implements AppTheme {
  @override
  String value = "Dark";

  @override
  Color get primaryPurple => const Color(0xFF8A2BE2);
  @override
  Color get secondaryPurple => const Color(0xFFB23AEE);
  @override
  Color get background => Colors.black;
  @override
  Color get cardBackground => const Color(0xFF0D1117);
  @override
  Color get textPrimary => Colors.white;
  @override
  Color get textSecondary => const Color(0xFFB3B3B3);
  @override
  Color get buttonBackground => const Color(0xFF3A3A3A);
  @override
  Color get buttonText => const Color(0xFFE0E0E0);
  @override
  Color get danger => const Color(0xFFE94560);
  @override
  Color get success => const Color(0xFF4CAF50);
  @override
  Color get warning => const Color(0xFFFF9800);

  @override
  Color get gradientStart => const Color(0xFF4A0E4E);
  @override
  Color get gradientMiddle => const Color(0xFF220A23);
  @override
  Color get gradientEnd => Colors.black;

  @override
  Color get modalBorder => Colors.grey.withValues(alpha: 0.2);

  @override
  Brightness get brightness => Brightness.light;

  @override
  TextStyle get headline1 => _TextStyles.headline1;
  @override
  TextStyle get headline2 => _TextStyles.headline2;
  @override
  TextStyle get subtitle1 => _TextStyles.subtitle1;
  @override
  TextStyle get bodyText1 => _TextStyles.bodyText1;
  @override
  TextStyle get bodyText2 => _TextStyles.bodyText2;
  @override
  TextStyle get button => _TextStyles.button;
  @override
  TextStyle get caption => _TextStyles.caption;
  @override
  TextStyle get overline => _TextStyles.overline;
}

class LightTheme implements AppTheme {
  @override
  String value = "Light";

  @override
  Color get primaryPurple => const Color(0xFFFC72FF);
  @override
  Color get secondaryPurple => const Color(0xFFB0B0B0);
  @override
  Color get background => const Color(0xFFFFFFFF);
  @override
  Color get cardBackground => const Color(0xFFF7F7F7);
  @override
  Color get textPrimary => const Color(0xFF000000);
  @override
  Color get textSecondary => const Color(0xFF6C6C6C);
  @override
  Color get buttonBackground => const Color(0xFFFF007A);
  @override
  Color get buttonText => const Color(0xFFFFFFFF);
  @override
  Color get danger => const Color(0xFFFF4D4D);
  @override
  Color get success => const Color(0xFF00D395);
  @override
  Color get warning => const Color(0xFFFFA500);

  @override
  Color get gradientStart => const Color(0xFFFF007A);
  @override
  Color get gradientMiddle => const Color(0xFFD500F9);
  @override
  Color get gradientEnd => const Color(0xFFFF007A);

  @override
  Color get modalBorder => const Color(0xFFE0E0E0);

  @override
  Brightness get brightness => Brightness.light;

  @override
  TextStyle get headline1 => _TextStyles.headline1;
  @override
  TextStyle get headline2 => _TextStyles.headline2;
  @override
  TextStyle get subtitle1 => _TextStyles.subtitle1;
  @override
  TextStyle get bodyText1 => _TextStyles.bodyText1;
  @override
  TextStyle get bodyText2 => _TextStyles.bodyText2;
  @override
  TextStyle get button => _TextStyles.button;
  @override
  TextStyle get caption => _TextStyles.caption;
  @override
  TextStyle get overline => _TextStyles.overline;
}

```

`lib/utils/utils.dart`:

```dart
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

List<int> hexToBytes(String hex) => [
      for (int i = 0; i < hex.length; i += 2)
        int.parse(hex.substring(i, i + 2), radix: 16)
    ];

String decodePersonalSignMessage(String dataToSign) {
  try {
    if (dataToSign.startsWith('0x')) {
      final bytes = hexToBytes(dataToSign.substring(2));
      return String.fromCharCodes(bytes);
    }
    return dataToSign;
  } catch (e) {
    return dataToSign;
  }
}

bool isDomainConnected(String domain, List<dynamic> connections) {
  return connections.any((conn) => conn.domain == domain);
}

List<String> filterByIndexes(List<String> addresses, Uint64List indexes) {
  return [
    for (var i = 0; i < indexes.length; i++)
      if (i < addresses.length) addresses[indexes[i].toInt()]
  ];
}

```

`lib/web3/eip_1193.dart`:

```dart
import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/config/eip1193.dart';
import 'package:zilpay/config/ftokens.dart';
import 'package:zilpay/mixins/eip712.dart';
import 'package:zilpay/modals/add_chain.dart';
import 'package:zilpay/modals/app_connect.dart';
import 'package:zilpay/modals/sign_message.dart';
import 'package:zilpay/modals/swich_chain_modal.dart';
import 'package:zilpay/modals/transfer.dart';
import 'package:zilpay/modals/watch_asset_modal.dart';
import 'package:zilpay/src/rust/api/connections.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/provider.dart';
import 'package:zilpay/src/rust/models/transactions/base_token.dart';
import 'package:zilpay/src/rust/models/transactions/evm.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/src/rust/models/transactions/transaction_metadata.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/web3/message.dart';
import 'dart:developer' as dev;

import 'package:zilpay/web3/web3_utils.dart';

extension NetworkConfigInfoExtension on NetworkConfigInfo {
  NetworkConfigInfo copyWith({
    String? name,
    String? logo,
    String? chain,
    String? shortName,
    List<String>? rpc,
    Uint16List? features,
    BigInt? chainId,
    Uint64List? chainIds,
    int? slip44,
    BigInt? diffBlockTime,
    BigInt? chainHash,
    String? ens,
    List<ExplorerInfo>? explorers,
    bool? fallbackEnabled,
    bool? testnet,
    List<FTokenInfo>? ftokens,
  }) {
    return NetworkConfigInfo(
      ftokens: ftokens ?? this.ftokens,
      name: name ?? this.name,
      logo: logo ?? this.logo,
      chain: chain ?? this.chain,
      shortName: shortName ?? this.shortName,
      rpc: rpc ?? this.rpc,
      features: features ?? this.features,
      chainId: chainId ?? this.chainId,
      chainIds: chainIds ?? this.chainIds,
      slip44: slip44 ?? this.slip44,
      diffBlockTime: diffBlockTime ?? this.diffBlockTime,
      chainHash: chainHash ?? this.chainHash,
      ens: ens ?? this.ens,
      explorers: explorers ?? this.explorers,
      fallbackEnabled: fallbackEnabled ?? this.fallbackEnabled,
      testnet: testnet ?? this.testnet,
    );
  }
}

class Web3EIP1193Handler {
  final InAppWebViewController webViewController;
  final String _currentDomain;
  final Set<String> _activeRequests = {};

  Web3EIP1193Handler({
    required this.webViewController,
    required String initialUrl,
  }) : _currentDomain = Uri.parse(initialUrl).host;

  bool _isRequestActive(String method) {
    return _activeRequests.contains(method);
  }

  void _addActiveRequest(String method) {
    _activeRequests.add(method);
  }

  void _removeActiveRequest(String method) {
    _activeRequests.remove(method);
  }

  Future<void> _sendResponse({
    required String type,
    required String uuid,
    Map<String, dynamic>? payload,
    dynamic result,
    Web3EIP1193ErrorCode? errorCode,
    String? errorMessage,
  }) async {
    final responsePayload = {
      if (payload != null) ...payload,
      if (result != null) 'result': result,
      if (errorCode != null && errorMessage != null)
        'error': {'code': errorCode.code, 'message': errorMessage},
    };

    final response = ZilPayWeb3Message(
      type: type,
      uuid: uuid,
      payload: responsePayload,
    ).toJson();

    final jsResponse = jsonEncode(response);
    final jsCode = '''
    (function() {
      const responseData = $jsResponse;
      if (window.__zilpay_response_handlers && window.__zilpay_response_handlers["$uuid"]) {
        const handler = window.__zilpay_response_handlers["$uuid"];
        handler(responseData);
        delete window.__zilpay_response_handlers["$uuid"];
      } else {
        window.dispatchEvent(new MessageEvent('message', { 
          data: responseData
        }));
      }
    })();
    ''';

    await webViewController.evaluateJavascript(source: jsCode);
  }

  void _returnError(
    String uuid,
    Web3EIP1193ErrorCode errorCode,
    String errorMessage,
  ) {
    _sendResponse(
      type: 'ZILPAY_RESPONSE',
      uuid: uuid,
      errorCode: errorCode,
      errorMessage: errorMessage,
    );
  }

  Future<List<String>> _getWalletAddresses(AppState appState) async {
    List<String> addresses = [];
    final selectedAccountIndex = appState.wallet?.selectedAccount.toInt();

    if (appState.chain?.slip44 == 313) {
      addresses = await getZilEthChecksumAddresses(
          walletIndex: BigInt.from(appState.selectedWallet));
    } else {
      addresses = (appState.wallet?.accounts ?? []).map((a) => a.addr).toList();
    }

    if (selectedAccountIndex != null &&
        selectedAccountIndex >= 0 &&
        selectedAccountIndex < addresses.length) {
      return [addresses[selectedAccountIndex]];
    }

    return addresses;
  }

  Future<void> handleWeb3EIP1193Message(
    ZilPayWeb3Message message,
    BuildContext context,
  ) async {
    final appState = Provider.of<AppState>(context, listen: false);
    final chain = appState.chain;

    try {
      final method = message.payload['method'] as String?;

      if (method == null) {
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unsupportedMethod,
          'No method specified',
        );
      }

      final zilPayMethod = Web3EIP1193Method.values.firstWhere(
        (m) => m.value == method,
        orElse: () => Web3EIP1193Method.ethRequestAccounts,
      );

      switch (zilPayMethod) {
        case Web3EIP1193Method.ethRequestAccounts:
          await _handleEthRequestAccounts(message, context, appState);
          break;
        case Web3EIP1193Method.walletRequestPermissions:
          await _handleWalletRequestPermissions(message, context, appState);
          break;
        case Web3EIP1193Method.walletGetPermissions:
          await _handleWalletGetPermissions(message, appState);
          break;

        case Web3EIP1193Method.ethAccounts:
          await _handleEthAccounts(message, appState);
          break;

        case Web3EIP1193Method.ethSign:
        case Web3EIP1193Method.personalSign:
          await _handleEthereumSigning(
            message: message,
            context: context,
            appState: appState,
            isPersonalSign: zilPayMethod == Web3EIP1193Method.personalSign,
          );
          break;

        case Web3EIP1193Method.ethGetBalance:
        case Web3EIP1193Method.ethGetTransactionByHash:
        case Web3EIP1193Method.ethGetTransactionReceipt:
        case Web3EIP1193Method.ethCall:
        case Web3EIP1193Method.ethEstimateGas:
        case Web3EIP1193Method.ethBlockNumber:
        case Web3EIP1193Method.ethGetBlockByNumber:
        case Web3EIP1193Method.ethGetBlockByHash:
        case Web3EIP1193Method.netVersion:
        case Web3EIP1193Method.ethChainId:
        case Web3EIP1193Method.ethGetCode:
        case Web3EIP1193Method.ethGetStorageAt:
        case Web3EIP1193Method.ethGasPrice:
        case Web3EIP1193Method.ethGetTransactionCount:
          await _proxyRpcRequest(
            method: zilPayMethod.value,
            uuid: message.uuid,
            params: message.payload['params'],
            chainHash: chain?.chainHash ?? BigInt.zero,
          );
          break;

        case Web3EIP1193Method.ethSignTypedDataV4:
          await _handleEthSignTypedDataV4(
            message,
            context,
            appState,
          );
          break;

        case Web3EIP1193Method.ethSendTransaction:
          await _handleEthSendTransaction(message, context, appState);
          break;
        case Web3EIP1193Method.walletWatchAsset:
          await _handleWalletWatchAsset(message, context, appState);
          break;

        case Web3EIP1193Method.walletAddEthereumChain:
          await _handleWalletAddEthereumChain(message, context, appState);
          break;

        case Web3EIP1193Method.walletSwitchEthereumChain:
          await _handleWalletSwitchEthereumChain(message, context, appState);
          break;

        default:
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.unsupportedMethod,
            'Method "${zilPayMethod.value}" is not supported',
          );
          break;
      }
    } catch (e) {
      dev.log('Error handling message: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing message: $e',
      );
    }
  }

  Future<void> _handleEthRequestAccounts(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      await appState.syncConnections();
      final connection = Web3Utils.findConnected(
        _currentDomain,
        appState.connections,
      );

      final addresses = await _getWalletAddresses(appState);

      if (connection != null &&
          appState.wallet?.accounts.length ==
              connection.accountIndexes.length) {
        _removeActiveRequest(method);

        return _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: message.uuid,
          result: addresses,
        );
      }

      String? title = await webViewController.getTitle();

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showAppConnectModal(
        context: context,
        title: message.title ?? "",
        uuid: message.uuid,
        iconUrl: message.icon ?? "",
        onReject: () {
          _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: <void>[],
          );
          _removeActiveRequest(method);
        },
        onConfirm: (selectedIndices) async {
          try {
            if (selectedIndices.isEmpty) {
              return _sendResponse(
                type: 'ZILPAY_RESPONSE',
                uuid: message.uuid,
                result: <void>[],
              );
            }

            final accountIndexes = Uint64List.fromList(selectedIndices);
            final connectionInfo = ConnectionInfo(
              domain: _currentDomain,
              accountIndexes: accountIndexes,
              favicon: message.icon,
              title: title ?? "",
              description: message.description,
              lastConnected: BigInt.from(DateTime.now().millisecondsSinceEpoch),
              canReadAccounts: true,
              canRequestSignatures: true,
              canSuggestTokens: false,
              canSuggestTransactions: true,
            );

            await createUpdateConnection(
              walletIndex: BigInt.from(appState.selectedWallet),
              conn: connectionInfo,
            );
            await appState.syncConnections();

            final connectedAddr = filterByIndexes(addresses, accountIndexes);
            _sendResponse(
              type: 'ZILPAY_RESPONSE',
              uuid: message.uuid,
              result: connectedAddr,
            );
          } finally {
            _removeActiveRequest(method);
          }
        },
      );
    } catch (e) {
      _removeActiveRequest(method);
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing request: $e',
      );
    }
  }

  Future<void> _handleEthAccounts(
    ZilPayWeb3Message message,
    AppState appState,
  ) async {
    await appState.syncConnections();
    final connection =
        Web3Utils.findConnected(_currentDomain, appState.connections);
    final addresses = await _getWalletAddresses(appState);
    final connectedAddr =
        filterByIndexes(addresses, connection?.accountIndexes ?? Uint64List(0));

    _sendResponse(
      type: 'ZILPAY_RESPONSE',
      uuid: message.uuid,
      result: connectedAddr,
    );
  }

  Future<void> _proxyRpcRequest({
    required String method,
    required String uuid,
    required BigInt chainHash,
    List<dynamic>? params,
  }) async {
    try {
      final payload = jsonEncode({
        'method': method,
        'params': params ?? [],
        'jsonrpc': '2.0',
        'id': uuid,
      });

      final jsonRes =
          await providerReqProxy(payload: payload, chainHash: chainHash);
      final response = jsonDecode(jsonRes);

      if (response['error'] != null) {
        final error = response['error'];
        final errorCode =
            error['code'] as int? ?? Web3EIP1193ErrorCode.internalError.code;
        final errorMessage = error['message'] as String? ?? 'Unknown RPC error';

        _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: uuid,
          errorCode: Web3EIP1193ErrorCode.values.firstWhere(
            (e) => e.code == errorCode,
            orElse: () => Web3EIP1193ErrorCode.internalError,
          ),
          errorMessage: errorMessage,
        );
      } else {
        _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: uuid,
          result: response['result'],
        );
      }
    } catch (e) {
      dev.log('RPC proxy error: $e', name: 'web3_handler');
      _returnError(
        uuid,
        Web3EIP1193ErrorCode.internalError,
        'Failed to proxy RPC request: $e',
      );
    }
  }

  Future<void> _handleEthereumSigning({
    required ZilPayWeb3Message message,
    required BuildContext context,
    required AppState appState,
    required bool isPersonalSign,
  }) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final connection =
          Web3Utils.findConnected(_currentDomain, appState.connections);

      if (connection == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'This domain is not connected. Please connect first.',
        );
      }

      final params = message.payload['params'] as List<dynamic>?;
      if (params == null || params.length < 2) {
        _removeActiveRequest(method);
        final methodName = isPersonalSign ? 'personal_sign' : 'eth_sign';
        final paramOrder =
            isPersonalSign ? '[message, address]' : '[address, message]';
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for $methodName. Required: $paramOrder',
        );
      }

      final address =
          isPersonalSign ? params[1] as String : params[0] as String;
      final dataToSign =
          isPersonalSign ? params[0] as String : params[1] as String;

      final addresses = await _getWalletAddresses(appState);
      final connectedAddresses =
          filterByIndexes(addresses, connection.accountIndexes);

      if (!connectedAddresses
          .map((a) => a.toLowerCase())
          .contains(address.toLowerCase())) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'The requested address is not authorized',
        );
      }

      final messageContent =
          isPersonalSign ? decodePersonalSignMessage(dataToSign) : dataToSign;

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showSignMessageModal(
        context: context,
        message: messageContent,
        onMessageSigned: (pubkey, sig) async {
          await _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: sig,
          );
          _removeActiveRequest(method);
          if (context.mounted) {
            Navigator.pop(context);
          }
        },
        onDismiss: () {
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.userRejectedRequest,
            'User rejected',
          );
          _removeActiveRequest(method);
        },
        appTitle: isPersonalSign ? 'Sign Message' : 'Sign Ethereum Message',
        appIcon: message.icon ?? '',
      );
    } catch (e) {
      _removeActiveRequest(method);
      final methodName = isPersonalSign ? 'personal_sign' : 'eth_sign';
      dev.log('Error in $methodName: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing $methodName: $e',
      );
    }
  }

  Future<void> _handleEthSendTransaction(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final connection = Web3Utils.findConnected(
        _currentDomain,
        appState.connections,
      );

      if (connection == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'This domain is not connected. Please connect first.',
        );
      }

      final params = message.payload['params'] as List<dynamic>?;
      if (params == null ||
          params.isEmpty ||
          params[0] is! Map<String, dynamic>) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for eth_sendTransaction',
        );
      }

      final txParams = params[0] as Map<String, dynamic>;
      final from = txParams['from'] as String?;

      if (from == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Missing required parameter: from',
        );
      }

      final addresses = await _getWalletAddresses(appState);
      List<String> connectedAddresses =
          filterByIndexes(addresses, connection.accountIndexes)
              .map((a) => a.toLowerCase())
              .toList();

      if (!connectedAddresses.contains(from.toLowerCase())) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'The requested address is not authorized',
        );
      }

      String? title = await webViewController.getTitle();

      final BigInt? chainId = txParams['chainId'] != null
          ? BigInt.parse(txParams['chainId'].toString().replaceFirst('0x', ''),
              radix: 16)
          : null;
      final BigInt? gasLimit = txParams['gas'] != null
          ? BigInt.parse(txParams['gas'].toString().replaceFirst('0x', ''),
              radix: 16)
          : null;
      final BigInt? maxFeePerGas = txParams['maxFeePerGas'] != null
          ? BigInt.parse(
              txParams['maxFeePerGas'].toString().replaceFirst('0x', ''),
              radix: 16)
          : null;
      final BigInt? maxPriorityFeePerGas =
          txParams['maxPriorityFeePerGas'] != null
              ? BigInt.parse(
                  txParams['maxPriorityFeePerGas']
                      .toString()
                      .replaceFirst('0x', ''),
                  radix: 16)
              : null;
      final BigInt? gasPrice = txParams['gasPrice'] != null
          ? BigInt.parse(txParams['gasPrice'].toString().replaceFirst('0x', ''),
              radix: 16)
          : null;
      final String? value = txParams['value'] as String?;
      final String? to = txParams['to'] as String?;

      final Uint8List? data = txParams['data'] != null
          ? Uint8List.fromList(
              hexToBytes(txParams['data'].toString().replaceFirst('0x', '')))
          : null;

      final evmRequest = TransactionRequestEVM(
        nonce: null,
        from: from,
        to: to,
        value: value,
        gasLimit: gasLimit,
        data: data,
        maxFeePerGas: maxFeePerGas,
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        gasPrice: gasPrice,
        chainId: chainId,
        accessList: null,
        blobVersionedHashes: null,
        maxFeePerBlobGas: null,
      );

      FTokenInfo? mbToken = appState.wallet?.tokens
          .firstWhere((t) => t.addrType == 1 && t.native);

      if (mbToken == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.internalError,
          'No native token found',
        );
      }

      final BigInt valueAmount = value != null && value != '0x0'
          ? BigInt.parse(value.replaceFirst('0x', ''), radix: 16)
          : BigInt.zero;

      final tokenInfo = BaseTokenInfo(
        value: valueAmount.toString(),
        symbol: mbToken.symbol,
        decimals: mbToken.decimals,
      );

      final metadata = TransactionMetadataInfo(
        chainHash: appState.chain?.chainHash ?? BigInt.zero,
        hash: null,
        info: null,
        icon: message.icon,
        title: title ?? "EVM Transaction",
        signer: null,
        tokenInfo: tokenInfo,
      );

      final transactionRequest = TransactionRequestInfo(
        metadata: metadata,
        scilla: null,
        evm: evmRequest,
      );

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showConfirmTransactionModal(
        context: context,
        tx: transactionRequest,
        to: to ?? "",
        colors: connection.colors,
        token: mbToken,
        amount: fromWei(
          value: valueAmount.toString(),
          decimals: mbToken.decimals,
        ).toString(),
        onConfirm: (tx) {
          _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: tx.transactionHash,
          );
          if (context.mounted) {
            Navigator.pop(context);
          }
          _removeActiveRequest(method);
        },
        onDismiss: () {
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.userRejectedRequest,
            'User rejected the request',
          );
          _removeActiveRequest(method);
        },
      );
    } catch (e) {
      _removeActiveRequest(method);
      dev.log('Error in eth_sendTransaction: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing eth_sendTransaction: $e',
      );
    }
  }

  Future<void> _handleWalletGetPermissions(
    ZilPayWeb3Message message,
    AppState appState,
  ) async {
    try {
      await appState.syncConnections();
      final connection =
          Web3Utils.findConnected(_currentDomain, appState.connections);

      if (connection == null) {
        return _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: message.uuid,
          result: [],
        );
      }

      final addresses = await _getWalletAddresses(appState);
      final connectedAddr =
          filterByIndexes(addresses, connection.accountIndexes);

      _sendResponse(
        type: 'ZILPAY_RESPONSE',
        uuid: message.uuid,
        result: [
          {
            'parentCapability': 'eth_accounts',
            'caveats': [
              {
                'type': 'filterResponse',
                'value': connectedAddr,
              }
            ],
          }
        ],
      );
    } catch (e) {
      dev.log('Error in wallet_getPermissions: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing wallet_getPermissions: $e',
      );
    }
  }

  Future<void> _handleWalletRequestPermissions(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final params = message.payload['params'] as List<dynamic>?;
      if (params == null ||
          params.isEmpty ||
          params[0] is! Map<String, dynamic>) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for wallet_requestPermissions',
        );
      }

      final requestParams = params[0] as Map<String, dynamic>;

      if (!requestParams.containsKey('eth_accounts')) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Only eth_accounts permission is supported',
        );
      }

      await appState.syncConnections();
      final connection = Web3Utils.findConnected(
        _currentDomain,
        appState.connections,
      );
      final addresses = await _getWalletAddresses(appState);

      if (connection != null &&
          appState.wallet?.accounts.length ==
              connection.accountIndexes.length) {
        _removeActiveRequest(method);
        return _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: message.uuid,
          result: {
            'permissions': [
              {
                'parentCapability': 'eth_accounts',
                'caveats': [
                  {
                    'type': 'filterResponse',
                    'value': addresses,
                  }
                ],
              }
            ]
          },
        );
      }

      String? title = await webViewController.getTitle();

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showAppConnectModal(
        context: context,
        title: title ?? "",
        uuid: message.uuid,
        iconUrl: message.icon ?? "",
        onReject: () {
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.userRejectedRequest,
            'User rejected the request',
          );
          _removeActiveRequest(method);
        },
        onConfirm: (selectedIndices) async {
          try {
            if (selectedIndices.isEmpty) {
              return _returnError(
                message.uuid,
                Web3EIP1193ErrorCode.userRejectedRequest,
                'User rejected the request',
              );
            }

            final accountIndexes = Uint64List.fromList(selectedIndices);
            final connectionInfo = ConnectionInfo(
              domain: _currentDomain,
              accountIndexes: accountIndexes,
              favicon: message.icon,
              title: title ?? "",
              description: message.description,
              lastConnected: BigInt.from(DateTime.now().millisecondsSinceEpoch),
              canReadAccounts: true,
              canRequestSignatures: true,
              canSuggestTokens: false,
              canSuggestTransactions: true,
            );

            await createUpdateConnection(
              walletIndex: BigInt.from(appState.selectedWallet),
              conn: connectionInfo,
            );
            await appState.syncConnections();

            final connectedAddr = filterByIndexes(addresses, accountIndexes);
            _sendResponse(
              type: 'ZILPAY_RESPONSE',
              uuid: message.uuid,
              result: {
                'permissions': [
                  {
                    'parentCapability': 'eth_accounts',
                    'caveats': [
                      {
                        'type': 'filterResponse',
                        'value': connectedAddr,
                      }
                    ],
                  }
                ]
              },
            );
          } finally {
            _removeActiveRequest(method);
          }
        },
      );
    } catch (e) {
      _removeActiveRequest(method);
      dev.log('Error in wallet_requestPermissions: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing wallet_requestPermissions: $e',
      );
    }
  }

  Future<void> _handleEthSignTypedDataV4(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final connection =
          Web3Utils.findConnected(_currentDomain, appState.connections);
      if (connection == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'This domain is not connected. Please connect first.',
        );
      }

      final params = message.payload['params'] as List<dynamic>?;
      if (params == null || params.length < 2) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for eth_signTypedData_v4. Required: [address, typedData]',
        );
      }

      final address = params[0] as String;
      final rawTypedData = params[1] as String;

      TypedDataEip712 typedDataeip712;

      try {
        typedDataeip712 = TypedDataEip712.fromJsonString(rawTypedData);
      } catch (e) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid typedData format: ${e.toString()}',
        );
      }

      final addresses = await _getWalletAddresses(appState);
      final connectedAddresses =
          filterByIndexes(addresses, connection.accountIndexes);

      final normalizedAddress = address.toLowerCase();
      final isAuthorized = connectedAddresses
          .any((a) => a.toLowerCase() == normalizedAddress.toLowerCase());

      if (!isAuthorized) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'The requested address is not authorized',
        );
      }

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      String? title = await webViewController.getTitle();

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showSignMessageModal(
        context: context,
        typedData: typedDataeip712,
        onMessageSigned: (pubkey, sig) async {
          await _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: sig,
          );
          _removeActiveRequest(method);
          if (context.mounted) {
            Navigator.pop(context);
          }
        },
        onDismiss: () {
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.userRejectedRequest,
            'User rejected',
          );
          _removeActiveRequest(method);
        },
        appTitle: title ?? 'Sign Typed Data',
        appIcon: message.icon ?? '',
      );
    } catch (e) {
      _removeActiveRequest(method);
      dev.log('Error in eth_signTypedData_v4: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing eth_signTypedData_v4: $e',
      );
    }
  }

  Future<void> _handleWalletWatchAsset(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final connection =
          Web3Utils.findConnected(_currentDomain, appState.connections);
      if (connection == null) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.unauthorized,
          'This domain is not authorized to suggest tokens.',
        );
      }

      final params = message.payload['params'] as Map<String, dynamic>?;
      if (params == null || params['type'] != 'ERC20') {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for wallet_watchAsset. Expected ERC20 token type.',
        );
      }

      final options = params['options'] as Map<String, dynamic>?;
      if (options == null ||
          !options.containsKey('address') ||
          !options.containsKey('symbol') ||
          !options.containsKey('decimals')) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Missing required fields: address, symbol, or decimals.',
        );
      }

      final tokenAddress = options['address'] as String;
      final tokenSymbol = options['symbol'] as String;
      final tokenImage = options['image'] as String?;

      final tokenExists = appState.wallet?.tokens.any((t) =>
          t.addr.toLowerCase() == tokenAddress.toLowerCase() &&
          t.addrType == 1);

      if (tokenExists == true) {
        _removeActiveRequest(method);
        return _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: message.uuid,
          result: true,
        );
      }

      String? title = await webViewController.getTitle();

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showWatchAssetModal(
        context: context,
        appTitle: title ?? "",
        appIcon: message.icon ?? "",
        tokenAddress: tokenAddress,
        tokenName: tokenSymbol,
        tokenSymbol: tokenSymbol,
        tokenIconUrl: tokenImage ?? appState.wallet?.tokens.first.logo,
        onConfirm: (ftoken) async {
          await addFtoken(
            meta: ftoken,
            walletIndex: BigInt.from(appState.selectedWallet),
          );
          _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: true,
          );
          await appState.syncData();
          _removeActiveRequest(method);
        },
        onCancel: () {
          _sendResponse(
            type: 'ZILPAY_RESPONSE',
            uuid: message.uuid,
            result: false,
          );
          _removeActiveRequest(method);
        },
      );
    } catch (e) {
      _removeActiveRequest(method);
      dev.log('Error in wallet_watchAsset: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing wallet_watchAsset: $e',
      );
    }
  }

  Future<void> _handleWalletAddEthereumChain(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final params = message.payload['params'] as List<dynamic>?;
      if (params == null ||
          params.isEmpty ||
          params[0] is! Map<String, dynamic>) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for wallet_addEthereumChain',
        );
      }

      final chainParams = params[0] as Map<String, dynamic>;

      if (!chainParams.containsKey('chainId') ||
          !chainParams.containsKey('chainName') ||
          !chainParams.containsKey('nativeCurrency') ||
          !chainParams.containsKey('rpcUrls') ||
          !chainParams.containsKey('blockExplorerUrls')) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Missing required fields for wallet_addEthereumChain',
        );
      }

      final rpcUrls = (chainParams['rpcUrls'] as List<dynamic>)
          .where((url) => url is String && url.startsWith('https'))
          .cast<String>()
          .toList();

      if (rpcUrls.isEmpty) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'No valid HTTP RPC URLs provided',
        );
      }

      final nativeCurrency =
          chainParams['nativeCurrency'] as Map<String, dynamic>;
      final chainId = BigInt.parse(
          chainParams['chainId'].toString().replaceFirst('0x', ''),
          radix: 16);
      final explorers = (chainParams['blockExplorerUrls'] as List<dynamic>)
          .map((url) => ExplorerInfo(name: 'Explorer', url: url, standard: 0))
          .toList();
      final symbol = nativeCurrency['symbol'].toString();
      final name = nativeCurrency['name'].toString();

      NetworkConfigInfo? foundChain;

      if (appState.state.providers.any((c) => c.chainId == chainId)) {
        final chain =
            appState.state.providers.firstWhere((c) => c.chainId == chainId);

        chain.rpc.addAll(rpcUrls);

        foundChain = chain;
      } else {
        final String mainnetJsonData =
            await rootBundle.loadString('assets/chains/mainnet-chains.json');
        final List<NetworkConfigInfo> mainnetChains =
            await getChainsProvidersFromJson(jsonStr: mainnetJsonData);

        if (mainnetChains.any((c) => c.chainId == chainId)) {
          final chain = mainnetChains.firstWhere((c) => c.chainId == chainId);

          chain.rpc.addAll(rpcUrls.map((v) => v));

          foundChain = chain;
        }
      }
      String logo =
          "https://static.cx.metamask.io/api/v1/tokenIcons/$chainId/$zeroEVM.png";

      foundChain ??= NetworkConfigInfo(
        ftokens: [
          FTokenInfo(
            logo: logo,
            name: name,
            symbol: symbol,
            decimals: 18,
            addr: zeroEVM,
            addrType: 1,
            balances: {},
            rate: 0,
            default_: false,
            native: true,
            chainHash: BigInt.zero,
          )
        ],
        name: chainParams['chainName'] as String,
        logo: logo,
        chain: chainParams['chainName'] as String,
        shortName: symbol,
        rpc: rpcUrls,
        features: Uint16List.fromList([155, 1559, 4844]),
        chainId: chainId,
        chainIds: Uint64List.fromList([chainId, 0]),
        slip44: 60,
        diffBlockTime: BigInt.zero,
        chainHash: BigInt.zero,
        explorers: explorers,
        fallbackEnabled: true,
        testnet: name.toLowerCase().contains("test"),
      );

      foundChain = foundChain.copyWith(
        rpc: foundChain.rpc.toSet().toList(),
      );
      String? title = await webViewController.getTitle();

      if (!context.mounted) {
        _removeActiveRequest(method);
        return;
      }

      showAddChainModal(
        context: context,
        title: title ?? "",
        appIcon: message.icon ?? '',
        chain: foundChain,
        onConfirm: (selectedRpc) async {
          try {
            foundChain = foundChain!.copyWith(
              rpc: selectedRpc,
            );
            await createOrUpdateChain(providerConfig: foundChain!);
            _sendResponse(
              type: 'ZILPAY_RESPONSE',
              uuid: message.uuid,
              result: null,
            );
          } catch (e) {
            debugPrint("add network error: $e");
            _returnError(
              message.uuid,
              Web3EIP1193ErrorCode.userRejectedRequest,
              e.toString(),
            );
          } finally {
            _removeActiveRequest(method);
          }
        },
        onReject: () {
          _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.userRejectedRequest,
            'User rejected the request',
          );
          _removeActiveRequest(method);
        },
      );
    } catch (e) {
      _removeActiveRequest(method);
      dev.log('Error in wallet_addEthereumChain: $e', name: 'web3_handler');
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing wallet_addEthereumChain: $e',
      );
    }
  }

  Future<void> _handleWalletSwitchEthereumChain(
    ZilPayWeb3Message message,
    BuildContext context,
    AppState appState,
  ) async {
    final method = message.payload['method'] as String;

    if (_isRequestActive(method)) {
      return _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.resourceUnavailable,
        'A similar request is already being processed',
      );
    }

    _addActiveRequest(method);

    try {
      final params = message.payload['params'] as List<dynamic>?;
      if (params == null ||
          params.isEmpty ||
          params[0] is! Map<String, dynamic>) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Invalid parameters for wallet_switchEthereumChain',
        );
      }

      final chainParams = params[0] as Map<String, dynamic>;
      if (!chainParams.containsKey('chainId')) {
        _removeActiveRequest(method);
        return _returnError(
          message.uuid,
          Web3EIP1193ErrorCode.invalidInput,
          'Missing required field: chainId',
        );
      }

      final chainId = BigInt.parse(
        chainParams['chainId'].toString().replaceFirst('0x', ''),
        radix: 16,
      );

      if (appState.account?.addrType == 0 && appState.chain?.slip44 == 313) {
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      NetworkConfigInfo? targetNetwork;
      final List<NetworkConfigInfo> providers = appState.state.providers;

      for (final provider in providers) {
        if (provider.chainId == chainId &&
            !(provider.slip44 == 313 && provider.chainId == BigInt.one)) {
          targetNetwork = provider;
          break;
        }
      }

      if (targetNetwork == null) {
        final String mainnetJsonData =
            await rootBundle.loadString('assets/chains/mainnet-chains.json');
        final String testnetJsonData =
            await rootBundle.loadString('assets/chains/testnet-chains.json');
        final List<NetworkConfigInfo> mainnetChains =
            await getChainsProvidersFromJson(jsonStr: mainnetJsonData);
        final List<NetworkConfigInfo> testnetChains =
            await getChainsProvidersFromJson(jsonStr: testnetJsonData);

        for (final chain in mainnetChains) {
          if (chain.chainId == chainId &&
              !(chain.slip44 == 313 && chain.chainId == BigInt.one)) {
            targetNetwork = chain;
            break;
          }
        }

        if (targetNetwork == null) {
          for (final chain in testnetChains) {
            if (chain.chainId == chainId &&
                !(chain.slip44 == 313 && chain.chainId == BigInt.one)) {
              targetNetwork = chain;
              break;
            }
          }
        }

        if (targetNetwork != null) {
          await addProvider(providerConfig: targetNetwork);
          await appState.syncData();
        } else {
          _removeActiveRequest(method);
          return _returnError(
            message.uuid,
            Web3EIP1193ErrorCode.chainNotAdded,
            'The requested chain has not been added. Use wallet_addEthereumChain first.',
          );
        }
      }

      final connection =
          Web3Utils.findConnected(_currentDomain, appState.connections);

      if (connection != null) {
        await selectAccountsChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          chainHash: targetNetwork.chainHash,
        );
        await appState.syncData();

        _sendResponse(
          type: 'ZILPAY_RESPONSE',
          uuid: message.uuid,
          result: null,
        );
        _removeActiveRequest(method);
      } else {
        showSwitchChainNetworkModal(
          context: context,
          selectedChainId: chainId,
          onNetworkSelected: () {
            _sendResponse(
              type: 'ZILPAY_RESPONSE',
              uuid: message.uuid,
              result: null,
            );
            _removeActiveRequest(method);
          },
          onReject: () {
            _returnError(
              message.uuid,
              Web3EIP1193ErrorCode.userRejectedRequest,
              'User rejected the request',
            );
            _removeActiveRequest(method);
          },
        );
      }
    } catch (e) {
      _removeActiveRequest(method);
      _returnError(
        message.uuid,
        Web3EIP1193ErrorCode.internalError,
        'Error processing wallet_switchEthereumChain: $e',
      );
    }
  }
}

```

`lib/web3/message.dart`:

```dart
import 'dart:convert';

import 'package:zilpay/src/rust/models/connection.dart';

class ZilPayWeb3Message {
  final String type;
  final Map<String, dynamic> payload;
  final String uuid;
  final String? icon;
  final String? title;
  final String? description;
  final ColorsInfo? colors;

  ZilPayWeb3Message({
    required this.type,
    required this.payload,
    required this.uuid,
    this.icon,
    this.title,
    this.description,
    this.colors,
  });

  factory ZilPayWeb3Message.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String?;
    final payload = json['payload'] as Map<String, dynamic>? ?? {};
    String uuid = json['uuid'] ?? "";
    String icon = json['icon'] ?? "";
    String title = json['title'] ?? "";
    String description = json['description'] ?? "";

    ColorsInfo? colors;
    // if (json['colors'] != null) {
    //   final colorsJson = json['colors'] as Map<String, dynamic>;
    //   colors = ColorsInfo(
    //     primary: colorsJson['primary'],
    //     secondary: colorsJson['secondary'],
    //     background: colorsJson['background'],
    //     text: colorsJson['text'],
    //   );
    // }

    if (type == null) {
      throw FormatException('Invalid or unknown message type: $type');
    }

    return ZilPayWeb3Message(
      type: type,
      payload: payload,
      uuid: uuid,
      icon: icon,
      title: title,
      description: description,
      colors: colors,
    );
  }

  String payloadToJsonString() {
    return jsonEncode(payload);
  }

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'payload': payload,
      'uuid': uuid,
      'icon': icon,
      'title': title,
      'description': description,
    };
  }

  @override
  String toString() {
    return 'ZilPayMessage(type: $type, payload: $payload uuid: $uuid, icon: $icon, title: $title)';
  }
}

```

`lib/web3/web3_utils.dart`:

```dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:zilpay/src/rust/api/token.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/web3/zilpay_legacy.dart';

List<int> hexToBytes(String hex) => [
      for (int i = 0; i < hex.length; i += 2)
        int.parse(hex.substring(i, i + 2), radix: 16)
    ];

String decodePersonalSignMessage(String dataToSign) {
  try {
    if (dataToSign.startsWith('0x')) {
      final bytes = hexToBytes(dataToSign.substring(2));
      return String.fromCharCodes(bytes);
    }
    return dataToSign;
  } catch (e) {
    return dataToSign;
  }
}

List<String> filterByIndexes(List<String> addresses, Uint64List indexes) {
  if (addresses.isEmpty || indexes.isEmpty) {
    return [];
  }

  List<String> result = [];
  int addressesLength = addresses.length;

  for (var indexValue in indexes) {
    int actualIndex = indexValue.toInt();

    if (actualIndex >= 0 && actualIndex < addressesLength) {
      result.add(addresses[actualIndex]);
    }
  }

  return result;
}

class Web3Utils {
  static ConnectionInfo? findConnected(
    String currentDomain,
    List<ConnectionInfo> connections,
  ) {
    for (final conn in connections) {
      final connDomain = conn.domain;
      if (currentDomain == connDomain ||
          (currentDomain.endsWith('.$connDomain') &&
              currentDomain.split('.').length ==
                  connDomain.split('.').length + 1)) {
        return conn;
      }
    }
    return null;
  }

  static List<String> filterByIndexes(
    List<String> addresses,
    Uint64List indexes,
  ) {
    return indexes
        .toList()
        .where((index) =>
            index >= BigInt.zero && index < BigInt.from(addresses.length))
        .map((index) => addresses[index.toInt()])
        .toList();
  }

  static Future<(String?, BigInt?, FTokenInfo?, String?)>
      fetchTokenMetaLegacyZilliqa({
    required dynamic data,
    required String contracAddr,
    required BigInt walletIndex,
  }) async {
    String? toAddress;
    BigInt? tokenAmount;
    FTokenInfo? tokenInfo;
    String? teg;

    try {
      if (data != null) {
        Map<String, dynamic> dataMap;

        if (data is String) {
          dataMap = jsonDecode(data) as Map<String, dynamic>;
        } else if (data is Map<String, dynamic>) {
          dataMap = data;
        } else {
          return (null, null, null, null);
        }

        teg = dataMap['_tag'];

        if (teg == 'Transfer' && dataMap['params'] is List) {
          List params = dataMap['params'];

          final typedParams = params
              .map((param) => ZilPayLegacyTransactionParam.fromJson(
                  param as Map<String, dynamic>))
              .toList();

          final toParam = typedParams.firstWhere(
            (param) => param.vname == 'to',
            orElse: () =>
                ZilPayLegacyTransactionParam(vname: '', type: '', value: ''),
          );
          if (toParam.value.isNotEmpty) {
            toAddress =
                await zilliqaLegacyBase16ToBech32(base16: toParam.value);
            contracAddr =
                await zilliqaLegacyBase16ToBech32(base16: contracAddr);
          }

          final amountParam = typedParams.firstWhere(
            (param) => param.vname == 'amount',
            orElse: () =>
                ZilPayLegacyTransactionParam(vname: '', type: '', value: ''),
          );
          if (amountParam.value.isNotEmpty) {
            tokenAmount = BigInt.parse(amountParam.value);
          }

          if (contracAddr.startsWith("zil1")) {
            try {
              tokenInfo = await fetchTokenMeta(
                addr: contracAddr,
                walletIndex: walletIndex,
              );
            } catch (e) {
              debugPrint("fetchTokenMeta error: $e");
            }
          }
        }
      }
    } catch (_) {}

    return (toAddress, tokenAmount, tokenInfo, teg);
  }
}

```

`lib/web3/zilpay_legacy.dart`:

```dart
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:provider/provider.dart';
import 'package:zilpay/modals/sign_message.dart';
import 'package:zilpay/modals/transfer.dart';
import 'package:zilpay/src/rust/api/backend.dart';
import 'package:zilpay/src/rust/api/connections.dart';
import 'package:zilpay/src/rust/api/utils.dart';
import 'package:zilpay/src/rust/api/wallet.dart';
import 'package:zilpay/src/rust/api/provider.dart';
import 'package:zilpay/src/rust/models/connection.dart';
import 'package:zilpay/src/rust/models/ftoken.dart';
import 'package:zilpay/src/rust/models/transactions/base_token.dart';
import 'package:zilpay/src/rust/models/transactions/request.dart';
import 'package:zilpay/src/rust/models/transactions/scilla.dart';
import 'package:zilpay/src/rust/models/transactions/transaction_metadata.dart';
import 'package:zilpay/state/app_state.dart';
import 'package:zilpay/config/zilliqa_legacy_messages.dart';
import 'package:zilpay/modals/app_connect.dart';
import 'package:zilpay/web3/message.dart';
import 'package:zilpay/web3/web3_utils.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

class ZilPayLegacyTransactionParam {
  final String vname;
  final String type;
  final String value;

  const ZilPayLegacyTransactionParam({
    required this.vname,
    required this.type,
    required this.value,
  });

  factory ZilPayLegacyTransactionParam.fromJson(Map<String, dynamic> json) =>
      ZilPayLegacyTransactionParam(
        vname: json['vname'] as String,
        type: json['type'] as String,
        value: json['value'] as String,
      );

  Map<String, String> toJson() => {
        'vname': vname,
        'type': type,
        'value': value,
      };
}

class ZilPayLegacyHandler {
  final InAppWebViewController webViewController;
  StreamSubscription<BlockEvent>? _blockStreamSubscription;

  ZilPayLegacyHandler({
    required this.webViewController,
  });

  void dispose() {
    _blockStreamSubscription?.cancel();
    stopBlockWorker();
  }

  Future<void> _sendResponse({
    required String type,
    required Map<String, Object?> payload,
    required String uuid,
  }) async {
    final response = ZilPayWeb3Message(
      type: type,
      payload: payload,
      uuid: uuid,
    ).toJson();

    final jsonString = jsonEncode(response);
    await webViewController.evaluateJavascript(source: '''
    window.dispatchEvent(new MessageEvent('message', { 
      data: $jsonString
    }));
    ''');
  }

  Future<Map<String, String>?> _getAccountIfConnected(AppState appState) async {
    final webUrl = await webViewController.getUrl();
    final currentDomain = Uri.parse(webUrl.toString()).host;
    final connected =
        Web3Utils.findConnected(currentDomain, appState.connections);

    if (connected == null) return null;

    final (bech32, base16) = await zilliqaGetBech32Base16Address(
      walletIndex: BigInt.from(appState.selectedWallet),
      accountIndex: appState.wallet!.selectedAccount,
    );

    return {"base16": base16, "bech32": bech32};
  }

  Future<void> sendData(AppState appState) async {
    await appState.syncConnections();
    final account = await _getAccountIfConnected(appState);

    await _sendResponse(
      type: ZilliqaLegacyMessages.getWalletData,
      payload: {
        'account': account,
        'http': appState.chain!.rpc.first,
        'network': appState.chain?.testnet ?? false ? 'testnet' : 'mainnet',
        'isConnect': account != null,
        'isEnable': true,
      },
      uuid: "",
    );
  }

  void handleStartBlockWorker(AppState appState) {
    if (_blockStreamSubscription != null) {
      return;
    }

    final blockStream =
        startBlockWorker(walletIndex: BigInt.from(appState.selectedWallet));

    _blockStreamSubscription = blockStream.listen((block) {
      // TODO: maybe need send bloc header.
      if (block.blockNumber != null) {
        _sendResponse(
          type: ZilliqaLegacyMessages.newBlock,
          payload: {'block': block.blockNumber!.toInt()},
          uuid: "",
        );
      }
    });
  }

  Future<void> _handleContentProxyMethod(
    ZilPayWeb3Message message,
    AppState appState,
  ) async {
    final chainHash = appState.chain?.chainHash ?? BigInt.zero;

    try {
      final jsonRes = await providerReqProxy(
        payload: message.payloadToJsonString(),
        chainHash: chainHash,
      );

      await _sendResponse(
        type: ZilliqaLegacyMessages.contentProxyResult,
        payload: {'resolve': jsonDecode(jsonRes)},
        uuid: message.uuid,
      );
    } catch (e) {
      await _sendResponse(
        type: ZilliqaLegacyMessages.responseToDapp,
        payload: {'reject': e.toString()},
        uuid: message.uuid,
      );
    }
  }

  Future<void> _handleCallToSignTx(
    ZilPayWeb3Message message,
    BuildContext context,
  ) async {
    try {
      final appState = Provider.of<AppState>(context, listen: false);
      FTokenInfo? ftoken = appState.wallet?.tokens
          .firstWhere((t) => t.addrType == 0 && t.native);

      if (ftoken == null) throw Exception('Native token not found');

      final amount = BigInt.parse(message.payload['amount'].toString());
      final gasPrice = BigInt.parse(message.payload['gasPrice'].toString());
      final gasLimit = BigInt.parse(message.payload['gasLimit'].toString());
      final toAddr = message.payload['toAddr'] as String;
      final code = message.payload['code'] as String? ?? "";
      final data = message.payload['data'] as String? ?? "";
      final title = message.payload['title'] as String? ?? "";
      final account = appState.account!;

      final chainHash = appState.chain?.chainHash ?? BigInt.zero;
      final chainId = appState.account?.chainId ??
          appState.chain?.chainIds.last ??
          BigInt.zero;
      final nonce = BigInt.zero;

      final scillaRequest = TransactionRequestScilla(
        chainId: chainId.toInt(),
        nonce: nonce,
        gasPrice: gasPrice,
        gasLimit: gasLimit,
        toAddr: toAddr,
        amount: amount,
        code: code,
        data: data,
      );

      var tokenInfo = BaseTokenInfo(
        value: amount.toString(),
        symbol: ftoken.symbol,
        decimals: ftoken.decimals,
      );

      String recipient = toAddr;
      String tokenAmount =
          fromWei(value: amount.toString(), decimals: ftoken.decimals)
              .toString();

      final (toAddress, ftAmount, ftMeta, teg) =
          await Web3Utils.fetchTokenMetaLegacyZilliqa(
        data: data,
        contracAddr: toAddr,
        walletIndex: BigInt.from(appState.selectedWallet),
      );

      if (ftMeta != null) {
        tokenAmount = fromWei(
                value: (ftAmount ?? BigInt.zero).toString(),
                decimals: ftMeta.decimals)
            .toString();
        recipient = toAddress!;
        tokenInfo = BaseTokenInfo(
          value: tokenAmount,
          symbol: ftMeta.symbol,
          decimals: ftMeta.decimals,
        );
        ftoken = ftMeta;
      }

      final metadata = TransactionMetadataInfo(
        chainHash: chainHash,
        hash: null,
        info: teg,
        icon: message.icon,
        title: title,
        signer: null,
        tokenInfo: tokenInfo,
      );

      final transactionRequest = TransactionRequestInfo(
        metadata: metadata,
        scilla: scillaRequest,
        evm: null,
      );

      if (account.addrType == 1) {
        // evm enabled.
        await zilliqaSwapChain(
          walletIndex: BigInt.from(appState.selectedWallet),
          accountIndex: appState.wallet!.selectedAccount,
        );
        await appState.syncData();
      }

      if (!context.mounted) return;

      showConfirmTransactionModal(
        context: context,
        tx: transactionRequest,
        to: recipient,
        token: ftoken,
        amount: tokenAmount,
        onConfirm: (tx) {
          _sendResponse(
            type: ZilliqaLegacyMessages.txResult,
            payload: {
              'resolve': {
                'amount': tx.amount.toString(),
                'code': code,
                'data': data,
                'gasLimit': tx.gasLimit.toString(),
                'gasPrice': tx.gasPrice.toString(),
                'nonce': tx.nonce.toString(),
                'priority': false,
                'pubKey': metadata.signer,
                'signature': tx.sig,
                'toAddr': toAddr,
                'version': 0,
                'from': tx.sender,
                'hash': tx.transactionHash,
              }
            },
            uuid: message.uuid,
          );
          Navigator.pop(context);
        },
        onDismiss: () {
          _sendResponse(
            type: ZilliqaLegacyMessages.txResult,
            payload: {'reject': "Rejected by user"},
            uuid: message.uuid,
          );
        },
      );
    } catch (e) {
      debugPrint('Error handling transaction: $e');
      await _sendResponse(
        type: ZilliqaLegacyMessages.txResult,
        payload: {'reject': e.toString()},
        uuid: message.uuid,
      );
    }
  }

  Future<void> _handleSignMessage(
    ZilPayWeb3Message message,
    BuildContext context,
  ) async {
    final messageContent = message.payload['content'] as String? ?? '';
    final title = message.payload['title'] as String? ?? 'Sign Message';
    final icon = message.payload['icon'] as String? ?? '';

    final appState = Provider.of<AppState>(context, listen: false);
    final account = appState.account!;

    if (account.addrType == 1) {
      // evm disable.
      await zilliqaSwapChain(
        walletIndex: BigInt.from(appState.selectedWallet),
        accountIndex: appState.wallet!.selectedAccount,
      );
      await appState.syncData();
    }

    if (!context.mounted) return;

    showSignMessageModal(
      context: context,
      message: messageContent,
      onMessageSigned: (pubkey, sig) async {
        String signature =
            sig.startsWith("0x") ? sig.replaceFirst("0x", "") : sig;

        await _sendResponse(
          type: ZilliqaLegacyMessages.signMessageResponse,
          payload: {
            'resolve': {
              'message': messageContent,
              'signature': signature,
              'publicKey': pubkey,
            },
          },
          uuid: message.uuid,
        );
        if (context.mounted) {
          Navigator.pop(context);
        }
      },
      onDismiss: () async {
        await _sendResponse(
          type: ZilliqaLegacyMessages.signMessageResponse,
          payload: {'reject': 'Rejected by user'},
          uuid: message.uuid,
        );
      },
      appTitle: title,
      appIcon: icon,
    );
  }

  Future<void> _handleConnectApp(
    ZilPayWeb3Message message,
    AppState appState,
    BuildContext context,
  ) async {
    await appState.syncConnections();

    final webUrl = await webViewController.getUrl();
    final currentDomain = Uri.parse(webUrl.toString()).host;

    final isAlreadyConnected =
        Web3Utils.findConnected(currentDomain, appState.connections);

    if (isAlreadyConnected != null) {
      final (bech32, base16) = await zilliqaGetBech32Base16Address(
        walletIndex: BigInt.from(appState.selectedWallet),
        accountIndex: appState.wallet!.selectedAccount,
      );

      await _sendResponse(
        type: ZilliqaLegacyMessages.responseToDapp,
        payload: {
          'account': {"base16": base16, "bech32": bech32}
        },
        uuid: message.uuid,
      );
      return;
    }

    if (appState.account?.addrType == 1) {
      await zilliqaSwapChain(
        walletIndex: BigInt.from(appState.selectedWallet),
        accountIndex: appState.wallet!.selectedAccount,
      );
      await appState.syncData();
    }

    if (!context.mounted) return;

    showAppConnectModal(
      context: context,
      title: message.title ?? "",
      uuid: message.uuid,
      colors: message.colors,
      iconUrl: message.icon ?? "",
      onReject: () {
        _sendResponse(
          type: ZilliqaLegacyMessages.responseToDapp,
          payload: {'reject': 'Rejected by user'},
          uuid: message.uuid,
        );
      },
      onConfirm: (selectedIndices) async {
        final walletIndexes = Uint64List.fromList(
            selectedIndices.map((index) => BigInt.from(index)).toList());

        final connectionInfo = ConnectionInfo(
          domain: currentDomain,
          accountIndexes: walletIndexes,
          favicon: message.icon,
          title: message.title ?? "",
          colors: message.colors,
          description: message.description,
          lastConnected: BigInt.from(DateTime.now().millisecondsSinceEpoch),
          canReadAccounts: true,
          canRequestSignatures: true,
          canSuggestTokens: false,
          canSuggestTransactions: true,
        );

        Map<String, String>? account;

        if (selectedIndices.isNotEmpty) {
          await createUpdateConnection(
            walletIndex: BigInt.from(appState.selectedWallet),
            conn: connectionInfo,
          );

          await appState.syncConnections();

          final (bech32, base16) = await zilliqaGetBech32Base16Address(
            walletIndex: BigInt.from(appState.selectedWallet),
            accountIndex: appState.wallet!.selectedAccount,
          );

          account = {"base16": base16, "bech32": bech32};
        }

        await _sendResponse(
          type: ZilliqaLegacyMessages.responseToDapp,
          payload: {'account': account},
          uuid: message.uuid,
        );
      },
    );
  }

  Future<void> handleLegacyZilPayMessage(
    ZilPayWeb3Message message,
    BuildContext context,
  ) async {
    final appState = Provider.of<AppState>(context, listen: false);

    switch (message.type) {
      case ZilliqaLegacyMessages.getWalletData:
        await sendData(appState);
        break;

      case ZilliqaLegacyMessages.contentProxyMethod:
        await _handleContentProxyMethod(message, appState);
        break;

      case ZilliqaLegacyMessages.callToSignTx:
        await _handleCallToSignTx(message, context);
        break;

      case ZilliqaLegacyMessages.signMessage:
        await _handleSignMessage(message, context);
        break;

      case ZilliqaLegacyMessages.connectApp:
        await _handleConnectApp(message, appState, context);
        break;

      case ZilliqaLegacyMessages.watchBlock:
        handleStartBlockWorker(appState);
        break;

      case ZilliqaLegacyMessages.disconnectApp:
        await _sendResponse(
          type: ZilliqaLegacyMessages.responseToDapp,
          payload: {'account': null},
          uuid: message.uuid,
        );
        break;

      default:
        debugPrint('Unhandled message type: ${message.type}');
        await _sendResponse(
          type: ZilliqaLegacyMessages.responseToDapp,
          payload: {'reject': 'Unsupported message type: ${message.type}'},
          uuid: message.uuid,
        );
    }
  }
}

```